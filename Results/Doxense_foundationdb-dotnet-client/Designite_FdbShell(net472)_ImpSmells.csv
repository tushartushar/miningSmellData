Implementation smell,Namespace,Class,File,Method,Description
Long Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The method has 116 lines of code.
Long Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The method has 107 lines of code.
Long Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The method has 151 lines of code.
Long Method,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The method has 559 lines of code.
Complex Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,Cyclomatic complexity of the method is 9
Complex Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,Cyclomatic complexity of the method is 16
Complex Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ClearRange,Cyclomatic complexity of the method is 8
Complex Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,Cyclomatic complexity of the method is 10
Complex Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,Cyclomatic complexity of the method is 16
Complex Method,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,Cyclomatic complexity of the method is 12
Complex Method,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,Cyclomatic complexity of the method is 55
Complex Method,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,CombinePath,Cyclomatic complexity of the method is 9
Complex Method,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Tokenize,Cyclomatic complexity of the method is 11
Complex Method,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,ParseQuotedString,Cyclomatic complexity of the method is 14
Complex Method,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,Cyclomatic complexity of the method is 13
Complex Method,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,CmdTabOrComplete,Cyclomatic complexity of the method is 15
Complex Method,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,WordForward,Cyclomatic complexity of the method is 10
Complex Method,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,WordBackward,Cyclomatic complexity of the method is 11
Complex Method,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,EditLoop,Cyclomatic complexity of the method is 10
Complex Method,Mono.Terminal,History,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,History,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Option,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,AddSeparators,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,ArgumentSource,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetArguments,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionPrototype,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetDescription,Cyclomatic complexity of the method is 12
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The method has 6 parameters. Parameters: path' extras' options' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,CreateDirectory,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,RemoveDirectory,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,MoveDirectory,The method has 6 parameters. Parameters: srcPath' dstPath' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ShowDirectoryLayer,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ChangeDirectoryLayer,The method has 6 parameters. Parameters: path' layer' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Clear,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ClearRange,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Count,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,The method has 6 parameters. Parameters: path' extras' reverse' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dump,The method has 6 parameters. Parameters: path' output' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Tree,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The method has 5 parameters. Parameters: folder' last' db' stream' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Shards,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,FdbCliCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\FdbCliCommands.cs,RunFdbCliCommand,The method has 5 parameters. Parameters: command' options' clusterFile' log' ct
Long Parameter List,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetOptionParts,The method has 5 parameters. Parameters: argument' flag' name' sep' value
Long Parameter List,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteDescription,The method has 5 parameters. Parameters: o' value' prefix' firstWidth' remWidth
Long Parameter List,Mono.Options,ActionOption,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ActionOption,The method has 5 parameters. Parameters: prototype' description' count' action' hidden
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "								Program.StdOut(log' $"  {FdbKey.Dump(subfolder.Copy().GetPrefix())'-12} {(subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">"))'-12} {count'9:N0} {name}"' ConsoleColor.White); " is 202.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "								Program.StdOut(log' $"  {FdbKey.Dump(subfolder.Copy().GetPrefix())'-12} {(subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">"))'-12} {"-"'9} {name}"' ConsoleColor.White); " is 197.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "							Program.StdOut(log' $"  {FdbKey.Dump(subfolder.Copy().GetPrefix())'-12} {(subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">"))'-12} {name}"' ConsoleColor.White); " is 189.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,RemoveDirectory,The length of the statement  "						Program.Error(log' $"# Cannot remove /{string.Join("/"' path)} because it still contains {subDirs.Count:N0} sub-directorie(s)"); " is 128.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dump,The length of the statement  "				Program.Comment(log' $"# Dumping content of {FdbKey.Dump(folder.GetPrefix())} [{folder.GetPrefix().ToHexaString(' ')}] to {output}"); " is 133.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The length of the statement  "				stream.WriteLine($"{sb}{(folder.Layer.ToString() == "partition" ? ("<" + folder.Name + ">") : folder.Name)}{(folder.Layer.IsNullOrEmpty ? string.Empty : (" [" + folder.Layer.ToString() + "]"))}"); " is 196.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "			// we want to merge the map of shards' with the map of directories from the Directory Layer' and count for each directory how many shards intersect " is 147.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "			// note: this may break in future versions of the DL! Maybe we need a custom API to get a flat list of all directories in a DL that span a specific range ? " is 155.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "			Program.StdOut(log' $"> Found {totalShards} shard(s) in partition /{folder.DirectoryLayer.FullName}"' ConsoleColor.Gray); " is 121.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "				if (progress) log.Write($"\r> {dir.Name}{(dir.Name.Length > n ? String.Empty : new string(' '' n - dir.Name.Length))}"); " is 120.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "				Program.StdOut(log' $"{kvp.Value'6} {RobustHistogram.FormatHistoBar((double)kvp.Value / foundShards' 20)'-20} {kvp.Key}"' ConsoleColor.Gray); " is 141.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "				Program.StdOut(log' $"Biggest folder is /{bigBad.FullName} with {max} shards ({100.0 * max / totalShards:N1}% total' {100.0 * max / foundShards:N1}% subtree)"); " is 160.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "					log.WriteLine(dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First().Parts[0].Address' machineId); " is 124.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "						log.WriteLine(machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts[0].Address' proc.Parts[0].Port' proc.ProcessId); " is 144.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "						//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4); " is 165.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "			Program.StdOut(log' $"Found {numNodes:N0} process(es) on {numMachines:N0} machine(s) in {numDCs:N0} datacenter(s)"' ConsoleColor.White); " is 136.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Shards,The length of the statement  "					//TODO: we can probably get more details on this shard looking in the system keyspace (where it is' how many replicas' ...) " is 123.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "				log.WriteLine($"Sampling {samples.Count:N0} out of {ranges.Count:N0} shards ({(100.0 * samples.Count / ranges.Count):N1}%) ..."); " is 129.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median))); " is 305.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "				log.WriteLine($"Sampled {FormatSize(globalSize)} ({globalSize:N0} bytes) and {globalCount:N0} keys in {sw.Elapsed.TotalSeconds:N1} sec"); " is 137.
Long Statement,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "				log.WriteLine($"Found {FormatSize(globalSize)} ({globalSize:N0} bytes) and {globalCount:N0} keys in {sw.Elapsed.TotalSeconds:N1} sec"); " is 135.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The length of the statement  "			stream.WriteLine("# Local Time: " + DateTime.Now.ToString("O") + " (" + localTime + " local) - Universal Time: " + DateTime.UtcNow.ToString("O") + " ( " + utcTime + " UTC)"); " is 174.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult(); " is 124.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel); " is 139.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel); " is 141.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel); " is 129.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel); " is 142.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel); " is 128.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' STuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel); " is 158.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								StdOut("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")"); " is 156.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								StdOut("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")"); " is 160.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel); " is 138.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,VersionCommand,The length of the statement  "			log.WriteLine("Using .NET Binding v{0} with API level {1}"' new System.Reflection.AssemblyName(typeof(Fdb).Assembly.FullName).Version' Fdb.ApiVersion); " is 151.
Long Statement,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,VersionCommand,The length of the statement  "			var res = await RunAsyncCommand((db' _' ct) => FdbCliCommands.RunFdbCliCommand(null' "-h"' clusterFile' log' ct)' cancel); " is 122.
Long Statement,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The length of the statement  "			// I'm using the midpoint of each bucket as the value used to compute the deviation' and the same approximation method used in Percentile(..) to compute the resulting median. " is 174.
Long Statement,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________"); " is 152.
Long Statement,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|"); " is 153.
Long Statement,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")' " is 188.
Long Statement,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // --------- " is 151.
Long Statement,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,ToString,The length of the statement  "			return String.Format(CultureInfo.InvariantCulture' "Count={0}' Avg={1}' Min={2}' Max={3}"' this.Count' this.Average' this.Count > 0 ? this.Min : 0' this.Max); " is 158.
Long Statement,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ForceCursor,The length of the statement  "			//log.WriteLine ("Going to cursor={0} row={1} col={2} actual={3} prompt={4} ttr={5} old={6}"' newpos' row' col' actual_pos' prompt.Length' TextToRenderPos (cursor)' cursor); " is 173.
Complex Conditional,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The conditional expression  "prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\""))"  is complex.
Complex Conditional,Mono.Options,Option,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 &&  					((names.Length == 1 && this.type != OptionValueType.None) ||  					 (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length-1] == '+' || n [n.Length-1] == '-') &&  					Contains ((rn = n.Substring (0' n.Length-1)))"  is complex.
Empty Catch Block,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The method has an empty catch block.
Empty Catch Block,Mono.Terminal,History,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,Close,The method has an empty catch block.
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The following statement contains a magic number: Program.StdOut(log' $"  {FdbKey.Dump(subfolder.Copy().GetPrefix())'-12} {(subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">"))'-12} {count'9:N0} {name}"' ConsoleColor.White);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The following statement contains a magic number: Program.StdOut(log' $"  {FdbKey.Dump(subfolder.Copy().GetPrefix())'-12} {(subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">"))'-12} {count'9:N0} {name}"' ConsoleColor.White);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The following statement contains a magic number: Program.StdOut(log' $"  {FdbKey.Dump(subfolder.Copy().GetPrefix())'-12} {(subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">"))'-12} {count'9:N0} {name}"' ConsoleColor.White);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Get,The following statement contains a magic number: switch (format)  			{  				case "--text":  				case "--json":  				case "--utf8":  				{  					Program.StdOut(log' v.ToStringUtf8()' ConsoleColor.Gray);  					break;  				}  				case "--hex":  				case "--hexa":  				{  					Program.StdOut(log' v.ToHexaString()' ConsoleColor.White);  					break;  				}  				case "--dump":  				{  					var sb = new StringBuilder(v.Count * 3 + (v.Count >> 4) * 2 + 16);  					for (int i = 0; i < v.Count; i += 16)  					{  						sb.AppendLine(v.Substring(i' 16).ToHexaString(' '));  					}  					Program.StdOut(log' sb.ToString()' ConsoleColor.White);  					break;  				}  				case "--int":  				{  					if (v.Count <= 8)  					{  						long he = v.ToInt64BE();  						long le = v.ToInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--uint":  				{  					if (v.Count <= 8)  					{  						ulong he = v.ToUInt64BE();  						ulong le = v.ToUInt64();  						Program.StdOut(log' $"BE: {he:X016} ({he:N0})"' ConsoleColor.White);  						Program.StdOut(log' $"LE: {le:X016} ({le:N0})"' ConsoleColor.White);  					}  					else  					{  						Program.StdOut(log' $"Value is too large ({v.Count} bytes)"' ConsoleColor.DarkRed);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				case "--tuple":  				{  					try  					{  						var t = TuPack.Unpack(v);  						Program.StdOut(log' t.ToString()' ConsoleColor.Gray);  					}  					catch (Exception e)  					{  						Program.Error(log' "Key value does not seem to be a valid Tuple: " + e.Message);  						Program.StdOut(log' v.ToHexaString(' ')' ConsoleColor.Gray);  					}  					break;  				}  				default:  				{  					Program.StdOut(log' v.ToString("V")' ConsoleColor.White);  					break;  				}  			}
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,The following statement contains a magic number: int count = 20;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The following statement contains a magic number: var sb = new StringBuilder(last.Count * 4);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.Write("\r" + new string(' '' n + 2) + "\r");
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.Write("\r" + new string(' '' n + 2) + "\r");
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: Program.StdOut(log' $"{kvp.Value'6} {RobustHistogram.FormatHistoBar((double)kvp.Value / foundShards' 20)'-20} {kvp.Key}"' ConsoleColor.Gray);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: Program.StdOut(log' $"{kvp.Value'6} {RobustHistogram.FormatHistoBar((double)kvp.Value / foundShards' 20)'-20} {kvp.Key}"' ConsoleColor.Gray);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: Program.StdOut(log' $"{kvp.Value'6} {RobustHistogram.FormatHistoBar((double)kvp.Value / foundShards' 20)'-20} {kvp.Key}"' ConsoleColor.Gray);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: Program.StdOut(log' $"Biggest folder is /{bigBad.FullName} with {max} shards ({100.0 * max / totalShards:N1}% total' {100.0 * max / foundShards:N1}% subtree)");
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: Program.StdOut(log' $"Biggest folder is /{bigBad.FullName} with {max} shards ({100.0 * max / totalShards:N1}% total' {100.0 * max / foundShards:N1}% subtree)");
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: size < 2048
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: double x = size / 1024.0;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x < 800
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x /= 1024.0;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x < 800
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x /= 1024.0;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(KeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: string dcId = dc.Key.EndsWith("0000000000000000") ? dc.Key.Substring(0' 16) : dc.Key;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: string machineId = machine.Key.EndsWith("0000000000000000") ? machine.Key.Substring(0' 16) : machine.Key;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: double ratio = 0.1d;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: ranges.Count <= 32
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: int workers = 8;
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = KeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = KeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = KeySelector.FirstGreaterThan(data.Last);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = KeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = KeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = KeySelector.FirstGreaterThan(data.Last);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = KeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = KeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = KeySelector.FirstGreaterThan(data.Last);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));
Magic Number,FdbShell,BasicCommands,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = KeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = KeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = KeySelector.FirstGreaterThan(data.Last);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The following statement contains a magic number: long localTime = (DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - 62135596800000;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The following statement contains a magic number: long utcTime = (DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond) - 62135596800000;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: Console.WindowWidth = 160;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: Console.WindowHeight = 60;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: Fdb.Start(Fdb.GetMaxSafeApiVersion(200' Fdb.GetDefaultApiVersion()));
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: int timeout = 30;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: int maxRetries = 10;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: Db.DefaultTimeout = Math.Max(0' timeout) * 1000;
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: switch (trimmedCommand)  						{  							case "":  							{  								continue;  							}  							case "log":  							{  								string prm = PopParam(ref extras);  								LogCommand(prm' extras' Console.Out);  								break;  							}    							case "version":  							{  								await VersionCommand(extras' clusterFile' Console.Out' cancel);  								break;  							}    							case "tree":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  								break;  							}  							case "map":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  								break;  							}    							case "dir":  							case "ls":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  								break;  							}  							case "ll":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  								break;  							}    							case "count":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  								break;  							}    							case "show":  							case "top":  							{  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  								break;  							}  							case "last":  							{  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  								break;  							}    							case "dump":  							{  								string output = PopParam(ref extras);  								if (string.IsNullOrEmpty(output))  								{  									StdErr("You must specify a target file path."' ConsoleColor.Red);  									break;  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dump(path' output' extras' db' log' ct)' cancel);  								break;  							}    							case "cd":  							case "pwd":  							{  								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var newPath = CombinePath(CurrentDirectoryPath' prm);  									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  									if (res.Failed)  									{  										StdErr($"# Failed to open Directory {newPath}: {res.Error.Message}"' ConsoleColor.Red);  										Console.Beep();  									}  									else if (res.Value == null)  									{  										StdOut($"# Directory {newPath} does not exist!"' ConsoleColor.Red);  										Console.Beep();  									}  									else  									{  										CurrentDirectoryPath = newPath;  										UpdatePrompt(CurrentDirectoryPath);  									}  								}  								else  								{  									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  									if (res.Failed)  									{  										StdErr($"# Failed to query Directory {Program.CurrentDirectoryPath}: {res.Error.Message}"' ConsoleColor.Red);  									}  									else if (res.Value == null)  									{  										StdOut($"# Directory {Program.CurrentDirectoryPath} does not exist anymore");  									}  								}    								break;  							}  							case "mkdir":  							case "md":  							{ // "mkdir DIRECTORYNAME"    								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  								}    								break;  							}  							case "rmdir":  							{ // "rmdir DIRECTORYNAME"  								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  								}    								break;  							}    							case "mv":  							case "ren":  							{ // "mv SOURCE DESTINATION"    								string prm = PopParam(ref extras);  								var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  								await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    								break;  							}    							case "get":  							{ // "get KEY"    								if (extras.Count == 0)  								{  									StdErr("You must specify a key to read."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Get(path' extras' db' log' ct)' cancel);  								break;  							}    							case "clear":  							{ // "clear KEY"    								if (extras.Count == 0)  								{  									StdErr("You must specify a key to clear."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Clear(path' extras' db' log' ct)' cancel);  								break;  							}    							case "clearrange":  							{ // "clear *" or "clear FROM TO"    								if (extras.Count == 0)  								{  									StdErr("You must specify either '*'' a prefix' or a key range."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ClearRange(path' extras' db' log' ct)' cancel);  								break;  							}    							case "layer":  							{  								string prm = PopParam(ref extras);  								if (string.IsNullOrEmpty(prm))  								{ // displays the layer id of the current folder  									var path = ParsePath(CurrentDirectoryPath);  									await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    								}  								else  								{ // change the layer id of the current folder  									prm = prm.Trim();  									// double or single quotes can be used to escape the value  									if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  									{  										prm = prm.Substring(1' prm.Length - 2);  									}    									var path = ParsePath(CurrentDirectoryPath);  									await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  								}    								break;  							}    							case "mkpart":  							{ // "mkpart PARTITIONNAME"    								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' STuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  								}    								break;  							}    							case "topology":  							{  								await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  								break;  							}    							case "shards":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  								break;  							}    							case "sampling":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  								break;  							}    							case "coordinators":  							{  								await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  								break;  							}    							case "partition":  							{  								string prm = PopParam(ref extras);  								if (string.IsNullOrEmpty(prm))  								{  									StdOut($"# Current partition is {String.Join("/"' partition)}");  									//TODO: browse existing partitions ?  									break;  								}    								var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  								IFdbDatabase newDb = null;  								try  								{  									var options = new FdbConnectionOptions  									{  										ClusterFile = clusterFile'  										PartitionPath = newPartition  									};  									newDb = await ChangeDatabase(options' cancel);  								}  								catch (Exception)  								{  									newDb?.Dispose();  									newDb = null;  									throw;  								}  								finally  								{  									if (newDb != null)  									{  										if (Db != null)  										{  											Db.Dispose();  											Db = null;  										}    										Db = newDb;  										partition = newPartition;  										StdOut($"# Changed partition to /{string.Join("/"' partition)}");  									}  								}    								break;  							}    							case "q":  							case "x":  							case "quit":  							case "exit":  							case "bye":  							{  								stop = true;  								break;  							}    							case "gc":  							{  								long before = GC.GetTotalMemory(false);  								Console.Write("Collecting garbage...");  								GC.Collect();  								GC.WaitForPendingFinalizers();  								GC.Collect();  								StdOut(" Done");  								long after = GC.GetTotalMemory(false);  								StdOut("- before = " + before.ToString("N0"));  								StdOut("- after  = " + after.ToString("N0"));  								StdOut("- delta  = " + (before - after).ToString("N0"));  								break;  							}    							case "mem":  							{  								StdOut("Memory usage:");  								StdOut("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  								//TODO: how do we get these values on Linux/Mac?  #if !NETCOREAPP  								StdOut("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  								StdOut("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  								StdOut("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  								StdOut("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  #endif  								break;  							}    							case "wide":  							{  								try  								{  									Console.WindowWidth = 160;  								}  								catch (Exception e)  								{  									StdErr("Failed to change console width: " + e.Message' ConsoleColor.DarkRed);  								}    								break;  							}    							case "status":  							case "wtf":  							{  								var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  								if (result.Failed) break;  								if (result.Value.ExitCode != 0)  								{  									StdErr($"# fdbcli exited with code {result.Value.ExitCode}"' ConsoleColor.DarkRed);  									StdOut("> StdErr:"' ConsoleColor.DarkGray);  									StdOut(result.Value.StdErr);  									StdOut("> StdOut:"' ConsoleColor.DarkGray);  								}    								StdOut(result.Value.StdOut);  								break;  							}    							default:  							{  								StdErr($"Unknown command : '{trimmedCommand}'"' ConsoleColor.Red);  								break;  							}  						}
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: switch (trimmedCommand)  						{  							case "":  							{  								continue;  							}  							case "log":  							{  								string prm = PopParam(ref extras);  								LogCommand(prm' extras' Console.Out);  								break;  							}    							case "version":  							{  								await VersionCommand(extras' clusterFile' Console.Out' cancel);  								break;  							}    							case "tree":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  								break;  							}  							case "map":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  								break;  							}    							case "dir":  							case "ls":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  								break;  							}  							case "ll":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  								break;  							}    							case "count":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  								break;  							}    							case "show":  							case "top":  							{  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  								break;  							}  							case "last":  							{  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  								break;  							}    							case "dump":  							{  								string output = PopParam(ref extras);  								if (string.IsNullOrEmpty(output))  								{  									StdErr("You must specify a target file path."' ConsoleColor.Red);  									break;  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dump(path' output' extras' db' log' ct)' cancel);  								break;  							}    							case "cd":  							case "pwd":  							{  								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var newPath = CombinePath(CurrentDirectoryPath' prm);  									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  									if (res.Failed)  									{  										StdErr($"# Failed to open Directory {newPath}: {res.Error.Message}"' ConsoleColor.Red);  										Console.Beep();  									}  									else if (res.Value == null)  									{  										StdOut($"# Directory {newPath} does not exist!"' ConsoleColor.Red);  										Console.Beep();  									}  									else  									{  										CurrentDirectoryPath = newPath;  										UpdatePrompt(CurrentDirectoryPath);  									}  								}  								else  								{  									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  									if (res.Failed)  									{  										StdErr($"# Failed to query Directory {Program.CurrentDirectoryPath}: {res.Error.Message}"' ConsoleColor.Red);  									}  									else if (res.Value == null)  									{  										StdOut($"# Directory {Program.CurrentDirectoryPath} does not exist anymore");  									}  								}    								break;  							}  							case "mkdir":  							case "md":  							{ // "mkdir DIRECTORYNAME"    								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  								}    								break;  							}  							case "rmdir":  							{ // "rmdir DIRECTORYNAME"  								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  								}    								break;  							}    							case "mv":  							case "ren":  							{ // "mv SOURCE DESTINATION"    								string prm = PopParam(ref extras);  								var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  								await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    								break;  							}    							case "get":  							{ // "get KEY"    								if (extras.Count == 0)  								{  									StdErr("You must specify a key to read."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Get(path' extras' db' log' ct)' cancel);  								break;  							}    							case "clear":  							{ // "clear KEY"    								if (extras.Count == 0)  								{  									StdErr("You must specify a key to clear."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Clear(path' extras' db' log' ct)' cancel);  								break;  							}    							case "clearrange":  							{ // "clear *" or "clear FROM TO"    								if (extras.Count == 0)  								{  									StdErr("You must specify either '*'' a prefix' or a key range."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ClearRange(path' extras' db' log' ct)' cancel);  								break;  							}    							case "layer":  							{  								string prm = PopParam(ref extras);  								if (string.IsNullOrEmpty(prm))  								{ // displays the layer id of the current folder  									var path = ParsePath(CurrentDirectoryPath);  									await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    								}  								else  								{ // change the layer id of the current folder  									prm = prm.Trim();  									// double or single quotes can be used to escape the value  									if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  									{  										prm = prm.Substring(1' prm.Length - 2);  									}    									var path = ParsePath(CurrentDirectoryPath);  									await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  								}    								break;  							}    							case "mkpart":  							{ // "mkpart PARTITIONNAME"    								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' STuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  								}    								break;  							}    							case "topology":  							{  								await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  								break;  							}    							case "shards":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  								break;  							}    							case "sampling":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  								break;  							}    							case "coordinators":  							{  								await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  								break;  							}    							case "partition":  							{  								string prm = PopParam(ref extras);  								if (string.IsNullOrEmpty(prm))  								{  									StdOut($"# Current partition is {String.Join("/"' partition)}");  									//TODO: browse existing partitions ?  									break;  								}    								var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  								IFdbDatabase newDb = null;  								try  								{  									var options = new FdbConnectionOptions  									{  										ClusterFile = clusterFile'  										PartitionPath = newPartition  									};  									newDb = await ChangeDatabase(options' cancel);  								}  								catch (Exception)  								{  									newDb?.Dispose();  									newDb = null;  									throw;  								}  								finally  								{  									if (newDb != null)  									{  										if (Db != null)  										{  											Db.Dispose();  											Db = null;  										}    										Db = newDb;  										partition = newPartition;  										StdOut($"# Changed partition to /{string.Join("/"' partition)}");  									}  								}    								break;  							}    							case "q":  							case "x":  							case "quit":  							case "exit":  							case "bye":  							{  								stop = true;  								break;  							}    							case "gc":  							{  								long before = GC.GetTotalMemory(false);  								Console.Write("Collecting garbage...");  								GC.Collect();  								GC.WaitForPendingFinalizers();  								GC.Collect();  								StdOut(" Done");  								long after = GC.GetTotalMemory(false);  								StdOut("- before = " + before.ToString("N0"));  								StdOut("- after  = " + after.ToString("N0"));  								StdOut("- delta  = " + (before - after).ToString("N0"));  								break;  							}    							case "mem":  							{  								StdOut("Memory usage:");  								StdOut("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  								//TODO: how do we get these values on Linux/Mac?  #if !NETCOREAPP  								StdOut("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  								StdOut("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  								StdOut("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  								StdOut("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  #endif  								break;  							}    							case "wide":  							{  								try  								{  									Console.WindowWidth = 160;  								}  								catch (Exception e)  								{  									StdErr("Failed to change console width: " + e.Message' ConsoleColor.DarkRed);  								}    								break;  							}    							case "status":  							case "wtf":  							{  								var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  								if (result.Failed) break;  								if (result.Value.ExitCode != 0)  								{  									StdErr($"# fdbcli exited with code {result.Value.ExitCode}"' ConsoleColor.DarkRed);  									StdOut("> StdErr:"' ConsoleColor.DarkGray);  									StdOut(result.Value.StdErr);  									StdOut("> StdOut:"' ConsoleColor.DarkGray);  								}    								StdOut(result.Value.StdOut);  								break;  							}    							default:  							{  								StdErr($"Unknown command : '{trimmedCommand}'"' ConsoleColor.Red);  								break;  							}  						}
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: switch (trimmedCommand)  						{  							case "":  							{  								continue;  							}  							case "log":  							{  								string prm = PopParam(ref extras);  								LogCommand(prm' extras' Console.Out);  								break;  							}    							case "version":  							{  								await VersionCommand(extras' clusterFile' Console.Out' cancel);  								break;  							}    							case "tree":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  								break;  							}  							case "map":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  								break;  							}    							case "dir":  							case "ls":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  								break;  							}  							case "ll":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  								break;  							}    							case "count":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  								break;  							}    							case "show":  							case "top":  							{  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  								break;  							}  							case "last":  							{  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  								break;  							}    							case "dump":  							{  								string output = PopParam(ref extras);  								if (string.IsNullOrEmpty(output))  								{  									StdErr("You must specify a target file path."' ConsoleColor.Red);  									break;  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Dump(path' output' extras' db' log' ct)' cancel);  								break;  							}    							case "cd":  							case "pwd":  							{  								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var newPath = CombinePath(CurrentDirectoryPath' prm);  									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  									if (res.Failed)  									{  										StdErr($"# Failed to open Directory {newPath}: {res.Error.Message}"' ConsoleColor.Red);  										Console.Beep();  									}  									else if (res.Value == null)  									{  										StdOut($"# Directory {newPath} does not exist!"' ConsoleColor.Red);  										Console.Beep();  									}  									else  									{  										CurrentDirectoryPath = newPath;  										UpdatePrompt(CurrentDirectoryPath);  									}  								}  								else  								{  									var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  									if (res.Failed)  									{  										StdErr($"# Failed to query Directory {Program.CurrentDirectoryPath}: {res.Error.Message}"' ConsoleColor.Red);  									}  									else if (res.Value == null)  									{  										StdOut($"# Directory {Program.CurrentDirectoryPath} does not exist anymore");  									}  								}    								break;  							}  							case "mkdir":  							case "md":  							{ // "mkdir DIRECTORYNAME"    								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  								}    								break;  							}  							case "rmdir":  							{ // "rmdir DIRECTORYNAME"  								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  								}    								break;  							}    							case "mv":  							case "ren":  							{ // "mv SOURCE DESTINATION"    								string prm = PopParam(ref extras);  								var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  								await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    								break;  							}    							case "get":  							{ // "get KEY"    								if (extras.Count == 0)  								{  									StdErr("You must specify a key to read."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Get(path' extras' db' log' ct)' cancel);  								break;  							}    							case "clear":  							{ // "clear KEY"    								if (extras.Count == 0)  								{  									StdErr("You must specify a key to clear."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.Clear(path' extras' db' log' ct)' cancel);  								break;  							}    							case "clearrange":  							{ // "clear *" or "clear FROM TO"    								if (extras.Count == 0)  								{  									StdErr("You must specify either '*'' a prefix' or a key range."' ConsoleColor.Red);  									break;  								}    								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ClearRange(path' extras' db' log' ct)' cancel);  								break;  							}    							case "layer":  							{  								string prm = PopParam(ref extras);  								if (string.IsNullOrEmpty(prm))  								{ // displays the layer id of the current folder  									var path = ParsePath(CurrentDirectoryPath);  									await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    								}  								else  								{ // change the layer id of the current folder  									prm = prm.Trim();  									// double or single quotes can be used to escape the value  									if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  									{  										prm = prm.Substring(1' prm.Length - 2);  									}    									var path = ParsePath(CurrentDirectoryPath);  									await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  								}    								break;  							}    							case "mkpart":  							{ // "mkpart PARTITIONNAME"    								string prm = PopParam(ref extras);  								if (!string.IsNullOrEmpty(prm))  								{  									var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  									await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' STuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  								}    								break;  							}    							case "topology":  							{  								await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  								break;  							}    							case "shards":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  								break;  							}    							case "sampling":  							{  								string prm = PopParam(ref extras);  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  								break;  							}    							case "coordinators":  							{  								await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  								break;  							}    							case "partition":  							{  								string prm = PopParam(ref extras);  								if (string.IsNullOrEmpty(prm))  								{  									StdOut($"# Current partition is {String.Join("/"' partition)}");  									//TODO: browse existing partitions ?  									break;  								}    								var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  								IFdbDatabase newDb = null;  								try  								{  									var options = new FdbConnectionOptions  									{  										ClusterFile = clusterFile'  										PartitionPath = newPartition  									};  									newDb = await ChangeDatabase(options' cancel);  								}  								catch (Exception)  								{  									newDb?.Dispose();  									newDb = null;  									throw;  								}  								finally  								{  									if (newDb != null)  									{  										if (Db != null)  										{  											Db.Dispose();  											Db = null;  										}    										Db = newDb;  										partition = newPartition;  										StdOut($"# Changed partition to /{string.Join("/"' partition)}");  									}  								}    								break;  							}    							case "q":  							case "x":  							case "quit":  							case "exit":  							case "bye":  							{  								stop = true;  								break;  							}    							case "gc":  							{  								long before = GC.GetTotalMemory(false);  								Console.Write("Collecting garbage...");  								GC.Collect();  								GC.WaitForPendingFinalizers();  								GC.Collect();  								StdOut(" Done");  								long after = GC.GetTotalMemory(false);  								StdOut("- before = " + before.ToString("N0"));  								StdOut("- after  = " + after.ToString("N0"));  								StdOut("- delta  = " + (before - after).ToString("N0"));  								break;  							}    							case "mem":  							{  								StdOut("Memory usage:");  								StdOut("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  								//TODO: how do we get these values on Linux/Mac?  #if !NETCOREAPP  								StdOut("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  								StdOut("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  								StdOut("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  								StdOut("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  #endif  								break;  							}    							case "wide":  							{  								try  								{  									Console.WindowWidth = 160;  								}  								catch (Exception e)  								{  									StdErr("Failed to change console width: " + e.Message' ConsoleColor.DarkRed);  								}    								break;  							}    							case "status":  							case "wtf":  							{  								var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  								if (result.Failed) break;  								if (result.Value.ExitCode != 0)  								{  									StdErr($"# fdbcli exited with code {result.Value.ExitCode}"' ConsoleColor.DarkRed);  									StdOut("> StdErr:"' ConsoleColor.DarkGray);  									StdOut(result.Value.StdErr);  									StdOut("> StdOut:"' ConsoleColor.DarkGray);  								}    								StdOut(result.Value.StdOut);  								break;  							}    							default:  							{  								StdErr($"Unknown command : '{trimmedCommand}'"' ConsoleColor.Red);  								break;  							}  						}
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,ChangeDatabase,The following statement contains a magic number: options.DefaultTimeout = TimeSpan.FromSeconds(30);
Magic Number,FdbShell,Program,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,ChangeDatabase,The following statement contains a magic number: options.DefaultRetryLimit = 50;
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetScaleToTicksRatio,The following statement contains a magic number: switch(scale)  			{  				case TimeScale.Ticks: return 1.0d;  				case TimeScale.Nanoseconds: return 1E-2d;  				case TimeScale.Microseconds: return 1E1d;  				case TimeScale.Milliseconds: return 1E4d;  				case TimeScale.Seconds: return 1E7d;  				default: return 1.0d;  			}
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetScaleToTicksRatio,The following statement contains a magic number: switch(scale)  			{  				case TimeScale.Ticks: return 1.0d;  				case TimeScale.Nanoseconds: return 1E-2d;  				case TimeScale.Microseconds: return 1E1d;  				case TimeScale.Milliseconds: return 1E4d;  				case TimeScale.Seconds: return 1E7d;  				default: return 1.0d;  			}
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetScaleToTicksRatio,The following statement contains a magic number: switch(scale)  			{  				case TimeScale.Ticks: return 1.0d;  				case TimeScale.Nanoseconds: return 1E-2d;  				case TimeScale.Microseconds: return 1E1d;  				case TimeScale.Milliseconds: return 1E4d;  				case TimeScale.Seconds: return 1E7d;  				default: return 1.0d;  			}
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetScaleToTicksRatio,The following statement contains a magic number: switch(scale)  			{  				case TimeScale.Ticks: return 1.0d;  				case TimeScale.Nanoseconds: return 1E-2d;  				case TimeScale.Microseconds: return 1E1d;  				case TimeScale.Milliseconds: return 1E4d;  				case TimeScale.Seconds: return 1E7d;  				default: return 1.0d;  			}
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,Percentile,The following statement contains a magic number: double threshold = this.Count * (p / 100.0d);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The following statement contains a magic number: var median = Percentile(50);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The following statement contains a magic number: var array = this.Buckets  				.Select((x' i) =>  				{  					double leftPoint = i > 0 ? BucketLimits[i - 1] : 0;  					double rightPoint = BucketLimits[i];  					// on considre qu'on est au millieu  					return new { Count = x' Deviation = Math.Abs(((leftPoint + rightPoint) / 2d) - median) };  				})  				.Where(kvp => kvp.Count > 0)  				.OrderBy((kvp => kvp.Deviation))  				.ToArray();
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The following statement contains a magic number: double threshold = this.Count * 0.5d;
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: int marks = (int)Math.Round((value * chars * 10)' MidpointRounding.AwayFromZero);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: max = (3 * max + this.Count) / 4;
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: max = (3 * max + this.Count) / 4;
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: int p = Math.Min((int)Math.Ceiling(rr * data[i])' 10);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: double mult = 100.0d / this.Count;
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));
Magic Number,FdbShell,RobustHistogram,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));
Magic Number,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,LineEditor,The following statement contains a magic number: handlers = new Handler[] {  				new Handler (ConsoleKey.Home'       CmdHome)'  				new Handler (ConsoleKey.End'        CmdEnd)'  				new Handler (ConsoleKey.LeftArrow'  CmdLeft)'  				new Handler (ConsoleKey.RightArrow' CmdRight)'  				new Handler (ConsoleKey.UpArrow'    CmdHistoryPrev)'  				new Handler (ConsoleKey.DownArrow'  CmdHistoryNext)'  				new Handler (ConsoleKey.Enter'      CmdDone)'  				new Handler (ConsoleKey.Backspace'  CmdBackspace)'  				new Handler (ConsoleKey.Delete'     CmdDeleteChar)'  				new Handler (ConsoleKey.Tab'        CmdTabOrComplete)'  				  				// Emacs keys  				Handler.Control ('A'' CmdHome)'  				Handler.Control ('E'' CmdEnd)'  				Handler.Control ('B'' CmdLeft)'  				Handler.Control ('F'' CmdRight)'  				Handler.Control ('P'' CmdHistoryPrev)'  				Handler.Control ('N'' CmdHistoryNext)'  				Handler.Control ('K'' CmdKillToEOF)'  				Handler.Control ('Y'' CmdYank)'  				Handler.Control ('D'' CmdDeleteChar)'  				Handler.Control ('L'' CmdRefresh)'  				Handler.Control ('R'' CmdReverseSearch)'  				Handler.Control ('G'' delegate {} )'  				Handler.Control ('C'' () => Console.WriteLine("YOU CANNOT ESCAPE!!!!") )'  				Handler.Alt ('B'' ConsoleKey.B' CmdBackwardWord)'  				Handler.Alt ('F'' ConsoleKey.F' CmdForwardWord)'  				  				Handler.Alt ('D'' ConsoleKey.D' CmdDeleteWord)'  				Handler.Alt ((char) 8' ConsoleKey.Backspace' CmdDeleteBackword)'  				  				// DEBUG  				//Handler.Control ('T'' CmdDebug)'    				// quote  				Handler.Control ('Q'' delegate { HandleChar (Console.ReadKey (true).KeyChar); })  			};
Magic Number,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ComputeRendered,The following statement contains a magic number: c < 26
Magic Number,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: p += 4;
Magic Number,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: c == 9
Magic Number,Mono.Terminal,LineEditor,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: c < 26
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Add,The following statement contains a magic number: Option p = new ActionOption (prototype' description' 2'  					delegate (OptionValueCollection v) {action (v [0]' v [1]);}' hidden);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' s.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);
Missing Default,Mono.Options,OptionSet,D:\research\architectureSmells\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  					case OptionValueType.None:  						c.OptionValues.Add (n);  						c.Option.Invoke (c);  						break;  					case OptionValueType.Optional:  					case OptionValueType.Required:  						ParseValue (v' c);  						break;  				}
