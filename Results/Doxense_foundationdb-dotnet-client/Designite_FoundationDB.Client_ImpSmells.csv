Implementation smell,Namespace,Class,File,Method,Description
Long Method,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The method has 235 lines of code.
Long Method,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The method has 119 lines of code.
Long Method,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedInsertOperationAsync,The method has 119 lines of code.
Long Method,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The method has 164 lines of code.
Long Method,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The method has 106 lines of code.
Long Method,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeObjectTo,The method has 144 lines of code.
Long Method,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The method has 135 lines of code.
Long Method,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,ReadToken,The method has 125 lines of code.
Complex Method,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,Cyclomatic complexity of the method is 11
Complex Method,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,Cyclomatic complexity of the method is 19
Complex Method,FoundationDB.Client,FdbExceptIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbExceptIterator.cs,FindNext,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Client,FdbIntersectIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbIntersectIterator.cs,FindNext,Cyclomatic complexity of the method is 10
Complex Method,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,ValidateKey,Cyclomatic complexity of the method is 9
Complex Method,FoundationDB.Client,SliceListStream,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceListStream.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Join,Cyclomatic complexity of the method is 11
Complex Method,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,JoinBytes,Cyclomatic complexity of the method is 11
Complex Method,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Split,Cyclomatic complexity of the method is 9
Complex Method,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,Cyclomatic complexity of the method is 9
Complex Method,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromStreamAsync,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Linq,FdbPrefetchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbPrefetchingAsyncIterator.cs,PrefetchNextItemsAsync,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Linq,FdbSelectManyAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbSelectManyAsyncIterator.cs,OnNextAsync,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Linq,FdbSelectManyAsyncIterator<TSource;TCollection;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbSelectManyAsyncIterator.cs,OnNextAsync,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,OnNextAsync,Cyclomatic complexity of the method is 12
Complex Method,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,AllocateAsync,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,Cyclomatic complexity of the method is 20
Complex Method,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,Cyclomatic complexity of the method is 13
Complex Method,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,DecodeKey,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Stringify,Cyclomatic complexity of the method is 15
Complex Method,FoundationDB.Layers.Tuples,CompositeComparer<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleComparisons.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,GetSerializerFor,Cyclomatic complexity of the method is 12
Complex Method,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,FdbFutureArray,Cyclomatic complexity of the method is 9
Complex Method,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,FdbFutureSingle,Cyclomatic complexity of the method is 8
Complex Method,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,Cyclomatic complexity of the method is 22
Long Parameter List,FoundationDB.Async,AsyncHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\AsyncHelpers.cs,TransformToListAsync,The method has 5 parameters. Parameters: source' transform' cancellationToken' maxConcurrency' scheduler
Long Parameter List,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The method has 5 parameters. Parameters: action' arg1' arg2' arg3' ct
Long Parameter List,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The method has 6 parameters. Parameters: action' arg1' arg2' arg3' arg4' ct
Long Parameter List,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The method has 7 parameters. Parameters: action' arg1' arg2' arg3' arg4' arg5' ct
Long Parameter List,FoundationDB.Client.Core,IFdbTransactionHandler,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Core\IFdbTransactionHandler.cs,GetRangeAsync,The method has 6 parameters. Parameters: beginInclusive' endExclusive' options' iteration' snapshot' cancellationToken
Long Parameter List,FoundationDB.Client,FdbEncoderSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspaceKeys`4.cs,Encode,The method has 5 parameters. Parameters: values' selector1' selector2' selector3' selector4
Long Parameter List,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The method has 5 parameters. Parameters: value1' value2' value3' value4' encoding
Long Parameter List,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The method has 5 parameters. Parameters: value1' value2' value3' value4' encoder
Long Parameter List,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The method has 5 parameters. Parameters: value1' value2' value3' value4' encoding
Long Parameter List,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The method has 5 parameters. Parameters: value1' value2' value3' value4' encoder
Long Parameter List,FoundationDB.Client,FdbDatabaseExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabaseExtensions.cs,GetRangeAsync,The method has 6 parameters. Parameters: db' beginInclusive' endExclusive' options' iteration' cancellationToken
Long Parameter List,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,OpenAsync,The method has 5 parameters. Parameters: clusterFile' dbName' globalSpace' readOnly' cancellationToken
Long Parameter List,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,OpenInternalAsync,The method has 5 parameters. Parameters: clusterFile' dbName' globalSpace' readOnly' cancellationToken
Long Parameter List,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The method has 5 parameters. Parameters: db' beginInclusive' endExclusive' onProgress' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,InsertAsync,The method has 5 parameters. Parameters: db' source' handler' options' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,InsertAsync,The method has 5 parameters. Parameters: db' source' handler' options' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunInsertOperationAsync,The method has 5 parameters. Parameters: db' source' body' options' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The method has 6 parameters. Parameters: trans' chunk' offset' count' bodyAsync' bodyBlocking
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,InsertBatchedAsync,The method has 5 parameters. Parameters: db' source' handler' options' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,InsertBatchedAsync,The method has 5 parameters. Parameters: db' source' handler' options' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedInsertOperationAsync,The method has 5 parameters. Parameters: db' source' body' options' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The method has 6 parameters. Parameters: trans' chunk' offset' count' bodyAsync' bodyBlocking
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The method has 6 parameters. Parameters: db' source' localInit' body' localFinally' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The method has 6 parameters. Parameters: db' source' localInit' body' localFinally' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,AggregateAsync,The method has 5 parameters. Parameters: db' source' localInit' body' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,AggregateAsync,The method has 6 parameters. Parameters: db' source' init' body' transform' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The method has 7 parameters. Parameters: db' source' localInit' body' localFinally' initialBatchSize' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The method has 5 parameters. Parameters: db' beginInclusive' endExclusive' handler' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The method has 5 parameters. Parameters: db' begin' end' handler' cancellationToken
Long Parameter List,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,FetchNextBatchAsync,The method has 5 parameters. Parameters: tr' begin' end' options' onReset
Long Parameter List,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,FdbTransaction,The method has 5 parameters. Parameters: db' context' id' handler' mode
Long Parameter List,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,GetRange,The method has 5 parameters. Parameters: trans' beginInclusive' endExclusive' limit' reverse
Long Parameter List,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,GetRange,The method has 5 parameters. Parameters: trans' beginKeyInclusive' endKeyExclusive' limit' reverse
Long Parameter List,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,GetRange,The method has 5 parameters. Parameters: trans' beginKeyInclusive' endKeyExclusive' limit' reverse
Long Parameter List,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,GetRangeAsync,The method has 5 parameters. Parameters: trans' beginInclusive' endExclusive' options' iteration
Long Parameter List,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,SetAndWatch,The method has 5 parameters. Parameters: trans' key' value' encoder' cancellationToken
Long Parameter List,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,SetAndWatch,The method has 5 parameters. Parameters: trans' key' value' encoder' cancellationToken
Long Parameter List,FoundationDB.Client,FdbRangeOptions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeOptions.cs,EnsureDefaults,The method has 5 parameters. Parameters: options' limit' targetBytes' mode' reverse
Long Parameter List,FoundationDB.Client,FdbMergeQueryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeQueryExtensions.cs,MergeSort,The method has 5 parameters. Parameters: trans' ranges' keySelector' resultSelector' keyComparer
Long Parameter List,FoundationDB.Client,FdbMergeQueryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeQueryExtensions.cs,Intersect,The method has 5 parameters. Parameters: trans' ranges' keySelector' resultSelector' keyComparer
Long Parameter List,FoundationDB.Client,FdbMergeQueryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeQueryExtensions.cs,Except,The method has 5 parameters. Parameters: trans' ranges' keySelector' resultSelector' keyComparer
Long Parameter List,FoundationDB.Client,FdbMergeQueryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeQueryExtensions.cs,Except,The method has 5 parameters. Parameters: trans' ranges' keySelector' resultSelector' keyComparer
Long Parameter List,FoundationDB.Client,FdbExceptIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbExceptIterator.cs,FdbExceptIterator,The method has 5 parameters. Parameters: sources' limit' keySelector' resultSelector' comparer
Long Parameter List,FoundationDB.Client,FdbQueryMergeIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbQueryMergeIterator.cs,FdbQueryMergeIterator,The method has 5 parameters. Parameters: sources' limit' keySelector' resultSelector' comparer
Long Parameter List,FoundationDB.Client,FdbIntersectIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbIntersectIterator.cs,FdbIntersectIterator,The method has 5 parameters. Parameters: sources' limit' keySelector' resultSelector' comparer
Long Parameter List,FoundationDB.Client,FdbMergeSortIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeSortIterator.cs,FdbMergeSortIterator,The method has 5 parameters. Parameters: sources' limit' keySelector' resultSelector' comparer
Long Parameter List,FoundationDB.Client,FdbRangeQuery<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.ResultIterator.cs,FdbRangeQuery,The method has 6 parameters. Parameters: transaction' begin' end' transform' snapshot' options
Long Parameter List,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The method has 5 parameters. Parameters: clusterFile' dbName' path' readOnly' cancellationToken
Long Parameter List,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,FdbDatabase,The method has 7 parameters. Parameters: cluster' handler' name' contentSubspace' directory' readOnly' ownsCluster
Long Parameter List,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,Create,The method has 7 parameters. Parameters: cluster' handler' name' contentSubspace' directory' readOnly' ownsCluster
Long Parameter List,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,ValidateKey,The method has 5 parameters. Parameters: database' key' endExclusive' ignoreError' error
Long Parameter List,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,OpenDatabaseInternalAsync,The method has 5 parameters. Parameters: databaseName' subspace' readOnly' ownsCluster' cancellationToken
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The method has 5 parameters. Parameters: items' selector1' selector2' selector3' selector4
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,Encode,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The method has 6 parameters. Parameters: items' selector1' selector2' selector3' selector4' selector5
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,Encode,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The method has 7 parameters. Parameters: items' selector1' selector2' selector3' selector4' selector5' selector6
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,Encode,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The method has 8 parameters. Parameters: items' selector1' selector2' selector3' selector4' selector5' selector6' selector7
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,Encode,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The method has 9 parameters. Parameters: items' selector1' selector2' selector3' selector4' selector5' selector6' selector7' selector8
Long Parameter List,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,Append,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,EncodeKey,The method has 5 parameters. Parameters: writer' item1' item2' item3' item4
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,EncodeKey,The method has 6 parameters. Parameters: writer' item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,EncodeKey,The method has 7 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,EncodeKey,The method has 8 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,EncodeKey,The method has 9 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,ToKeyRange,The method has 5 parameters. Parameters: prefix' item1' item2' item3' item4
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,ToKeyRange,The method has 6 parameters. Parameters: prefix' item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,ToKeyRange,The method has 7 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,ToKeyRange,The method has 8 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Client,IDynamicKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\IDynamicKeyEncoder.cs,ToKeyRange,The method has 9 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,EncodeKey,The method has 5 parameters. Parameters: writer' item1' item2' item3' item4
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,EncodeKey,The method has 6 parameters. Parameters: writer' item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,EncodeKey,The method has 7 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,EncodeKey,The method has 8 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,EncodeKey,The method has 9 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,ToKeyRange,The method has 5 parameters. Parameters: prefix' item1' item2' item3' item4
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,ToKeyRange,The method has 6 parameters. Parameters: prefix' item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,ToKeyRange,The method has 7 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,ToKeyRange,The method has 8 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,ToKeyRange,The method has 9 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Client,Ordered,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,Encode,The method has 5 parameters. Parameters: writer' codec1' value1' codec2' value2
Long Parameter List,FoundationDB.Client,Ordered,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,Encode,The method has 7 parameters. Parameters: writer' codec1' value1' codec2' value2' codec3' value3
Long Parameter List,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,SameBytes,The method has 5 parameters. Parameters: left' leftOffset' right' rightOffset' count
Long Parameter List,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,SameBytesUnsafe,The method has 5 parameters. Parameters: left' leftOffset' right' rightOffset' count
Long Parameter List,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CompareBytes,The method has 6 parameters. Parameters: left' leftOffset' leftCount' right' rightOffset' rightCount
Long Parameter List,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CompareBytesUnsafe,The method has 6 parameters. Parameters: left' leftOffset' leftCount' right' rightOffset' rightCount
Long Parameter List,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CopyBytes,The method has 5 parameters. Parameters: dst' dstOffset' src' srcOffset' count
Long Parameter List,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CopyBytesUnsafe,The method has 5 parameters. Parameters: dst' dstOffset' src' srcOffset' count
Long Parameter List,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Uuid128,The method has 11 parameters. Parameters: a' b' c' d' e' f' g' h' i' j' k
Long Parameter List,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Uuid128,The method has 11 parameters. Parameters: a' b' c' d' e' f' g' h' i' j' k
Long Parameter List,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The method has 5 parameters. Parameters: sb' buffer' offset' count' encoding
Long Parameter List,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte5,The method has 5 parameters. Parameters: value1' value2' value3' value4' value5
Long Parameter List,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte5,The method has 5 parameters. Parameters: value1' value2' value3' value4' value5
Long Parameter List,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,ToDictionaryAsync,The method has 5 parameters. Parameters: source' keySelector' elementSelector' comparer' cancellationToken
Long Parameter List,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,AggregateAsync,The method has 5 parameters. Parameters: source' seed' aggregator' resultSelector' cancellationToken
Long Parameter List,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,AggregateAsync,The method has 5 parameters. Parameters: source' seed' aggregator' resultSelector' cancellationToken
Long Parameter List,FoundationDB.Linq,OrderedSequence<TSource;TKey>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,OrderedSequence,The method has 5 parameters. Parameters: source' keySelector' comparer' descending' parent
Long Parameter List,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,FdbWhereSelectAsyncIterator,The method has 5 parameters. Parameters: source' filter' transform' limit' offset
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,CreateOrOpenAsync,The method has 5 parameters. Parameters: directory' db' path' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,CreateOrOpenAsync,The method has 5 parameters. Parameters: directory' db' name' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryCreateOrOpenAsync,The method has 5 parameters. Parameters: directory' trans' path' readOnly' layer
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryCreateOrOpenAsync,The method has 5 parameters. Parameters: directory' trans' name' readOnly' layer
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,CreateAsync,The method has 5 parameters. Parameters: directory' db' path' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,CreateAsync,The method has 5 parameters. Parameters: directory' db' name' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryCreateAsync,The method has 5 parameters. Parameters: directory' db' path' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryCreateAsync,The method has 5 parameters. Parameters: directory' db' name' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,OpenAsync,The method has 5 parameters. Parameters: directory' db' path' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,OpenAsync,The method has 5 parameters. Parameters: directory' db' name' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryOpenAsync,The method has 5 parameters. Parameters: directory' db' path' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryOpenAsync,The method has 5 parameters. Parameters: directory' db' name' layer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,MoveAsync,The method has 5 parameters. Parameters: directory' db' oldPath' newPath' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,TryMoveAsync,The method has 5 parameters. Parameters: directory' db' oldPath' newPath' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryExtensions.cs,ChangeLayerAsync,The method has 5 parameters. Parameters: directory' db' path' newLayer' cancellationToken
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,FdbDirectorySubspace,The method has 6 parameters. Parameters: location' relativeLocation' prefix' directoryLayer' layer' encoder
Long Parameter List,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The method has 8 parameters. Parameters: readTrans' trans' path' layer' prefix' allowCreate' allowOpen' throwOnError
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FdbTuple,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Create,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodeKey,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodeKey,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodeKey,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodeKey,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKey,The method has 5 parameters. Parameters: prefix' value1' value2' value3' value4
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKey,The method has 6 parameters. Parameters: prefix' value1' value2' value3' value4' value5
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKey,The method has 7 parameters. Parameters: prefix' value1' value2' value3' value4' value5' value6
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKey,The method has 8 parameters. Parameters: prefix' value1' value2' value3' value4' value5' value6' value7
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKey,The method has 9 parameters. Parameters: prefix' value1' value2' value3' value4' value5' value6' value7' value8
Long Parameter List,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CombineHashCodes,The method has 5 parameters. Parameters: h1' h2' h3' h4' h5
Long Parameter List,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteNulEscapedBytes,The method has 5 parameters. Parameters: writer' type' value' offset' count
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,EncodeKey,The method has 5 parameters. Parameters: writer' item1' item2' item3' item4
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,EncodeKey,The method has 6 parameters. Parameters: writer' item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,EncodeKey,The method has 7 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,EncodeKey,The method has 8 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,EncodeKey,The method has 9 parameters. Parameters: writer' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,ToKeyRange,The method has 5 parameters. Parameters: prefix' item1' item2' item3' item4
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,ToKeyRange,The method has 6 parameters. Parameters: prefix' item1' item2' item3' item4' item5
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,ToKeyRange,The method has 7 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,ToKeyRange,The method has 8 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,FoundationDB.Layers.Tuples,TupleKeyEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\TypeSystem\TupleKeyEncoder.cs,ToKeyRange,The method has 9 parameters. Parameters: prefix' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,Append,The method has 5 parameters. Parameters: tuple' value1' value2' value3' value4
Long Parameter List,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,GetRangeAsync,The method has 6 parameters. Parameters: begin' end' options' iteration' snapshot' cancellationToken
Long Parameter List,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGetRange,The method has 9 parameters. Parameters: transaction' begin' end' limit' targetBytes' mode' iteration' snapshot' reverse
Long Parameter List,FoundationDB.Client.Native,NativeMethods,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,fdb_transaction_get_key,The method has 6 parameters. Parameters: transaction' keyName' keyNameLength' orEqual' offset' snapshot
Long Parameter List,FoundationDB.Client.Native,NativeMethods,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,fdb_transaction_get_range,The method has 15 parameters. Parameters: transaction' beginKeyName' beginKeyNameLength' beginOrEqual' beginOffset' endKeyName' endKeyNameLength' endOrEqual' endOffset' limit' targetBytes' mode' iteration' snapshot' reverse
Long Parameter List,FoundationDB.Client.Native,NativeMethods,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,fdb_transaction_set,The method has 5 parameters. Parameters: transaction' keyName' keyNameLength' value' valueLength
Long Parameter List,FoundationDB.Client.Native,NativeMethods,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,fdb_transaction_clear_range,The method has 5 parameters. Parameters: transaction' beginKeyName' beginKeyNameLength' endKeyName' endKeyNameLength
Long Parameter List,FoundationDB.Client.Native,NativeMethods,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,fdb_transaction_atomic_op,The method has 6 parameters. Parameters: transaction' keyName' keyNameLength' param' paramLength' operationType
Long Parameter List,FoundationDB.Client.Native,NativeMethods,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,fdb_transaction_add_conflict_range,The method has 6 parameters. Parameters: transaction' beginKeyName' beginKeyNameLength' endKeyName' endKeyNameLength' type
Long Parameter List,FoundationDB.Filters.Logging,FdbLoggedDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggedDatabase.cs,FdbLoggedDatabase,The method has 5 parameters. Parameters: database' forceReadOnly' ownsDatabase' onCommitted' defaultOptions
Long Parameter List,FoundationDB.Filters.Logging,FdbLoggingExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggingExtensions.cs,Annotate,The method has 5 parameters. Parameters: trans' format' arg0' arg1' arg2
Long Parameter List,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetFancyChar,The method has 5 parameters. Parameters: pos' count' start' end' skip
Long Parameter List,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetFancyGraph,The method has 5 parameters. Parameters: width' offset' duration' total' skip
Long Statement,FoundationDB.Async,AsyncTransform<T;R>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\AsyncTransform.cs,OnNextAsync,The length of the statement  "			if (m_done) throw new InvalidOperationException("Cannot send any more values because this transform has already completed"); " is 124.
Long Statement,FoundationDB.Async,AsyncBuffer<T;R>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\AsyncBuffer.cs,OnNextAsync,The length of the statement  "				if (m_done) return TaskHelpers.FromException<object>(new InvalidOperationException("Cannot send any more values because this buffer has already completed")); " is 157.
Long Statement,FoundationDB.Async,AsyncTaskBuffer<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\AsyncTaskBuffer.cs,OnNextAsync,The length of the statement  "				if (m_done) return TaskHelpers.FromException<object>(new InvalidOperationException("Cannot send any more values because this buffer has already completed")); " is 157.
Long Statement,FoundationDB.Async,Maybe,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\Maybe.cs,Equals,The length of the statement  "			return this.HasValue == other.HasValue && object.ReferenceEquals(this.ErrorContainer' other.ErrorContainer) && EqualityComparer<T>.Default.Equals(this.Value' other.Value); " is 171.
Long Statement,FoundationDB.Async,Maybe,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\Maybe.cs,ToString,The length of the statement  "			//TODO: consider adding '['/']' around the value' to distinguish a Maybe<T> between a T in the console and the debugger ? " is 121.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Then,The length of the statement  "			// Note: we use 'await' instead of ContinueWith' so that we can give the caller a nicer callstack in case of errors (instead of an AggregateExecption) " is 150.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Then,The length of the statement  "			// Note: we use 'await' instead of ContinueWith' so that we can give the caller a nicer callstack in case of errors (instead of an AggregateExecption) " is 150.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The length of the statement  "			// note: if action is null' then there is a bug in the caller' and it should blow up instantly (will help preserving the call stack) " is 132.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The length of the statement  "			// note: if action is null' then there is a bug in the caller' and it should blow up instantly (will help preserving the call stack) " is 132.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The length of the statement  "			// note: if action is null' then there is a bug in the caller' and it should blow up instantly (will help preserving the call stack) " is 132.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The length of the statement  "			// note: if action is null' then there is a bug in the caller' and it should blow up instantly (will help preserving the call stack) " is 132.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,Inline,The length of the statement  "			// note: if action is null' then there is a bug in the caller' and it should blow up instantly (will help preserving the call stack) " is 132.
Long Statement,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,FromCancellation,The length of the statement  "			// The "best" way I've seen to emulate the same behavior' is creating a fake task (with a dummy action) with the same alread-cancelled CancellationToken " is 152.
Long Statement,FoundationDB.Client.Converters,ComparisonHelper,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,CreateTypeComparator,The length of the statement  "			// note: the most common scenarios will be when we compare 'A' to "A"' or (int)123 to (long)123' Guids in string or System.Guid form' ... " is 137.
Long Statement,FoundationDB.Client.Converters,ComparisonHelper,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,CreateTypeComparator,The length of the statement  "						return x == null ? y == null : y != null && TryAdaptToDecimal(x' t1' out d1) && TryAdaptToDecimal(y' t2' out d2) && d1 == d2; " is 125.
Long Statement,FoundationDB.Client.Converters,ComparisonHelper,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,CreateTypeComparator,The length of the statement  "						return x == null ? y == null : y != null && TryAdaptToInteger(x' t1' out l1) && TryAdaptToInteger(y' t2' out l2) && l1 == l2; " is 125.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' sbyte>((value) => string.IsNullOrEmpty(value) ? default(sbyte) : SByte.Parse(value' CultureInfo.InvariantCulture)); " is 138.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' byte>((value) => string.IsNullOrEmpty(value) ? default(byte) : Byte.Parse(value' CultureInfo.InvariantCulture)); " is 135.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' short>((value) => string.IsNullOrEmpty(value) ? default(short) : Int16.Parse(value' CultureInfo.InvariantCulture)); " is 138.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' ushort>((value) => string.IsNullOrEmpty(value) ? default(ushort) : UInt16.Parse(value' CultureInfo.InvariantCulture)); " is 141.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' int>((value) => string.IsNullOrEmpty(value) ? default(int) : Int32.Parse(value' CultureInfo.InvariantCulture)); " is 134.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' uint>((value) => string.IsNullOrEmpty(value) ? default(uint) : UInt32.Parse(value' CultureInfo.InvariantCulture)); " is 137.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' long>((value) => string.IsNullOrEmpty(value) ? default(long) : Int64.Parse(value' CultureInfo.InvariantCulture)); " is 136.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' ulong>((value) => string.IsNullOrEmpty(value) ? default(ulong) : UInt64.Parse(value' CultureInfo.InvariantCulture)); " is 139.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' float>((value) => string.IsNullOrEmpty(value) ? default(float) : Single.Parse(value' NumberStyles.Float' CultureInfo.InvariantCulture)); " is 159.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' double>((value) => string.IsNullOrEmpty(value) ? default(double) : Double.Parse(value' NumberStyles.Float' CultureInfo.InvariantCulture)); " is 161.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<string' System.Net.IPAddress>((value) => string.IsNullOrEmpty(value) ? default(System.Net.IPAddress) : System.Net.IPAddress.Parse(value)); " is 153.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<byte[]' string>((value) => value == null ? default(string) : value.Length == 0 ? String.Empty : System.Convert.ToBase64String(value)); " is 149.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<byte[]' Guid>((value) => value == null || value.Length == 0 ? default(Guid) : new Uuid128(value).ToGuid()); " is 122.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<byte[]' TimeSpan>((value) => value == null ? TimeSpan.Zero : TimeSpan.FromTicks(Slice.Create(value).ToInt64())); " is 127.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<byte[]' System.Net.IPAddress>((value) => value == null || value.Length == 0 ? default(System.Net.IPAddress) : new System.Net.IPAddress(value)); " is 158.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<System.Net.IPAddress' Slice>((value) => value != null ? Slice.Create(value.GetAddressBytes()) : Slice.Nil); " is 122.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,RegisterDefaultConverters,The length of the statement  "			RegisterUnsafe<Slice' System.Net.IPAddress>((value) => !value.IsNullOrEmpty ? new System.Net.IPAddress(value.GetBytes()) : null); " is 129.
Long Statement,FoundationDB.Client.Converters,FdbConverters,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\FdbConverters.cs,FailCannotConvert,The length of the statement  "			throw new InvalidOperationException(String.Format("Cannot convert values of type {0} into {1}"' sourceName' destinationName)); " is 126.
Long Statement,FoundationDB.Client,FdbEncoderSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspaceKeys`4.cs,Encode,The length of the statement  "				(ref SliceWriter writer' TSource value' ICompositeKeyEncoder<T1' T2' T3' T4> encoder) => writer.WriteBytes(encoder.EncodeKey(selector1(value)' selector2(value)' selector3(value)' selector4(value)))' " is 198.
Long Statement,FoundationDB.Client,FdbEncoderSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspaceKeys`4.cs,Encode,The length of the statement  "				(ref SliceWriter writer' TSource value' ICompositeKeyEncoder<T1' T2' T3> encoder) => writer.WriteBytes(encoder.EncodeKey(selector1(value)' selector2(value)' selector3(value)))' " is 176.
Long Statement,FoundationDB.Client,FdbEncoderSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspaceKeys`4.cs,Encode,The length of the statement  "				(ref SliceWriter writer' TSource value' ICompositeKeyEncoder<T1' T2> encoder) => writer.WriteBytes(encoder.EncodeKey(selector1(value)' selector2(value)))' " is 154.
Long Statement,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The length of the statement  "			return FdbSubspace.CreateDynamic(this.Subspace.ConcatKey(this.Encoder.EncodeKey(value1' value2' value3' value4))' encoding); " is 124.
Long Statement,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The length of the statement  "			return FdbSubspace.CreateDynamic(this.Subspace.ConcatKey(this.Encoder.EncodeKey(value1' value2' value3' value4))' encoder); " is 123.
Long Statement,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The length of the statement  "			return FdbSubspace.CreateEncoder<TNext>(this.Subspace.ConcatKey(this.Encoder.EncodeKey(value1' value2' value3' value4))' encoding); " is 131.
Long Statement,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The length of the statement  "			return FdbSubspace.CreateEncoder<TNext>(this.Subspace.ConcatKey(this.Encoder.EncodeKey(value1' value2' value3' value4))' encoder); " is 130.
Long Statement,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The length of the statement  "			return FdbSubspace.CreateEncoder<TNext>(this.Subspace.ConcatKey(this.Encoder.EncodeKey(value1' value2' value3))' encoding); " is 123.
Long Statement,FoundationDB.Client,FdbEncoderSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbEncoderSubspacePartition`4.cs,ByKey,The length of the statement  "			return FdbSubspace.CreateEncoder<TNext>(this.Subspace.ConcatKey(this.Encoder.EncodeKey(value1' value2' value3))' encoder); " is 122.
Long Statement,FoundationDB.Client,FdbEndPoint,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbEndPoint.cs,Create,The length of the statement  "			// Current implementation of IPEndPoint does really check the exact size of the buffer' and should not use the extra byte we added... " is 133.
Long Statement,FoundationDB.Client,FdbEndPoint,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbEndPoint.cs,Create,The length of the statement  "			if ((socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetwork && count == 17) || (socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetworkV6 && count == 29)) " is 183.
Long Statement,FoundationDB.Client,FdbDatabaseExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabaseExtensions.cs,SetLocationCacheSize,The length of the statement  "			//REVIEW: we can't really change this to a Property' because we don't have a way to get the current value for the getter' and set only properties are weird... " is 158.
Long Statement,FoundationDB.Client,FdbDatabaseExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabaseExtensions.cs,SetMaxWatches,The length of the statement  "			if (count < 0) throw new FdbException(FdbError.InvalidOptionValue' "Maximum outstanding watches count must be a positive integer"); " is 131.
Long Statement,FoundationDB.Client,FdbDatabaseExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabaseExtensions.cs,SetMaxWatches,The length of the statement  "			//REVIEW: we can't really change this to a Property' because we don't have a way to get the current value for the getter' and set only properties are weird... " is 158.
Long Statement,FoundationDB.Client,FdbDatabaseExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabaseExtensions.cs,SetMachineId,The length of the statement  "			//REVIEW: we can't really change this to a Property' because we don't have a way to get the current value for the getter' and set only properties are weird... " is 158.
Long Statement,FoundationDB.Client,FdbDatabaseExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabaseExtensions.cs,SetDataCenterId,The length of the statement  "			//REVIEW: we can't really change this to a Property' because we don't have a way to get the current value for the getter' and set only properties are weird... " is 158.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,UseApiVersion,The length of the statement  "			if (s_started) throw new InvalidOperationException(string.Format("You cannot set API version {0} because version {1} has already been selected"' value' s_apiVersion)); " is 167.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,UseApiVersion,The length of the statement  "			if (value < min) throw new ArgumentException(String.Format("The minimum API version supported by this binding is {0} and the default version is {1}."' min' DefaultApiVersion)); " is 176.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,UseApiVersion,The length of the statement  "			if (value > max) throw new ArgumentException(String.Format("The maximum API version supported by this binding is {0} and the default version is {1}."' max' DefaultApiVersion)); " is 176.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The length of the statement  "					if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("Failed to stop event loop: {0}"' err.ToString())); " is 127.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The length of the statement  "					// BUGBUG: specs says that we need to wait for the network thread to stop gracefuly' or else data integrity may not be guaranteed... " is 132.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The length of the statement  "							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread has not stopped after {0} seconds. Forcing shutdown..."' duration.Elapsed.TotalSeconds.ToString("N0"))); " is 204.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The length of the statement  "							//REVIEW: is this even usefull? If the thread is stuck in a native P/Invoke call' it won't get notified until it returns to managed code ... " is 140.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The length of the statement  "								if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread failed to stop after more than {0} seconds. Transaction integrity may not be guaranteed."' duration.Elapsed.TotalSeconds.ToString("N0"))); " is 238.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The length of the statement  "							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread took a long time to stop ({0} seconds)."' duration.Elapsed.TotalSeconds.ToString("N0"))); " is 189.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EventLoop,The length of the statement  "			//TODO: we need to move the crash handling logic outside this method' so that an app can hook up an event and device what to do: crash or keep running (dangerous!). " is 164.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EventLoop,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "EventLoop"' String.Format("FDB Event Loop running on thread #{0}..."' s_eventLoopThreadId.Value)); " is 144.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EventLoop,The length of the statement  "						if (Logging.On) Logging.Info(typeof(Fdb)' "EventLoop"' String.Format("The fdb network thread returned with error code {0}: {1}"' err' GetErrorMessage(err))); " is 157.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EventLoop,The length of the statement  "						if (Logging.On) Logging.Error(typeof(Fdb)' "EventLoop"' String.Format("The fdb network thread returned with error code {0}: {1}"' err' GetErrorMessage(err))); " is 158.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EventLoop,The length of the statement  "				//note: any error is this thread is BAD NEWS for the process' the the network thread usually cannot be restarted safely. " is 120.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EventLoop,The length of the statement  "					Environment.FailFast("The FoundationDB Network Event Loop crashed with an Access Violation' and had to be terminated. You may try to create full memory dumps' as well as attach a debugger to this process (it will automatically break when this problem occurs)."' e); " is 265.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,CreateClusterInternalAsync,The length of the statement  "			if (Logging.On) Logging.Info(typeof(Fdb)' "CreateClusterAsync"' clusterFile == null ? "Connecting to default cluster..." : String.Format("Connecting to cluster using '{0}' ..."' clusterFile)); " is 192.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,OpenAsync,The length of the statement  "			return OpenAsync(clusterFile: null' dbName: null' globalSpace: FdbSubspace.Empty' cancellationToken: cancellationToken); " is 120.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,OpenInternalAsync,The length of the statement  "			if (Logging.On) Logging.Info(typeof(Fdb)' "OpenAsync"' String.Format("Connecting to database '{0}' using cluster file '{1}' and subspace '{2}' ..."' dbName' clusterFile' globalSpace)); " is 184.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,OpenInternalAsync,The length of the statement  "				db = await cluster.OpenDatabaseInternalAsync(dbName' globalSpace' readOnly: readOnly' ownsCluster: true' cancellationToken: cancellationToken).ConfigureAwait(false); " is 165.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Error(typeof(Fdb)' "Start"' String.Format("Failed to fdb API version {0}: {1}"' apiVersion' err)); " is 122.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "						// note: we already bound check the values before' so that means that fdb_c.dll is either an older version or an incompatible new version. " is 138.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "						throw new FdbException(err' String.Format("The API version {0} is not supported by the FoundationDB client library (fdb_c.dll) installed on this system. The binding only supports versions {1} to {2}. You either need to upgrade the .NET binding or the FoundationDB client library to a newer version."' apiVersion' GetMinApiVersion()' GetMaxApiVersion())); " is 354.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will trace client activity in '{0}'"' Fdb.Options.TracePath)); " is 131.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will use custom TLS plugin '{0}'"' Fdb.Options.TLSPlugin)); " is 128.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will load TLS root certificate and private key from memory ({0} bytes)"' Fdb.Options.TLSCertificateBytes.Count)); " is 182.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will load TLS root certificate and private key from '{0}'"' Fdb.Options.TLSCertificatePath)); " is 162.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will load TLS private key from memory ({0} bytes)"' Fdb.Options.TLSPrivateKeyBytes.Count)); " is 160.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will load TLS private key from '{0}'"' Fdb.Options.TLSPrivateKeyPath)); " is 140.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "				if (Logging.On) Logging.Verbose(typeof(Fdb)' "Start"' String.Format("Will verify TLS peers with pattern '{0}'"' Fdb.Options.TLSVerificationPattern)); " is 149.
Long Statement,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The length of the statement  "						if (Logging.On) Logging.Verbose(typeof(Fdb)' "AppDomainUnloadHandler"' "AppDomain is unloading' stopping FoundationDB Network Thread..."); " is 138.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetCoordinatorsAsync,The length of the statement  "					//note: we ask for high priotity' because this method maybe called by a monitoring system than has to run when the cluster is clogged up in requests " is 148.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetCoordinatorsAsync,The length of the statement  "				if (coordinators.IsNull) throw new InvalidOperationException("Failed to read the list of coordinators from the cluster's system keyspace."); " is 140.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetConfigParameterAsync,The length of the statement  "				if (string.IsNullOrEmpty(name)) throw new ArgumentException("Configuration parameter name cannot be null or empty"' "name"); " is 124.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetConfigParameterAsync,The length of the statement  "					//note: we ask for high priotity' because this method maybe called by a monitoring system than has to run when the cluster is clogged up in requests " is 148.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetStorageEngineModeAsync,The length of the statement  "				if (value.IsNull) throw new InvalidOperationException("Failed to read the storage engine mode from the cluster's system keyspace"); " is 131.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetChunksAsync,The length of the statement  "				if (endExclusive < beginInclusive) throw new ArgumentException("The end key cannot be less than the begin key"' "endExclusive"); " is 128.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetBoundaryKeysInternalAsync,The length of the statement  "						var chunk = await trans.Snapshot.GetRangeAsync(KeyServers + begin' KeyServers + end' options' iterations).ConfigureAwait(false); " is 128.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				if (endExclusive < beginInclusive) throw new ArgumentException("The end key cannot be less than the begin key"' "endExclusive"); " is 128.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// To count the number of items in the range' we will scan it using a key selector with an offset equal to our window size " is 122.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// > if the returned key is still inside the range' we add the window size to the counter' and start again from the current key " is 127.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// Since we don't know in advance if the range contains 1 key or 1 Billion keys' choosing a good value for the window size is critical: " is 135.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// > if it is too small and the range is very large' we will need too many sequential reads and the network latency will quickly add up " is 135.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// > if it is too large and the range is small' we will spend too many times halving the window size until we get the correct value " is 131.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// > for the last segment' we don't need to wait for a GetKey to complete before issuing the next' so we could split the segment into 4 (or more)' do the GetKeyAsync() in parallel' detect the quarter that cross the boundary' and iterate again until the size is small " is 266.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// > once the window size is small enough' we can switch to using GetRange to read the last segment in one shot' instead of iterating with window size 16' 8' 4' 2 and 1 (the wost case being 2^N - 1 items remaning) " is 213.
Long Statement,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The length of the statement  "				// note: we make a copy of the keys because the operation could take a long time and the key's could prevent a potentially large underlying buffer from being GCed " is 162.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunInsertOperationAsync,The length of the statement  "						Trace.WriteLine("> commit called with " + batch.Count.ToString("N0") + " items and " + trans.Size.ToString("N0") + " bytes"); " is 125.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunInsertOperationAsync,The length of the statement  "						// if transaction Size is bigger than Fdb.MaxTransactionSize (10MB) then commit will fail' but we will retry with a smaller batch anyway " is 136.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunInsertOperationAsync,The length of the statement  "								if (batch.Count == 1) throw new InvalidOperationException("Cannot insert one the item of the source collection because it exceeds the maximum size allowed per transaction"); " is 173.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The length of the statement  "				Contract.Requires(trans != null && chunk != null && offset >= 0 && count >= 0 && (bodyAsync != null || bodyBlocking != null)); " is 126.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The length of the statement  "					if (count == 1) throw new InvalidOperationException("Cannot insert one the item of the source collection because it exceeds the maximum size allowed per transaction"); " is 167.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The length of the statement  "				//TODO: for the moment we do a recursive call' which could potentially cause a stack overflow in addition to being ugly. " is 120.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedInsertOperationAsync,The length of the statement  "						Trace.WriteLine("> commit called with " + batch.Count.ToString("N0") + " items and " + trans.Size.ToString("N0") + " bytes"); " is 125.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedInsertOperationAsync,The length of the statement  "						// if transaction Size is bigger than Fdb.MaxTransactionSize (10MB) then commit will fail' but we will retry with a smaller batch anyway " is 136.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedInsertOperationAsync,The length of the statement  "								if (chunk.Count == 1) throw new InvalidOperationException("Cannot insert one the item of the source collection because it exceeds the maximum size allowed per transaction"); " is 173.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The length of the statement  "				Contract.Requires(trans != null && chunk != null && offset >= 0 && count >= 0 && (bodyAsync != null || bodyBlocking != null)); " is 126.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The length of the statement  "					if (count == 1) throw new InvalidOperationException("Cannot insert one the item of the source collection because it exceeds the maximum size allowed per transaction"); " is 167.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RetryChunk,The length of the statement  "				//TODO: for the moment we do a recursive call' which could potentially cause a stack overflow in addition to being ugly. " is 120.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				return RunBatchedReadOperationAsync<TSource' TLocal' object>(db' source' localInit' body' localFinally' DefaultInitialBatchSize' cancellationToken); " is 148.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				// > either it's not async' then it could only Write/Clear' and in which case we need a writeable transaction ... ? (and who will commit and when ??) " is 149.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				// It could maybe make sense if the source was an IFdbAsyncEnumerable<T> because you could not use Parallel.ForEach(...) for that " is 129.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				return RunBatchedReadOperationAsync<TSource' TLocal' object>(db' source' localInit' body' localFinally' DefaultInitialBatchSize' cancellationToken); " is 148.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				return RunBatchedReadOperationAsync<TSource' object' object>(db' source' null' body' null' DefaultInitialBatchSize' cancellationToken); " is 135.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				// > either it's not async' then it could only Write/Clear' and in which case we need a writeable transaction ... ? (and who will commit and when ??) " is 149.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				// It could maybe make sense if the source was an IFdbAsyncEnumerable<T> because you could not use Parallel.ForEach(...) for that " is 129.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ForEachAsync,The length of the statement  "				return RunBatchedReadOperationAsync<TSource' object' object>(db' source' null' body' null' DefaultInitialBatchSize' cancellationToken); " is 135.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,AggregateAsync,The length of the statement  "				return RunBatchedReadOperationAsync<TSource' TAggregate' TAggregate>(db' source' localInit' body' identity' DefaultInitialBatchSize' cancellationToken); " is 152.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,AggregateAsync,The length of the statement  "				return RunBatchedReadOperationAsync<TSource' TAggregate' TResult>(db' source' init' body' transform' DefaultInitialBatchSize' cancellationToken); " is 145.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The length of the statement  "					throw new ArgumentException(String.Format("Unsupported delegate type {0} for local finally"' body.GetType().FullName)' "localFinally"); " is 135.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The length of the statement  "												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number! " is 123.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "				return ExportAsync(db' FdbKeySelector.FirstGreaterOrEqual(beginInclusive)' FdbKeySelector.FirstGreaterOrEqual(endExclusive)' handler' cancellationToken); " is 153.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "				return ExportAsync(db' FdbKeySelector.FirstGreaterOrEqual(range.Begin)' FdbKeySelector.FirstGreaterOrEqual(range.End)' handler' cancellationToken); " is 147.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "				// to maximize throughput' we want to read as much as possible per transaction' so that means that we should prefetch the next batch while the current batch is processing " is 170.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "				// TODO: alternative method that we could use to almost double the throughput (second thread that exports backwards starting from the end) " is 138.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "				// If handler() is always slower than the prefetch()' the bottleneck is the local processing (or possibly local disk if writing to disk) " is 136.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "				// If handler() does some buffering' and only flush to disk every N batches' then reading may stall because we could have prefetch more pages (TODO: we could prefetch more pages in queue ?) " is 189.
Long Statement,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The length of the statement  "					tr.Annotate("Exported {0} items in {1} chunks ({2:N1}% network)"' count' chunks' chunks > 0 ? (100.0 * waitForFetch / chunks) : 0.0); " is 133.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting transaction option {0}"' option.ToString())); " is 140.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting transaction option {0} to '{1}'"' option.ToString()' value ?? "<null>")); " is 168.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting transaction option {0} to {1}"' option.ToString()' value)); " is 154.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,SetOption,The length of the statement  "			// Spec says: "If the option is documented as taking an Int parameter' value must point to a signed 64-bit integer (little-endian)' and value_length must be 8." " is 160.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetAsync,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetAsync"' String.Format("Getting value for '{0}'"' key.ToString())); " is 129.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetValuesAsync,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetValuesAsync"' String.Format("Getting batch of {0} values ..."' keys.Length)); " is 140.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetRangeAsync,The length of the statement  "			return m_handler.GetRangeAsync(beginInclusive' endExclusive' options' iteration' snapshot: false' cancellationToken: m_cancellation); " is 133.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetRangeCore,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetRangeCore"' String.Format("Getting range '{0} <= x < {1}'"' begin.ToString()' end.ToString())); " is 158.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetRangeCore,The length of the statement  "			return new FdbRangeQuery<KeyValuePair<Slice' Slice>>(this' begin' end' TaskHelpers.Cache<KeyValuePair<Slice' Slice>>.Identity' snapshot' options); " is 146.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetKeyAsync,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetKeyAsync"' String.Format("Getting key '{0}'"' selector.ToString())); " is 131.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetKeyAsync,The length of the statement  "			var key = await m_handler.GetKeyAsync(selector' snapshot: false' cancellationToken: m_cancellation).ConfigureAwait(false); " is 122.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetKeysAsync,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetKeysAsync"' String.Format("Getting batch of {0} keys ..."' selectors.Length)); " is 141.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Set,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "Set"' String.Format("Setting '{0}' = {1}"' FdbKey.Dump(key)' Slice.Dump(value))); " is 141.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The length of the statement  "					throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations are only supported starting from API level 200. You need to select API level 200 or more at the start of your process."); " is 192.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The length of the statement  "					throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations are only supported starting from client version 2.x. You need to update the version of the client' and select API level 200 or more at the start of your process."); " is 235.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The length of the statement  "			if (mutation == FdbMutationType.Add || mutation == FdbMutationType.BitAnd || mutation == FdbMutationType.BitOr || mutation == FdbMutationType.BitXor ) " is 150.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The length of the statement  "						throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations Max and Min are only supported starting from API level 300. You need to select API level 300 or more at the start of your process."); " is 204.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The length of the statement  "						throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations Max and Min are only supported starting from client version 3.x. You need to update the version of the client' and select API level 300 or more at the start of your process.."); " is 248.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The length of the statement  "			throw new FdbException(FdbError.InvalidMutationType' "An invalid mutation type was issued. If you are attempting to call a new mutation type' you will need to update the version of this assembly' and select the latest API level."); " is 231.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Atomic,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "AtomicCore"' String.Format("Atomic {0} on '{1}' = {2}"' mutation.ToString()' FdbKey.Dump(key)' Slice.Dump(param))); " is 175.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,ClearRange,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "ClearRange"' String.Format("Clearing Range '{0}' <= k < '{1}'"' beginKeyInclusive.ToString()' endKeyExclusive.ToString())); " is 183.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,AddConflictRange,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "AddConflictRange"' String.Format("Adding {2} conflict range '{0}' <= k < '{1}'"' beginKeyInclusive.ToString()' endKeyExclusive.ToString()' type.ToString())); " is 217.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetAddressesForKeyAsync,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetAddressesForKeyAsync"' String.Format("Getting addresses for key '{0}'"' FdbKey.Dump(key))); " is 154.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Watch,The length of the statement  "			// > don't keep a reference on a potentially large buffer while the watch is active' preventing it from being garbage collected " is 127.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Watch,The length of the statement  "			// > allow the caller to reuse freely the slice underlying buffer' without changing the value that we will return when the task completes " is 137.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Watch,The length of the statement  "			// Note: the FDBFuture returned by 'fdb_transaction_watch()' outlives the transaction' and can only be cancelled with 'fdb_future_cancel()' or 'fdb_future_destroy()' " is 165.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Watch,The length of the statement  "			// Since Task<T> does not expose any cancellation mechanism by itself (and we don't want to force the caller to create a CancellationTokenSource everytime)' " is 156.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Cancel,The length of the statement  "					case STATE_DISPOSED: throw new ObjectDisposedException("FdbTransaction"' "Cannot cancel transaction because it already has been disposed"); " is 139.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Cancel,The length of the statement  "					default: throw new InvalidOperationException(String.Format("Cannot cancel transaction because it is in unknown state {0}"' state)); " is 131.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureCanWrite,The length of the statement  "			// note: write operations are not async' and cannnot block' so it is (somewhat) safe to call them from the network thread itself. " is 129.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,ThrowOnInvalidState,The length of the statement  "				case STATE_DISPOSED: throw new ObjectDisposedException("FdbTransaction"' "This transaction has already been disposed and cannot be used anymore"); " is 146.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,ThrowOnInvalidState,The length of the statement  "				case STATE_FAILED: throw new InvalidOperationException("The transaction is in a failed state and cannot be used anymore"); " is 122.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,ThrowOnInvalidState,The length of the statement  "				case STATE_CANCELED: throw new FdbException(FdbError.TransactionCancelled' "The transaction has already been cancelled"); " is 121.
Long Statement,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,Dispose,The length of the statement  "							if (Logging.On) Logging.Error(this' "Dispose"' String.Format("Transaction #{0} failed to dispose the transaction handler: {1}"' m_id' e.Message)); " is 146.
Long Statement,FoundationDB.Client,Snapshotted,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetAsync,The length of the statement  "				if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetAsync"' String.Format("Getting value for '{0}'"' key.ToString())); " is 129.
Long Statement,FoundationDB.Client,Snapshotted,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetValuesAsync,The length of the statement  "				if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetValuesAsync"' String.Format("Getting batch of {0} values ..."' keys.Length)); " is 140.
Long Statement,FoundationDB.Client,Snapshotted,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetKeyAsync,The length of the statement  "				if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetKeyAsync"' String.Format("Getting key '{0}'"' selector.ToString())); " is 131.
Long Statement,FoundationDB.Client,Snapshotted,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetKeyAsync,The length of the statement  "				var key = await m_parent.m_handler.GetKeyAsync(selector' snapshot: true' cancellationToken: m_parent.m_cancellation).ConfigureAwait(false); " is 139.
Long Statement,FoundationDB.Client,Snapshotted,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetKeysAsync,The length of the statement  "				if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "GetKeysCoreAsync"' String.Format("Getting batch of {0} keys ..."' selectors.Length)); " is 145.
Long Statement,FoundationDB.Client,Snapshotted,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,GetRangeAsync,The length of the statement  "				return m_parent.m_handler.GetRangeAsync(beginInclusive' endExclusive' options' iteration' snapshot: true' cancellationToken: m_parent.m_cancellation); " is 150.
Long Statement,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,SetValues,The length of the statement  "			if (values.Length != keys.Length) throw new ArgumentException("Both key and value arrays must have the same size."' "values"); " is 126.
Long Statement,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,SetValues,The length of the statement  "					if (!valueIter.MoveNext()) throw new ArgumentException("Both key and value sequences must have the same size."' "values"); " is 122.
Long Statement,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,SetValues,The length of the statement  "				if (valueIter.MoveNext()) throw new ArgumentException("Both key and values sequences must have the same size."' "values"); " is 122.
Long Statement,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,GetRange,The length of the statement  "			return GetRange(trans' beginKeyInclusive.ToFoundationDbKey()' endKeyExclusive.ToFoundationDbKey()' new FdbRangeOptions(limit: limit' reverse: reverse)); " is 152.
Long Statement,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,AddReadConflictRange,The length of the statement  "			trans.AddConflictRange(beginKeyInclusive.ToFoundationDbKey()' endKeyExclusive.ToFoundationDbKey()' FdbConflictRangeType.Read); " is 126.
Long Statement,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,AddWriteConflictRange,The length of the statement  "			trans.AddConflictRange(beginKeyInclusive.ToFoundationDbKey()' endKeyExclusive.ToFoundationDbKey()' FdbConflictRangeType.Write); " is 127.
Long Statement,FoundationDB.Client,FdbRangeOptions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeOptions.cs,EnsureDefaults,The length of the statement  "			Contract.Ensures(options.Mode.HasValue && Enum.IsDefined(typeof(FdbStreamingMode)' options.Mode.Value)' "Streaming mode must be valid"); " is 136.
Long Statement,FoundationDB.Client,FdbRangeOptions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeOptions.cs,EnsureLegalValues,The length of the statement  "			if (this.Mode < FdbStreamingMode.WantAll || this.Mode > FdbStreamingMode.Serial) throw new FdbException(FdbError.InvalidOptionValue' "Range StreaminMode must be valid"); " is 169.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The length of the statement  "				//note: we start the clock immediately' but the transaction's 5 seconde max lifetime is actually measured from the first read operation (Get' GetRange' GetReadVersion' etc...) " is 175.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The length of the statement  "				// => algorithms that monitor the elapsed duration to rate limit themselves may think that the trans is older than it really is... " is 130.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The length of the statement  "									throw new NotSupportedException(String.Format("Cannot execute completion handler of type {0}"' handler.GetType().Name)); " is 120.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The length of the statement  "							if (Logging.On && Logging.IsVerbose) Logging.Verbose(String.Format(CultureInfo.InvariantCulture' "fdb: transaction {0} failed with error code {1}"' trans.Id' e.Code)); " is 167.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The length of the statement  "							if (Logging.On && Logging.IsVerbose) Logging.Verbose(String.Format(CultureInfo.InvariantCulture' "fdb: transaction {0} can be safely retried"' trans.Id)); " is 154.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The length of the statement  "							if (Logging.On) Logging.Info(String.Format(CultureInfo.InvariantCulture' "fdb WARNING: long transaction ({0:N1} sec elapsed in transaction lambda function ({1} retries' {2})"' context.BaseDuration.TotalSeconds' context.Retries' context.Committed ? "committed" : "not yet committed")); " is 284.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,RunReadAsync,The length of the statement  "			var context = new FdbOperationContext(db' FdbTransactionMode.ReadOnly | FdbTransactionMode.InsideRetryLoop' cancellationToken); " is 127.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,RunReadWithResultAsync,The length of the statement  "			var context = new FdbOperationContext(db' FdbTransactionMode.ReadOnly | FdbTransactionMode.InsideRetryLoop' cancellationToken); " is 127.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,RunWriteAsync,The length of the statement  "			var context = new FdbOperationContext(db' FdbTransactionMode.Default | FdbTransactionMode.InsideRetryLoop' cancellationToken); " is 126.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,RunWriteAsync,The length of the statement  "			var context = new FdbOperationContext(db' FdbTransactionMode.Default | FdbTransactionMode.InsideRetryLoop' cancellationToken); " is 126.
Long Statement,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,RunWriteWithResultAsync,The length of the statement  "			var context = new FdbOperationContext(db' FdbTransactionMode.Default | FdbTransactionMode.InsideRetryLoop' cancellationToken); " is 126.
Long Statement,FoundationDB.Client,FdbMergeQueryExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeQueryExtensions.cs,Except,The length of the statement  "			return Except<TKey' TResult>(trans' ranges.Select(r => FdbKeySelectorPair.Create(r))' keySelector' resultSelector' keyComparer); " is 128.
Long Statement,FoundationDB.Client,FdbExceptIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbExceptIterator.cs,Clone,The length of the statement  "			return new FdbExceptIterator<TSource' TKey' TResult>(m_sources' m_limit' m_keySelector' m_resultSelector' m_keyComparer); " is 121.
Long Statement,FoundationDB.Client,FdbIntersectIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbIntersectIterator.cs,Clone,The length of the statement  "			return new FdbIntersectIterator<TSource' TKey' TResult>(m_sources' m_limit' m_keySelector' m_resultSelector' m_keyComparer); " is 124.
Long Statement,FoundationDB.Client,FdbKeySelectorPair,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKeySelectorPair.cs,ToString,The length of the statement  "			return "[ " + m_begin.PrettyPrint(FdbKey.PrettyPrintMode.Begin) + "' " + m_end.PrettyPrint(FdbKey.PrettyPrintMode.End) + " )"; " is 126.
Long Statement,FoundationDB.Client,FdbMergeSortIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbMergeSortIterator.cs,Clone,The length of the statement  "			return new FdbMergeSortIterator<TSource' TKey' TResult>(m_sources' m_limit' m_keySelector' m_resultSelector' m_keyComparer); " is 124.
Long Statement,FoundationDB.Client,Errors,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Errors.cs,InvalidKeyOutsideDatabaseNamespace,The length of the statement  "					String.Format("An attempt was made to use a key '{2}' that is outside of the global namespace {0} of database '{1}'"' db.GlobalSpace' db.Name' FdbKey.Dump(key)) " is 160.
Long Statement,FoundationDB.Client,Errors,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Errors.cs,InvalidKeyOutsideDatabaseNamespace,The length of the statement  "					String.Format("An attempt was made to use a key that is outside of the global namespace {0} of database '{1}'"' db.GlobalSpace' db.Name) " is 136.
Long Statement,FoundationDB.Client,Errors,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Errors.cs,FailedToRegisterTransactionOnDatabase,The length of the statement  "				return new InvalidOperationException(String.Format("Failed to register transaction #{0} with this instance of database {1}"' transaction.Id' db.Name)); " is 151.
Long Statement,FoundationDB.Client,FdbRangeQuery<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.ResultIterator.cs,Select,The length of the statement  "			// note: avoid storing the query in the scope by storing the transform locally so that only 'f' and 'lambda' are kept alive " is 123.
Long Statement,FoundationDB.Client,FdbRangeQuery<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.ResultIterator.cs,LastOrDefaultAsync,The length of the statement  "			//BUGBUG: if there is a Take(N) on the query' Last() will mean "The Nth key" and not the "last key in the original range". " is 122.
Long Statement,FoundationDB.Client,FdbRangeQuery<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.ResultIterator.cs,LastAsync,The length of the statement  "			//BUGBUG: if there is a Take(N) on the query' Last() will mean "The Nth key" and not the "last key in the original range". " is 122.
Long Statement,FoundationDB.Client,FdbRangeQuery<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.ResultIterator.cs,ToString,The length of the statement  "			return String.Format(CultureInfo.InvariantCulture' "Range({0}' {1}' {2})"' this.Range' this.Limit' this.Reversed ? "reverse" : "forward"); " is 138.
Long Statement,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The length of the statement  "					// we can safely optimize this case by not doing any query' because it should not have any impact on conflict resolutions. " is 122.
Long Statement,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The length of the statement  "					// => The result of 'query.Take(X)' where X would be computed from reads in the db' and be equal to 0' would conflict because of those reads anyway. " is 148.
Long Statement,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The length of the statement  "					var keys = await this.Transaction.GetKeysAsync(new[] { bounds.Begin' this.Begin' bounds.End' this.End }).ConfigureAwait(false); " is 127.
Long Statement,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,FetchNextPageAsync,The length of the statement  "						Debug.WriteLine("FdbRangeQuery.PagingIterator.FetchNextPageAsync() returned " + this.Chunk.Length + " results (" + this.RowCount + " total) " + (hasMore ? " with more to come" : " and has no more data")); " is 204.
Long Statement,FoundationDB.Client,FdbKeyRange,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKeyRange.cs,ToString,The length of the statement  "			return "{" + FdbKey.PrettyPrint(m_begin' FdbKey.PrettyPrintMode.Begin) + "' " + FdbKey.PrettyPrint(m_end' FdbKey.PrettyPrintMode.End) + "}"; " is 140.
Long Statement,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The length of the statement  "						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation. " is 155.
Long Statement,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The length of the statement  "						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this! " is 177.
Long Statement,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The length of the statement  "						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity.... " is 175.
Long Statement,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The length of the statement  "				return OpenNamedPartitionAsync(clusterFile: null' dbName: null' path: path' readOnly: false' cancellationToken: cancellationToken); " is 131.
Long Statement,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The length of the statement  "					db = await Fdb.OpenInternalAsync(clusterFile' dbName' rootSpace' readOnly: false' cancellationToken: cancellationToken).ConfigureAwait(false); " is 142.
Long Statement,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The length of the statement  "					if (Logging.On) Logging.Verbose(typeof(Fdb.Directory)' "OpenNamedPartitionAsync"' String.Format("Opened root layer of database {0} using cluster file '{1}'"' db.Name' db.Cluster.Path)); " is 185.
Long Statement,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The length of the statement  "					var descriptor = await rootLayer.CreateOrOpenAsync(db' partitionPath' layer: FdbDirectoryPartition.LayerId' cancellationToken: cancellationToken).ConfigureAwait(false); " is 168.
Long Statement,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The length of the statement  "					if (Logging.On) Logging.Verbose(typeof(Fdb.Directory)' "OpenNamedPartitionAsync"' String.Format("Found named partition '{0}' at prefix {1}"' descriptor.FullName' descriptor)); " is 175.
Long Statement,FoundationDB.Client,Directory,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\Fdb.Directory.cs,OpenNamedPartitionAsync,The length of the statement  "					if (Logging.On) Logging.Info(typeof(Fdb.Directory)' "OpenNamedPartitionAsync"' String.Format("Opened partition {0} at {1}' using directory layer at {2}"' descriptor.FullName' db.GlobalSpace' db.Directory.DirectoryLayer.NodeSubspace)); " is 234.
Long Statement,FoundationDB.Client,FdbDatabasePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDatabasePartition.cs,CheckLayer,The length of the statement  "				throw new InvalidOperationException(String.Format("The directory {0} is a partition which is not compatible with layer {1}."' this.FullName' layer.ToAsciiOrHexaString())); " is 171.
Long Statement,FoundationDB.Client,FdbDatabasePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDatabasePartition.cs,CreateOrOpenAsync,The length of the statement  "			return m_database.ReadWriteAsync((tr) => m_directory.CreateOrOpenAsync(tr' new [] { name }' Slice.Nil)' cancellationToken); " is 123.
Long Statement,FoundationDB.Client,FdbDatabasePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDatabasePartition.cs,TryCreateAsync,The length of the statement  "			return m_database.ReadWriteAsync((tr) => m_directory.TryCreateAsync(tr' new [] { name }' Slice.Nil)' cancellationToken); " is 120.
Long Statement,FoundationDB.Client,FdbDatabasePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDatabasePartition.cs,RegisterAsync,The length of the statement  "			return m_database.ReadWriteAsync((tr) => m_directory.RegisterAsync(tr' new[] { name }' layer' prefix)' cancellationToken); " is 122.
Long Statement,FoundationDB.Client,FdbDynamicSubspacePartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspacePartition.cs,ByKey,The length of the statement  "			return new FdbDynamicSubspace(this.Subspace.Keys.Encode<T1' T2' T3' T4>(value1' value2' value3' value4)' false' this.Encoder); " is 126.
Long Statement,FoundationDB.Client,FdbSubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbSubspace.cs,Copy,The length of the statement  "				//SPOILER WARNING: You didn't hear it from me' but some say that you can use this to bypass the fact that FdbDirectoryPartition.get_Key and ToRange() throws in v2.x ... If you bypass this protection and bork your database' don't come crying! " is 241.
Long Statement,FoundationDB.Client,FdbSubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbSubspace.cs,BoundCheck,The length of the statement  "			//note: Since this is needed to make GetRange/GetKey work properly' this should work for all subspace' include directory partitions " is 131.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,WriteAsync,The length of the statement  "			//REVIEW: right now' nothing prevents the lambda from calling read methods on the transaction' making this equivalent to calling ReadWriteAsync() " is 145.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,WriteAsync,The length of the statement  "			// => this version of WriteAsync is only there to catch mistakes when someones passes in an async lambda' instead of an Action<IFdbTransaction> " is 143.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,WriteAsync,The length of the statement  "			//REVIEW: right now' nothing prevents the lambda from calling read methods on the transaction' making this equivalent to calling ReadWriteAsync() " is 145.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,WriteAsync,The length of the statement  "			// => this version of WriteAsync is only there to catch mistakes when someones passes in an async lambda' instead of an Action<IFdbTransaction> " is 143.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting database option {0}"' option.ToString())); " is 137.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting database option {0} to '{1}'"' option.ToString()' value ?? "<null>")); " is 165.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting database option {0} to {1}"' option.ToString()' value)); " is 151.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,SetOption,The length of the statement  "			// Spec says: "If the option is documented as taking an Int parameter' value must point to a signed 64-bit integer (little-endian)' and value_length must be 8." " is 160.
Long Statement,FoundationDB.Client,FdbDatabase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbDatabase.cs,Dispose,The length of the statement  "							if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "Dispose"' String.Format("Disposing database {0} handler"' m_name)); " is 127.
Long Statement,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,OpenDatabaseAsync,The length of the statement  "			return await OpenDatabaseInternalAsync(databaseName' subspace' readOnly: readOnly' ownsCluster: false' cancellationToken: cancellationToken).ConfigureAwait(false); " is 163.
Long Statement,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,OpenDatabaseInternalAsync,The length of the statement  "			if (Logging.On) Logging.Info(typeof(FdbCluster)' "OpenDatabaseAsync"' String.Format("Connecting to database '{0}' ..."' databaseName)); " is 135.
Long Statement,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,OpenDatabaseInternalAsync,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(typeof(FdbCluster)' "OpenDatabaseAsync"' String.Format("Connected to database '{0}'"' databaseName)); " is 154.
Long Statement,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting cluster option {0}"' option.ToString())); " is 136.
Long Statement,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting cluster option {0} to '{1}'"' option.ToString()' value ?? "<null>")); " is 164.
Long Statement,FoundationDB.Client,FdbCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbCluster.cs,SetOption,The length of the statement  "			if (Logging.On && Logging.IsVerbose) Logging.Verbose(this' "SetOption"' String.Format("Setting cluster option {0} to {1}"' option.ToString()' value)); " is 150.
Long Statement,FoundationDB.Client,Batched<TValue;TState>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,Convert,The length of the statement  "			// - doing it this way adds a memory copy (writer => buffer) but reduce the number of byte[] allocations (and reduce the GC overhead) " is 133.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2>(ref writer' selector1(item)' selector2(item))' " is 140.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2' T3>(ref writer' selector1(item)' selector2(item)' selector3(item))' " is 161.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2' T3' T4>(ref writer' selector1(item)' selector2(item)' selector3(item)' selector4(item))' " is 182.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2' T3' T4' T5>(ref writer' selector1(item)' selector2(item)' selector3(item)' selector4(item)' selector5(item))' " is 203.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2' T3' T4' T5' T6>(ref writer' selector1(item)' selector2(item)' selector3(item)' selector4(item)' selector5(item)' selector6(item))' " is 224.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2' T3' T4' T5' T6' T7>(ref writer' selector1(item)' selector2(item)' selector3(item)' selector4(item)' selector5(item)' selector6(item)' selector7(item))' " is 245.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,EncodeMany,The length of the statement  "				(ref SliceWriter writer' TItem item' IDynamicKeyEncoder encoder) => encoder.EncodeKey<T1' T2' T3' T4' T5' T6' T7' T8>(ref writer' selector1(item)' selector2(item)' selector3(item)' selector4(item)' selector5(item)' selector6(item)' selector7(item)' selector8(item))' " is 266.
Long Statement,FoundationDB.Client,FdbDynamicSubspaceKeys,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbDynamicSubspaceKeys.cs,DecodeMany,The length of the statement  "			return BatchDecode(packed' this.Subspace' this.Encoder' (data' encoder) => encoder.DecodeKey<T1' T2' T3' T4' T5>(data)); " is 120.
Long Statement,FoundationDB.Client,KeyValueEncoders,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKeys,The length of the statement  "			// note: T=>Slice usually is used for writing batches as fast as possible' which means that keys will be consumed immediately and don't need to be streamed " is 155.
Long Statement,FoundationDB.Client,KeyValueEncoders,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeValues,The length of the statement  "			// note: T=>Slice usually is used for writing batches as fast as possible' which means that keys will be consumed immediately and don't need to be streamed " is 155.
Long Statement,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The length of the statement  "				return this.Encoder.EncodeComposite(new FdbTuple<T1' T2' T3' T4>(key.Item1' key.Item2' default(T3)' default(T4))' items); " is 121.
Long Statement,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The length of the statement  "					if (reader.HasMore) throw new InvalidOperationException(String.Format("Unexpected data at the end of composite key after {0} items"' count)); " is 141.
Long Statement,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The length of the statement  "					if (reader.HasMore) throw new InvalidOperationException(String.Format("Unexpected data at the end of composite key after {0} items"' count)); " is 141.
Long Statement,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The length of the statement  "					if (items < 1 || items > 3) throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 3"); " is 120.
Long Statement,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The length of the statement  "					if (items < 1 || items > 4) throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 4"); " is 120.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedSlice,The length of the statement  "			// If you break here' that means that a slice is invalid (negative count' offset' ...)' which may be a sign of memory corruption! " is 129.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedSlice,The length of the statement  "			if (slice.Offset < 0) throw new FormatException("The specified slice has a negative offset' which is not legal. This may be a side effect of memory corruption."); " is 162.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedSlice,The length of the statement  "			if (slice.Count < 0) throw new FormatException("The specified slice has a negative size' which is not legal. This may be a side effect of memory corruption."); " is 159.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedSlice,The length of the statement  "				if (slice.Offset + slice.Count > slice.Array.Length) throw new FormatException("The specified slice is larger than its underlying buffer."); " is 140.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedBuffer,The length of the statement  "			if (offset < 0) throw new ArgumentException("The specified segment has a negative offset' which is not legal. This may be a side effect of memory corruption."' "offset"); " is 170.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedBuffer,The length of the statement  "			if (count < 0) throw new ArgumentException("The specified segment has a negative size' which is not legal. This may be a side effect of memory corruption."' "count"); " is 166.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ThrowMalformedBuffer,The length of the statement  "				if (offset + count > array.Length) throw new ArgumentException("The specified segment is larger than its underlying buffer."' "count"); " is 135.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ComputeHashCode,The length of the statement  "			if (bytes == null || offset < 0 || count < 0 || offset + count > bytes.Length) SliceHelpers.ThrowMalformedBuffer(bytes' offset' count); " is 135.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ComputeHashCodeUnsafe,The length of the statement  "			// => won't matter much for *ordered* dictionary that will probably use IComparer<T>.Compare(..) instead of the IEqalityComparer<T>.GetHashCode()/Equals() combo " is 160.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CompareBytesUnsafe,The length of the statement  "			Contract.Requires(left != null && right != null && leftOffset >= 0 && leftCount >= 0 && rightOffset >= 0 && rightCount >= 0); " is 125.
Long Statement,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CompareMemoryUnsafe,The length of the statement  "			// - If at least one bit is difference' the XOR result will be non-zero' and the first different will be in the first non-zero byte. " is 132.
Long Statement,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,NewUuid,The length of the statement  "			//Note: we chould use Guid.NewGuid() as a source of randomness' but even though a guid is "guaranteed" to be unique' a substring of a guid is not.. or is it? " is 157.
Long Statement,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,ToByteArray,The length of the statement  "			Contract.Assert(bytes != null && bytes.Length == 8); // HACKHACK: for perf reasons' we rely on the fact that Slice.FromFixedU64BE() allocates a new 8-byte array that we can return without copying " is 195.
Long Statement,FoundationDB.Client,SliceListStream,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceListStream.cs,ReadByte,The length of the statement  "			if (m_position >= m_length || (m_offsetInCurrentSlice >= m_slices[m_indexOfCurrentSlice].Count && !AdvanceToNextSlice())) " is 121.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Find,The length of the statement  "				// note: this is a very simplistic way to find a value' and is optimized for the case where the separator is only one byte (most common)  " is 136.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Join,The length of the statement  "			// - Only difference is that Slice.Nil and Slice.Empty are equivalent (either for separator' or for the elements of the array) " is 126.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Join,The length of the statement  "			if (startIndex < 0) throw new ArgumentOutOfRangeException("startIndex"' startIndex' "Start index must be a positive integer"); " is 126.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Join,The length of the statement  "			if (startIndex > values.Length - count) throw new ArgumentOutOfRangeException("startIndex"' startIndex' "Start index must fit within the array"); " is 145.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Join,The length of the statement  "			//note: we want to make sure the buffer of the writer will be the exact size (so that we can use the result as a byte[] without copying again) " is 142.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,JoinBytes,The length of the statement  "			// - Only difference is that Slice.Nil and Slice.Empty are equivalent (either for separator' or for the elements of the array) " is 126.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,JoinBytes,The length of the statement  "			if (startIndex < 0) throw new ArgumentOutOfRangeException("startIndex"' startIndex' "Start index must be a positive integer"); " is 126.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,JoinBytes,The length of the statement  "			if (startIndex > values.Length - count) throw new ArgumentOutOfRangeException("startIndex"' startIndex' "Start index must fit within the array"); " is 145.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,JoinBytes,The length of the statement  "			//note: we want to make sure the buffer of the writer will be the exact size (so that we can use the result as a byte[] without copying again) " is 142.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Split,The length of the statement  "			if (options < StringSplitOptions.None || options > StringSplitOptions.RemoveEmptyEntries) throw new ArgumentException("options"); " is 129.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromBase64,The length of the statement  "			return base64String == null ? Slice.Nil : base64String.Length == 0 ? Slice.Empty : Slice.Create(Convert.FromBase64String(base64String)); " is 136.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt32,The length of the statement  "					//TODO: possible micro optimization is for values like 0x100' 0x201' 0x1413 or 0x4342' where we could use 2 consecutive bytes in the ByteSprite' " is 144.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromHexa,The length of the statement  "			if ((hexaString.Length & 1) != 0) throw new ArgumentException("Hexadecimal string must be of even length"' "hexaString"); " is 121.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The length of the statement  "				return new StringBuilder(n + 2).Append('\'').Append(Encoding.ASCII.GetString(buffer' this.Offset' this.Count)).Append('\'').ToString(); " is 135.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The length of the statement  "				return EscapeString(new StringBuilder(n + 2).Append('\'')' buffer' this.Offset' this.Count' Encoding.UTF8).Append('\'').ToString(); " is 131.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToBool,The length of the statement  "			//TODO: consider checking if the slice consist of only zeroes ? (ex: Slice.FromFixed32(0) could be considered falsy ...) " is 120.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToGuid,The length of the statement  "				// we need to swap the byte order of the Data1' Data2 and Data3 chunks' to ensure that Guid.ToString() will return the proper value. " is 132.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Substring,The length of the statement  "			if (offset < 0 || offset >= this.Count) throw new ArgumentOutOfRangeException("offset"' "Offset must be inside the slice"); " is 123.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Substring,The length of the statement  "			if (offset > this.Count - count) throw new ArgumentOutOfRangeException("count"' "Offset and count must refer to a location within the slice"); " is 142.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,IndexOf,The length of the statement  "			if (startIndex < 0 || startIndex > this.Count) throw new ArgumentOutOfRangeException("startIndex"' startIndex' "Start index must be inside the buffer"); " is 152.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EndsWith,The length of the statement  "			return SliceHelpers.SameBytes(this.Array' this.Offset + this.Count - value.Count' value.Array' value.Offset' value.Count); " is 122.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,SuffixedBy,The length of the statement  "			return SliceHelpers.SameBytes(parent.Array' parent.Offset + this.Count - parent.Count' this.Array' this.Offset' parent.Count); " is 126.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,LoadFromNonBlockingStream,The length of the statement  "				if (n <= 0) throw new InvalidOperationException(String.Format("Unexpected end of stream at {0} / {1} bytes"' p' length)); " is 121.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,LoadFromBlockingStream,The length of the statement  "				if (n <= 0) throw new InvalidOperationException(String.Format("Unexpected end of stream at {0} / {1} bytes"' p' length)); " is 121.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,LoadFromBlockingStreamAsync,The length of the statement  "				if (n <= 0) throw new InvalidOperationException(String.Format("Unexpected end of stream at {0} / {1} bytes"' p' length)); " is 121.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Equals,The length of the statement  "			return this.Count == other.Count && SliceHelpers.SameBytesUnsafe(this.Array' this.Offset' other.Array' other.Offset' this.Count); " is 129.
Long Statement,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Equals,The length of the statement  "			return this.Count == other.Count && SliceHelpers.SameBytes(this.Array' this.Offset' other.Array' other.Offset' this.Count); " is 123.
Long Statement,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteBytes,The length of the statement  "			Contract.Requires(this.Buffer != null && this.Position >= 0 && data != null && count >= 0 && this.Position + count <= this.Buffer.Length && offset >= 0 && offset + count <= data.Length); " is 186.
Long Statement,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteBytes,The length of the statement  "			Contract.Requires(this.Buffer != null && this.Position >= 0 && data != null && count >= 0 && this.Position + count <= this.Buffer.Length); " is 138.
Long Statement,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,FailCannotGrowBuffer,The length of the statement  "			// If you breakpoint here' that means that you probably have an uncheked maximum buffer size' or a runaway while(..) { append(..) } code in your layer code ! " is 157.
Long Statement,FoundationDB.Linq,FdbPrefetchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbPrefetchingAsyncIterator.cs,PrefetchNextItemsAsync,The length of the statement  "			// read items from the source until the next call to Inner.MoveNext() is not already complete' or we have filled our prefetch buffer' then returns the first item in the buffer. " is 176.
Long Statement,FoundationDB.Linq,FdbPrefetchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbPrefetchingAsyncIterator.cs,PrefetchNextItemsAsync,The length of the statement  "			// most db queries will read items by chunks' so there is a high chance the the next following calls to MoveNext() will already be completed " is 140.
Long Statement,FoundationDB.Linq,FdbPrefetchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbPrefetchingAsyncIterator.cs,PrefetchNextItemsAsync,The length of the statement  "			// as long as this is the case' and that our buffer is not full' continue eating items. Stop only when we end up with a pending task. " is 133.
Long Statement,FoundationDB.Linq,FdbPrefetchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbPrefetchingAsyncIterator.cs,PrefetchNextItemsAsync,The length of the statement  "				// we know the task is already completed' so we will immediately get the next result' or blow up if the inner iterator failed " is 125.
Long Statement,FoundationDB.Linq,FdbPrefetchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbPrefetchingAsyncIterator.cs,PrefetchNextItemsAsync,The length of the statement  "				//note: if inner blows up' we won't send any previously read items down the line. This may change the behavior of queries with a .Take(N) that would have stopped before reading the (N+1)th item that would have failed. " is 217.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "			// read items from the source until the next call to Inner.MoveNext() is not already complete' or we have filled our buffer " is 123.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "			// most db queries will read items by chunks' so there is a high chance the the next following calls to MoveNext() will already be completed " is 140.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "			// as long as this is the case' and that our buffer is not full' continue eating items. Stop only when we end up with a pending task. " is 133.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "					//TODO: add heuristics to check if the batch is large enough to stop there' or if we should eat the latency and wait for the next wave of items to arrive! " is 154.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "					// ex: we batch by 10' inner return 11 consecutive items. We will transform the first 10' then only fill the next batch with the 11th item because the 12th item is still not ready. " is 180.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "				// we know the task is already completed' so we will immediately get the next result' or blow up if the inner iterator failed " is 125.
Long Statement,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnNextAsync,The length of the statement  "				//note: if inner blows up' we won't send any previously read items down the line. This may change the behavior of queries with a .Take(N) that would have stopped before reading the (N+1)th item that would have failed. " is 217.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Map,The length of the statement  "			return new FdbWhereSelectAsyncIterator<TSource' TResult>(source' filter: null' transform: selector' limit: limit' offset: offset); " is 130.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Offset,The length of the statement  "			return new FdbWhereSelectAsyncIterator<TResult' TResult>(source' filter: null' transform: new AsyncTransformExpression<TResult' TResult>(TaskHelpers.Cache<TResult>.Identity)' limit: null' offset: offset); " is 204.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Limit,The length of the statement  "			return new FdbWhereSelectAsyncIterator<TResult' TResult>(source' filter: null' transform: new AsyncTransformExpression<TResult' TResult>(TaskHelpers.Cache<TResult>.Identity)' limit: limit' offset: null); " is 203.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Run,The length of the statement  "			//note: we should not use "ConfigureAwait(false)" here because we would like to execute the action in the original synchronization context if possible... " is 153.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Run,The length of the statement  "			//note: we should not use "ConfigureAwait(false)" here because we would like to execute the action in the original synchronization context if possible... " is 153.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Run,The length of the statement  "			//note: we should not use "ConfigureAwait(false)" here because we would like to execute the action in the original synchronization context if possible... " is 153.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Run,The length of the statement  "			//note: we should not use "ConfigureAwait(false)" here because we would like to execute the action in the original synchronization context if possible... " is 153.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Head,The length of the statement  "			//note: we should not use "ConfigureAwait(false)" here because we would like to execute the action in the original synchronization context if possible... " is 153.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Singleton,The length of the statement  "			//note: we can't call this method Single<T>(T)' because then Single<T>(Func<T>) would be ambigous with Single<Func<T>>(T) " is 121.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,SelectMany,The length of the statement  "			return Flatten<TSource' TCollection' TResult>(source' new AsyncTransformExpression<TSource'IEnumerable<TCollection>>(collectionSelector)' resultSelector); " is 154.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,SelectMany,The length of the statement  "			return SelectMany<TSource' TCollection' TResult>(source' TaskHelpers.WithCancellation(asyncCollectionSelector)' resultSelector); " is 128.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,SelectMany,The length of the statement  "			return Flatten<TSource' TCollection' TResult>(source' new AsyncTransformExpression<TSource'IEnumerable<TCollection>>(asyncCollectionSelector)' resultSelector); " is 159.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,SelectAsync,The length of the statement  "			return new FdbParallelSelectAsyncIterator<TSource' TResult>(source' asyncSelector' options ?? new FdbParallelQueryOptions()); " is 125.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Prefetch,The length of the statement  "			if (prefetchCount <= 0) throw new ArgumentOutOfRangeException("prefetchCount"' prefetchCount' "Prefetch count must be at least one."); " is 134.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,Window,The length of the statement  "			if (maxWindowSize <= 0) throw new ArgumentOutOfRangeException("maxWindowSize"' maxWindowSize' "Window size must be at least one."); " is 131.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,AggregateAsync,The length of the statement  "			await ForEachAsync(source' (x) => { accumulate = aggregator(accumulate' x); }' cancellationToken).ConfigureAwait(false); " is 120.
Long Statement,FoundationDB.Linq,FdbAsyncEnumerable,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,AggregateAsync,The length of the statement  "			await ForEachAsync(source' (x) => { accumulate = aggregator(accumulate' x); }' cancellationToken).ConfigureAwait(false); " is 120.
Long Statement,FoundationDB.Linq,OrderedEnumerator<TSource>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.OrderedSequence.cs,MoveNext,The length of the statement  "				// Firt call will be slow (and async)' but the rest of the calls will use the results already sorted in memory' and should be as fast as possible! " is 146.
Long Statement,FoundationDB.Linq,AsyncObserverExpression<TSource>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Expressions\AsyncObserverExpression.cs,Then,The length of the statement  "					return new AsyncObserverExpression<TSource>(async (x' ct) => { await f(x' ct).ConfigureAwait(false); await g(x' ct).ConfigureAwait(false); }); " is 142.
Long Statement,FoundationDB.Linq,AsyncTransformExpression<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Expressions\AsyncTransformExpression.cs,IsIdentity,The length of the statement  "			//note: Identity Function is not async' and is only possible if TSource == TResult' so we can skip checking the types ourselves... " is 130.
Long Statement,FoundationDB.Linq,AsyncTransformExpression<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Expressions\AsyncTransformExpression.cs,Cast,The length of the statement  "					return new AsyncTransformExpression<TSource' TCasted>(async (x' ct) => (TCasted)(object)(await f(x' ct).ConfigureAwait(false))); " is 128.
Long Statement,FoundationDB.Linq,AsyncTransformExpression<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Expressions\AsyncTransformExpression.cs,Then,The length of the statement  "					return new AsyncTransformExpression<TSource' TOuter>(async (x' ct) => await g(await f(x' ct).ConfigureAwait(false)' ct).ConfigureAwait(false)); " is 143.
Long Statement,FoundationDB.Linq,AsyncFilterExpression<TSource>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Expressions\AsyncFilterExpression.cs,AndAlso,The length of the statement  "					return new AsyncFilterExpression<TSource>(async (x' ct) => (await f(x' ct).ConfigureAwait(false)) && (await g(x' ct).ConfigureAwait(false))); " is 141.
Long Statement,FoundationDB.Linq,AsyncFilterExpression<TSource>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Expressions\AsyncFilterExpression.cs,OrElse,The length of the statement  "					return new AsyncFilterExpression<TSource>(async (x' ct) => (await f(x' ct).ConfigureAwait(false)) || (await g(x' ct).ConfigureAwait(false))); " is 141.
Long Statement,FoundationDB.Linq,FdbParallelSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbParallelSelectAsyncIterator.cs,OnFirstAsync,The length of the statement  "			m_processingQueue = new AsyncTransformQueue<TSource' TResult>(m_taskSelector' m_options.MaxConcurrency ?? DefaultMaxConcurrency' m_options.Scheduler); " is 150.
Long Statement,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,Where,The length of the statement  "			// also' since transform is done after filtering' we can only optimize if transform is null (not allowed!) or the identity function " is 131.
Long Statement,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,Where,The length of the statement  "			if (m_limit == null && (m_offset == null || m_offset.Value == 0) && typeof(TSource) == typeof(TResult)) //BUGBUG: type comparison maybe should check derived classes also ? " is 171.
Long Statement,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,Where,The length of the statement  "				var asyncFilter = new AsyncFilterExpression<TSource>((Func<TSource' CancellationToken' Task<bool>>)(Delegate)asyncPredicate); " is 125.
Long Statement,FoundationDB.Linq,FdbAsyncFilterIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbAsyncFilterIterator.cs,StartInner,The length of the statement  "			// filtering changes the number of items' so that means that' even if the underlying caller wants one item' we may need to read more. " is 133.
Long Statement,FoundationDB.Linq,FdbAsyncFilterIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbAsyncFilterIterator.cs,StartInner,The length of the statement  "			// => change all "Head" requests into "Iterator" to prevent any wrong optimizations by the underlying source (ex: using a too small batch size) " is 143.
Long Statement,FoundationDB.Linq,FdbAsyncIterator<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbAsyncIterator.cs,SelectMany,The length of the statement  "			return FdbAsyncEnumerable.Flatten<TResult' TNew>(this' new AsyncTransformExpression<TResult'IEnumerable<TNew>>(selector)); " is 122.
Long Statement,FoundationDB.Linq,FdbAsyncIterator<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbAsyncIterator.cs,SelectMany,The length of the statement  "			return FdbAsyncEnumerable.Flatten<TResult' TNew>(this' new AsyncTransformExpression<TResult'IEnumerable<TNew>>(asyncSelector)); " is 127.
Long Statement,FoundationDB.Linq,FdbAsyncIterator<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbAsyncIterator.cs,SelectMany,The length of the statement  "			return FdbAsyncEnumerable.Flatten<TResult' TCollection' TNew>(this' new AsyncTransformExpression<TResult'IEnumerable<TCollection>>(collectionSelector)' resultSelector); " is 168.
Long Statement,FoundationDB.Linq,FdbAsyncIterator<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbAsyncIterator.cs,SelectMany,The length of the statement  "			return FdbAsyncEnumerable.Flatten<TResult' TCollection' TNew>(this' new AsyncTransformExpression<TResult'IEnumerable<TCollection>>(asyncCollectionSelector)' resultSelector); " is 173.
Long Statement,FoundationDB.Linq,Buffer<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.Iterators.cs,ToList,The length of the statement  "					{ // there is no List<T>.AddRange(buffer' offset' count)' and copying in a tmp buffer would waste the memory we tried to save with the buffer " is 141.
Long Statement,FoundationDB.Linq,Buffer<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\FdbAsyncEnumerable.Iterators.cs,ToList,The length of the statement  "						// also' for most of the small queries' like FirstOrDefault()/SingleOrDefault()' count will be 1 (or very small) so calling Add(T) will still be optimum " is 152.
Long Statement,FoundationDB.Client.Status,LoadCounter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Status\FdbSystemStatus.cs,ToString,The length of the statement  "			return String.Format(CultureInfo.InvariantCulture' "Counter={0:N0}' Hz={1:N1}' Roughness={2:N2}"' this.Counter' this.Hz' this.Roughness); " is 137.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryPartition,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryPartition.cs,ToString,The length of the statement  "			return String.Format("DirectoryPartition(path={0}' prefix={1})"' this.FullName' this.InternalKey.ToAsciiOrHexaString()); " is 120.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,CheckLayer,The length of the statement  "				throw new InvalidOperationException(String.Format("The directory {0} was created with incompatible layer {1} instead of expected {2}."' this.FullName' this.Layer.ToAsciiOrHexaString()' layer.ToAsciiOrHexaString())); " is 215.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,ChangeLayerAsync,The length of the statement  "			return new FdbDirectorySubspace(this.Location' this.RelativeLocation' this.InternalKey' this.DirectoryLayer' newLayer' TypeSystem.Default.GetDynamicEncoder()); " is 159.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,CreateOrOpenAsync,The length of the statement  "			return this.DirectoryLayer.CreateOrOpenInternalAsync(null' trans' ToRelativePath(path)' layer' Slice.Nil' allowCreate: true' allowOpen: true' throwOnError: true); " is 162.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,OpenAsync,The length of the statement  "			return this.DirectoryLayer.CreateOrOpenInternalAsync(trans' null' ToRelativePath(path)' layer' prefix: Slice.Nil' allowCreate: false' allowOpen: true' throwOnError: true); " is 171.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,TryOpenAsync,The length of the statement  "			return this.DirectoryLayer.CreateOrOpenInternalAsync(trans' null' ToRelativePath(path)' layer' prefix: Slice.Nil' allowCreate: false' allowOpen: true' throwOnError: false); " is 172.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,CreateAsync,The length of the statement  "			return this.DirectoryLayer.CreateOrOpenInternalAsync(null' trans' ToRelativePath(path)' layer' prefix: Slice.Nil' allowCreate: true' allowOpen: false' throwOnError: true); " is 171.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,TryCreateAsync,The length of the statement  "			return this.DirectoryLayer.CreateOrOpenInternalAsync(null' trans' ToRelativePath(path)' layer' prefix: Slice.Nil' allowCreate: true' allowOpen: false' throwOnError: false); " is 172.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,RegisterAsync,The length of the statement  "			return this.DirectoryLayer.CreateOrOpenInternalAsync(null' trans' ToRelativePath(path)' layer' prefix: prefix' allowCreate: true' allowOpen: false' throwOnError: true); " is 168.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,MoveToAsync,The length of the statement  "			if (!location.StartsWith(directoryLayer.Location)) throw new InvalidOperationException("Cannot move between partitions."); " is 122.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,MoveAsync,The length of the statement  "			return this.DirectoryLayer.MoveAsync(trans' this.ToRelativePath(oldPath).ToArray<string>()' this.ToRelativePath(newPath).ToArray<string>()); " is 140.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,TryMoveToAsync,The length of the statement  "			if (!location.StartsWith(directoryLayer.Location)) throw new InvalidOperationException("Cannot move between partitions."); " is 122.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,TryMoveAsync,The length of the statement  "			return this.DirectoryLayer.TryMoveAsync(trans' this.ToRelativePath(oldPath).ToArray<string>()' this.ToRelativePath(newPath).ToArray<string>()); " is 143.
Long Statement,FoundationDB.Layers.Directories,FdbDirectorySubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectorySubspace.cs,ToString,The length of the statement  "				return String.Format("DirectorySubspace(path={0}' prefix={1}' layer={2})"' this.FullName' this.InternalKey.ToAsciiOrHexaString()' this.Layer.ToAsciiOrHexaString()); " is 164.
Long Statement,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,AllocateAsync,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Advance allocator window size to {0} starting at {1}"' window' start + window); " is 139.
Long Statement,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,AllocateAsync,The length of the statement  "					if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Allocated prefix {0} from window [{1}..{2}] ({3} used)"' candidate' start' start + window - 1' count + 1); " is 166.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CheckLayer,The length of the statement  "				throw new InvalidOperationException(String.Format("The directory layer {0} is not compatible with layer {1}."' this.FullName' layer.ToAsciiOrHexaString())); " is 156.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenAsync,The length of the statement  "			return CreateOrOpenInternalAsync(null' trans' ParsePath(path)' layer' Slice.Nil' allowCreate: true' allowOpen: true' throwOnError: true); " is 137.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,OpenAsync,The length of the statement  "			return CreateOrOpenInternalAsync(trans' null' ParsePath(path)' layer' prefix: Slice.Nil' allowCreate: false' allowOpen: true' throwOnError: true); " is 146.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateAsync,The length of the statement  "			return CreateOrOpenInternalAsync(null' trans' ParsePath(path)' layer' prefix: Slice.Nil' allowCreate: true' allowOpen: false' throwOnError: true); " is 146.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,TryOpenAsync,The length of the statement  "			return CreateOrOpenInternalAsync(trans' null' ParsePath(path)' layer' prefix: Slice.Nil' allowCreate: false' allowOpen: true' throwOnError: false); " is 147.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,TryCreateAsync,The length of the statement  "			return CreateOrOpenInternalAsync(null' trans' ParsePath(path)' layer' prefix: Slice.Nil' allowCreate: true' allowOpen: false' throwOnError: false); " is 147.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,RegisterAsync,The length of the statement  "			return CreateOrOpenInternalAsync(null' trans' ParsePath(path)' layer' prefix: prefix' allowCreate: true' allowOpen: false' throwOnError: true); " is 143.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,TryRegisterAsync,The length of the statement  "			return CreateOrOpenInternalAsync(null' trans' ParsePath(path)' layer' prefix: prefix' allowCreate: true' allowOpen: false' throwOnError: false); " is 144.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ChangeLayerAsync,The length of the statement  "			return await CreateOrOpenInternalAsync(null' trans' location' newLayer' prefix: Slice.Nil' allowCreate: false' allowOpen: true' throwOnError: true).ConfigureAwait(false); " is 170.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ToString,The length of the statement  "			return String.Format("DirectoryLayer(path={0}' contents={1}' nodes={2})"' this.FullName' this.ContentSubspace.Key.ToAsciiOrHexaString()' this.NodeSubspace.Key.ToAsciiOrHexaString()); " is 182.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ToRelativePath,The length of the statement  "			if (!path.StartsWith(this.Location)) throw new InvalidOperationException("The path cannot be outside of this partition"); " is 121.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "			Contract.Requires(readTrans == null || trans == null || object.ReferenceEquals(readTrans' trans)' "The write transaction should be the same as the read transaction"); " is 166.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "					return await dl.CreateOrOpenInternalAsync(readTrans' trans' subpath' layer' prefix' allowCreate' allowOpen' throwOnError).ConfigureAwait(false); " is 144.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "					throw new InvalidOperationException(String.Format("The directory {0} was created with incompatible layer {1} instead of expected {2}."' path' layer.ToAsciiOrHexaString()' existingNode.Layer.ToAsciiOrHexaString())); " is 214.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Ensure that there is no data already present under prefix {0}"' prefix); " is 132.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "					throw new InvalidOperationException(String.Format("The database has keys stored at the prefix chosen by the automatic prefix allocator: {0}"' prefix.ToAsciiOrHexaString())); " is 173.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Ensure that the prefix {0} has not already been allocated"' prefix); " is 128.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "					throw new InvalidOperationException("The directory layer has manually allocated prefixes that conflict with the automatic prefix allocator."); " is 142.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Ensure that the prefix {0} hasn't already been allocated"' prefix); " is 127.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "				var parentSubspace = await CreateOrOpenInternalAsync(readTrans' trans' path.Substring(0' path.Count - 1)' Slice.Nil' Slice.Nil' true' true' true).ConfigureAwait(false); " is 168.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "			if (parentNode == null) throw new InvalidOperationException(string.Format("The parent directory of {0} doesn't exist."' path)); " is 127.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CreateOrOpenInternalAsync,The length of the statement  "			if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Registering the new prefix {0} into the folder sub-tree"' prefix); " is 126.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "				throw new InvalidOperationException(string.Format("The destination directory({0}) cannot be a subdirectory of the source directory({1})."' newPath' oldPath)); " is 158.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "				if (throwOnError) throw new InvalidOperationException(string.Format("The source directory '{0}' does not exist."' oldPath)); " is 124.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "			// we have already checked that old and new are under this partition path' but one of them (or both?) could be under a sub-partition.. " is 134.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "				return await GetPartitionForNode(newNode).DirectoryLayer.MoveInternalAsync(trans' oldNode.PartitionSubPath' newNode.PartitionSubPath' throwOnError).ConfigureAwait(false); " is 170.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "				if (throwOnError) throw new InvalidOperationException(string.Format("The destination directory '{0}' already exists. Remove it first."' newPath)); " is 146.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "				if (throwOnError) throw new InvalidOperationException(string.Format("The parent of the destination directory '{0}' does not exist. Create it first."' newPath)); " is 160.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "			if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Register the prefix {0} to its new location in the folder sub-tree"' oldNode.Subspace.Key); " is 151.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,MoveInternalAsync,The length of the statement  "			trans.Set(GetSubDirKey(parentNode.Subspace' newPath.Get<string>(-1))' this.NodeSubspace.Keys.Decode<Slice>(oldNode.Subspace.Key)); " is 130.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,RemoveInternalAsync,The length of the statement  "				return await GetPartitionForNode(n).DirectoryLayer.RemoveInternalAsync(trans' n.PartitionSubPath' throwIfMissing).ConfigureAwait(false); " is 136.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ListInternalAsync,The length of the statement  "				return await GetPartitionForNode(node).DirectoryLayer.ListInternalAsync(trans' node.PartitionSubPath' throwIfMissing).ConfigureAwait(false); " is 140.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ExistsInternalAsync,The length of the statement  "				return await GetPartitionForNode(node).DirectoryLayer.ExistsInternalAsync(trans' node.PartitionSubPath).ConfigureAwait(false); " is 126.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ChangeLayerInternalAsync,The length of the statement  "				throw new InvalidOperationException(string.Format("The directory '{0}' does not exist' or as already been removed."' path)); " is 124.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,ChangeLayerInternalAsync,The length of the statement  "				await GetPartitionForNode(node).DirectoryLayer.ChangeLayerInternalAsync(trans' node.PartitionSubPath' newLayer).ConfigureAwait(false); " is 134.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CheckVersion,The length of the statement  "			// the version is stored as 3 x 32-bit unsigned ints' so (1' 0' 0) will be "<01><00><00><00> <00><00><00><00> <00><00><00><00>" " is 127.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CheckVersion,The length of the statement  "			if (major > LayerVersion.Major) throw new InvalidOperationException(String.Format("Cannot load directory with version {0}.{1}.{2} using directory layer {3}"' major' minor' upgrade' LayerVersion)); " is 196.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,CheckVersion,The length of the statement  "			if (writeAccess && minor > LayerVersion.Minor) throw new InvalidOperationException(String.Format("Directory with version {0}.{1}.{2} is read-only when opened using directory layer {3}"' major' minor' upgrade' LayerVersion)); " is 224.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,FindAsync,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) tr.Annotate("Looking for child {0} under node {1}..."' path.Get<string>(i)' n.Key); " is 127.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,FindAsync,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) tr.Annotate("Reading Layer value for subfolder {0} found at {1}"' path' n.Key); " is 123.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,RemoveFromParent,The length of the statement  "				if (FdbDirectoryLayer.AnnotateTransactions) tr.Annotate("Removing path {0} from its parent folder at {1}"' path' parent.Subspace.Key); " is 134.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,RemoveRecursive,The length of the statement  "			//note: we could use Task.WhenAll to remove the children' but there is a risk of task explosion if the subtree is very large... " is 127.
Long Statement,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,GetSubDirKey,The length of the statement  "			// but since the last item of path can be of any type' we will use tuple splicing to copy the last item without changing its type " is 129.
Long Statement,FoundationDB.Layers.Directories,Node,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,IsInPartition,The length of the statement  "				return this.Exists && this.Layer == FdbDirectoryPartition.LayerId && (includeEmptySubPath || this.TargetPath.Count > this.Path.Count); " is 134.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// the caller probably cares about the return type' since it is using a struct' but whatever tuple type we use will end up boxing this tuple on the heap' and we will loose type information. " is 189.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// but' by returning a FdbLinkedTuple<T6>' the tuple will still remember the exact type' and efficiently serializer/convert the values (without having to guess the type) " is 169.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// the caller probably cares about the return type' since it is using a struct' but whatever tuple type we use will end up boxing this tuple on the heap' and we will loose type information. " is 189.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// but' by returning a FdbLinkedTuple<T5>' the tuple will still remember the exact type' and efficiently serializer/convert the values (without having to guess the type) " is 169.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Create,The length of the statement  "			//note: this is a convenience method for people that wants to pass more than 3 args arguments' and not have to call CreateRange(object[]) method " is 144.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Create,The length of the statement  "			// We don't copy the array' and rely on the fact that the array was created by the compiler and that nobody will get a reference on it. " is 135.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKeys,The length of the statement  "			// pre-allocate by guessing that each key will take at least 8 bytes. Even if 8 is too small' we should have at most one or two buffer resize " is 141.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKeys,The length of the statement  "			// pre-allocate by guessing that each key will take at least 8 bytes. Even if 8 is too small' we should have at most one or two buffer resize " is 141.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Stringify,The length of the statement  "			if (item is Guid) return ((Guid)item).ToString("B"' CultureInfo.InstalledUICulture); /* {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} */ " is 129.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Stringify,The length of the statement  "			if (item is Uuid128) return ((Uuid128)item).ToString("B"' CultureInfo.InstalledUICulture); /* {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} */ " is 135.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FailIndexOutOfRange,The length of the statement  "			throw new IndexOutOfRangeException(String.Format("Index {0} is outside of the tuple's range (0..{1})"' index' count - 1)); " is 122.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// Note: By create a FdbTuple<T1' T2' T3> we risk an explosion of the number of combinations of Ts which could potentially cause problems at runtime (too many variants of the same generic types).  " is 195.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// ex: if we have N possible types' then there could be N^3 possible variants of FdbTuple<T1' T2' T3> that the JIT has to deal with. " is 132.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// Here' the caller was explicitly using the FdbTuple<T1' T2' T3> struct so probably care about memory footprint' so we keep returning a struct " is 143.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// Note: By create a FdbTuple<T1' T2' T3' T4> we risk an explosion of the number of combinations of Ts which could potentially cause problems at runtime (too many variants of the same generic types).  " is 199.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			// ex: if we have N possible types' then there could be N^4 possible variants of FdbTuple<T1' T2' T3' T4> that the JIT has to deal with. " is 136.
Long Statement,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The length of the statement  "			//note: this override exists to prevent the explosion of tuple types such as FdbTuple<T1' FdbTuple<T1' T2>' FdbTuple<T1' T2' T3>' FdbTuple<T1' T2' T4>> ! " is 153.
Long Statement,FoundationDB.Layers.Tuples,FdbPrefixedTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbPrefixedTuple.cs,Equals,The length of the statement  "			return !object.ReferenceEquals(other' null) && ((IStructuralEquatable)this).Equals(other' SimilarValueComparer.Default); " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbJoinedTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbJoinedTuple.cs,Equals,The length of the statement  "			return !object.ReferenceEquals(other' null) && ((IStructuralEquatable)this).Equals(other' SimilarValueComparer.Default); " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbLinkedTuple<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbLinkedTuple.cs,Equals,The length of the statement  "			return !object.ReferenceEquals(other' null) && ((IStructuralEquatable)this).Equals(other' SimilarValueComparer.Default); " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The length of the statement  "			// This ensures that all negative numbers have their first byte < 0x80' and all positive numbers have their first byte >= 0x80 " is 126.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The length of the statement  "			// This ensures that all negative numbers have their first byte < 0x80' and all positive numbers have their first byte >= 0x80 " is 126.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The length of the statement  "			// note: we could use BitConverter.DoubleToInt64Bits(...)' but it does the same thing' and also it does not exist for floats... " is 127.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// * We will only attempt to optimze strings that don't have any 00 to escape to 00 FF. For these' we will fallback to converting to byte[] then escaping. " is 154.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// * Since .NET's strings are UTF-16' the max possible UNICODE value to encode is 0xFFFF' which takes 3 bytes in UTF-8 (EF BF BF) " is 129.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// * Most western europe languages have only a few non-ASCII chars here and there' and most of them will only use 2 bytes (ex: 'é' => 'C3 A9') " is 142.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// => if not' we will use an UTF8Encoder to convert the string to UTF-8' in chunks' using a small buffer allocated on the stack " is 127.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// fastest way to check for non-ASCII' is to OR all the chars together' and look at bits 7 to 15. If they are not all zero' there is at least ONE non-ASCII char. " is 161.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// * Western languages have a few chars that usually need 2 bytes. If we pre-allocate 50% more bytes' it should fit most of the time' without too much waste " is 156.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// * Eastern langauges will have all chars encoded to 3 bytes. If we also pre-allocated 50% more' we should only need one resize of the buffer (150% x 2 = 300%)' which is acceptable " is 181.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The length of the statement  "			// note: encoder.Convert() tries to fill up the buffer as much as possible with complete chars' and will set 'done' to true when all chars have been converted. " is 159.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseSingle,The length of the statement  "			// We need to reverse encoding process: if first byte < 0x80 then it is negative (bits need to be flipped)' else it is positive (highest bit must be set to 0) " is 158.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseDouble,The length of the statement  "			// We need to reverse encoding process: if first byte < 0x80 then it is negative (bits need to be flipped)' else it is positive (highest bit must be set to 0) " is 158.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseDouble,The length of the statement  "			// note: we could use BitConverter.Int64BitsToDouble(...)' but it does the same thing' and also it does not exist for floats... " is 127.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The length of the statement  "					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other " is 147.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The length of the statement  "			throw new FormatException(String.Format("Invalid tuple type byte {0} at index {1}/{2}"' type' reader.Input.Position' reader.Input.Buffer.Count)); " is 145.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ReadEmbeddedTupleBytes,The length of the statement  "			// The current embedded tuple starts here' and stops on a <00>' but itself can contain more embedded tuples' and could have a <00> bytes as part of regular items (like bytes' strings' that end with <00> or could contain a <00><FF> ...) " is 235.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ReadEmbeddedTupleBytes,The length of the statement  "			// This means that we have to parse the tuple recursively' discard the tokens' and note where the cursor ended. The parsing of the tuple itself will be processed later. " is 168.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ReadEmbeddedTupleBytes,The length of the statement  "			throw new FormatException(String.Format("Truncated embedded tuple started at index {0}/{1}"' start' reader.Input.Buffer.Count)); " is 128.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleFormatter<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\Formatters\FdbTupleFormatter.cs,CreateAppender,The length of the statement  "					if (!FdbTuple.StartsWith(tuple' prefix)) throw new ArgumentException("Tuple does not start with the expected prefix"' "tuple"); " is 127.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleFormatter<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\Formatters\FdbTupleFormatter.cs,CreateDefaultFormatter,The length of the statement  "				// note: we cannot call directlty 'new FormattableFormatter<T>()' because of the generic type constraints' so we have to use reflection... " is 138.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleFormatter<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\Formatters\FdbTupleFormatter.cs,CreateDefaultFormatter,The length of the statement  "				// => this WILL fail if someone implements 'ITupleFormattable' on a class that does not have public parameterless constructor ! " is 127.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,GetSerializer,The length of the statement  "				encoder = delegate { throw new InvalidOperationException(String.Format("Does not know how to serialize values of type {0} into keys"' typeof(T).Name)); }; " is 154.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,GetSerializerFor,The length of the statement  "			var method = typeof(FdbTuplePackers).GetMethod("SerializeTo"' BindingFlags.Static | BindingFlags.Public' null' typeArgs' null); " is 127.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeObjectTo,The length of the statement  "				if (tuple == null) throw new InvalidOperationException(String.Format("An instance of type {0} returned a null Tuple while serialiazing"' value.GetType().Name)); " is 160.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeObjectTo,The length of the statement  "			throw new NotSupportedException(String.Format("Doesn't know how to serialize objects of type {0} into Tuple Encoding format"' value.GetType().Name)); " is 149.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - Since we are going to lose the TimeZone infos anyway' we can just store everything in UTC and let the caller deal with it " is 126.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - Most other *nix uses the number of milliseconds since 1970-Jan-01 UTC' but if we store as an integer we will lose some precision (rounded to nearest millisecond) " is 166.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - We could store the number of milliseconds as a floating point value' which would require support of Floating Points in the Tuple Encoding (currently a Draft) " is 162.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - Other database engines store dates as a number of DAYS since Epoch' using a floating point number. This allows for quickly extracting the date by truncating the value' and the time by using the decimal part " is 211.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// => JS binding MAY support decoding of 64-bit floats in the future' in which case the value would be preserved exactly. " is 121.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - Storing the number of milliseconds as an integer will round the precision to 1 millisecond' which is not acceptable " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - We could store the the number of milliseconds as a floating point value' which would require support of Floating Points in the Tuple Encoding (currently a Draft) " is 166.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// - It is frequent for JSON APIs and other database engines to represent durations as a number of SECONDS' using a floating point number. " is 138.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeTo,The length of the statement  "			// => could spare ~16 bytes per key in indexes on GUID properties that are frequently missing or empty (== default(Guid)) " is 121.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeFormattableTo,The length of the statement  "			if (tuple == null) throw new InvalidOperationException(String.Format("Custom formatter {0}.ToTuple() cannot return null"' formattable.GetType().Name)); " is 151.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,GetDeserializer,The length of the statement  "				return (_) => { throw new InvalidOperationException(String.Format("Does not know how to deserialize keys into values of type {0}"' typeof(T).Name)); }; " is 151.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,MakeNullableDeserializer,The length of the statement  "			// We have a Decoder of T' but we have to transform it into a Decoder for Nullable<T>' which returns null if the slice is "nil"' or falls back to the underlying decoder if the slice contains something " is 200.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,MakeNullableDeserializer,The length of the statement  "				Expression.Call(typeof(FdbTuplePackers).GetMethod("IsNilSegment"' BindingFlags.Static | BindingFlags.NonPublic)' prmSlice)' " is 123.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeUInt64,The length of the statement  "			throw new FormatException(String.Format("Cannot convert tuple segment of type 0x{0:X} into an unsigned integer"' type)); " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeIPAddress,The length of the statement  "			throw new FormatException(String.Format("Cannot convert tuple segment of type 0x{0:X} into System.Net.IPAddress"' type)); " is 121.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,Unpack,The length of the statement  "			if (reader.Input.HasMore) throw new FormatException("Parsing of tuple failed failed before reaching the end of the key"); " is 121.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,UnpackSingle,The length of the statement  "			if (slicer.Input.HasMore) throw new FormatException("Parsing of singleton tuple failed before reaching the end of the key"); " is 124.
Long Statement,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,UnpackLast,The length of the statement  "			if (slicer.Input.HasMore) throw new FormatException("Parsing of tuple failed failed before reaching the end of the key"); " is 121.
Long Statement,FoundationDB.Layers.Tuples,FdbSlicedTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbSlicedTuple.cs,ToString,The length of the statement  "			//OPTIMIZE: this could be optimized' because it may be called a lot when logging is enabled on keys parsed from range reads " is 123.
Long Statement,FoundationDB.Layers.Tuples,FdbSlicedTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbSlicedTuple.cs,Equals,The length of the statement  "			return !object.ReferenceEquals(other' null) && ((IStructuralEquatable)this).Equals(other' SimilarValueComparer.Default); " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbListTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbListTuple.cs,Equals,The length of the statement  "			return !object.ReferenceEquals(other' null) && ((IStructuralEquatable)this).Equals(other' SimilarValueComparer.Default); " is 120.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,ToTuple,The length of the statement  "			//note: this method is here to allow a fluent API with method chaining' like "something.ToFoundationDbKey().ToTuple().With((int x' int y) => .....)" " is 148.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,ToTupleOrDefault,The length of the statement  "			//note: this method is here to allow a fluent API with method chaining' like "something.ToFoundationDbKey().ToTuple().With((int x' int y) => .....)" " is 148.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,ThrowInvalidTupleSize,The length of the statement  "				case 1: throw new InvalidOperationException(String.Format("This operation requires a tuple of size {0} or less' but this tuple has {1} elements"' expected' tuple.Count)); " is 170.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,ThrowInvalidTupleSize,The length of the statement  "				case -1: throw new InvalidOperationException(String.Format("This operation requires a tuple of size {0} or more' but this tuple has {1} elements"' expected' tuple.Count)); " is 171.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,ThrowInvalidTupleSize,The length of the statement  "				default: throw new InvalidOperationException(String.Format("This operation requires a tuple of size {0}' but this tuple has {1} elements"' expected' tuple.Count)); " is 163.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The length of the statement  "			lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)); " is 133.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The length of the statement  "			lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7)); " is 151.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The length of the statement  "			return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)); " is 122.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The length of the statement  "			return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)); " is 140.
Long Statement,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The length of the statement  "			return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7)); " is 158.
Long Statement,FoundationDB.Client.Native,FdbNativeCluster,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeCluster.cs,OpenDatabaseAsync,The length of the statement  "			if (cancellationToken.IsCancellationRequested) return TaskHelpers.FromCancellation<IFdbDatabaseHandler>(cancellationToken); " is 123.
Long Statement,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,TryGetValueResult,The length of the statement  "			Debug.WriteLine("FdbTransaction[].TryGetValueResult() => err=" + err + "' present=" + present + "' valueLength=" + result.Count); " is 129.
Long Statement,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,GetRangeAsync,The length of the statement  "			var future = FdbNative.TransactionGetRange(m_handle' begin' end' options.Limit ?? 0' options.TargetBytes ?? 0' options.Mode ?? FdbStreamingMode.Iterator' iteration' snapshot' reversed); " is 185.
Long Statement,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,GetStringArrayResult,The length of the statement  "			Debug.WriteLine("FdbTransaction[].FutureGetStringArray() => err=" + err + "' results=" + (result == null ? "<null>" : result.Length.ToString())); " is 145.
Long Statement,FoundationDB.Client.Native,FdbFuture,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFuture.cs,CreateTaskFromHandleArray,The length of the statement  "			//TODO: technically' there is no reason why FdbFutureArray would not accept an empty array. We should simplify this by handling the case in the ctor (we are already allocating something anyway...) " is 196.
Long Statement,FoundationDB.Client.Native,FdbFuture<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFuture.cs,TryCleanup,The length of the statement  "			// We try to cleanup the future handle as soon as possible' meaning as soon as we have the result' or an error' or a cancellation " is 129.
Long Statement,FoundationDB.Client.Native,FdbFuture<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFuture.cs,DoCleanup,The length of the statement  "				// note: always defer the completion on the threadpool' because we don't want to dead lock here (we can be called by Dispose) " is 125.
Long Statement,FoundationDB.Client.Native,FdbFuture<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFuture.cs,DoCleanup,The length of the statement  "				// The only surviving value after this would be a Task and an optional WorkItem on the ThreadPool that will signal it... " is 120.
Long Statement,FoundationDB.Client.Native,FdbFuture<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFuture.cs,RegisterCallback,The length of the statement  "			var prm = new IntPtr(id); // note: we assume that we can only run in 64-bit mode' so it is safe to cast a long into an IntPtr " is 125.
Long Statement,FoundationDB.Client.Native,FdbFuture<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFuture.cs,CancellationHandler,The length of the statement  "				Debug.WriteLine("Future<" + typeof(T).Name + ">.Cancel(0x" + future.m_handle.Handle.ToString("x") + ") was called on thread #" + Thread.CurrentThread.ManagedThreadId.ToString()); " is 178.
Long Statement,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,ReleaseMemory,The length of the statement  "						//REVIEW: there is a possibility of a race condition with Dispoe() that could potentially call FutureDestroy(handle) at the same time (not verified) " is 148.
Long Statement,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,CancelHandles,The length of the statement  "						//REVIEW: there is a possibility of a race condition with Dispoe() that could potentially call FutureDestroy(handle) at the same time (not verified) " is 148.
Long Statement,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,FutureCompletionCallback,The length of the statement  "			Debug.WriteLine("Future<" + typeof(T).Name + ">.Callback(0x" + futureHandle.ToString("x") + "' " + parameter.ToString("x") + ") has fired on thread #" + Thread.CurrentThread.ManagedThreadId.ToString()); " is 202.
Long Statement,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,HandleCompletion,The length of the statement  "			Debug.WriteLine("FutureArray<" + typeof(T).Name + ">.Callback(...) handling completion on thread #" + Thread.CurrentThread.ManagedThreadId.ToString()); " is 151.
Long Statement,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,HandleCompletion,The length of the statement  "								//note: result selector will execute from network thread' but this should be our own code that only calls into some fdb_future_get_XXXX()' which should be safe... " is 162.
Long Statement,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,FutureCompletionCallback,The length of the statement  "			Debug.WriteLine("Future<" + typeof(T).Name + ">.Callback(0x" + futureHandle.ToString("x") + "' " + parameter.ToString("x") + ") has fired on thread #" + Thread.CurrentThread.ManagedThreadId.ToString()); " is 202.
Long Statement,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,HandleCompletion,The length of the statement  "			// this is very frequent when we are called with await' or ContinueWith(...' TaskContinuationOptions.ExecuteSynchronously) " is 122.
Long Statement,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,HandleCompletion,The length of the statement  "							//note: result selector will execute from network thread' but this should be our own code that only calls into some fdb_future_get_XXXX()' which should be safe... " is 162.
Long Statement,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,HandleCompletion,The length of the statement  "				Debug.WriteLine("Future<" + typeof(T).Name + "> callback completed in " + sw.Elapsed.TotalMilliseconds.ToString() + " ms"); " is 123.
Long Statement,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,CancelHandles,The length of the statement  "			//REVIEW: there is a possibility of a race condition with Dispose() that could potentially call FutureDestroy(handle) at the same time (not verified) " is 149.
Long Statement,FoundationDB.Client.Native,FdbFutureSingle<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureSingle.cs,ReleaseMemory,The length of the statement  "			//REVIEW: there is a possibility of a race condition with Dispose() that could potentially call FutureDestroy(handle) at the same time (not verified) " is 149.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureSetCallback,The length of the statement  "			Debug.WriteLine("fdb_future_set_callback(0x" + future.Handle.ToString("x") + "' 0x" + ptrCallback.ToString("x") + ") => err=" + err); " is 133.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetCluster,The length of the statement  "			Debug.WriteLine("fdb_future_get_cluster(0x" + future.Handle.ToString("x") + ") => err=" + err + "' handle=0x" + cluster.Handle.ToString("x")); " is 142.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetDatabase,The length of the statement  "			Debug.WriteLine("fdb_future_get_database(0x" + future.Handle.ToString("x") + ") => err=" + err + "' handle=0x" + database.Handle.ToString("x")); " is 144.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,ClusterCreateDatabase,The length of the statement  "			Debug.WriteLine("fdb_cluster_create_database(0x" + cluster.Handle.ToString("x") + "' name: '" + name + "') => 0x" + cluster.Handle.ToString("x")); " is 146.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,DatabaseCreateTransaction,The length of the statement  "			Debug.WriteLine("fdb_database_create_transaction(0x" + database.Handle.ToString("x") + ") => err=" + err + "' handle=0x" + transaction.Handle.ToString("x")); " is 157.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionCommit,The length of the statement  "			Debug.WriteLine("fdb_transaction_commit(0x" + transaction.Handle.ToString("x") + ") => 0x" + future.Handle.ToString("x")); " is 122.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionWatch,The length of the statement  "				Debug.WriteLine("fdb_transaction_watch(0x" + transaction.Handle.ToString("x") + "' key: '" + FdbKey.Dump(key) + "') => 0x" + future.Handle.ToString("x")); " is 154.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionOnError,The length of the statement  "			Debug.WriteLine("fdb_transaction_on_error(0x" + transaction.Handle.ToString("x") + "' " + errorCode + ") => 0x" + future.Handle.ToString("x")); " is 143.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionSetReadVersion,The length of the statement  "			Debug.WriteLine("fdb_transaction_set_read_version(0x" + transaction.Handle.ToString("x") + "' version: " + version.ToString() + ")"); " is 133.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGetReadVersion,The length of the statement  "			Debug.WriteLine("fdb_transaction_get_read_version(0x" + transaction.Handle.ToString("x") + ") => 0x" + future.Handle.ToString("x")); " is 132.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGet,The length of the statement  "				Debug.WriteLine("fdb_transaction_get(0x" + transaction.Handle.ToString("x") + "' key: '" + FdbKey.Dump(key) + "'' snapshot: " + snapshot + ") => 0x" + future.Handle.ToString("x")); " is 180.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGetRange,The length of the statement  "					Debug.WriteLine("fdb_transaction_get_range(0x" + transaction.Handle.ToString("x") + "' begin: " + begin.PrettyPrint(FdbKey.PrettyPrintMode.Begin) + "' end: " + end.PrettyPrint(FdbKey.PrettyPrintMode.End) + "' " + snapshot + ") => 0x" + future.Handle.ToString("x")); " is 265.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGetKey,The length of the statement  "				var future = NativeMethods.fdb_transaction_get_key(transaction' ptrKey + selector.Key.Offset' selector.Key.Count' selector.OrEqual' selector.Offset' snapshot); " is 159.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGetKey,The length of the statement  "				Debug.WriteLine("fdb_transaction_get_key(0x" + transaction.Handle.ToString("x") + "' " + selector.ToString() + "' " + snapshot + ") => 0x" + future.Handle.ToString("x")); " is 170.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionGetAddressesForKey,The length of the statement  "				Debug.WriteLine("fdb_transaction_get_addresses_for_key(0x" + transaction.Handle.ToString("x") + "' key: '" + FdbKey.Dump(key) + "') => 0x" + future.Handle.ToString("x")); " is 170.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetValue,The length of the statement  "			Debug.WriteLine("fdb_future_get_value(0x" + future.Handle.ToString("x") + ") => err=" + err + "' present=" + valuePresent + "' valueLength=" + valueLength); " is 156.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetKey,The length of the statement  "			Debug.WriteLine("fdb_future_get_key(0x" + future.Handle.ToString("x") + ") => err=" + err + "' keyLength=" + keyLength); " is 120.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetKey,The length of the statement  "			// note: fdb_future_get_key is allowed to return NULL for the empty key (not to be confused with a key that has an empty value) " is 127.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetKey,The length of the statement  "			{ // from the spec: "If a key selector would otherwise describe a key off the beginning of the database' it instead resolves to the empty key ''." " is 146.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetKeyValueArray,The length of the statement  "			Debug.WriteLine("fdb_future_get_keyvalue_array(0x" + future.Handle.ToString("x") + ") => err=" + err + "' count=" + count + "' more=" + more); " is 142.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetStringArray,The length of the statement  "			Debug.WriteLine("fdb_future_get_string_array(0x" + future.Handle.ToString("x") + ") => err=" + err + "' count=" + count); " is 121.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetStringArray,The length of the statement  "					//TODO: if pointers are corrupted' or memory is garbled' we could very well walk around the heap' randomly copying a bunch of stuff (like passwords or jpegs of cats...) " is 168.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FutureGetStringArray,The length of the statement  "					// there is no real way to ensure that pointers are valid' except maybe having a maximum valid size for strings' and they should probably only contain legible text ? " is 165.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionSet,The length of the statement  "				Debug.WriteLine("fdb_transaction_set(0x" + transaction.Handle.ToString("x") + "' key: '" + FdbKey.Dump(key) + "'' value: '" + FdbKey.Dump(value) + "')"); " is 153.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionAtomicOperation,The length of the statement  "				Debug.WriteLine("fdb_transaction_atomic_op(0x" + transaction.Handle.ToString("x") + "' key: '" + FdbKey.Dump(key) + "'' param: '" + FdbKey.Dump(param) + "'' " + operationType.ToString() + ")"); " is 193.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionAtomicOperation,The length of the statement  "				NativeMethods.fdb_transaction_atomic_op(transaction' pKey + key.Offset' key.Count' pParam + param.Offset' param.Count' operationType); " is 134.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionClearRange,The length of the statement  "				Debug.WriteLine("fdb_transaction_clear_range(0x" + transaction.Handle.ToString("x") + "' beginKey: '" + FdbKey.Dump(beginKey) + "' endKey: '" + FdbKey.Dump(endKey) + "')"); " is 172.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionClearRange,The length of the statement  "				NativeMethods.fdb_transaction_clear_range(transaction' pBeginKey + beginKey.Offset' beginKey.Count' pEndKey + endKey.Offset' endKey.Count); " is 139.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionAddConflictRange,The length of the statement  "				Debug.WriteLine("fdb_transaction_add_conflict_range(0x" + transaction.Handle.ToString("x") + "' beginKey: '" + FdbKey.Dump(beginKey) + "' endKey: '" + FdbKey.Dump(endKey) + "'' " + type.ToString() + ")"); " is 204.
Long Statement,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,TransactionAddConflictRange,The length of the statement  "				return NativeMethods.fdb_transaction_add_conflict_range(transaction' pBeginKey + beginKey.Offset' beginKey.Count' pEndKey + endKey.Offset' endKey.Count' type); " is 159.
Long Statement,FoundationDB.Client.Native,UnmanagedLibrary,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\UnmanagedLibrary.cs,Load,The length of the statement  "					throw new System.IO.FileNotFoundException(String.Format("Failed to load native {0} library: {1}"' IntPtr.Size == 8 ? "x64" : "x86"' path)' path' ex); " is 149.
Long Statement,FoundationDB.Filters.Logging,FdbLoggingExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggingExtensions.cs,Annotate,The length of the statement  "			if (logged != null) logged.Log.AddOperation(new FdbTransactionLog.LogCommand(String.Format(format' arg0))' countAsOperation: false); " is 132.
Long Statement,FoundationDB.Filters.Logging,FdbLoggingExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggingExtensions.cs,Annotate,The length of the statement  "			if (logged != null) logged.Log.AddOperation(new FdbTransactionLog.LogCommand(String.Format(format' arg0' arg1))' countAsOperation: false); " is 138.
Long Statement,FoundationDB.Filters.Logging,FdbLoggingExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggingExtensions.cs,Annotate,The length of the statement  "			if (logged != null) logged.Log.AddOperation(new FdbTransactionLog.LogCommand(String.Format(format' arg0' arg1' arg2))' countAsOperation: false); " is 144.
Long Statement,FoundationDB.Filters.Logging,FdbLoggingExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggingExtensions.cs,Annotate,The length of the statement  "			if (logged != null) logged.Log.AddOperation(new FdbTransactionLog.LogCommand(String.Format(format' args))' countAsOperation: false); " is 132.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetDuration,The length of the statement  "			return TimeSpan.FromTicks((long)Math.Round(((double)elapsed / Stopwatch.Frequency) * TimeSpan.TicksPerSecond' MidpointRounding.AwayFromZero)); " is 142.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetCommandsReport,The length of the statement  "			sb.AppendFormat(culture' "Transaction #{0} ({3}' {1} operations' started {2}Z"' this.Id' cmds.Length' this.StartedUtc.TimeOfDay' this.IsReadOnly ? "read-only" : "read/write"); " is 175.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetCommandsReport,The length of the statement  "				sb.AppendLine(String.Format(culture' "Stats: {0:N0} operations' {1:N0} reads ({3:N0} bytes)' {2:N0} writes ({4:N0} bytes)' {5:N2} ms"' this.Operations' reads' writes' this.ReadSize' this.CommitSize' this.TotalDuration.TotalMilliseconds)); " is 238.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The length of the statement  "			sb.AppendFormat(culture' "Transaction #{0} ({4}' {1} operations' '#' = {2:N1} ms' started {3}Z"' this.Id' cmds.Length' (scale * 1000d)' this.StartedUtc.TimeOfDay' this.IsReadOnly ? "read-only" : "read/write"); " is 209.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The length of the statement  "						sb.AppendLine(String.Format(culture' "├────────┼{0}┼──────────────────────────────────┼─────────────┤ == Attempt #{1:N0} =="' bar' (++attempts))); " is 146.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The length of the statement  "					sb.AppendLine(String.Format(culture' " in {0:N3} ms and {1:N0} attempt(s)"' this.TotalDuration.TotalMilliseconds' attempts)); " is 125.
Long Statement,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The length of the statement  "				sb.AppendLine(String.Format(culture' "> Completed after {0:N3} ms without performing any operation"' this.TotalDuration.TotalMilliseconds)); " is 140.
Long Statement,FoundationDB.Filters.Logging,Command<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetResult,The length of the statement  "				if (res.Length > MAX_LENGTH) res = res.Substring(0' MAX_LENGTH / 2) + "..." + res.Substring(res.Length - (MAX_LENGTH / 2)' MAX_LENGTH / 2); " is 139.
Long Statement,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,BuildFromDirectoryLayer,The length of the statement  "				//HACKHACK: for now' we will simply poke inside the node subspace of the directory layer' which is brittle (if the structure changes in future versions!) " is 153.
Long Statement,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,BuildFromDirectoryLayer,The length of the statement  "				// Entries that correspond to subfolders have the form: NodeSubspace.Pack( (parent_prefix' 0' "child_name") ) = child_prefix " is 124.
Long Statement,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,BuildFromDirectoryLayer,The length of the statement  "					//Slice parent = t.Get<Slice>(0); //TODO: use this to construct the full materialized path of this directory? (would need more than one pass) " is 141.
Long Statement,FoundationDB.Filters.Logging,AtomicCommand,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,ToString,The length of the statement  "				sb.Append("Atomic_").Append(this.Mutation.ToString()).Append(' ').Append(resolver.Resolve(this.Key)).Append("' <").Append(this.Param.ToHexaString(' ')).Append('>'); " is 164.
Long Statement,FoundationDB.Filters.Logging,AddConflictRangeCommand,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetArguments,The length of the statement  "				return String.Concat(this.Type.ToString()' "! "' resolver.ResolveBegin(this.Begin)' " <= k < "' resolver.ResolveEnd(this.End)); " is 127.
Long Statement,FoundationDB.Filters.Logging,GetRangeCommand,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetArguments,The length of the statement  "				string s = this.Begin.PrettyPrint(FdbKey.PrettyPrintMode.Begin) + " <= k < " + this.End.PrettyPrint(FdbKey.PrettyPrintMode.End); " is 128.
Long Statement,FoundationDB.Filters.Logging,FdbLoggedTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggedTransaction.cs,GetRange,The length of the statement  "			// this method does not execute immediately' so we don't need to record any operation here' only when GetRangeAsync() is called (by ToListAsync() or any other LINQ operator) " is 173.
Long Statement,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,SyntaxError,The length of the statement  "			return new FormatException(String.Format(CultureInfo.InvariantCulture' "Invalid JSON Syntax: {0} at {1}"' msg' m_cursor)); " is 122.
Long Statement,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,SyntaxError,The length of the statement  "			return new FormatException(String.Format(CultureInfo.InvariantCulture' "Invalid JSON Syntax: {0} at {1}"' String.Format(CultureInfo.InvariantCulture' msg' arg0)' m_cursor)); " is 173.
Long Statement,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,ParseObject,The length of the statement  "			if (token != Token.MapBegin) throw new InvalidOperationException(String.Format("JSON object expected' but got a {0}"' token)); " is 126.
Long Statement,FoundationDB.Client.Utils,SliceBuffer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceBuffer.cs,InternRange,The length of the statement  "			//TODO: if end is prefixed by begin' we could merge both keys (frequent when dealing with ranges on tuples that add \xFF " is 120.
Long Statement,FoundationDB.Client.Utils,SliceBuffer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceBuffer.cs,InternRange,The length of the statement  "			//TODO: if end is prefixed by begin' we could merge both keys (frequent when dealing with ranges on tuples that add \xFF " is 120.
Long Statement,FoundationDB.Client.Utils,SliceBuffer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceBuffer.cs,Intern,The length of the statement  "				// note: we don't memoize the suffix' because in most case' it comes from a constant' and it would be a waste to copy it other and other again... " is 145.
Long Statement,FoundationDB.Client.Utils,Logging,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Logging.cs,PrintLine,The length of the statement  "				s_traceSource.TraceEvent(eventType' id' "[" + Thread.CurrentThread.ManagedThreadId.ToString("d4"' CultureInfo.InvariantCulture) + "] " + msg); " is 142.
Complex Conditional,FoundationDB.Client,FdbEndPoint,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbEndPoint.cs,Create,The conditional expression  "(socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetwork && count == 17) || (socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetworkV6 && count == 29)"  is complex.
Complex Conditional,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The conditional expression  "bodyAsyncWithContextAndState == null &&  					bodyAsyncWithContext == null &&  					bodyWithContextAndState == null &&  					bodyWithContext == null"  is complex.
Complex Conditional,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The conditional expression  "mutation == FdbMutationType.Add || mutation == FdbMutationType.BitAnd || mutation == FdbMutationType.BitOr || mutation == FdbMutationType.BitXor"  is complex.
Complex Conditional,FoundationDB.Client,FdbRangeOptions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeOptions.cs,EnsureDefaults,The conditional expression  "options.Limit == null || options.TargetBytes == null || options.Mode == null || options.Reverse == null"  is complex.
Complex Conditional,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The conditional expression  "c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254"  is complex.
Complex Conditional,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,EnsureSliceIsValid,The conditional expression  "slice.Count < 0 || slice.Offset < 0 || slice.Array == null || slice.Offset + slice.Count > slice.Array.Length"  is complex.
Complex Conditional,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,EnsureBufferIsValid,The conditional expression  "count < 0 || offset < 0 || array == null || offset + count > array.Length"  is complex.
Complex Conditional,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ComputeHashCode,The conditional expression  "bytes == null || offset < 0 || count < 0 || offset + count > bytes.Length"  is complex.
Complex Conditional,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode16,The conditional expression  "(!separator || chars[offset + 8] == '-')  				&& TryCharsToHexs(chars' offset' out a)   				&& TryCharsToHexs(chars' offset + (separator ? 9 : 8)' out b)"  is complex.
Complex Conditional,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The conditional expression  "(c >= ' ' && c <= '~') || (c >= 880 && c <= 2047) || (c >= 12352 && c <= 12591)"  is complex.
Complex Conditional,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The conditional expression  "n >= 3 && buffer[p] == 0xEF && buffer[p + 1] == 0xBB && buffer[p + 2] == 0xBF"  is complex.
Complex Conditional,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The conditional expression  "(buffer[p] == '{' && buffer[p + n - 1] == '}') || (buffer[p] == '[' && buffer[p + n - 1] == ']')"  is complex.
Complex Conditional,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,Where,The conditional expression  "m_limit == null  				&& (m_offset == null || m_offset.Value == 0)  				&& typeof(TSource) == typeof(TResult) //BUGBUG: type comparison maybe should check derived classes also ?  				&& m_transform.IsIdentity()"  is complex.
Complex Conditional,FoundationDB.Linq,FdbWhereSelectAsyncIterator<TSource;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWhereSelectAsyncIterator.cs,Where,The conditional expression  "m_limit == null && (m_offset == null || m_offset.Value == 0) && typeof(TSource) == typeof(TResult)"  is complex.
Complex Conditional,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,Resolve,The conditional expression  "s != null && s.Length >= 3 && s[0] == '(' && s[s.Length - 1] == ')'"  is complex.
Complex Conditional,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,ReadNumberLiteral,The conditional expression  "char.IsDigit(c) || c == '.' || c == '+' || c == '-' || c == 'e' || c == 'E'"  is complex.
Empty Catch Block,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,SafeCancel,The method has an empty catch block.
Empty Catch Block,FoundationDB.Async,TaskHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\TaskHelpers.cs,SafeCancelAndDispose,The method has an empty catch block.
Empty Catch Block,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The method has an empty catch block.
Empty Catch Block,FoundationDB.Client,FdbQueryMergeIterator<TSource;TKey;TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbQueryMergeIterator.cs,OnFirstAsync,The method has an empty catch block.
Empty Catch Block,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The method has an empty catch block.
Empty Catch Block,FoundationDB.Client.Native,FdbFutureArray<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbFutureArray.cs,FutureCompletionCallback,The method has an empty catch block.
Magic Number,FoundationDB.Async,AsyncHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\AsyncHelpers.cs,TransformToListAsync,The following statement contains a magic number: using (var queue = CreateOrderPreservingAsyncBuffer<R>(maxConcurrency ?? 32))  			{  				using (var pipe = CreateAsyncTransform<T' R>(transform' queue' scheduler))  				{  					// start the output pump  					var output = PumpToListAsync(queue' cancellationToken);    					// start the intput pump  					var input = PumpToAsync(source' pipe' cancellationToken);    					await Task.WhenAll(input' output).ConfigureAwait(false);    					return output.Result;  				}  			}
Magic Number,FoundationDB.Client.Converters,TypePair,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,GetHashCode,The following statement contains a magic number: h = (h >> 13) | (h << 19);
Magic Number,FoundationDB.Client.Converters,TypePair,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,GetHashCode,The following statement contains a magic number: h = (h >> 13) | (h << 19);
Magic Number,FoundationDB.Client,FdbEndPoint,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbEndPoint.cs,Create,The following statement contains a magic number: if ((socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetwork && count == 17) || (socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetworkV6 && count == 29))  			{  				tls = socketAddress[count - 1] != 0;  			}
Magic Number,FoundationDB.Client,FdbEndPoint,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbEndPoint.cs,Create,The following statement contains a magic number: if ((socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetwork && count == 17) || (socketAddress.Family == System.Net.Sockets.AddressFamily.InterNetworkV6 && count == 29))  			{  				tls = socketAddress[count - 1] != 0;  			}
Magic Number,FoundationDB.Client,FdbClusterFile,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbClusterFile.cs,Parse,The following statement contains a magic number: var coordinators = pairs.Select(pair =>  			{  				bool tls = false;  				if (pair.EndsWith(":tls"' StringComparison.OrdinalIgnoreCase))  				{  					pair = pair.Substring(0' pair.Length - 4);  					tls = true;  				}  				int r = pair.LastIndexOf(':');  				if (r < 0) throw new FormatException("Missing ':' in coordinator address");  				// the format is "{IP}:{PORT}" or "{IP}:{PORT}:tls"    				return new FdbEndPoint(  					IPAddress.Parse(pair.Substring(0' r))'  					Int32.Parse(pair.Substring(r + 1))'  					tls  				);  			}).ToArray();
Magic Number,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The following statement contains a magic number: if (s_eventLoopStarted)  			{    				// We cannot be called from the network thread itself' or else we will dead lock !  				Fdb.EnsureNotOnNetworkThread();    				if (Logging.On) Logging.Verbose(typeof(Fdb)' "StopEventLoop"' "Stopping network thread...");    				s_eventLoopStopRequested = true;    				var err = FdbNative.StopNetwork();  				if (err != FdbError.Success)  				{  					if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("Failed to stop event loop: {0}"' err.ToString()));  				}  				s_eventLoopStarted = false;    				var thread = s_eventLoop;  				if (thread != null && thread.IsAlive)  				{  					// BUGBUG: specs says that we need to wait for the network thread to stop gracefuly' or else data integrity may not be guaranteed...  					// We should wait for a bit' and only attempt to Abort() the thread after a timeout (30sec ? more ?)    					// keep track of how much time it took to stop...  					var duration = Stopwatch.StartNew();    					try  					{  						//TODO: replace with a ManualResetEvent that would get signaled at the end of the event loop ?  						while (thread.IsAlive && duration.Elapsed.TotalSeconds < 5)  						{  							// wait a bit...  							Thread.Sleep(250);  						}    						if (thread.IsAlive)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread has not stopped after {0} seconds. Forcing shutdown..."' duration.Elapsed.TotalSeconds.ToString("N0")));    							// Force a shutdown  							thread.Abort();    							bool stopped = thread.Join(TimeSpan.FromSeconds(30));  							//REVIEW: is this even usefull? If the thread is stuck in a native P/Invoke call' it won't get notified until it returns to managed code ...  							// => in that case' we have a zombie thread on our hands...    							if (!stopped)  							{  								if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread failed to stop after more than {0} seconds. Transaction integrity may not be guaranteed."' duration.Elapsed.TotalSeconds.ToString("N0")));  							}  						}  					}  					catch (ThreadAbortException)  					{  						// Should not happen' unless we are called from a thread that is itself being stopped ?  					}  					finally  					{  						s_eventLoop = null;  						duration.Stop();  						if (duration.Elapsed.TotalSeconds >= 20)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread took a long time to stop ({0} seconds)."' duration.Elapsed.TotalSeconds.ToString("N0")));  						}  					}  				}  			}
Magic Number,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The following statement contains a magic number: if (s_eventLoopStarted)  			{    				// We cannot be called from the network thread itself' or else we will dead lock !  				Fdb.EnsureNotOnNetworkThread();    				if (Logging.On) Logging.Verbose(typeof(Fdb)' "StopEventLoop"' "Stopping network thread...");    				s_eventLoopStopRequested = true;    				var err = FdbNative.StopNetwork();  				if (err != FdbError.Success)  				{  					if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("Failed to stop event loop: {0}"' err.ToString()));  				}  				s_eventLoopStarted = false;    				var thread = s_eventLoop;  				if (thread != null && thread.IsAlive)  				{  					// BUGBUG: specs says that we need to wait for the network thread to stop gracefuly' or else data integrity may not be guaranteed...  					// We should wait for a bit' and only attempt to Abort() the thread after a timeout (30sec ? more ?)    					// keep track of how much time it took to stop...  					var duration = Stopwatch.StartNew();    					try  					{  						//TODO: replace with a ManualResetEvent that would get signaled at the end of the event loop ?  						while (thread.IsAlive && duration.Elapsed.TotalSeconds < 5)  						{  							// wait a bit...  							Thread.Sleep(250);  						}    						if (thread.IsAlive)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread has not stopped after {0} seconds. Forcing shutdown..."' duration.Elapsed.TotalSeconds.ToString("N0")));    							// Force a shutdown  							thread.Abort();    							bool stopped = thread.Join(TimeSpan.FromSeconds(30));  							//REVIEW: is this even usefull? If the thread is stuck in a native P/Invoke call' it won't get notified until it returns to managed code ...  							// => in that case' we have a zombie thread on our hands...    							if (!stopped)  							{  								if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread failed to stop after more than {0} seconds. Transaction integrity may not be guaranteed."' duration.Elapsed.TotalSeconds.ToString("N0")));  							}  						}  					}  					catch (ThreadAbortException)  					{  						// Should not happen' unless we are called from a thread that is itself being stopped ?  					}  					finally  					{  						s_eventLoop = null;  						duration.Stop();  						if (duration.Elapsed.TotalSeconds >= 20)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread took a long time to stop ({0} seconds)."' duration.Elapsed.TotalSeconds.ToString("N0")));  						}  					}  				}  			}
Magic Number,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The following statement contains a magic number: if (s_eventLoopStarted)  			{    				// We cannot be called from the network thread itself' or else we will dead lock !  				Fdb.EnsureNotOnNetworkThread();    				if (Logging.On) Logging.Verbose(typeof(Fdb)' "StopEventLoop"' "Stopping network thread...");    				s_eventLoopStopRequested = true;    				var err = FdbNative.StopNetwork();  				if (err != FdbError.Success)  				{  					if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("Failed to stop event loop: {0}"' err.ToString()));  				}  				s_eventLoopStarted = false;    				var thread = s_eventLoop;  				if (thread != null && thread.IsAlive)  				{  					// BUGBUG: specs says that we need to wait for the network thread to stop gracefuly' or else data integrity may not be guaranteed...  					// We should wait for a bit' and only attempt to Abort() the thread after a timeout (30sec ? more ?)    					// keep track of how much time it took to stop...  					var duration = Stopwatch.StartNew();    					try  					{  						//TODO: replace with a ManualResetEvent that would get signaled at the end of the event loop ?  						while (thread.IsAlive && duration.Elapsed.TotalSeconds < 5)  						{  							// wait a bit...  							Thread.Sleep(250);  						}    						if (thread.IsAlive)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread has not stopped after {0} seconds. Forcing shutdown..."' duration.Elapsed.TotalSeconds.ToString("N0")));    							// Force a shutdown  							thread.Abort();    							bool stopped = thread.Join(TimeSpan.FromSeconds(30));  							//REVIEW: is this even usefull? If the thread is stuck in a native P/Invoke call' it won't get notified until it returns to managed code ...  							// => in that case' we have a zombie thread on our hands...    							if (!stopped)  							{  								if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread failed to stop after more than {0} seconds. Transaction integrity may not be guaranteed."' duration.Elapsed.TotalSeconds.ToString("N0")));  							}  						}  					}  					catch (ThreadAbortException)  					{  						// Should not happen' unless we are called from a thread that is itself being stopped ?  					}  					finally  					{  						s_eventLoop = null;  						duration.Stop();  						if (duration.Elapsed.TotalSeconds >= 20)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread took a long time to stop ({0} seconds)."' duration.Elapsed.TotalSeconds.ToString("N0")));  						}  					}  				}  			}
Magic Number,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,StopEventLoop,The following statement contains a magic number: if (s_eventLoopStarted)  			{    				// We cannot be called from the network thread itself' or else we will dead lock !  				Fdb.EnsureNotOnNetworkThread();    				if (Logging.On) Logging.Verbose(typeof(Fdb)' "StopEventLoop"' "Stopping network thread...");    				s_eventLoopStopRequested = true;    				var err = FdbNative.StopNetwork();  				if (err != FdbError.Success)  				{  					if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("Failed to stop event loop: {0}"' err.ToString()));  				}  				s_eventLoopStarted = false;    				var thread = s_eventLoop;  				if (thread != null && thread.IsAlive)  				{  					// BUGBUG: specs says that we need to wait for the network thread to stop gracefuly' or else data integrity may not be guaranteed...  					// We should wait for a bit' and only attempt to Abort() the thread after a timeout (30sec ? more ?)    					// keep track of how much time it took to stop...  					var duration = Stopwatch.StartNew();    					try  					{  						//TODO: replace with a ManualResetEvent that would get signaled at the end of the event loop ?  						while (thread.IsAlive && duration.Elapsed.TotalSeconds < 5)  						{  							// wait a bit...  							Thread.Sleep(250);  						}    						if (thread.IsAlive)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread has not stopped after {0} seconds. Forcing shutdown..."' duration.Elapsed.TotalSeconds.ToString("N0")));    							// Force a shutdown  							thread.Abort();    							bool stopped = thread.Join(TimeSpan.FromSeconds(30));  							//REVIEW: is this even usefull? If the thread is stuck in a native P/Invoke call' it won't get notified until it returns to managed code ...  							// => in that case' we have a zombie thread on our hands...    							if (!stopped)  							{  								if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread failed to stop after more than {0} seconds. Transaction integrity may not be guaranteed."' duration.Elapsed.TotalSeconds.ToString("N0")));  							}  						}  					}  					catch (ThreadAbortException)  					{  						// Should not happen' unless we are called from a thread that is itself being stopped ?  					}  					finally  					{  						s_eventLoop = null;  						duration.Stop();  						if (duration.Elapsed.TotalSeconds >= 20)  						{  							if (Logging.On) Logging.Warning(typeof(Fdb)' "StopEventLoop"' String.Format("The fdb network thread took a long time to stop ({0} seconds)."' duration.Elapsed.TotalSeconds.ToString("N0")));  						}  					}  				}  			}
Magic Number,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,GetChunksAsync,The following statement contains a magic number: var chunks = new List<FdbKeyRange>(count + 2);
Magic Number,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The following statement contains a magic number: const int INIT_WINDOW_SIZE = 1 << 8;
Magic Number,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The following statement contains a magic number: const int MAX_WINDOW_SIZE = 1 << 13;
Magic Number,FoundationDB.Client,System,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,EstimateCountAsync,The following statement contains a magic number: const int MIN_WINDOW_SIZE = 64;
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunInsertOperationAsync,The following statement contains a magic number: using (var trans = db.BeginTransaction(cancellationToken))  				{  					var timer = Stopwatch.StartNew();    					Func<Task> commit = async () =>  					{  #if FULL_DEBUG  						Trace.WriteLine("> commit called with " + batch.Count.ToString("N0") + " items and " + trans.Size.ToString("N0") + " bytes");  #endif    						FdbException error = null;    						// if transaction Size is bigger than Fdb.MaxTransactionSize (10MB) then commit will fail' but we will retry with a smaller batch anyway    						try  						{  							await trans.CommitAsync().ConfigureAwait(false);  						}  						catch (FdbException e)  						{ // the batch failed to commit :(  							error = e;  							//TODO: C# 6.0 will support awaits in catch blocks!  						}    						if (error != null)  						{ // we failed to commit this batch' we need to retry...    #if FULL_DEBUG  							Trace.WriteLine("> commit failed : " + error);  #endif    							if (error.Code == FdbError.TransactionTooLarge)  							{  								if (batch.Count == 1) throw new InvalidOperationException("Cannot insert one the item of the source collection because it exceeds the maximum size allowed per transaction");  							}  							else  							{  								await trans.OnErrorAsync(error.Code).ConfigureAwait(false);  							}    							int half = checked(batch.Count + 1) >> 1;  							// retry the first half  							await RetryChunk(trans' batch' 0' half' bodyAsync' bodyBlocking).ConfigureAwait(false);  							// retry the second half  							await RetryChunk(trans' batch' half' batch.Count - half' bodyAsync' bodyBlocking).ConfigureAwait(false);  						}    						// success!  						batch.Clear();  						trans.Reset();  						timer.Reset();  					};    					foreach(var item in source)  					{  						if (cancellationToken.IsCancellationRequested) break;    						// store it (in case we need to retry)  						batch.Add(item);  						++itemCount;    						if (bodyAsync != null)  						{  							await bodyAsync(item' trans);  						}  						else if (bodyBlocking != null)  						{  							bodyBlocking(item' trans);  						}    						// commit the batch if ..  						if (trans.Size >= sizeThreshold			// transaction is startting to get big...  						 || batch.Count >= batchCount			// too many items would need to be retried...  						 || timer.Elapsed.TotalSeconds >= 4		// it's getting late...  						)  						{  							await commit().ConfigureAwait(false);  							Contract.Assert(batch.Count == 0);  						}  					}    					cancellationToken.ThrowIfCancellationRequested();    					// handle the last (or only) batch  					if (batch.Count > 0)  					{  						await commit().ConfigureAwait(false);  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedInsertOperationAsync,The following statement contains a magic number: using (var trans = db.BeginTransaction(cancellationToken))  				{  					var timer = Stopwatch.StartNew();    					Func<Task> commit = async () =>  					{  #if FULL_DEBUG  						Trace.WriteLine("> commit called with " + batch.Count.ToString("N0") + " items and " + trans.Size.ToString("N0") + " bytes");  #endif    						FdbException error = null;    						// if transaction Size is bigger than Fdb.MaxTransactionSize (10MB) then commit will fail' but we will retry with a smaller batch anyway    						try  						{  							await trans.CommitAsync().ConfigureAwait(false);    							// recompute the batch count' so that we do about 4 batch per transaction  							// we observed that 'chunk.Count' items produced 'trans.Size' bytes.  							// we would like to have 'sizeThreshold' bytes' and about 8 batch per transaction  							batchCount = (int)(((long)chunk.Count * sizeThreshold) / (trans.Size * 8L));  							//Console.WriteLine("New batch size is {0}"' batchCount);  						}  						catch (FdbException e)  						{ // the batch failed to commit :(  							error = e;  							//TODO: C# 6.0 will support awaits in catch blocks!  						}    						if (error != null)  						{ // we failed to commit this batch' we need to retry...    #if FULL_DEBUG  							Trace.WriteLine("> commit failed : " + error);  #endif    							if (error.Code == FdbError.TransactionTooLarge)  							{  								if (chunk.Count == 1) throw new InvalidOperationException("Cannot insert one the item of the source collection because it exceeds the maximum size allowed per transaction");  								// reduce the size of future batches  								if (batchCount > 1) batchCount <<= 1;  							}  							else  							{  								await trans.OnErrorAsync(error.Code).ConfigureAwait(false);  							}    							int half = checked(chunk.Count + 1) >> 1;  							// retry the first half  							await RetryChunk(trans' chunk' 0' half' bodyAsync' bodyBlocking).ConfigureAwait(false);  							// retry the second half  							await RetryChunk(trans' chunk' half' chunk.Count - half' bodyAsync' bodyBlocking).ConfigureAwait(false);  						}    						// success!  						chunk.Clear();  						trans.Reset();  						timer.Reset();  					};    					int offset = 0; // offset of the current batch in the chunk    					foreach (var item in source)  					{  						if (cancellationToken.IsCancellationRequested) break;    						// store it (in case we need to retry)  						chunk.Add(item);  						++itemCount;    						if (chunk.Count - offset >= batchCount  						 || trans.Size >= sizeThreshold)  						{ // we have enough items to fill a batch    							var batch = new TSource[chunk.Count - offset];  							chunk.CopyTo(offset' batch' 0' batch.Length);  							if (bodyAsync != null)  							{  								await bodyAsync(batch' trans);  							}  							else if (bodyBlocking != null)  							{  								bodyBlocking(batch' trans);  							}  							offset += batch.Length;    							// commit the batch if ..  							if (trans.Size >= sizeThreshold			// transaction is startting to get big...  							 || timer.Elapsed.TotalSeconds >= 4)	// it's getting late...  							{  								await commit().ConfigureAwait(false);    								offset = 0;  							}  						}  					}    					cancellationToken.ThrowIfCancellationRequested();    					// handle the last (or only) batch  					if (chunk.Count > 0)  					{  						var batch = new TSource[chunk.Count - offset];  						chunk.CopyTo(offset' batch' 0' batch.Length);  						if (bodyAsync != null)  						{  							await bodyAsync(batch' trans);  						}  						else if (bodyBlocking != null)  						{  							bodyBlocking(batch' trans);  						}    						await commit().ConfigureAwait(false);  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,RunBatchedReadOperationAsync,The following statement contains a magic number: using (var iterator = source.GetEnumerator())  				{  					var totalTimer = Stopwatch.StartNew();    					using (var trans = db.BeginReadOnlyTransaction(cancellationToken))  					{  						var ctx = new BatchOperationContext()  						{  							Transaction = trans'  							Step = batchSize'  							TotalTimer = totalTimer'  							GenerationTimer = Stopwatch.StartNew()'  						};    						try  						{  							if (localInit != null)  							{ // need to initialize the state  								//TODO: maybe defer only if there are things in the source sequence?  								localValue = localInit();  								localInitialized = true;  							}    							while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  							{  								FillNextBatch<TSource>(iterator' batch' ctx.Step);    								if (batch.Count == 0)  								{  									break;  								}    								int offsetInCurrentBatch = 0;  								while (!ctx.Abort && !cancellationToken.IsCancellationRequested)  								{  									var r = Math.Min(ctx.Step' batch.Count - offsetInCurrentBatch);  									if (items == null || items.Length != r)  									{  										items = new TSource[r];  									}  									batch.CopyTo(offsetInCurrentBatch' items' 0' items.Length);    									FdbException error = null;  									try  									{  										var sw = Stopwatch.StartNew();  										if (bodyAsyncWithContextAndState != null)  										{  											localValue = await bodyAsyncWithContextAndState(items' ctx' localValue);  										}  										else if (bodyWithContextAndState != null)  										{  											localValue = bodyWithContextAndState(items' ctx' localValue);  										}  										else if (bodyAsyncWithContext != null)  										{  											await bodyAsyncWithContext(items' ctx);  										}  										else if (bodyWithContext != null)  										{  											bodyWithContext(items' ctx);  										}  										sw.Stop();    										if (!ctx.Abort)  										{  											offsetInCurrentBatch += items.Length;  											if (offsetInCurrentBatch >= batch.Count)  											{  												// scale up the batch size if everything was superquick !  												if (ctx.Cooldown > 0) ctx.Cooldown--;  												if (ctx.Cooldown <= 0 && sw.Elapsed.TotalSeconds < (5.0 - ctx.ElapsedGeneration.TotalSeconds) / 2)//REVIEW: magical number!  												{  													ctx.Step = Math.Min(ctx.Step * 2' DefaultMaximumBatchSize); //REVIEW: magical number!  													//REVIEW: magical number!  													ctx.Cooldown = 2;  												}  												break;  											}  										}  									}  									catch (Exception e)  									{  										error = e as FdbException;  										// if the callback uses task.Wait() or task.Result the exception may be wrapped in an AggregateException  										if (error == null && e is AggregateException)  										{  											error = (e as AggregateException).InnerException as FdbException;  										}  									}    									if (error != null)  									{  										if (error.Code == FdbError.PastVersion)  										{ // this generation lasted too long' we need to start a new one and try again...  											trans.Reset();  											ctx.GenerationTimer.Restart();  											ctx.Generation++;    											// scale back batch size  											if (ctx.Step > DefaultMinimumBatchSize)  											{  												ctx.Step = Math.Max(ctx.Step >> 1' DefaultMinimumBatchSize);  												//REVIEW: magical number!  												ctx.Cooldown = 10;  											}  										}  										else  										{ // the error may be retryable...  											await trans.OnErrorAsync(error.Code);  											ctx.GenerationTimer.Restart();  											ctx.Generation++;  											//REVIEW: magical number!  											if (ctx.Cooldown < 2) ctx.Cooldown = 2;    										}  									}  								}  								cancellationToken.ThrowIfCancellationRequested();    								ctx.Position += offsetInCurrentBatch;  								batch.Clear();  							}  							cancellationToken.ThrowIfCancellationRequested();  						}  						catch(Exception)  						{  							ctx.Failed = true;  							throw;  						}  						finally  						{  							if (localFinally != null && localInitialized)  							{ // we need to cleanup the state whatever happens  								if (localFinallyVoid != null)  								{  									localFinallyVoid(localValue);  								}  								else if (localFinallyWithResult != null)  								{  									result = localFinallyWithResult(localValue);  								}  							}  						}  					}  				}
Magic Number,FoundationDB.Client,Bulk,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.Bulk.cs,ExportAsync,The following statement contains a magic number: using (var tr = db.BeginReadOnlyTransaction(cancellationToken))  				{  					reset(tr);    					//TODO: make options configurable!  					var options = new FdbRangeOptions  					{  						// serial mode is optimized for a single client with maximum throughput  						Mode = FdbStreamingMode.Serial'  					};    					long count = 0;  					long chunks = 0;  					long waitForFetch = 0;    					// read the first batch  					var page = await FetchNextBatchAsync(tr' begin' end' options' reset);  					++waitForFetch;    					while (page.HasMore)  					{  						// prefetch the next one (don't wait for the task yet)  						var next = FetchNextBatchAsync(tr' FdbKeySelector.FirstGreaterThan(page.Last.Key)' end' options' reset);    						// process the current one  						if (page.Count > 0)  						{  							cancellationToken.ThrowIfCancellationRequested();  							await handler(page.Chunk' count' cancellationToken);  							++chunks;  							count += page.Count;  						}    						if (next.Status != TaskStatus.RanToCompletion) ++waitForFetch;  						page = await next;  					}    					// process the last page' if any  					if (page.Count > 0)  					{  						cancellationToken.ThrowIfCancellationRequested();  						await handler(page.Chunk' count' cancellationToken);  						++chunks;  						count += page.Count;  					}    					tr.Annotate("Exported {0} items in {1} chunks ({2:N1}% network)"' count' chunks' chunks > 0 ? (100.0 * waitForFetch / chunks) : 0.0);    					return count;  				}
Magic Number,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The following statement contains a magic number: if (selectedApiVersion < 200)  			{ // mutations were not available at this time    				if (Fdb.GetMaxApiVersion() >= 200)  				{ // but the installed client could support it  					throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations are only supported starting from API level 200. You need to select API level 200 or more at the start of your process.");  				}  				else  				{ // not supported by the local client  					throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations are only supported starting from client version 2.x. You need to update the version of the client' and select API level 200 or more at the start of your process.");  				}  			}
Magic Number,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The following statement contains a magic number: if (selectedApiVersion < 200)  			{ // mutations were not available at this time    				if (Fdb.GetMaxApiVersion() >= 200)  				{ // but the installed client could support it  					throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations are only supported starting from API level 200. You need to select API level 200 or more at the start of your process.");  				}  				else  				{ // not supported by the local client  					throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations are only supported starting from client version 2.x. You need to update the version of the client' and select API level 200 or more at the start of your process.");  				}  			}
Magic Number,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The following statement contains a magic number: if (mutation == FdbMutationType.Max || mutation == FdbMutationType.Min)  			{ // these mutations are available since v300  				if (selectedApiVersion < 300)  				{  					if (Fdb.GetMaxApiVersion() >= 300)  					{  						throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations Max and Min are only supported starting from API level 300. You need to select API level 300 or more at the start of your process.");  					}  					else  					{  						throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations Max and Min are only supported starting from client version 3.x. You need to update the version of the client' and select API level 300 or more at the start of your process..");  					}  				}  				// ok!  				return;  			}
Magic Number,FoundationDB.Client,FdbTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransaction.Snapshot.cs,EnsureMutationTypeIsSupported,The following statement contains a magic number: if (mutation == FdbMutationType.Max || mutation == FdbMutationType.Min)  			{ // these mutations are available since v300  				if (selectedApiVersion < 300)  				{  					if (Fdb.GetMaxApiVersion() >= 300)  					{  						throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations Max and Min are only supported starting from API level 300. You need to select API level 300 or more at the start of your process.");  					}  					else  					{  						throw new FdbException(FdbError.InvalidMutationType' "Atomic mutations Max and Min are only supported starting from client version 3.x. You need to update the version of the client' and select API level 300 or more at the start of your process..");  					}  				}  				// ok!  				return;  			}
Magic Number,FoundationDB.Client,FdbTransactionExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbTransactionExtensions.cs,WithReadAccessToSystemKeys,The following statement contains a magic number: trans.SetOption(Fdb.ApiVersion >= 300 ? FdbTransactionOption.ReadSystemKeys : FdbTransactionOption.AccessSystemKeys);
Magic Number,FoundationDB.Client,FdbOperationContext,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbOperationContext.cs,ExecuteInternal,The following statement contains a magic number: try  			{  				// make sure to reset everything (in case a context is reused multiple times)  				context.Committed = false;  				context.Retries = 0;  				context.BaseDuration = TimeSpan.Zero;  				context.StartedUtc = DateTime.UtcNow;  				context.Clock.Start();  				//note: we start the clock immediately' but the transaction's 5 seconde max lifetime is actually measured from the first read operation (Get' GetRange' GetReadVersion' etc...)  				// => algorithms that monitor the elapsed duration to rate limit themselves may think that the trans is older than it really is...  				// => we would need to plug into the transaction handler itself to be notified when exactly a read op starts...    				using (var trans = db.BeginTransaction(context.Mode' CancellationToken.None' context))  				{  					while (!context.Committed && !context.Cancellation.IsCancellationRequested)  					{  						FdbException e = null;  						try  						{  							// call the user provided lambda  							if (handler is Func<IFdbTransaction' Task>)  							{  								await ((Func<IFdbTransaction' Task>)handler)(trans).ConfigureAwait(false);  							}  							else if (handler is Action<IFdbTransaction>)  							{  								((Action<IFdbTransaction>)handler)(trans);  							}  							else if (handler is Func<IFdbReadOnlyTransaction' Task>)  							{  								await ((Func<IFdbReadOnlyTransaction' Task>)handler)(trans).ConfigureAwait(false);  							}  							else  							{  								throw new NotSupportedException(String.Format("Cannot execute handlers of type {0}"' handler.GetType().Name));  							}    							if (context.Abort)  							{  								break;  							}    							if (!trans.IsReadOnly)  							{ // commit the transaction  								await trans.CommitAsync().ConfigureAwait(false);  							}    							// we are done  							context.Committed = true;    							if (onDone != null)  							{  								if (onDone is Action<IFdbReadOnlyTransaction>)  								{  									((Action<IFdbReadOnlyTransaction>)onDone)(trans);  								}  								else if (onDone is Action<IFdbTransaction>)  								{  									((Action<IFdbTransaction>)onDone)(trans);  								}  								else if (onDone is Func<IFdbReadOnlyTransaction' Task>)  								{  									await ((Func<IFdbReadOnlyTransaction' Task>)onDone)(trans).ConfigureAwait(false);  								}  								else if (onDone is Func<IFdbTransaction' Task>)  								{  									await ((Func<IFdbTransaction' Task>)onDone)(trans).ConfigureAwait(false);  								}  								else  								{  									throw new NotSupportedException(String.Format("Cannot execute completion handler of type {0}"' handler.GetType().Name));  								}  							}  						}  						catch (FdbException x)  						{  							//TODO: will be able to await in catch block in C# 6 !  							e = x;  						}    						if (e != null)  						{  							if (Logging.On && Logging.IsVerbose) Logging.Verbose(String.Format(CultureInfo.InvariantCulture' "fdb: transaction {0} failed with error code {1}"' trans.Id' e.Code));  							await trans.OnErrorAsync(e.Code).ConfigureAwait(false);  							if (Logging.On && Logging.IsVerbose) Logging.Verbose(String.Format(CultureInfo.InvariantCulture' "fdb: transaction {0} can be safely retried"' trans.Id));  						}    						// update the base time for the next attempt  						context.BaseDuration = context.ElapsedTotal;  						if (context.BaseDuration.TotalSeconds >= 10)  						{  							//REVIEW: this may not be a goot idea to spam the logs with long running transactions??  							if (Logging.On) Logging.Info(String.Format(CultureInfo.InvariantCulture' "fdb WARNING: long transaction ({0:N1} sec elapsed in transaction lambda function ({1} retries' {2})"' context.BaseDuration.TotalSeconds' context.Retries' context.Committed ? "committed" : "not yet committed"));  						}    						context.Retries++;  					}  				}  				context.Cancellation.ThrowIfCancellationRequested();    				if (context.Abort)  				{  					throw new OperationCanceledException(context.Cancellation);  				}    			}  			finally  			{  				context.Clock.Stop();  				context.Dispose();  			}
Magic Number,FoundationDB.Client,FdbRangeQuery<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.ResultIterator.cs,HeadAsync,The following statement contains a magic number: var options = new FdbRangeOptions()  			{  				Limit = single ? 2 : 1'  				TargetBytes = 0'  				Mode = FdbStreamingMode.Exact'  				Reverse = this.Reversed  			};
Magic Number,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The following statement contains a magic number: if (this.Begin != bounds.Begin || this.End != bounds.End)  				{  					//TODO: find a better way to do this!  					var keys = await this.Transaction.GetKeysAsync(new[] { bounds.Begin' this.Begin' bounds.End' this.End }).ConfigureAwait(false);    					var min = keys[0] >= keys[1] ? keys[0] : keys[1];  					var max = keys[2] <= keys[3] ? keys[2] : keys[3];  					if (min >= max) return false;	// range is empty    					// rewrite the initial selectors with the bounded keys  					this.Begin = FdbKeySelector.FirstGreaterOrEqual(min);  					this.End = FdbKeySelector.FirstGreaterOrEqual(max);  				}
Magic Number,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The following statement contains a magic number: if (this.Begin != bounds.Begin || this.End != bounds.End)  				{  					//TODO: find a better way to do this!  					var keys = await this.Transaction.GetKeysAsync(new[] { bounds.Begin' this.Begin' bounds.End' this.End }).ConfigureAwait(false);    					var min = keys[0] >= keys[1] ? keys[0] : keys[1];  					var max = keys[2] <= keys[3] ? keys[2] : keys[3];  					if (min >= max) return false;	// range is empty    					// rewrite the initial selectors with the bounded keys  					this.Begin = FdbKeySelector.FirstGreaterOrEqual(min);  					this.End = FdbKeySelector.FirstGreaterOrEqual(max);  				}
Magic Number,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The following statement contains a magic number: if (this.Begin != bounds.Begin || this.End != bounds.End)  				{  					//TODO: find a better way to do this!  					var keys = await this.Transaction.GetKeysAsync(new[] { bounds.Begin' this.Begin' bounds.End' this.End }).ConfigureAwait(false);    					var min = keys[0] >= keys[1] ? keys[0] : keys[1];  					var max = keys[2] <= keys[3] ? keys[2] : keys[3];  					if (min >= max) return false;	// range is empty    					// rewrite the initial selectors with the bounded keys  					this.Begin = FdbKeySelector.FirstGreaterOrEqual(min);  					this.End = FdbKeySelector.FirstGreaterOrEqual(max);  				}
Magic Number,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,OnFirstAsync,The following statement contains a magic number: if (this.Begin != bounds.Begin || this.End != bounds.End)  				{  					//TODO: find a better way to do this!  					var keys = await this.Transaction.GetKeysAsync(new[] { bounds.Begin' this.Begin' bounds.End' this.End }).ConfigureAwait(false);    					var min = keys[0] >= keys[1] ? keys[0] : keys[1];  					var max = keys[2] <= keys[3] ? keys[2] : keys[3];  					if (min >= max) return false;	// range is empty    					// rewrite the initial selectors with the bounded keys  					this.Begin = FdbKeySelector.FirstGreaterOrEqual(min);  					this.End = FdbKeySelector.FirstGreaterOrEqual(max);  				}
Magic Number,FoundationDB.Client,FdbKeyRange,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKeyRange.cs,GetHashCode,The following statement contains a magic number: return ((h1 << 5) + h1) ^ h2;
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following statement contains a magic number: if (key.Count > 1)  			{  				byte c = key[0];  				//OPTIMIZE: maybe we need a lookup table  				if (c <= 28 || c == 32 || c == 33 || c == 48 || c == 49 || c >= 254)  				{ // it could be a tuple...  					try  					{  						IFdbTuple tuple = null;  						string suffix = null;  						bool skip = false;    						try  						{  							switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}  						}  						catch (Exception e)  						{  							suffix = null;  							skip = !(e is FormatException || e is ArgumentOutOfRangeException);  						}    						if (tuple == null && !skip)  						{ // attempt a regular decoding  							//***README*** if you break under here' see README in the last catch() block  							tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key);  						}    						if (tuple != null) return tuple.ToString() + suffix;  					}  					catch (Exception)  					{  						//README: If Visual Studio is breaking inside some Tuple parsing method somewhere inside this try/catch'  						// this is because your debugger is configured to automatically break on thrown exceptions of type FormatException' ArgumentException' or InvalidOperation.  						// Unfortunately' there isn't much you can do except unchecking "break when this exception type is thrown". If you know a way to disable locally this behaviour' please fix this!  						// => only other option would be to redesign the parsing of tuples as a TryParseXXX() that does not throw' OR to have a VerifyTuple() methods that only checks for validity....  					}  				}  			}
Magic Number,FoundationDB.Client,FdbSubspace,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Subspaces\FdbSubspace.cs,BoundCheck,The following statement contains a magic number: if (allowSystemKeys && key.Count > 0 && key[0] == 255) return key;
Magic Number,FoundationDB.Client,DynamicKeyEncoderBase,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\DynamicKeyEncoderBase.cs,ToRange,The following statement contains a magic number: var writer = new SliceWriter(prefix' 16);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(key' 2);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(FdbTuple.Create<T1' T2>(item1' item2)' 2);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeKey,The following statement contains a magic number: return DecodeComposite(encoded' 2);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(key' 3);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(FdbTuple.Create<T1' T2' T3>(item1' item2' item3)' 3);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeKey,The following statement contains a magic number: return DecodeComposite(encoded' 3);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(key' 4);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(FdbTuple.Create<T1' T2' T3' T4>(item1' item2' item3' item4)' 4);
Magic Number,FoundationDB.Client,CompositeKeyEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeKey,The following statement contains a magic number: return DecodeComposite(encoded' 4);
Magic Number,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return this.Encoder.EncodeComposite(new FdbTuple<T1' T2' T3>(value1' value2' default(T3))' 2);
Magic Number,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(value' 2);
Magic Number,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeKey,The following statement contains a magic number: return DecodeComposite(encoded' 2);
Magic Number,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return this.Encoder.EncodeComposite(new FdbTuple<T1' T2' T3' T4>(value1' value2' default(T3)' default(T4))' 2);
Magic Number,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeKey,The following statement contains a magic number: return EncodeComposite(value' 2);
Magic Number,FoundationDB.Client,PairEncoder,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeKey,The following statement contains a magic number: return DecodeComposite(encoded' 2);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: if (count >= 2) m_codec2.EncodeOrderedSelfTerm(ref writer' items.Item2);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: if (count >= 2) key2 = m_codec2.DecodeOrderedSelfTerm(ref reader);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: Contract.Requires(count > 0 && count <= 3);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: if (count >= 2) m_codec2.EncodeOrderedSelfTerm(ref writer' items.Item2);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: if (count >= 3) m_codec3.EncodeOrderedSelfTerm(ref writer' items.Item3);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: if (count >= 2) key2 = m_codec2.DecodeOrderedSelfTerm(ref reader);
Magic Number,FoundationDB.Client,CodecCompositeKeyEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: if (count >= 3) key3 = m_codec3.DecodeOrderedSelfTerm(ref reader);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: switch (items)  					{  						case 2: return key.ToSlice();  						case 1: return FdbTuple.EncodeKey<T1>(key.Item1);  						default: throw new ArgumentOutOfRangeException("items"' items' "Item count must be either 1 or 2");  					}
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: if (items < 1 || items > 2) throw new ArgumentOutOfRangeException("items"' items' "Item count must be either 1 or 2");
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: switch (items)  					{  						case 3: return key.ToSlice();  						case 2: return FdbTuple.EncodeKey<T1' T2>(key.Item1' key.Item2);  						case 1: return FdbTuple.EncodeKey<T1>(key.Item1);  						default: throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 3");  					}
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: switch (items)  					{  						case 3: return key.ToSlice();  						case 2: return FdbTuple.EncodeKey<T1' T2>(key.Item1' key.Item2);  						case 1: return FdbTuple.EncodeKey<T1>(key.Item1);  						default: throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 3");  					}
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: if (items < 1 || items > 3) throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 3");
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: switch (items)  					{  						case 4: return key.ToSlice();  						case 3: return FdbTuple.EncodeKey(key.Item1' key.Item2' key.Item3);  						case 2: return FdbTuple.EncodeKey(key.Item1' key.Item2);  						case 1: return FdbTuple.EncodeKey(key.Item1);  						default: throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 4");  					}
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: switch (items)  					{  						case 4: return key.ToSlice();  						case 3: return FdbTuple.EncodeKey(key.Item1' key.Item2' key.Item3);  						case 2: return FdbTuple.EncodeKey(key.Item1' key.Item2);  						case 1: return FdbTuple.EncodeKey(key.Item1);  						default: throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 4");  					}
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,EncodeComposite,The following statement contains a magic number: switch (items)  					{  						case 4: return key.ToSlice();  						case 3: return FdbTuple.EncodeKey(key.Item1' key.Item2' key.Item3);  						case 2: return FdbTuple.EncodeKey(key.Item1' key.Item2);  						case 1: return FdbTuple.EncodeKey(key.Item1);  						default: throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 4");  					}
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: if (items < 1 || items > 4) throw new ArgumentOutOfRangeException("items"' items' "Item count must be between 1 and 4");
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3' T4>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)'  						items >= 4 ? t.Get<T4>(3) : default(T4)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3' T4>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)'  						items >= 4 ? t.Get<T4>(3) : default(T4)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3' T4>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)'  						items >= 4 ? t.Get<T4>(3) : default(T4)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3' T4>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)'  						items >= 4 ? t.Get<T4>(3) : default(T4)  					);
Magic Number,FoundationDB.Client,TupleCompositeEncoder<T1;T2;T3;T4>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\TypeSystem\Encoders\KeyValueEncoders.cs,DecodeComposite,The following statement contains a magic number: return FdbTuple.Create<T1' T2' T3' T4>(  						t.Get<T1>(0)'  						items >= 2 ? t.Get<T2>(1) : default(T2)'  						items >= 3 ? t.Get<T3>(2) : default(T3)'  						items >= 4 ? t.Get<T4>(3) : default(T4)  					);
Magic Number,FoundationDB.Client,SlicePairComparer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SlicePairComparer.cs,GetHashCode,The following statement contains a magic number: switch(m_mode)  			{  				case KEY_ONLY: return obj.Key.GetHashCode();  				case VALUE_ONLY: return obj.Value.GetHashCode();  				default: return (obj.Key.GetHashCode() * 31) + obj.Value.GetHashCode();  			}
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,Align,The following statement contains a magic number: const int ALIGNMENT = 16;
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 2);
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 4);
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 8);
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,NextPowerOfTwo,The following statement contains a magic number: x |= (x >> 16);
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ComputeHashCodeUnsafe,The following statement contains a magic number: uint h = 2166136261;
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,ComputeHashCodeUnsafe,The following statement contains a magic number: while (n-- > 0)  			{  				h = (h ^ bytes[p++]) * 16777619; // FNV1 32 prime  			}
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,SameBytesUnsafe,The following statement contains a magic number: if (count <= 8)  			{  				while (count-- > 0)  				{  					if (left[leftOffset++] != right[rightOffset++]) return false;  				}  				return true;  			}
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CopyBytesUnsafe,The following statement contains a magic number: if (count <= 8)  			{ // for very small keys' the cost of pinning and marshalling may be to high    				while (count-- > 0)  				{  					dst[dstOffset++] = src[srcOffset++];  				}  			}  			else if (object.ReferenceEquals(dst' src))  			{ // In cases where the keys are backed by the same buffer' we don't need to pin the same buffer twice    				unsafe  				{  					fixed (byte* ptr = dst)  					{  						MoveMemoryUnsafe(ptr + dstOffset' ptr + srcOffset' count);  					}  				}  			}  			else  			{  				unsafe  				{  					fixed (byte* pDst = dst)  					fixed (byte* pSrc = src)  					{  						MoveMemoryUnsafe(pDst + dstOffset' pSrc + srcOffset' count);  					}  				}  			}
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,CopyBytesUnsafe,The following statement contains a magic number: if (count <= 8)  			{  				while (count-- > 0)  				{  					dst[dstOffset++] = *src++;  				}  			}  			else  			{  				fixed (byte* ptr = dst)  				{  					MoveMemoryUnsafe(ptr + dstOffset' src' count);  				}  			}
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,SetBytes,The following statement contains a magic number: if (count <= 8)  			{ // for very small keys' the cost of pinning and marshalling may be to high    				while (count-- > 0)  				{  					bytes[offset++] = value;  				}  			}  			else  			{  				unsafe  				{  					fixed (byte* ptr = bytes)  					{  						SetMemoryUnsafe(ptr + offset' value' count);  					}  				}  			}
Magic Number,FoundationDB.Client,SliceHelpers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceHelpers.cs,SetBytes,The following statement contains a magic number: if (count <= 8)  			{ // for very small keys' the cost of pinning and marshalling may be to high    				while (count-- > 0)  				{  					*bytes++ = value;  				}  			}  			else  			{  				SetMemoryUnsafe(bytes' value' count);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Uuid64,The following statement contains a magic number: if (value.Length != 8) throw new ArgumentException("Value must be 8 bytes long"' "value");
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Uuid64,The following statement contains a magic number: if (value.Count != 8) throw new ArgumentException("Value must be 8 bytes long"' "value");
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following statement contains a magic number: if (s.Length <= 11)  			{  				return TryDecode62(s.ToCharArray()' out result);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,ToByteArray,The following statement contains a magic number: Contract.Assert(bytes != null && bytes.Length == 8);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,GetHashCode,The following statement contains a magic number: return ((int)m_value) ^ (int)(m_value >> 32);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexToLowerChar,The following statement contains a magic number: return a > 9 ? (char)(a - 10 + 'a') : (char)(a + '0');
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexToLowerChar,The following statement contains a magic number: return a > 9 ? (char)(a - 10 + 'a') : (char)(a + '0');
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[0] = HexToLowerChar(a >> 28);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[1] = HexToLowerChar(a >> 24);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[2] = HexToLowerChar(a >> 20);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[2] = HexToLowerChar(a >> 20);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[3] = HexToLowerChar(a >> 16);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[3] = HexToLowerChar(a >> 16);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[4] = HexToLowerChar(a >> 12);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[4] = HexToLowerChar(a >> 12);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[5] = HexToLowerChar(a >> 8);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[5] = HexToLowerChar(a >> 8);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[6] = HexToLowerChar(a >> 4);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[6] = HexToLowerChar(a >> 4);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: ptr[7] = HexToLowerChar(a);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToLowerChars,The following statement contains a magic number: return ptr + 8;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexToUpperChar,The following statement contains a magic number: return a > 9 ? (char)(a - 10 + 'A') : (char)(a + '0');
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexToUpperChar,The following statement contains a magic number: return a > 9 ? (char)(a - 10 + 'A') : (char)(a + '0');
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[0] = HexToUpperChar(a >> 28);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[1] = HexToUpperChar(a >> 24);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[2] = HexToUpperChar(a >> 20);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[2] = HexToUpperChar(a >> 20);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[3] = HexToUpperChar(a >> 16);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[3] = HexToUpperChar(a >> 16);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[4] = HexToUpperChar(a >> 12);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[4] = HexToUpperChar(a >> 12);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[5] = HexToUpperChar(a >> 8);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[5] = HexToUpperChar(a >> 8);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[6] = HexToUpperChar(a >> 4);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[6] = HexToUpperChar(a >> 4);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: ptr[7] = HexToUpperChar(a);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,HexsToUpperChars,The following statement contains a magic number: return ptr + 8;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode16,The following statement contains a magic number: int size = 16 + (separator ? 1 : 0) + (quotes ? 2 : 0);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode16,The following statement contains a magic number: int size = 16 + (separator ? 1 : 0) + (quotes ? 2 : 0);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode16,The following statement contains a magic number: char* buffer = stackalloc char[24];
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode16,The following statement contains a magic number: ptr = upper 		  				? HexsToUpperChars(ptr' (int)(value >> 32))  				: HexsToLowerChars(ptr' (int)(value >> 32));
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode16,The following statement contains a magic number: ptr = upper 		  				? HexsToUpperChars(ptr' (int)(value >> 32))  				: HexsToLowerChars(ptr' (int)(value >> 32));
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,CharToHex,The following statement contains a magic number: if (c <= '9')  			{  				return c >= '0' ? (c - 48) : INVALID_CHAR;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,CharToHex,The following statement contains a magic number: if (c <= 'F')  			{  				return c >= 'A' ? (c - 55) : INVALID_CHAR;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,CharToHex,The following statement contains a magic number: if (c <= 'f')  			{  				return c >= 'a' ? (c - 87) : INVALID_CHAR;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryCharsToHexs,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				int a = CharToHex(chars[offset++]);  				if (a == INVALID_CHAR)  				{  					result = 0;  					return false;  				}  				word = (word << 4) | a;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryCharsToHexs,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				int a = CharToHex(chars[offset++]);  				if (a == INVALID_CHAR)  				{  					result = 0;  					return false;  				}  				word = (word << 4) | a;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode16,The following statement contains a magic number: if ((!separator || chars[offset + 8] == '-')  				&& TryCharsToHexs(chars' offset' out a)   				&& TryCharsToHexs(chars' offset + (separator ? 9 : 8)' out b))  			{  				result = ((ulong)a << 32) | (ulong)b;  				return true;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode16,The following statement contains a magic number: if ((!separator || chars[offset + 8] == '-')  				&& TryCharsToHexs(chars' offset' out a)   				&& TryCharsToHexs(chars' offset + (separator ? 9 : 8)' out b))  			{  				result = ((ulong)a << 32) | (ulong)b;  				return true;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode16,The following statement contains a magic number: if ((!separator || chars[offset + 8] == '-')  				&& TryCharsToHexs(chars' offset' out a)   				&& TryCharsToHexs(chars' offset + (separator ? 9 : 8)' out b))  			{  				result = ((ulong)a << 32) | (ulong)b;  				return true;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode16,The following statement contains a magic number: if ((!separator || chars[offset + 8] == '-')  				&& TryCharsToHexs(chars' offset' out a)   				&& TryCharsToHexs(chars' offset + (separator ? 9 : 8)' out b))  			{  				result = ((ulong)a << 32) | (ulong)b;  				return true;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode62,The following statement contains a magic number: const int MAX_SIZE = 11;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode62,The following statement contains a magic number: unsafe  			{  				// The maximum size is 11 chars' but we will allocate 64 bytes on the stack to keep alignment.  				char* chars = stackalloc char[16];  				char[] bc = Base62LexicographicChars;    				// start from the last "digit"  				char* pc = chars + (MAX_SIZE - 1);    				while (pc >= chars)  				{  					ulong r = value % 62L;  					value /= 62L;  					*pc-- = bc[(int)r];  					if (!padded && value == 0)  					{ // the rest will be all zeroes  						break;  					}  				}    				++pc;  				int count = MAX_SIZE - (int)(pc - chars);  				Contract.Assert(count > 0 && count <= 11);  				return count <= 0 ? String.Empty : new string(pc' 0' count);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Encode62,The following statement contains a magic number: unsafe  			{  				// The maximum size is 11 chars' but we will allocate 64 bytes on the stack to keep alignment.  				char* chars = stackalloc char[16];  				char[] bc = Base62LexicographicChars;    				// start from the last "digit"  				char* pc = chars + (MAX_SIZE - 1);    				while (pc >= chars)  				{  					ulong r = value % 62L;  					value /= 62L;  					*pc-- = bc[(int)r];  					if (!padded && value == 0)  					{ // the rest will be all zeroes  						break;  					}  				}    				++pc;  				int count = MAX_SIZE - (int)(pc - chars);  				Contract.Assert(count > 0 && count <= 11);  				return count <= 0 ? String.Empty : new string(pc' 0' count);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode62,The following statement contains a magic number: if (s == null || s.Length == 0 || s.Length > 11)  			{ // fail: too small/too big  				value = 0;  				return false;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode62,The following statement contains a magic number: while (p >= 0)  			{  				// read digit  				int a = s[p];  				// decode base62 digit  				a = a >= 32 && a < 128 ? bv[a - 32] : -1;  				if (a == -1)  				{ // fail: invalid character  					value = 0;  					return false;  				}  				// accumulate' while checking for overflow  				acc = checked(acc + ((ulong)a * factor));  				if (p-- > 0) factor *= 62;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode62,The following statement contains a magic number: while (p >= 0)  			{  				// read digit  				int a = s[p];  				// decode base62 digit  				a = a >= 32 && a < 128 ? bv[a - 32] : -1;  				if (a == -1)  				{ // fail: invalid character  					value = 0;  					return false;  				}  				// accumulate' while checking for overflow  				acc = checked(acc + ((ulong)a * factor));  				if (p-- > 0) factor *= 62;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode62,The following statement contains a magic number: while (p >= 0)  			{  				// read digit  				int a = s[p];  				// decode base62 digit  				a = a >= 32 && a < 128 ? bv[a - 32] : -1;  				if (a == -1)  				{ // fail: invalid character  					value = 0;  					return false;  				}  				// accumulate' while checking for overflow  				acc = checked(acc + ((ulong)a * factor));  				if (p-- > 0) factor *= 62;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryDecode62,The following statement contains a magic number: while (p >= 0)  			{  				// read digit  				int a = s[p];  				// decode base62 digit  				a = a >= 32 && a < 128 ? bv[a - 32] : -1;  				if (a == -1)  				{ // fail: invalid character  					value = 0;  					return false;  				}  				// accumulate' while checking for overflow  				acc = checked(acc + ((ulong)a * factor));  				if (p-- > 0) factor *= 62;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: Contract.Requires(buffer != null && offset >= 0 && offset + 7 < buffer.Length);
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: ulong res = buffer[offset + 7];
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 6]) << 8;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 6]) << 8;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 5]) << 16;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 5]) << 16;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 4]) << 24;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 4]) << 24;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 3]) << 32;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 3]) << 32;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 2]) << 40;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 2]) << 40;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 1]) << 48;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: res |= ((ulong)buffer[offset + 0]) << 56;
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* ptr = (byte*)&tmp;  				// big endian  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				tmp = *((ulong*)src);  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{ // Intel ?  				byte* src = (byte*)&value;  				ptr[0] = src[7];  				ptr[1] = src[6];  				ptr[2] = src[5];  				ptr[3] = src[4];  				ptr[4] = src[3];  				ptr[5] = src[2];  				ptr[6] = src[1];  				ptr[7] = src[0];  			}  			else  			{ // ARM ?  				*((ulong*)ptr) = value;  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Convert,The following statement contains a magic number: if (input.Count == 16)  			{  				unsafe  				{  					fixed (byte* buf = input.Array)  					{  						return Read(buf + input.Offset);  					}  				}  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Read,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* ptr = (byte*)&tmp;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* ptr = (long*)&tmp;  				ptr[0] = *(long*)(src);  				ptr[1] = *(long*)(src + 8);  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,Write,The following statement contains a magic number: if (BitConverter.IsLittleEndian)  			{  				byte* src = (byte*)&value;    				// Data1: 32 bits' must swap  				ptr[0] = src[3];  				ptr[1] = src[2];  				ptr[2] = src[1];  				ptr[3] = src[0];  				// Data2: 16 bits' must swap  				ptr[4] = src[5];  				ptr[5] = src[4];  				// Data3: 16 bits' must swap  				ptr[6] = src[7];  				ptr[7] = src[6];  				// Data4: 64 bits' no swap required  				*(long*)(ptr + 8) = *(long*)(src + 8);  			}  			else  			{  				long* src = (long*)&value;  				*(long*)(ptr) = src[0];  				*(long*)(ptr + 8) = src[1];  			}
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,ToByteArray,The following statement contains a magic number: var res = new byte[16];
Magic Number,FoundationDB.Client,Uuid128,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid128.cs,ToSlice,The following statement contains a magic number: return new Slice(ToByteArray()' 0' 16);
Magic Number,FoundationDB.Client,SliceListStream,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceListStream.cs,Read,The following statement contains a magic number: while (count > 0)  			{  				if (m_offsetInCurrentSlice >= m_slices[m_indexOfCurrentSlice].Count && !AdvanceToNextSlice())  				{  					break;  				}    				var slice = m_slices[m_indexOfCurrentSlice];    				int remaining = Math.Min(slice.Count - m_offsetInCurrentSlice' count);  				if (remaining <= 0) return 0;    				int pos = m_offsetInCurrentSlice;  				int start = slice.Offset + pos;    				if (remaining <= 8)  				{ // too small' copy it ourselves  					int n = remaining;  					while (n-- > 0)  					{  						buffer[offset + n] = slice.Array[start + n];  					}  				}  				else  				{ // large enough  					Buffer.BlockCopy(slice.Array' start' buffer' offset' remaining);  				}    				m_offsetInCurrentSlice += remaining;  				m_position += remaining;  				offset += remaining;  				read += remaining;  				count -= remaining;  			}
Magic Number,FoundationDB.Client,SliceStream,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceStream.cs,Read,The following statement contains a magic number: if (remaining <= 8)  			{ // too small' copy it ourselves  				int n = remaining;  				while (n-- > 0)  				{  					buffer[offset + n] = m_slice.Array[start + n];  				}  			}  			else  			{ // large enough  				Buffer.BlockCopy(m_slice.Array' start' buffer' offset' remaining);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Slice,The following statement contains a magic number: var tmp = new byte[256];
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt16,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				else  				{  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt16,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				else  				{  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt16,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				else  				{  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed16,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)  				}'  				0'  				2  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed16,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)  				}'  				0'  				2  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt16,The following statement contains a magic number: if (value <= 255)  			{  				return Slice.FromByte((byte)value);  			}  			else  			{  				return FromFixedU16(value);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU16,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)  				}'  				0'  				2  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU16,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)  				}'  				0'  				2  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU16BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU16BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromVarint16,The following statement contains a magic number: if (value < 128)  			{  				return FromByte((byte)value);  			}  			else  			{  				var writer = new SliceWriter(3);  				writer.WriteVarint16(value);  				return writer.ToSlice();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromVarint16,The following statement contains a magic number: if (value < 128)  			{  				return FromByte((byte)value);  			}  			else  			{  				var writer = new SliceWriter(3);  				writer.WriteVarint16(value);  				return writer.ToSlice();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt32,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				if (value <= 65535)  				{  					//TODO: possible micro optimization is for values like 0x100' 0x201' 0x1413 or 0x4342' where we could use 2 consecutive bytes in the ByteSprite'  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt32,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				if (value <= 65535)  				{  					//TODO: possible micro optimization is for values like 0x100' 0x201' 0x1413 or 0x4342' where we could use 2 consecutive bytes in the ByteSprite'  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt32,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				if (value <= 65535)  				{  					//TODO: possible micro optimization is for values like 0x100' 0x201' 0x1413 or 0x4342' where we could use 2 consecutive bytes in the ByteSprite'  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromInt32,The following statement contains a magic number: if (value >= 0)  			{  				if (value <= 255)  				{  					return Slice.FromByte((byte)value);  				}  				if (value <= 65535)  				{  					//TODO: possible micro optimization is for values like 0x100' 0x201' 0x1413 or 0x4342' where we could use 2 consecutive bytes in the ByteSprite'  					return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt32,The following statement contains a magic number: if (value <= 255)  			{  				return Slice.FromByte((byte)value);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt32,The following statement contains a magic number: if (value <= 65535)  			{  				return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt32,The following statement contains a magic number: if (value <= 65535)  			{  				return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt32,The following statement contains a magic number: if (value <= 65535)  			{  				return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU32BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				4  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromVarint32,The following statement contains a magic number: if (value < 128)  			{  				return FromByte((byte)value);  			}  			else  			{  				var writer = new SliceWriter(5);  				writer.WriteVarint32(value);  				return writer.ToSlice();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromVarint32,The following statement contains a magic number: if (value < 128)  			{  				return FromByte((byte)value);  			}  			else  			{  				var writer = new SliceWriter(5);  				writer.WriteVarint32(value);  				return writer.ToSlice();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixed64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= 255)  			{  				return Slice.FromByte((byte)value);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= 65535)  			{  				return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= 65535)  			{  				return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= 65535)  			{  				return new Slice(new byte[] { (byte)value' (byte)(value >> 8) }' 0' 2);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= uint.MaxValue)  			{  				return new Slice(  					new byte[]  					{  						(byte)value'  						(byte)(value >> 8)'  						(byte)(value >> 16)'  						(byte)(value >> 24)  					}'  					0'  					4  				);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= uint.MaxValue)  			{  				return new Slice(  					new byte[]  					{  						(byte)value'  						(byte)(value >> 8)'  						(byte)(value >> 16)'  						(byte)(value >> 24)  					}'  					0'  					4  				);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= uint.MaxValue)  			{  				return new Slice(  					new byte[]  					{  						(byte)value'  						(byte)(value >> 8)'  						(byte)(value >> 16)'  						(byte)(value >> 24)  					}'  					0'  					4  				);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromUInt64,The following statement contains a magic number: if (value <= uint.MaxValue)  			{  				return new Slice(  					new byte[]  					{  						(byte)value'  						(byte)(value >> 8)'  						(byte)(value >> 16)'  						(byte)(value >> 24)  					}'  					0'  					4  				);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)value'  					(byte)(value >> 8)'  					(byte)(value >> 16)'  					(byte)(value >> 24)'  					(byte)(value >> 32)'  					(byte)(value >> 40)'  					(byte)(value >> 48)'  					(byte)(value >> 56)  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromFixedU64BE,The following statement contains a magic number: return new Slice(  				new byte[]  				{  					(byte)(value >> 56)'  					(byte)(value >> 48)'  					(byte)(value >> 40)'  					(byte)(value >> 32)'  					(byte)(value >> 24)'  					(byte)(value >> 16)'  					(byte)(value >> 8)'  					(byte)value  				}'  				0'  				8  			);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromVarint64,The following statement contains a magic number: if (value < 128)  			{  				return FromByte((byte)value);  			}  			else  			{  				var writer = new SliceWriter(10);  				writer.WriteVarint64(value);  				return writer.ToSlice();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromVarint64,The following statement contains a magic number: if (value < 128)  			{  				return FromByte((byte)value);  			}  			else  			{  				var writer = new SliceWriter(10);  				writer.WriteVarint64(value);  				return writer.ToSlice();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromChar,The following statement contains a magic number: if (value < 128)  			{ // ASCII  				return Slice.FromByte((byte)value);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromChar,The following statement contains a magic number: var tmp = new byte[8];
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: int x = c - 48;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x < 10) return x;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x >= 17 && x <= 42) return x - 7;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x >= 17 && x <= 42) return x - 7;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x >= 17 && x <= 42) return x - 7;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x >= 49 && x <= 74) return x - 39;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x >= 49 && x <= 74) return x - 39;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,NibbleToDecimal,The following statement contains a magic number: if (x >= 49 && x <= 74) return x - 39;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromHexa,The following statement contains a magic number: for (int i = 0; i < hexaString.Length; i += 2)  			{  				buffer[i >> 1] = (byte) ((NibbleToDecimal(hexaString[i]) << 4) | NibbleToDecimal(hexaString[i + 1]));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,FromHexa,The following statement contains a magic number: for (int i = 0; i < hexaString.Length; i += 2)  			{  				buffer[i >> 1] = (byte) ((NibbleToDecimal(hexaString[i]) << 4) | NibbleToDecimal(hexaString[i + 1]));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: var sb = new StringBuilder(n * 2);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 87)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: var sb = new StringBuilder(n * (sep == '\0' ? 2 : 3));
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: var sb = new StringBuilder(n * (sep == '\0' ? 2 : 3));
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				if (sep != '\0' && sb.Length > 0) sb.Append(sep);  				byte b = buffer[p++];  				int x = b >> 4;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  				x = b & 0xF;  				sb.Append((char)(x + (x < 10 ? 48 : 55)));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The following statement contains a magic number: if (sb == null) sb = new StringBuilder(count + 16);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The following statement contains a magic number: foreach(var c in encoding.GetChars(buffer' offset' count))  			{  				if ((c >= ' ' && c <= '~') || (c >= 880 && c <= 2047) || (c >= 12352 && c <= 12591))  					sb.Append(c);  				else if (c == '\n')  					sb.Append(@"\n");  				else if (c == '\r')  					sb.Append(@"\r");  				else if (c == '\t')  					sb.Append(@"\t");  				else if (c > 127)  					sb.Append(@"\u").Append(((int)c).ToString("x4"' CultureInfo.InvariantCulture));  				else // pas clean!  					sb.Append(@"\x").Append(((int)c).ToString("x2"' CultureInfo.InvariantCulture));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The following statement contains a magic number: foreach(var c in encoding.GetChars(buffer' offset' count))  			{  				if ((c >= ' ' && c <= '~') || (c >= 880 && c <= 2047) || (c >= 12352 && c <= 12591))  					sb.Append(c);  				else if (c == '\n')  					sb.Append(@"\n");  				else if (c == '\r')  					sb.Append(@"\r");  				else if (c == '\t')  					sb.Append(@"\t");  				else if (c > 127)  					sb.Append(@"\u").Append(((int)c).ToString("x4"' CultureInfo.InvariantCulture));  				else // pas clean!  					sb.Append(@"\x").Append(((int)c).ToString("x2"' CultureInfo.InvariantCulture));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The following statement contains a magic number: foreach(var c in encoding.GetChars(buffer' offset' count))  			{  				if ((c >= ' ' && c <= '~') || (c >= 880 && c <= 2047) || (c >= 12352 && c <= 12591))  					sb.Append(c);  				else if (c == '\n')  					sb.Append(@"\n");  				else if (c == '\r')  					sb.Append(@"\r");  				else if (c == '\t')  					sb.Append(@"\t");  				else if (c > 127)  					sb.Append(@"\u").Append(((int)c).ToString("x4"' CultureInfo.InvariantCulture));  				else // pas clean!  					sb.Append(@"\x").Append(((int)c).ToString("x2"' CultureInfo.InvariantCulture));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The following statement contains a magic number: foreach(var c in encoding.GetChars(buffer' offset' count))  			{  				if ((c >= ' ' && c <= '~') || (c >= 880 && c <= 2047) || (c >= 12352 && c <= 12591))  					sb.Append(c);  				else if (c == '\n')  					sb.Append(@"\n");  				else if (c == '\r')  					sb.Append(@"\r");  				else if (c == '\t')  					sb.Append(@"\t");  				else if (c > 127)  					sb.Append(@"\u").Append(((int)c).ToString("x4"' CultureInfo.InvariantCulture));  				else // pas clean!  					sb.Append(@"\x").Append(((int)c).ToString("x2"' CultureInfo.InvariantCulture));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,EscapeString,The following statement contains a magic number: foreach(var c in encoding.GetChars(buffer' offset' count))  			{  				if ((c >= ' ' && c <= '~') || (c >= 880 && c <= 2047) || (c >= 12352 && c <= 12591))  					sb.Append(c);  				else if (c == '\n')  					sb.Append(@"\n");  				else if (c == '\r')  					sb.Append(@"\r");  				else if (c == '\t')  					sb.Append(@"\t");  				else if (c > 127)  					sb.Append(@"\u").Append(((int)c).ToString("x4"' CultureInfo.InvariantCulture));  				else // pas clean!  					sb.Append(@"\x").Append(((int)c).ToString("x2"' CultureInfo.InvariantCulture));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (n >= 3 && buffer[p] == 0xEF && buffer[p + 1] == 0xBB && buffer[p + 2] == 0xBF)  			{ // this is supposed to be an UTF-8 string  				return EscapeString(new StringBuilder(n).Append('\'')' buffer' p + 3' n - 3' Encoding.UTF8).Append('\'').ToString();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (n >= 3 && buffer[p] == 0xEF && buffer[p + 1] == 0xBB && buffer[p + 2] == 0xBF)  			{ // this is supposed to be an UTF-8 string  				return EscapeString(new StringBuilder(n).Append('\'')' buffer' p + 3' n - 3' Encoding.UTF8).Append('\'').ToString();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (n >= 3 && buffer[p] == 0xEF && buffer[p + 1] == 0xBB && buffer[p + 2] == 0xBF)  			{ // this is supposed to be an UTF-8 string  				return EscapeString(new StringBuilder(n).Append('\'')' buffer' p + 3' n - 3' Encoding.UTF8).Append('\'').ToString();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (n >= 3 && buffer[p] == 0xEF && buffer[p + 1] == 0xBB && buffer[p + 2] == 0xBF)  			{ // this is supposed to be an UTF-8 string  				return EscapeString(new StringBuilder(n).Append('\'')' buffer' p + 3' n - 3' Encoding.UTF8).Append('\'').ToString();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (n >= 2)  			{  				// look for JSON objets or arrays  				if ((buffer[p] == '{' && buffer[p + n - 1] == '}') || (buffer[p] == '[' && buffer[p + n - 1] == ']'))  				{  					return EscapeString(new StringBuilder(n + 16)' buffer' p' n' Encoding.UTF8).ToString();  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (n >= 2)  			{  				// look for JSON objets or arrays  				if ((buffer[p] == '{' && buffer[p + n - 1] == '}') || (buffer[p] == '[' && buffer[p + n - 1] == ']'))  				{  					return EscapeString(new StringBuilder(n + 16)' buffer' p' n' Encoding.UTF8).ToString();  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				if (b >= 32 && b < 127) continue;    				// we accept via escaping the following special chars: CR' LF' TAB  				if (b == 10 || b == 13 || b == 9)  				{  					mustEscape = true;  					continue;  				}    				//TODO: are there any chars above 128 that could be accepted ?    				// this looks like binary  				return "<" + ToHexaString(' ') + ">";  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				if (b >= 32 && b < 127) continue;    				// we accept via escaping the following special chars: CR' LF' TAB  				if (b == 10 || b == 13 || b == 9)  				{  					mustEscape = true;  					continue;  				}    				//TODO: are there any chars above 128 that could be accepted ?    				// this looks like binary  				return "<" + ToHexaString(' ') + ">";  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				if (b >= 32 && b < 127) continue;    				// we accept via escaping the following special chars: CR' LF' TAB  				if (b == 10 || b == 13 || b == 9)  				{  					mustEscape = true;  					continue;  				}    				//TODO: are there any chars above 128 that could be accepted ?    				// this looks like binary  				return "<" + ToHexaString(' ') + ">";  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				if (b >= 32 && b < 127) continue;    				// we accept via escaping the following special chars: CR' LF' TAB  				if (b == 10 || b == 13 || b == 9)  				{  					mustEscape = true;  					continue;  				}    				//TODO: are there any chars above 128 that could be accepted ?    				// this looks like binary  				return "<" + ToHexaString(' ') + ">";  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: while (n-- > 0)  			{  				byte b = buffer[p++];  				if (b >= 32 && b < 127) continue;    				// we accept via escaping the following special chars: CR' LF' TAB  				if (b == 10 || b == 13 || b == 9)  				{  					mustEscape = true;  					continue;  				}    				//TODO: are there any chars above 128 that could be accepted ?    				// this looks like binary  				return "<" + ToHexaString(' ') + ">";  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (!mustEscape)  			{ // only printable chars found  				return new StringBuilder(n + 2).Append('\'').Append(Encoding.ASCII.GetString(buffer' this.Offset' this.Count)).Append('\'').ToString();  			}  			else  			{ // some escaping required  				return EscapeString(new StringBuilder(n + 2).Append('\'')' buffer' this.Offset' this.Count' Encoding.UTF8).Append('\'').ToString();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToAsciiOrHexaString,The following statement contains a magic number: if (!mustEscape)  			{ // only printable chars found  				return new StringBuilder(n + 2).Append('\'').Append(Encoding.ASCII.GetString(buffer' this.Offset' this.Count)).Append('\'').ToString();  			}  			else  			{ // some escaping required  				return EscapeString(new StringBuilder(n + 2).Append('\'')' buffer' this.Offset' this.Count' Encoding.UTF8).Append('\'').ToString();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt16,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (short) (this.Array[this.Offset] | (this.Array[this.Offset + 1] << 8));  				default: throw new FormatException("Cannot convert slice into an Int16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt16,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (short) (this.Array[this.Offset] | (this.Array[this.Offset + 1] << 8));  				default: throw new FormatException("Cannot convert slice into an Int16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt16BE,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (short)(this.Array[this.Offset + 1] | (this.Array[this.Offset] << 8));  				default: throw new FormatException("Cannot convert slice into an Int16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt16BE,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (short)(this.Array[this.Offset + 1] | (this.Array[this.Offset] << 8));  				default: throw new FormatException("Cannot convert slice into an Int16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt16,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (ushort)(this.Array[this.Offset] | (this.Array[this.Offset + 1] << 8));  				default: throw new FormatException("Cannot convert slice into an UInt16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt16,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (ushort)(this.Array[this.Offset] | (this.Array[this.Offset + 1] << 8));  				default: throw new FormatException("Cannot convert slice into an UInt16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt16BE,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (ushort)(this.Array[this.Offset + 1] | (this.Array[this.Offset] << 8));  				default: throw new FormatException("Cannot convert slice into an UInt16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt16BE,The following statement contains a magic number: switch (this.Count)  			{  				case 0: return 0;  				case 1: return this.Array[this.Offset];  				case 2: return (ushort)(this.Array[this.Offset + 1] | (this.Array[this.Offset] << 8));  				default: throw new FormatException("Cannot convert slice into an UInt16 because it is larger than 2 bytes");  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt16,The following statement contains a magic number: if (bytes < 0 || bytes > 2) throw new ArgumentOutOfRangeException("bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt16,The following statement contains a magic number: switch(bytes)  			{  				case 0: return 0;  				case 1: return buffer[p];  				default: return (ushort)(buffer[p] | (buffer[p + 1] << 8));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt16BE,The following statement contains a magic number: if (bytes < 0 || bytes > 2) throw new ArgumentOutOfRangeException("bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt16BE,The following statement contains a magic number: switch (bytes)  			{  				case 0: return 0;  				case 1: return buffer[p];  				default: return (ushort)(buffer[p + 1] | (buffer[p] << 8));  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt32,The following statement contains a magic number: if (this.Count > 4) throw new FormatException("Cannot convert slice into an Int32 because it is larger than 4 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt32,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p--];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt32BE,The following statement contains a magic number: if (n > 4) throw new FormatException("Cannot convert slice into an Int32 because it is larger than 4 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt32BE,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p++];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt32,The following statement contains a magic number: if (n > 4) throw new FormatException("Cannot convert slice into an UInt32 because it is larger than 4 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt32,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p--];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt32BE,The following statement contains a magic number: if (n > 4) throw new FormatException("Cannot convert slice into an UInt32 because it is larger than 4 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt32BE,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p++];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt32,The following statement contains a magic number: if (bytes < 0 || bytes > 4) throw new ArgumentOutOfRangeException("bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt32,The following statement contains a magic number: while (--bytes > 0)  			{  				value = (value << 8) | buffer[p--];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt32BE,The following statement contains a magic number: if (bytes < 0 || bytes > 4) throw new ArgumentOutOfRangeException("bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt32BE,The following statement contains a magic number: while (--bytes > 0)  			{  				value = (value << 8) | buffer[p++];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt64,The following statement contains a magic number: if (this.Count > 8) throw new FormatException("Cannot convert slice into an Int64 because it is larger than 8 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt64,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p--];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt64BE,The following statement contains a magic number: if (this.Count > 8) throw new FormatException("Cannot convert slice into an Int64 because it is larger than 8 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToInt64BE,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p++];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt64,The following statement contains a magic number: if (this.Count > 8) throw new FormatException("Cannot convert slice into an UInt64 because it is larger than 8 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt64,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p--];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt64BE,The following statement contains a magic number: if (this.Count > 8) throw new FormatException("Cannot convert slice into an UInt64 because it is larger than 8 bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUInt64BE,The following statement contains a magic number: while (--n > 0)  			{  				value = (value << 8) | buffer[p++];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt64,The following statement contains a magic number: if (bytes < 0 || bytes > 8) throw new ArgumentOutOfRangeException("bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt64,The following statement contains a magic number: while (--bytes > 0)  			{  				value = (value << 8) | buffer[p--];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt64BE,The following statement contains a magic number: if (bytes < 0 || bytes > 8) throw new ArgumentOutOfRangeException("bytes");
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ReadUInt64BE,The following statement contains a magic number: while (--bytes > 0)  			{  				value = (value << 8) | buffer[p++];  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid64,The following statement contains a magic number: switch (this.Count)  			{  				case 8:  				{ // binary (8 bytes)  					return new Uuid64(this);  				}    				case 16: // hex16  				case 17: // hex8-hex8  				case 19: // {hex8-hex8}  				{  					return Uuid64.Parse(this.ToAscii());  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid64,The following statement contains a magic number: switch (this.Count)  			{  				case 8:  				{ // binary (8 bytes)  					return new Uuid64(this);  				}    				case 16: // hex16  				case 17: // hex8-hex8  				case 19: // {hex8-hex8}  				{  					return Uuid64.Parse(this.ToAscii());  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid64,The following statement contains a magic number: switch (this.Count)  			{  				case 8:  				{ // binary (8 bytes)  					return new Uuid64(this);  				}    				case 16: // hex16  				case 17: // hex8-hex8  				case 19: // {hex8-hex8}  				{  					return Uuid64.Parse(this.ToAscii());  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid64,The following statement contains a magic number: switch (this.Count)  			{  				case 8:  				{ // binary (8 bytes)  					return new Uuid64(this);  				}    				case 16: // hex16  				case 17: // hex8-hex8  				case 19: // {hex8-hex8}  				{  					return Uuid64.Parse(this.ToAscii());  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToGuid,The following statement contains a magic number: if (this.Count == 16)  			{ // direct byte array    				// UUID are stored using the RFC4122 format (Big Endian)' while .NET's System.GUID use Little Endian  				// we need to swap the byte order of the Data1' Data2 and Data3 chunks' to ensure that Guid.ToString() will return the proper value.    				return new Uuid128(this).ToGuid();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToGuid,The following statement contains a magic number: if (this.Count == 36)  			{ // string representation (ex: "da846709-616d-4e82-bf55-d1d3e9cde9b1")  				return Guid.Parse(this.ToAscii());  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid128,The following statement contains a magic number: if (this.Count == 16)  			{  				return new Uuid128(this);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid128,The following statement contains a magic number: if (this.Count == 36)  			{  				return Uuid128.Parse(this.ToAscii());  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ConcatRange,The following statement contains a magic number: if ((arr = slices as Slice[]) != null)  			{	// fast-path for arrays (most frequent with range reads)    				// we wil use a SliceBuffer to store all the keys produced in as few byte[] arrays as needed    				// precompute the exact size needed  				int totalSize = prefix.Count * arr.Length;  				for (int i = 0; i < arr.Length; i++) totalSize += arr[i].Count;  				var buf = new SliceBuffer(Math.Min(totalSize' 64 * 1024));    				res = new Slice[arr.Length];  				for (int i = 0; i < arr.Length; i++)  				{  					res[i] = buf.Intern(prefix' arr[i]'	aligned: false);  				}  			}  			else if ((coll = slices as ICollection<Slice>) != null)  			{  // collection (size known)    				//TODO: also use a SliceBuffer since we could precompute the total size...    				res = new Slice[coll.Count];  				int p = 0;  				foreach (var suffix in coll)  				{  					res[p++] = prefix.Concat(suffix);  				}  			}  			else  			{  // streaming sequence (size unknown)    				//note: we can only scan the list once' so would be no way to get a sensible value for the buffer's page size  				var list = new List<Slice>();  				foreach (var suffix in slices)  				{  					list.Add(prefix.Concat(suffix));  				}  				res = list.ToArray();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ConcatRange,The following statement contains a magic number: if ((arr = slices as Slice[]) != null)  			{	// fast-path for arrays (most frequent with range reads)    				// we wil use a SliceBuffer to store all the keys produced in as few byte[] arrays as needed    				// precompute the exact size needed  				int totalSize = prefix.Count * arr.Length;  				for (int i = 0; i < arr.Length; i++) totalSize += arr[i].Count;  				var buf = new SliceBuffer(Math.Min(totalSize' 64 * 1024));    				res = new Slice[arr.Length];  				for (int i = 0; i < arr.Length; i++)  				{  					res[i] = buf.Intern(prefix' arr[i]'	aligned: false);  				}  			}  			else if ((coll = slices as ICollection<Slice>) != null)  			{  // collection (size known)    				//TODO: also use a SliceBuffer since we could precompute the total size...    				res = new Slice[coll.Count];  				int p = 0;  				foreach (var suffix in coll)  				{  					res[p++] = prefix.Concat(suffix);  				}  			}  			else  			{  // streaming sequence (size unknown)    				//note: we can only scan the list once' so would be no way to get a sensible value for the buffer's page size  				var list = new List<Slice>();  				foreach (var suffix in slices)  				{  					list.Add(prefix.Concat(suffix));  				}  				res = list.ToArray();  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: const int MAX_SIZE = 1024;
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: var sb = new StringBuilder(count + 16);
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Dump,The following statement contains a magic number: while (count-- > 0)  			{  				int c = buffer[pos++];  				if (c < 32 || c >= 127 || c == 60)  				{  					sb.Append('<');  					int x = c >> 4;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					x = c & 0xF;  					sb.Append((char)(x + (x < 10 ? 48 : 55)));  					sb.Append('>');  				}  				else  				{  					sb.Append((char)c);  				}  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)  			{  				char c = value[i];  				if (c == '<')  				{  					if (value[i + 3] != '>') throw new FormatException(String.Format("Invalid escape character at offset {0}"' i));  					c = (char)(NibbleToDecimal(value[i + 1]) << 4 | NibbleToDecimal(value[i + 2]));  					i += 3;  				}  				writer.WriteByte((byte)c);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)  			{  				char c = value[i];  				if (c == '<')  				{  					if (value[i + 3] != '>') throw new FormatException(String.Format("Invalid escape character at offset {0}"' i));  					c = (char)(NibbleToDecimal(value[i + 1]) << 4 | NibbleToDecimal(value[i + 2]));  					i += 3;  				}  				writer.WriteByte((byte)c);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)  			{  				char c = value[i];  				if (c == '<')  				{  					if (value[i + 3] != '>') throw new FormatException(String.Format("Invalid escape character at offset {0}"' i));  					c = (char)(NibbleToDecimal(value[i + 1]) << 4 | NibbleToDecimal(value[i + 2]));  					i += 3;  				}  				writer.WriteByte((byte)c);  			}
Magic Number,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)  			{  				char c = value[i];  				if (c == '<')  				{  					if (value[i + 3] != '>') throw new FormatException(String.Format("Invalid escape character at offset {0}"' i));  					c = (char)(NibbleToDecimal(value[i + 1]) << 4 | NibbleToDecimal(value[i + 2]));  					i += 3;  				}  				writer.WriteByte((byte)c);  			}
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadFixed16,The following statement contains a magic number: return ReadBytes(2).ToUInt16();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadFixed32,The following statement contains a magic number: return ReadBytes(4).ToUInt32();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadFixed64,The following statement contains a magic number: return ReadBytes(8).ToUInt64();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadFixed16BE,The following statement contains a magic number: return ReadBytes(2).ToUInt16BE();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadFixed32BE,The following statement contains a magic number: return ReadBytes(4).ToUInt32BE();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadFixed64BE,The following statement contains a magic number: return ReadBytes(8).ToUInt64BE();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadVarint16,The following statement contains a magic number: return checked((ushort)ReadVarint(3));
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadVarint32,The following statement contains a magic number: return checked((uint)ReadVarint(5));
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadVarint64,The following statement contains a magic number: return ReadVarint(10);
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadVarint,The following statement contains a magic number: while (count-- > 0)  			{  				if (p > end) throw new FormatException("Truncated Varint");  				byte b = buffer[p++];    				x |= (b & 0x7FUL) << s;  				if (b < 0x80)  				{  					this.Position = p - m_buffer.Offset;  					return x;  				}  				s += 7;  			}
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadUuid128,The following statement contains a magic number: return ReadBytes(16).ToUuid128();
Magic Number,FoundationDB.Client,SliceReader,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceReader.cs,ReadUuid64,The following statement contains a magic number: return ReadBytes(8).ToUuid64();
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,SliceWriter,The following statement contains a magic number: if (capacity == 0)  			{ // most frequent usage is to add a packed integer at the end of a prefix  				capacity = SliceHelpers.Align(n + 8);  			}  			else  			{  				capacity = Math.Max(capacity' n);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,Reset,The following statement contains a magic number: if (this.Position > 0)  			{  				// reduce size ?  				// If the buffer exceeds 4K and we used less than 1/8 of it the last time' we will "shrink" the buffer  				if (this.Buffer.Length > 4096 && (this.Position << 3) <= Buffer.Length)  				{ // Shrink it  					Buffer = new byte[SliceHelpers.NextPowerOfTwo(this.Position)];  				}  				else  				{ // Clear it  					//TODO: native memset() ?  					Array.Clear(Buffer' 0' this.Position);  				}  				this.Position = 0;  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,Reset,The following statement contains a magic number: if (this.Position > 0)  			{  				// reduce size ?  				// If the buffer exceeds 4K and we used less than 1/8 of it the last time' we will "shrink" the buffer  				if (this.Buffer.Length > 4096 && (this.Position << 3) <= Buffer.Length)  				{ // Shrink it  					Buffer = new byte[SliceHelpers.NextPowerOfTwo(this.Position)];  				}  				else  				{ // Clear it  					//TODO: native memset() ?  					Array.Clear(Buffer' 0' this.Position);  				}  				this.Position = 0;  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte2,The following statement contains a magic number: EnsureBytes(2);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte2,The following statement contains a magic number: this.Position = p + 2;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte2,The following statement contains a magic number: this.Position = p + 2;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte3,The following statement contains a magic number: EnsureBytes(3);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte3,The following statement contains a magic number: buffer[p + 2] = value3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte3,The following statement contains a magic number: this.Position = p + 3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte3,The following statement contains a magic number: Contract.Requires(this.Buffer != null && this.Position + 2 < this.Buffer.Length);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte3,The following statement contains a magic number: buffer[p + 2] = value3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte3,The following statement contains a magic number: this.Position = p + 3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte4,The following statement contains a magic number: EnsureBytes(4);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte4,The following statement contains a magic number: buffer[p + 2] = value3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte4,The following statement contains a magic number: buffer[p + 3] = value4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte4,The following statement contains a magic number: this.Position = p + 4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte4,The following statement contains a magic number: Contract.Requires(this.Buffer != null && this.Position + 3 < this.Buffer.Length);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte4,The following statement contains a magic number: buffer[p + 2] = value3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte4,The following statement contains a magic number: buffer[p + 3] = value4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte4,The following statement contains a magic number: this.Position = p + 4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte5,The following statement contains a magic number: EnsureBytes(5);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte5,The following statement contains a magic number: buffer[p + 2] = value3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte5,The following statement contains a magic number: buffer[p + 3] = value4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte5,The following statement contains a magic number: buffer[p + 4] = value5;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteByte5,The following statement contains a magic number: this.Position = p + 5;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte5,The following statement contains a magic number: Contract.Requires(this.Buffer != null && this.Position + 4 < this.Buffer.Length);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte5,The following statement contains a magic number: buffer[p + 2] = value3;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte5,The following statement contains a magic number: buffer[p + 3] = value4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte5,The following statement contains a magic number: buffer[p + 4] = value5;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,UnsafeWriteByte5,The following statement contains a magic number: this.Position = p + 5;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed16,The following statement contains a magic number: EnsureBytes(2);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed16,The following statement contains a magic number: buffer[p + 1] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed16,The following statement contains a magic number: this.Position = p + 2;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: EnsureBytes(4);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: buffer[p + 1] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: buffer[p + 3] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: buffer[p + 3] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32,The following statement contains a magic number: this.Position = p + 4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: EnsureBytes(8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 1] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 3] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 3] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 4] = (byte)(value >> 32);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 4] = (byte)(value >> 32);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 5] = (byte)(value >> 40);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 5] = (byte)(value >> 40);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 6] = (byte)(value >> 48);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 6] = (byte)(value >> 48);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 7] = (byte)(value >> 56);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: buffer[p + 7] = (byte)(value >> 56);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64,The following statement contains a magic number: this.Position = p + 8;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed16BE,The following statement contains a magic number: EnsureBytes(2);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed16BE,The following statement contains a magic number: buffer[p] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed16BE,The following statement contains a magic number: this.Position = p + 2;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: EnsureBytes(4);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: buffer[p] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: buffer[p + 1] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: buffer[p + 3] = (byte)(value);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed32BE,The following statement contains a magic number: this.Position = p + 4;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: EnsureBytes(8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p] = (byte)(value >> 56);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 1] = (byte)(value >> 48);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 40);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 2] = (byte)(value >> 40);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 3] = (byte)(value >> 32);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 3] = (byte)(value >> 32);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 4] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 4] = (byte)(value >> 24);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 5] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 5] = (byte)(value >> 16);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 6] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 6] = (byte)(value >> 8);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: buffer[p + 7] = (byte)(value);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteFixed64BE,The following statement contains a magic number: this.Position = p + 8;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint16,The following statement contains a magic number: const uint MASK = 128;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint16,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint16,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint16,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint16,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint16,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: const uint MASK = 128;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint32,The following statement contains a magic number: if (value < (1 << 7))  			{  				WriteByte((byte)value);  			}  			else if (value < (1 << 14))  			{  				WriteByte2(  					(byte)(value | MASK)'  					(byte)(value >> 7)  				);  			}  			else if (value < (1 << 21))  			{  				WriteByte3(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)(value >> 14)  				);  			}  			else if (value < (1 << 28))  			{  				WriteByte4(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)(value >> 21)  				);  			}  			else  			{  				WriteByte5(  					(byte)(value | MASK)'  					(byte)((value >> 7) | MASK)'  					(byte)((value >> 14) | MASK)'  					(byte)((value >> 21) | MASK)'  					(byte)(value >> 28)  				);  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: const uint MASK = 128;
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: EnsureBytes(value < (1 << 7) ? 1 : value < (1 << 14) ? 2 : value < (1 << 21) ? 3 : 10);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: EnsureBytes(value < (1 << 7) ? 1 : value < (1 << 14) ? 2 : value < (1 << 21) ? 3 : 10);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: EnsureBytes(value < (1 << 7) ? 1 : value < (1 << 14) ? 2 : value < (1 << 21) ? 3 : 10);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: EnsureBytes(value < (1 << 7) ? 1 : value < (1 << 14) ? 2 : value < (1 << 21) ? 3 : 10);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: EnsureBytes(value < (1 << 7) ? 1 : value < (1 << 14) ? 2 : value < (1 << 21) ? 3 : 10);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: EnsureBytes(value < (1 << 7) ? 1 : value < (1 << 14) ? 2 : value < (1 << 21) ? 3 : 10);
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarint64,The following statement contains a magic number: while (value >= MASK)  			{  				buffer[p++] = (byte)((value & (MASK - 1)) | MASK);  				value >>= 7;  			}
Magic Number,FoundationDB.Client,SliceWriter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceWriter.cs,WriteVarbytes,The following statement contains a magic number: if (n < 128)  			{  				EnsureBytes(n + 1);  				var buffer = this.Buffer;  				int p = this.Position;  				// write the count (single byte)  				buffer[p] = (byte)n;  				// write the bytes  				if (n > 0)  				{  					SliceHelpers.CopyBytesUnsafe(buffer' p + 1' value.Array' value.Offset' n);  				}  				this.Position = p + n + 1;  			}  			else  			{  				// write the count  				WriteVarint32((uint)value.Count);  				// write the bytes  				SliceHelpers.CopyBytesUnsafe(this.Buffer' this.Position' value.Array' value.Offset' n);  				this.Position += n;  			}
Magic Number,FoundationDB.Linq,FdbBatchingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbBatchingAsyncIterator.cs,OnStarted,The following statement contains a magic number: m_buffer = new List<TInput>(Math.Min(m_batchSize' 1024));
Magic Number,FoundationDB.Linq,FdbWindowingAsyncIterator<TInput>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Linq\Iterators\FdbWindowingAsyncIterator.cs,OnStarted,The following statement contains a magic number: m_buffer = new List<TInput>(Math.Min(m_maxWindowSize' 1024));
Magic Number,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,AllocateAsync,The following statement contains a magic number: if ((count + 1) * 2 >= window)  			{ // advance the window  				if (FdbDirectoryLayer.AnnotateTransactions) trans.Annotate("Advance allocator window size to {0} starting at {1}"' window' start + window);  				trans.ClearRange(this.Counters.Key' this.Counters.Keys.Encode(start) + FdbKey.MinValue);  				start += window;  				count = 0;  				trans.ClearRange(this.Recent.Key' this.Recent.Keys.Encode(start));  			}
Magic Number,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,GetWindowSize,The following statement contains a magic number: if (start < 255) return 64;
Magic Number,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,GetWindowSize,The following statement contains a magic number: if (start < 255) return 64;
Magic Number,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,GetWindowSize,The following statement contains a magic number: if (start < 65535) return 1024;
Magic Number,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,GetWindowSize,The following statement contains a magic number: if (start < 65535) return 1024;
Magic Number,FoundationDB.Layers.Directories,FdbHighContentionAllocator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbHighContentionAllocator.cs,GetWindowSize,The following statement contains a magic number: return 8192;
Magic Number,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,InitializeDirectory,The following statement contains a magic number: var writer = new SliceWriter(3 * 4);
Magic Number,FoundationDB.Layers.Directories,FdbDirectoryLayer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Directories\FdbDirectoryLayer.cs,InitializeDirectory,The following statement contains a magic number: var writer = new SliceWriter(3 * 4);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -5: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -4: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -3: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -2: return FdbConverters.Convert<T4' R>(this.Item4);  					case 4: case -1: return FdbConverters.Convert<T5' R>(this.Item5);  					default: FdbTuple.FailIndexOutOfRange(index' 5); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The following statement contains a magic number: return new FdbListTuple(new object[6] { this.Item1' this.Item2' this.Item3' this.Item4' this.Item5' value }' 0' 6);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The following statement contains a magic number: return new FdbListTuple(new object[6] { this.Item1' this.Item2' this.Item3' this.Item4' this.Item5' value }' 0' 6);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CopyTo,The following statement contains a magic number: array[offset + 2] = this.Item3;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CopyTo,The following statement contains a magic number: array[offset + 3] = this.Item4;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CopyTo,The following statement contains a magic number: array[offset + 4] = this.Item5;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,ToString,The following statement contains a magic number: return new StringBuilder(48).Append('(')  				.Append(FdbTuple.Stringify(this.Item1)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item2)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item3)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item4)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item5)).Append(')')  				.ToString();
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -4: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -3: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -2: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -1: return FdbConverters.Convert<T4' R>(this.Item4);  					default: FdbTuple.FailIndexOutOfRange(index' 4); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -4: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -3: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -2: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -1: return FdbConverters.Convert<T4' R>(this.Item4);  					default: FdbTuple.FailIndexOutOfRange(index' 4); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -4: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -3: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -2: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -1: return FdbConverters.Convert<T4' R>(this.Item4);  					default: FdbTuple.FailIndexOutOfRange(index' 4); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -4: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -3: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -2: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -1: return FdbConverters.Convert<T4' R>(this.Item4);  					default: FdbTuple.FailIndexOutOfRange(index' 4); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -4: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -3: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -2: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -1: return FdbConverters.Convert<T4' R>(this.Item4);  					default: FdbTuple.FailIndexOutOfRange(index' 4); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -4: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -3: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -2: return FdbConverters.Convert<T3' R>(this.Item3);  					case 3: case -1: return FdbConverters.Convert<T4' R>(this.Item4);  					default: FdbTuple.FailIndexOutOfRange(index' 4); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The following statement contains a magic number: return new FdbListTuple(new object[5] { this.Item1' this.Item2' this.Item3' this.Item4' value }' 0' 5);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The following statement contains a magic number: return new FdbListTuple(new object[5] { this.Item1' this.Item2' this.Item3' this.Item4' value }' 0' 5);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CopyTo,The following statement contains a magic number: array[offset + 2] = this.Item3;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CopyTo,The following statement contains a magic number: array[offset + 3] = this.Item4;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,ToString,The following statement contains a magic number: return new StringBuilder(48).Append('(')  				.Append(FdbTuple.Stringify(this.Item1)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item2)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item3)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item4)).Append(')')  				.ToString();
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FromArray,The following statement contains a magic number: switch(count)  			{  				case 0: return FdbTuple.Empty;  				case 1: return FdbTuple.Create<T>(items[offset]);  				case 2: return FdbTuple.Create<T' T>(items[offset]' items[offset + 1]);  				case 3: return FdbTuple.Create<T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]);  				case 4: return FdbTuple.Create<T' T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]' items[offset + 3]);  				default:  				{ // copy the items in a temp array  					//TODO: we would probably benefit from having an FdbListTuple<T> here!  					var tmp = new object[count];  					Array.Copy(items' offset' tmp' 0' count);  					return new FdbListTuple(tmp' 0' count);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FromArray,The following statement contains a magic number: switch(count)  			{  				case 0: return FdbTuple.Empty;  				case 1: return FdbTuple.Create<T>(items[offset]);  				case 2: return FdbTuple.Create<T' T>(items[offset]' items[offset + 1]);  				case 3: return FdbTuple.Create<T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]);  				case 4: return FdbTuple.Create<T' T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]' items[offset + 3]);  				default:  				{ // copy the items in a temp array  					//TODO: we would probably benefit from having an FdbListTuple<T> here!  					var tmp = new object[count];  					Array.Copy(items' offset' tmp' 0' count);  					return new FdbListTuple(tmp' 0' count);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FromArray,The following statement contains a magic number: switch(count)  			{  				case 0: return FdbTuple.Empty;  				case 1: return FdbTuple.Create<T>(items[offset]);  				case 2: return FdbTuple.Create<T' T>(items[offset]' items[offset + 1]);  				case 3: return FdbTuple.Create<T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]);  				case 4: return FdbTuple.Create<T' T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]' items[offset + 3]);  				default:  				{ // copy the items in a temp array  					//TODO: we would probably benefit from having an FdbListTuple<T> here!  					var tmp = new object[count];  					Array.Copy(items' offset' tmp' 0' count);  					return new FdbListTuple(tmp' 0' count);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FromArray,The following statement contains a magic number: switch(count)  			{  				case 0: return FdbTuple.Empty;  				case 1: return FdbTuple.Create<T>(items[offset]);  				case 2: return FdbTuple.Create<T' T>(items[offset]' items[offset + 1]);  				case 3: return FdbTuple.Create<T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]);  				case 4: return FdbTuple.Create<T' T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]' items[offset + 3]);  				default:  				{ // copy the items in a temp array  					//TODO: we would probably benefit from having an FdbListTuple<T> here!  					var tmp = new object[count];  					Array.Copy(items' offset' tmp' 0' count);  					return new FdbListTuple(tmp' 0' count);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FromArray,The following statement contains a magic number: switch(count)  			{  				case 0: return FdbTuple.Empty;  				case 1: return FdbTuple.Create<T>(items[offset]);  				case 2: return FdbTuple.Create<T' T>(items[offset]' items[offset + 1]);  				case 3: return FdbTuple.Create<T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]);  				case 4: return FdbTuple.Create<T' T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]' items[offset + 3]);  				default:  				{ // copy the items in a temp array  					//TODO: we would probably benefit from having an FdbListTuple<T> here!  					var tmp = new object[count];  					Array.Copy(items' offset' tmp' 0' count);  					return new FdbListTuple(tmp' 0' count);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,FromArray,The following statement contains a magic number: switch(count)  			{  				case 0: return FdbTuple.Empty;  				case 1: return FdbTuple.Create<T>(items[offset]);  				case 2: return FdbTuple.Create<T' T>(items[offset]' items[offset + 1]);  				case 3: return FdbTuple.Create<T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]);  				case 4: return FdbTuple.Create<T' T' T' T>(items[offset]' items[offset + 1]' items[offset + 2]' items[offset + 3]);  				default:  				{ // copy the items in a temp array  					//TODO: we would probably benefit from having an FdbListTuple<T> here!  					var tmp = new object[count];  					Array.Copy(items' offset' tmp' 0' count);  					return new FdbListTuple(tmp' 0' count);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Pack,The following statement contains a magic number: var writer = new TupleWriter(tuples.Length * (16 + prefix.Count));
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKeys,The following statement contains a magic number: var writer = new TupleWriter(keys.Length * (prefix.Count + 8));
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,EncodePrefixedKeys,The following statement contains a magic number: var writer = new TupleWriter(elements.Length * (prefix.Count + 8));
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Splice,The following statement contains a magic number: switch(len)  			{  				case 1: return new FdbListTuple(new object[] { tuple[start] }' 0' 1);  				case 2: return new FdbListTuple(new object[] { tuple[start]' tuple[start + 1] }' 0' 2);  				default:  				{  					var items = new object[len];  					//note: can be slow for tuples using linked-lists' but hopefully they will have their own Slice implementation...  					int q = start;  					for (int p = 0; p < items.Length; p++)  					{  						items[p] = tuple[q++];  					}  					return new FdbListTuple(items' 0' len);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Splice,The following statement contains a magic number: switch(len)  			{  				case 1: return new FdbListTuple(new object[] { tuple[start] }' 0' 1);  				case 2: return new FdbListTuple(new object[] { tuple[start]' tuple[start + 1] }' 0' 2);  				default:  				{  					var items = new object[len];  					//note: can be slow for tuples using linked-lists' but hopefully they will have their own Slice implementation...  					int q = start;  					for (int p = 0; p < items.Length; p++)  					{  						items[p] = tuple[q++];  					}  					return new FdbListTuple(items' 0' len);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CombineHashCodes,The following statement contains a magic number: return ((h1 << 5) + h1) ^ h2;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CombineHashCodes,The following statement contains a magic number: int h = ((h1 << 5) + h1) ^ h2;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CombineHashCodes,The following statement contains a magic number: return ((h << 5) + h) ^ h3;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  				case 0: case -2: return FdbConverters.Convert<T1' R>(this.Item1);  				case 1: case -1: return FdbConverters.Convert<T2' R>(this.Item2);  				default: FdbTuple.FailIndexOutOfRange(index' 2); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  				case 0: case -2: return FdbConverters.Convert<T1' R>(this.Item1);  				case 1: case -1: return FdbConverters.Convert<T2' R>(this.Item2);  				default: FdbTuple.FailIndexOutOfRange(index' 2); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -3: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -2: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -1: return FdbConverters.Convert<T3' R>(this.Item3);  					default: FdbTuple.FailIndexOutOfRange(index' 3); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -3: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -2: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -1: return FdbConverters.Convert<T3' R>(this.Item3);  					default: FdbTuple.FailIndexOutOfRange(index' 3); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -3: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -2: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -1: return FdbConverters.Convert<T3' R>(this.Item3);  					default: FdbTuple.FailIndexOutOfRange(index' 3); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Get,The following statement contains a magic number: switch(index)  			{  					case 0: case -3: return FdbConverters.Convert<T1' R>(this.Item1);  					case 1: case -2: return FdbConverters.Convert<T2' R>(this.Item2);  					case 2: case -1: return FdbConverters.Convert<T3' R>(this.Item3);  					default: FdbTuple.FailIndexOutOfRange(index' 3); return default(R);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The following statement contains a magic number: return new FdbListTuple(new object[4] { this.Item1' this.Item2' this.Item3' value }' 0' 4);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,Append,The following statement contains a magic number: return new FdbListTuple(new object[4] { this.Item1' this.Item2' this.Item3' value }' 0' 4);
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,CopyTo,The following statement contains a magic number: array[offset + 2] = this.Item3;
Magic Number,FoundationDB.Layers.Tuples,FdbTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuple`5.cs,ToString,The following statement contains a magic number: return new StringBuilder(32).Append('(')  				.Append(FdbTuple.Stringify(this.Item1)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item2)).Append("' ")  				.Append(FdbTuple.Stringify(this.Item3)).Append(')')  				.ToString();
Magic Number,FoundationDB.Layers.Tuples,CompositeComparer<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleComparisons.cs,Compare,The following statement contains a magic number: if (ny == 2 || nx == 2) return nx - ny;
Magic Number,FoundationDB.Layers.Tuples,CompositeComparer<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleComparisons.cs,Compare,The following statement contains a magic number: if (ny == 2 || nx == 2) return nx - ny;
Magic Number,FoundationDB.Layers.Tuples,CompositeComparer<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleComparisons.cs,Compare,The following statement contains a magic number: c = this.Comparer3.Compare(x.Get<T3>(p + 2)' y.Get<T3>(p + 2));
Magic Number,FoundationDB.Layers.Tuples,CompositeComparer<T1;T2;T3>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleComparisons.cs,Compare,The following statement contains a magic number: c = this.Comparer3.Compare(x.Get<T3>(p + 2)' y.Get<T3>(p + 2));
Magic Number,FoundationDB.Layers.Tuples,FdbJoinedTuple,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbJoinedTuple.cs,Concat,The following statement contains a magic number: if (n1 + n2 >= 10)  			{ // it's getting bug' merge to a new List tuple  				return new FdbListTuple(this.Head' this.Tail' tuple);  			}  			else  			{  				// REVIEW: should we always concat with the tail?  				return new FdbJoinedTuple(this.Head' this.Tail.Concat(tuple));  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt32,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // zero  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  					return;  				}    				if (value > 0)  				{ // 1..255: frequent for array index  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  					return;  				}    				if (value > -256)  				{ // -255..-1  					writer.Output.WriteByte2(FdbTupleTypes.IntNeg1' (byte)(255 + value));  					return;  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt32,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // zero  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  					return;  				}    				if (value > 0)  				{ // 1..255: frequent for array index  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  					return;  				}    				if (value > -256)  				{ // -255..-1  					writer.Output.WriteByte2(FdbTupleTypes.IntNeg1' (byte)(255 + value));  					return;  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt32,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // zero  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  					return;  				}    				if (value > 0)  				{ // 1..255: frequent for array index  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  					return;  				}    				if (value > -256)  				{ // -255..-1  					writer.Output.WriteByte2(FdbTupleTypes.IntNeg1' (byte)(255 + value));  					return;  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt64,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // zero  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  					return;  				}    				if (value > 0)  				{ // 1..255: frequent for array index  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  					return;  				}    				if (value > -256)  				{ // -255..-1  					writer.Output.WriteByte2(FdbTupleTypes.IntNeg1' (byte)(255 + value));  					return;  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt64,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // zero  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  					return;  				}    				if (value > 0)  				{ // 1..255: frequent for array index  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  					return;  				}    				if (value > -256)  				{ // -255..-1  					writer.Output.WriteByte2(FdbTupleTypes.IntNeg1' (byte)(255 + value));  					return;  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt64,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // zero  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  					return;  				}    				if (value > 0)  				{ // 1..255: frequent for array index  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  					return;  				}    				if (value > -256)  				{ // -255..-1  					writer.Output.WriteByte2(FdbTupleTypes.IntNeg1' (byte)(255 + value));  					return;  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt64Slow,The following statement contains a magic number: if (bytes > 0)  			{  				// head  				--bytes;  				int shift = bytes << 3;    				while (bytes-- > 0)  				{  					buffer[p++] = (byte)(v >> shift);  					shift -= 8;  				}  				// last  				buffer[p++] = (byte)v;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteInt64Slow,The following statement contains a magic number: if (bytes > 0)  			{  				// head  				--bytes;  				int shift = bytes << 3;    				while (bytes-- > 0)  				{  					buffer[p++] = (byte)(v >> shift);  					shift -= 8;  				}  				// last  				buffer[p++] = (byte)v;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUInt32,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // 0  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  				}  				else  				{ // 1..255  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  				}  			}  			else  			{ // >= 256  				WriteUInt64Slow(ref writer' value);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUInt64,The following statement contains a magic number: if (value <= 255)  			{  				if (value == 0)  				{ // 0  					writer.Output.WriteByte(FdbTupleTypes.IntZero);  				}  				else  				{ // 1..255  					writer.Output.WriteByte2(FdbTupleTypes.IntPos1' (byte)value);  				}  			}  			else  			{ // >= 256  				WriteUInt64Slow(ref writer' value);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUInt64Slow,The following statement contains a magic number: if (bytes > 0)  			{  				// head  				--bytes;  				int shift = bytes << 3;    				while (bytes-- > 0)  				{  					buffer[p++] = (byte)(value >> shift);  					shift -= 8;  				}  				// last  				buffer[p++] = (byte)value;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUInt64Slow,The following statement contains a magic number: if (bytes > 0)  			{  				// head  				--bytes;  				int shift = bytes << 3;    				while (bytes-- > 0)  				{  					buffer[p++] = (byte)(value >> shift);  					shift -= 8;  				}  				// last  				buffer[p++] = (byte)value;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: writer.Output.EnsureBytes(5);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: buffer[p + 1] = (byte)(bits >> 24);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: buffer[p + 2] = (byte)(bits >> 16);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: buffer[p + 2] = (byte)(bits >> 16);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: buffer[p + 3] = (byte)(bits >> 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: buffer[p + 3] = (byte)(bits >> 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: buffer[p + 4] = (byte)(bits);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteSingle,The following statement contains a magic number: writer.Output.Position = p + 5;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: writer.Output.EnsureBytes(9);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 1] = (byte)(bits >> 56);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 2] = (byte)(bits >> 48);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 2] = (byte)(bits >> 48);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 3] = (byte)(bits >> 40);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 3] = (byte)(bits >> 40);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 4] = (byte)(bits >> 32);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 4] = (byte)(bits >> 32);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 5] = (byte)(bits >> 24);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 5] = (byte)(bits >> 24);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 6] = (byte)(bits >> 16);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 6] = (byte)(bits >> 16);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 7] = (byte)(bits >> 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 7] = (byte)(bits >> 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: buffer[p + 8] = (byte)(bits);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteDouble,The following statement contains a magic number: writer.Output.Position = p + 9;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUnescapedAsciiChars,The following statement contains a magic number: writer.Output.EnsureBytes(2 + count);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The following statement contains a magic number: if ((mask >> 7) == 0)  			{ // => directly dump the chars to the buffer  				WriteUnescapedAsciiChars(ref writer' chars' count);  				return true;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The following statement contains a magic number: const int CHUNK_SIZE = 1024;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,TryWriteUnescapedUtf8String,The following statement contains a magic number: writer.Output.EnsureBytes(checked(2 + count + (count >> 1)));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteChar,The following statement contains a magic number: if (value == 0)  			{ // NUL => "00 0F"  				// note: \0 is the only unicode character that will produce a zero byte when converted in UTF-8  				writer.Output.WriteByte4(FdbTupleTypes.Utf8' 0x00' 0xFF' 0x00);  			}  			else if (value < 0x80)  			{ // 0x00..0x7F => 0xxxxxxx  				writer.Output.WriteByte3(FdbTupleTypes.Utf8' (byte)value' 0x00);  			}  			else if (value <  0x800)  			{ // 0x80..0x7FF => 110xxxxx 10xxxxxx => two bytes  				writer.Output.WriteByte4(FdbTupleTypes.Utf8' (byte)(0xC0 | (value >> 6))' (byte)(0x80 | (value & 0x3F))' 0x00);  			}  			else  			{ // 0x800..0xFFFF => 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  				// note: System.Char is 16 bits' and thus cannot represent UNICODE chars above 0xFFFF.  				// => This means that a System.Char will never take more than 3 bytes in UTF-8 !  				var tmp = Encoding.UTF8.GetBytes(new string(value' 1));  				writer.Output.EnsureBytes(tmp.Length + 2);  				writer.Output.UnsafeWriteByte(FdbTupleTypes.Utf8);  				writer.Output.UnsafeWriteBytes(tmp' 0' tmp.Length);  				writer.Output.UnsafeWriteByte(0x00);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteChar,The following statement contains a magic number: if (value == 0)  			{ // NUL => "00 0F"  				// note: \0 is the only unicode character that will produce a zero byte when converted in UTF-8  				writer.Output.WriteByte4(FdbTupleTypes.Utf8' 0x00' 0xFF' 0x00);  			}  			else if (value < 0x80)  			{ // 0x00..0x7F => 0xxxxxxx  				writer.Output.WriteByte3(FdbTupleTypes.Utf8' (byte)value' 0x00);  			}  			else if (value <  0x800)  			{ // 0x80..0x7FF => 110xxxxx 10xxxxxx => two bytes  				writer.Output.WriteByte4(FdbTupleTypes.Utf8' (byte)(0xC0 | (value >> 6))' (byte)(0x80 | (value & 0x3F))' 0x00);  			}  			else  			{ // 0x800..0xFFFF => 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  				// note: System.Char is 16 bits' and thus cannot represent UNICODE chars above 0xFFFF.  				// => This means that a System.Char will never take more than 3 bytes in UTF-8 !  				var tmp = Encoding.UTF8.GetBytes(new string(value' 1));  				writer.Output.EnsureBytes(tmp.Length + 2);  				writer.Output.UnsafeWriteByte(FdbTupleTypes.Utf8);  				writer.Output.UnsafeWriteBytes(tmp' 0' tmp.Length);  				writer.Output.UnsafeWriteByte(0x00);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteNulEscapedBytes,The following statement contains a magic number: writer.Output.EnsureBytes(n + 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteNulEscapedBytes,The following statement contains a magic number: writer.Output.EnsureBytes(n + 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteGuid,The following statement contains a magic number: writer.Output.EnsureBytes(17);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteGuid,The following statement contains a magic number: unsafe  			{  				// UUIDs are stored using the RFC 4122 standard' so we need to swap some parts of the System.Guid    				byte* ptr = stackalloc byte[16];  				Uuid128.Write(value' ptr);  				writer.Output.UnsafeWriteBytes(ptr' 16);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteGuid,The following statement contains a magic number: unsafe  			{  				// UUIDs are stored using the RFC 4122 standard' so we need to swap some parts of the System.Guid    				byte* ptr = stackalloc byte[16];  				Uuid128.Write(value' ptr);  				writer.Output.UnsafeWriteBytes(ptr' 16);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUuid128,The following statement contains a magic number: writer.Output.EnsureBytes(17);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUuid128,The following statement contains a magic number: unsafe  			{  				byte* ptr = stackalloc byte[16];  				value.WriteTo(ptr);  				writer.Output.UnsafeWriteBytes(ptr' 16);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUuid128,The following statement contains a magic number: unsafe  			{  				byte* ptr = stackalloc byte[16];  				value.WriteTo(ptr);  				writer.Output.UnsafeWriteBytes(ptr' 16);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUuid64,The following statement contains a magic number: writer.Output.EnsureBytes(9);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUuid64,The following statement contains a magic number: unsafe  			{  				byte* ptr = stackalloc byte[8];  				value.WriteTo(ptr);  				writer.Output.UnsafeWriteBytes(ptr' 8);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,WriteUuid64,The following statement contains a magic number: unsafe  			{  				byte* ptr = stackalloc byte[8];  				value.WriteTo(ptr);  				writer.Output.UnsafeWriteBytes(ptr' 8);  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseInt64,The following statement contains a magic number: if (bytes > 8) throw new FormatException("Invalid size for tuple integer");
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseInt64,The following statement contains a magic number: if (neg)  			{ // the value is encoded as the one's complement of the absolute value  				value = (-(~value));  				if (bytes < 8) value |= (-1L << (bytes << 3));  				return value;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseInt64,The following statement contains a magic number: if (neg)  			{ // the value is encoded as the one's complement of the absolute value  				value = (-(~value));  				if (bytes < 8) value |= (-1L << (bytes << 3));  				return value;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseBytes,The following statement contains a magic number: if (slice.Count <= 2) return Slice.Empty;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseBytes,The following statement contains a magic number: var decoded = UnescapeByteString(slice.Array' slice.Offset + 1' slice.Count - 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseAscii,The following statement contains a magic number: if (slice.Count <= 2) return String.Empty;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseAscii,The following statement contains a magic number: var decoded = UnescapeByteString(slice.Array' slice.Offset + 1' slice.Count - 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseUnicode,The following statement contains a magic number: if (slice.Count <= 2) return String.Empty;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseUnicode,The following statement contains a magic number: var decoded = UnescapeByteString(slice.Array' slice.Offset + 1' slice.Count - 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseTuple,The following statement contains a magic number: if (slice.Count <= 2) return FdbTuple.Empty;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseTuple,The following statement contains a magic number: return FdbTuplePackers.Unpack(slice.Substring(1' slice.Count - 2)' true);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseSingle,The following statement contains a magic number: if (slice.Count != 5)  			{  				throw new FormatException("Slice has invalid size for a Single");  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseSingle,The following statement contains a magic number: uint bits = slice.ReadUInt32BE(1' 4);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseDouble,The following statement contains a magic number: if (slice.Count != 9)  			{  				throw new FormatException("Slice has invalid size for a Double");  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseDouble,The following statement contains a magic number: ulong bits = slice.ReadUInt64BE(1' 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseGuid,The following statement contains a magic number: if (slice.Count != 17)  			{  				throw new FormatException("Slice has invalid size for a GUID");  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseGuid,The following statement contains a magic number: return Uuid128.Convert(new Slice(slice.Array' slice.Offset + 1' 16));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseUuid128,The following statement contains a magic number: if (slice.Count != 17)  			{  				throw new FormatException("Slice has invalid size for a 128-bit UUID");  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseUuid128,The following statement contains a magic number: return new Uuid128(new Slice(slice.Array' slice.Offset + 1' 16));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseUuid64,The following statement contains a magic number: if (slice.Count != 9)  			{  				throw new FormatException("Slice has invalid size for a 64-bit UUID");  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseUuid64,The following statement contains a magic number: return new Uuid64(new Slice(slice.Array' slice.Offset + 1' 8));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The following statement contains a magic number: switch (type)  			{  				case -1:  				{ // End of Stream  					return Slice.Nil;  				}    				case FdbTupleTypes.Nil:  				{ // <00> / <00><FF> => null  					if (reader.Depth > 0)  					{ // must be <00><FF> inside an embedded tuple  						if (reader.Input.PeekByteAt(1) == 0xFF)  						{ // this is a Nil entry  							reader.Input.Skip(2);  							return Slice.Empty;  						}  						else  						{ // this is the end of the embedded tuple  							reader.Input.Skip(1);  							return Slice.Nil;  						}  					}  					else  					{ // can be <00> outside an embedded tuple  						reader.Input.Skip(1);  						return Slice.Empty;  					}  				}    				case FdbTupleTypes.Bytes:  				{ // <01>(bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.Utf8:  				{ // <02>(utf8 bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.TupleStart:  				{ // <03>(packed tuple)<04>    					//PERF: currently' we will first scan to get all the bytes of this tuple' and parse it later.  					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other  					return ReadEmbeddedTupleBytes(ref reader);  				}  				case FdbTupleTypes.Single:  				{ // <20>(4 bytes)  					return reader.Input.ReadBytes(5);  				}    				case FdbTupleTypes.Double:  				{ // <21>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.Uuid128:  				{ // <30>(16 bytes)  					return reader.Input.ReadBytes(17);  				}    				case FdbTupleTypes.Uuid64:  				{ // <31>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.AliasDirectory:  				case FdbTupleTypes.AliasSystem:  				{ // <FE> or <FF>  					return reader.Input.ReadBytes(1);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The following statement contains a magic number: switch (type)  			{  				case -1:  				{ // End of Stream  					return Slice.Nil;  				}    				case FdbTupleTypes.Nil:  				{ // <00> / <00><FF> => null  					if (reader.Depth > 0)  					{ // must be <00><FF> inside an embedded tuple  						if (reader.Input.PeekByteAt(1) == 0xFF)  						{ // this is a Nil entry  							reader.Input.Skip(2);  							return Slice.Empty;  						}  						else  						{ // this is the end of the embedded tuple  							reader.Input.Skip(1);  							return Slice.Nil;  						}  					}  					else  					{ // can be <00> outside an embedded tuple  						reader.Input.Skip(1);  						return Slice.Empty;  					}  				}    				case FdbTupleTypes.Bytes:  				{ // <01>(bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.Utf8:  				{ // <02>(utf8 bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.TupleStart:  				{ // <03>(packed tuple)<04>    					//PERF: currently' we will first scan to get all the bytes of this tuple' and parse it later.  					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other  					return ReadEmbeddedTupleBytes(ref reader);  				}  				case FdbTupleTypes.Single:  				{ // <20>(4 bytes)  					return reader.Input.ReadBytes(5);  				}    				case FdbTupleTypes.Double:  				{ // <21>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.Uuid128:  				{ // <30>(16 bytes)  					return reader.Input.ReadBytes(17);  				}    				case FdbTupleTypes.Uuid64:  				{ // <31>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.AliasDirectory:  				case FdbTupleTypes.AliasSystem:  				{ // <FE> or <FF>  					return reader.Input.ReadBytes(1);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The following statement contains a magic number: switch (type)  			{  				case -1:  				{ // End of Stream  					return Slice.Nil;  				}    				case FdbTupleTypes.Nil:  				{ // <00> / <00><FF> => null  					if (reader.Depth > 0)  					{ // must be <00><FF> inside an embedded tuple  						if (reader.Input.PeekByteAt(1) == 0xFF)  						{ // this is a Nil entry  							reader.Input.Skip(2);  							return Slice.Empty;  						}  						else  						{ // this is the end of the embedded tuple  							reader.Input.Skip(1);  							return Slice.Nil;  						}  					}  					else  					{ // can be <00> outside an embedded tuple  						reader.Input.Skip(1);  						return Slice.Empty;  					}  				}    				case FdbTupleTypes.Bytes:  				{ // <01>(bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.Utf8:  				{ // <02>(utf8 bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.TupleStart:  				{ // <03>(packed tuple)<04>    					//PERF: currently' we will first scan to get all the bytes of this tuple' and parse it later.  					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other  					return ReadEmbeddedTupleBytes(ref reader);  				}  				case FdbTupleTypes.Single:  				{ // <20>(4 bytes)  					return reader.Input.ReadBytes(5);  				}    				case FdbTupleTypes.Double:  				{ // <21>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.Uuid128:  				{ // <30>(16 bytes)  					return reader.Input.ReadBytes(17);  				}    				case FdbTupleTypes.Uuid64:  				{ // <31>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.AliasDirectory:  				case FdbTupleTypes.AliasSystem:  				{ // <FE> or <FF>  					return reader.Input.ReadBytes(1);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The following statement contains a magic number: switch (type)  			{  				case -1:  				{ // End of Stream  					return Slice.Nil;  				}    				case FdbTupleTypes.Nil:  				{ // <00> / <00><FF> => null  					if (reader.Depth > 0)  					{ // must be <00><FF> inside an embedded tuple  						if (reader.Input.PeekByteAt(1) == 0xFF)  						{ // this is a Nil entry  							reader.Input.Skip(2);  							return Slice.Empty;  						}  						else  						{ // this is the end of the embedded tuple  							reader.Input.Skip(1);  							return Slice.Nil;  						}  					}  					else  					{ // can be <00> outside an embedded tuple  						reader.Input.Skip(1);  						return Slice.Empty;  					}  				}    				case FdbTupleTypes.Bytes:  				{ // <01>(bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.Utf8:  				{ // <02>(utf8 bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.TupleStart:  				{ // <03>(packed tuple)<04>    					//PERF: currently' we will first scan to get all the bytes of this tuple' and parse it later.  					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other  					return ReadEmbeddedTupleBytes(ref reader);  				}  				case FdbTupleTypes.Single:  				{ // <20>(4 bytes)  					return reader.Input.ReadBytes(5);  				}    				case FdbTupleTypes.Double:  				{ // <21>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.Uuid128:  				{ // <30>(16 bytes)  					return reader.Input.ReadBytes(17);  				}    				case FdbTupleTypes.Uuid64:  				{ // <31>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.AliasDirectory:  				case FdbTupleTypes.AliasSystem:  				{ // <FE> or <FF>  					return reader.Input.ReadBytes(1);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The following statement contains a magic number: switch (type)  			{  				case -1:  				{ // End of Stream  					return Slice.Nil;  				}    				case FdbTupleTypes.Nil:  				{ // <00> / <00><FF> => null  					if (reader.Depth > 0)  					{ // must be <00><FF> inside an embedded tuple  						if (reader.Input.PeekByteAt(1) == 0xFF)  						{ // this is a Nil entry  							reader.Input.Skip(2);  							return Slice.Empty;  						}  						else  						{ // this is the end of the embedded tuple  							reader.Input.Skip(1);  							return Slice.Nil;  						}  					}  					else  					{ // can be <00> outside an embedded tuple  						reader.Input.Skip(1);  						return Slice.Empty;  					}  				}    				case FdbTupleTypes.Bytes:  				{ // <01>(bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.Utf8:  				{ // <02>(utf8 bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.TupleStart:  				{ // <03>(packed tuple)<04>    					//PERF: currently' we will first scan to get all the bytes of this tuple' and parse it later.  					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other  					return ReadEmbeddedTupleBytes(ref reader);  				}  				case FdbTupleTypes.Single:  				{ // <20>(4 bytes)  					return reader.Input.ReadBytes(5);  				}    				case FdbTupleTypes.Double:  				{ // <21>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.Uuid128:  				{ // <30>(16 bytes)  					return reader.Input.ReadBytes(17);  				}    				case FdbTupleTypes.Uuid64:  				{ // <31>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.AliasDirectory:  				case FdbTupleTypes.AliasSystem:  				{ // <FE> or <FF>  					return reader.Input.ReadBytes(1);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: return (MostSignificantBit(v) + 8) >> 3;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: return (MostSignificantBit(v) + 8) >> 3;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: return v >= 0 ? NumberOfBytes((ulong)v) : v != long.MinValue ? NumberOfBytes((ulong)-v) : 8;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: if (v > 0xFFFFFFFF)  			{ // for 64-bit values' shift everything by 32 bits to the right  				msb += 32;  				v >>= 32;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: if (v > 0xFFFFFFFF)  			{ // for 64-bit values' shift everything by 32 bits to the right  				msb += 32;  				v >>= 32;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: return (msb + 8) >> 3;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,NumberOfBytes,The following statement contains a magic number: return (msb + 8) >> 3;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,MostSignificantBit,The following statement contains a magic number: v |= v >> 2;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,MostSignificantBit,The following statement contains a magic number: v |= v >> 4;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,MostSignificantBit,The following statement contains a magic number: v |= v >> 8;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,MostSignificantBit,The following statement contains a magic number: v |= v >> 16;
Magic Number,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,MostSignificantBit,The following statement contains a magic number: var r = (v * 0x07C4ACDDU) >> 27;
Magic Number,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeBoolean,The following statement contains a magic number: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{ // empty is false' all other is true  					return slice.Count != 2; // <01><00>  				}  				case FdbTupleTypes.Utf8:  				{// empty is false' all other is true  					return slice.Count != 2; // <02><00>  				}  				case FdbTupleTypes.Single:  				{  					//TODO: should NaN considered to be false ?  					return 0f != FdbTupleParser.ParseSingle(slice);  				}  				case FdbTupleTypes.Double:  				{  					//TODO: should NaN considered to be false ?  					return 0f != FdbTupleParser.ParseDouble(slice);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeBoolean,The following statement contains a magic number: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{ // empty is false' all other is true  					return slice.Count != 2; // <01><00>  				}  				case FdbTupleTypes.Utf8:  				{// empty is false' all other is true  					return slice.Count != 2; // <02><00>  				}  				case FdbTupleTypes.Single:  				{  					//TODO: should NaN considered to be false ?  					return 0f != FdbTupleParser.ParseSingle(slice);  				}  				case FdbTupleTypes.Double:  				{  					//TODO: should NaN considered to be false ?  					return 0f != FdbTupleParser.ParseDouble(slice);  				}  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,Unpack,The following statement contains a magic number: var items = new Slice[4];
Magic Number,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,Unpack,The following statement contains a magic number: while ((item = FdbTupleParser.ParseNext(ref reader)).HasValue)  			{  				if (p >= items.Length)  				{  					// note: do not grow exponentially' because tuples will never but very large...  					Array.Resize(ref items' p + 4);  				}  				items[p++] = item;  			}
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,ToRange,The following statement contains a magic number: writer.Output.EnsureBytes(writer.Output.Position + 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: tuple.OfSize(2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: tuple.OfSize(3);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: return new FdbTuple<T1' T2' T3>(  				tuple.Get<T1>(0)'  				tuple.Get<T2>(1)'                  tuple.Get<T3>(2)  			);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: tuple.OfSize(4);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: return new FdbTuple<T1' T2' T3' T4>(  				tuple.Get<T1>(0)'  				tuple.Get<T2>(1)'  				tuple.Get<T3>(2)'                  tuple.Get<T4>(3)  			);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: return new FdbTuple<T1' T2' T3' T4>(  				tuple.Get<T1>(0)'  				tuple.Get<T2>(1)'  				tuple.Get<T3>(2)'                  tuple.Get<T4>(3)  			);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: tuple.OfSize(5);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: return new FdbTuple<T1' T2' T3' T4' T5>(  				tuple.Get<T1>(0)'  				tuple.Get<T2>(1)'  				tuple.Get<T3>(2)'  				tuple.Get<T4>(3)'                  tuple.Get<T5>(4)  			);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: return new FdbTuple<T1' T2' T3' T4' T5>(  				tuple.Get<T1>(0)'  				tuple.Get<T2>(1)'  				tuple.Get<T3>(2)'  				tuple.Get<T4>(3)'                  tuple.Get<T5>(4)  			);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,As,The following statement contains a magic number: return new FdbTuple<T1' T2' T3' T4' T5>(  				tuple.Get<T1>(0)'  				tuple.Get<T2>(1)'  				tuple.Get<T3>(2)'  				tuple.Get<T4>(3)'                  tuple.Get<T5>(4)  			);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 3);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 4);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 5);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 6);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 7);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 2);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 3);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 4);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 5);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 6);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 7);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: OfSize(tuple' 8);
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Layers.Tuples,FdbTupleExtensions,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleExtensions.cs,With,The following statement contains a magic number: return lambda(tuple.Get<T1>(0)' tuple.Get<T2>(1)' tuple.Get<T3>(2)' tuple.Get<T4>(3)' tuple.Get<T5>(4)' tuple.Get<T6>(5)' tuple.Get<T7>(6)' tuple.Get<T8>(7));
Magic Number,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,Set,The following statement contains a magic number: Interlocked.Add(ref m_payloadBytes' key.Count + value.Count + 28);
Magic Number,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,Clear,The following statement contains a magic number: Interlocked.Add(ref m_payloadBytes' (key.Count * 2) + 28 + 1);
Magic Number,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,Clear,The following statement contains a magic number: Interlocked.Add(ref m_payloadBytes' (key.Count * 2) + 28 + 1);
Magic Number,FoundationDB.Client.Native,FdbNativeTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNativeTransaction.cs,ClearRange,The following statement contains a magic number: Interlocked.Add(ref m_payloadBytes' beginKeyInclusive.Count + endKeyExclusive.Count + 28);
Magic Number,FoundationDB.Client.Native,FdbNative,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\FdbNative.cs,FdbNative,The following statement contains a magic number: if (libraryPath != null)  			{  				try  				{  					if (libraryPath.Length == 0)  					{ // CLR will handle the search  						libraryPath = FDB_C_DLL;  					}  					else if (!libraryPath.EndsWith(".dll"' StringComparison.OrdinalIgnoreCase))  					{ // add the file name  						libraryPath = Path.Combine(Fdb.Options.NativeLibPath' FDB_C_DLL);  					}    					FdbCLib = UnmanagedLibrary.Load(libraryPath);  				}  				catch (Exception e)  				{  					if (FdbCLib != null) FdbCLib.Dispose();  					FdbCLib = null;  					if (e is BadImageFormatException && IntPtr.Size == 4)  					{  						e = new InvalidOperationException("The native FDB client is 64-bit only' and cannot be loaded in a 32-bit process."' e);  					}  					else  					{  						e = new InvalidOperationException("An error occurred while loading the native FoundationDB library"' e);  					}  					LibraryLoadError = ExceptionDispatchInfo.Capture(e);  				}  			}
Magic Number,FoundationDB.Client.Native,UnmanagedLibrary,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Native\UnmanagedLibrary.cs,Load,The following statement contains a magic number: if (handle == null || handle.IsInvalid)  			{  				var ex = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());  				if (ex is System.IO.FileNotFoundException)  				{  					throw new System.IO.FileNotFoundException(String.Format("Failed to load native {0} library: {1}"' IntPtr.Size == 8 ? "x64" : "x86"' path)' path' ex);  				}  				throw ex;  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,FdbTransactionLog,The following statement contains a magic number: if (this.ShoudCaptureTransactionStackTrace)  			{  				this.CallSite = CaptureStackTrace(2);  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,BeginOperation,The following statement contains a magic number: if (this.ShouldCaptureOperationStackTrace) cmd.CallSite = CaptureStackTrace(2);
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetCommandsReport,The following statement contains a magic number: for (int i = 0; i < cmds.Length; i++)  			{  				var cmd = cmds[i];  				if (detailed)  				{  					sb.AppendFormat(  						culture'  						"{0'3} - T+{1'7:##0.000} ({2'7:##'##0} µs) : {3}"'  						/* 0 */ cmd.Step'  						/* 1 */ cmd.StartOffset.TotalMilliseconds'  						/* 2 */ cmd.Duration.Ticks / 10.0'  						/* 3 */ cmd.ToString()  					);  				}  				else  				{  					sb.AppendFormat(  						culture'  						"{0'3} : {2}{1}"'  						/* 0 */ cmd.Step'  						/* 1 */ cmd.ToString()'  						/* 2 */ cmd.Error != null ? "[FAILED] " : ""  					);  				}  				sb.AppendLine();  				switch (cmd.Mode)  				{  					case FdbTransactionLog.Mode.Read: ++reads; break;  					case FdbTransactionLog.Mode.Write: ++writes; break;  				}  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The following statement contains a magic number: int maxWidth = showCommands ? 80 : 160;
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The following statement contains a magic number: int maxWidth = showCommands ? 80 : 160;
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The following statement contains a magic number: if (cmds.Length > 0)  			{  				var bar = new string('─'' width + 2);  				sb.AppendLine(String.Format(culture' "┌  oper. ┬{0}┬──── start ──── end ── duration ──┬─ sent  recv ┐"' bar));    				// look for the timestamps of the first and last commands  				var first = TimeSpan.Zero;  				var last = duration;  				for (int i = 0; i < cmds.Length;i++)  				{  					if (cmds[i].Op == Operation.Log) continue;  					first = cmds[i].StartOffset;  					break;  				}  				for(int i = cmds.Length - 1; i >= 0; i--)  				{  					if (cmds[i].Op == Operation.Log) continue;  					if (cmds[i].EndOffset.HasValue) duration = cmds[i].EndOffset.Value;  					break;  				}  				duration -= first;    				int step = -1;  				bool previousWasOnError = false;  				int attempts = 1;  				int charsToSkip = 0;  				foreach (var cmd in cmds)  				{  					if (previousWasOnError)  					{  						sb.AppendLine(String.Format(culture' "├────────┼{0}┼──────────────────────────────────┼─────────────┤ == Attempt #{1:N0} =="' bar' (++attempts)));  					}    					long ticks = cmd.Duration.Ticks;  					string w = GetFancyGraph(width' (cmd.StartOffset - first).Ticks' ticks' duration.Ticks' charsToSkip);    					if (ticks > 0)  					{  						sb.AppendFormat(  							culture'  							"│{6}{1'-3:##0}{10}{0'2}{7}│ {2} │ T+{3'7:##0.000} ~ {4'7:##0.000} ({5'7:##'##0} µs) │ {8'5} {9'5} │ {11}"'  							/* 0 */ cmd.ShortName'  							/* 1 */ cmd.Step'  							/* 2 */ w'  							/* 3 */ cmd.StartOffset.TotalMilliseconds'  							/* 4 */ (cmd.EndOffset ?? TimeSpan.Zero).TotalMilliseconds'  							/* 5 */ ticks / 10.0'  							/* 6 */ cmd.Step == step ? ":" : " "'  							/* 7 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 8 */ cmd.ArgumentBytes'  							/* 9 */ cmd.ResultBytes'  							/* 10 */ cmd.Error != null ? "!" : " "'  							/* 11 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}  					else  					{ // annotation  						sb.AppendFormat(  							culture'  							"│{0}{1'-3:##0}{2}{3'2}{4}│ {5} │ T+{6'7:##0.000}                        │     -     - │ {7}"'  							/* 0 */ cmd.Step == step ? ":" : " "'  							/* 1 */ cmd.Step'  							/* 2 */ cmd.Error != null ? "!" : " "'  							/* 3 */ cmd.ShortName'  							/* 4 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 5 */ w'  							/* 6 */ cmd.StartOffset.TotalMilliseconds'  							/* 7 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}    					if (showCommands && cmd.CallSite != null)  					{  						var f = GetFirstInterestingStackFrame(cmd.CallSite);  						if (f != null)  						{  							var m = f.GetMethod();  							string name = GetUserFriendlyMethodName(m);  							sb.Append(" // ").Append(name);  							string fn = f.GetFileName();  							if (fn != null) sb.AppendFormat(culture' " at {0}:{1}"' fn' f.GetFileLineNumber());  						}  					}    					sb.AppendLine();    					previousWasOnError = cmd.Op == Operation.OnError;  					if (previousWasOnError)  					{  						charsToSkip = (int)Math.Floor(1.0d * width * (cmd.EndOffset ?? TimeSpan.Zero).Ticks / duration.Ticks);  					}    					step = cmd.Step;  				}    				sb.AppendLine(String.Format(culture' "└────────┴{0}┴──────────────────────────────────┴─────────────┘"' bar));    				// Footer  				if (this.Completed)  				{  					sb.Append("> ");  					flag = false;  					if (this.ReadSize > 0)  					{  						sb.AppendFormat(culture' "Read {0:N0} bytes"' this.ReadSize);  						flag = true;  					}  					if (this.CommitSize > 0)  					{  						if (flag) sb.Append(" and ");  						sb.AppendFormat(culture' "Committed {0:N0} bytes"' this.CommitSize);  						flag = true;  					}  					if (!flag) sb.Append("Completed");  					sb.AppendLine(String.Format(culture' " in {0:N3} ms and {1:N0} attempt(s)"' this.TotalDuration.TotalMilliseconds' attempts));  				}  			}  			else  			{ // empty transaction  				sb.AppendLine(String.Format(culture' "> Completed after {0:N3} ms without performing any operation"' this.TotalDuration.TotalMilliseconds));  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The following statement contains a magic number: if (cmds.Length > 0)  			{  				var bar = new string('─'' width + 2);  				sb.AppendLine(String.Format(culture' "┌  oper. ┬{0}┬──── start ──── end ── duration ──┬─ sent  recv ┐"' bar));    				// look for the timestamps of the first and last commands  				var first = TimeSpan.Zero;  				var last = duration;  				for (int i = 0; i < cmds.Length;i++)  				{  					if (cmds[i].Op == Operation.Log) continue;  					first = cmds[i].StartOffset;  					break;  				}  				for(int i = cmds.Length - 1; i >= 0; i--)  				{  					if (cmds[i].Op == Operation.Log) continue;  					if (cmds[i].EndOffset.HasValue) duration = cmds[i].EndOffset.Value;  					break;  				}  				duration -= first;    				int step = -1;  				bool previousWasOnError = false;  				int attempts = 1;  				int charsToSkip = 0;  				foreach (var cmd in cmds)  				{  					if (previousWasOnError)  					{  						sb.AppendLine(String.Format(culture' "├────────┼{0}┼──────────────────────────────────┼─────────────┤ == Attempt #{1:N0} =="' bar' (++attempts)));  					}    					long ticks = cmd.Duration.Ticks;  					string w = GetFancyGraph(width' (cmd.StartOffset - first).Ticks' ticks' duration.Ticks' charsToSkip);    					if (ticks > 0)  					{  						sb.AppendFormat(  							culture'  							"│{6}{1'-3:##0}{10}{0'2}{7}│ {2} │ T+{3'7:##0.000} ~ {4'7:##0.000} ({5'7:##'##0} µs) │ {8'5} {9'5} │ {11}"'  							/* 0 */ cmd.ShortName'  							/* 1 */ cmd.Step'  							/* 2 */ w'  							/* 3 */ cmd.StartOffset.TotalMilliseconds'  							/* 4 */ (cmd.EndOffset ?? TimeSpan.Zero).TotalMilliseconds'  							/* 5 */ ticks / 10.0'  							/* 6 */ cmd.Step == step ? ":" : " "'  							/* 7 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 8 */ cmd.ArgumentBytes'  							/* 9 */ cmd.ResultBytes'  							/* 10 */ cmd.Error != null ? "!" : " "'  							/* 11 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}  					else  					{ // annotation  						sb.AppendFormat(  							culture'  							"│{0}{1'-3:##0}{2}{3'2}{4}│ {5} │ T+{6'7:##0.000}                        │     -     - │ {7}"'  							/* 0 */ cmd.Step == step ? ":" : " "'  							/* 1 */ cmd.Step'  							/* 2 */ cmd.Error != null ? "!" : " "'  							/* 3 */ cmd.ShortName'  							/* 4 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 5 */ w'  							/* 6 */ cmd.StartOffset.TotalMilliseconds'  							/* 7 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}    					if (showCommands && cmd.CallSite != null)  					{  						var f = GetFirstInterestingStackFrame(cmd.CallSite);  						if (f != null)  						{  							var m = f.GetMethod();  							string name = GetUserFriendlyMethodName(m);  							sb.Append(" // ").Append(name);  							string fn = f.GetFileName();  							if (fn != null) sb.AppendFormat(culture' " at {0}:{1}"' fn' f.GetFileLineNumber());  						}  					}    					sb.AppendLine();    					previousWasOnError = cmd.Op == Operation.OnError;  					if (previousWasOnError)  					{  						charsToSkip = (int)Math.Floor(1.0d * width * (cmd.EndOffset ?? TimeSpan.Zero).Ticks / duration.Ticks);  					}    					step = cmd.Step;  				}    				sb.AppendLine(String.Format(culture' "└────────┴{0}┴──────────────────────────────────┴─────────────┘"' bar));    				// Footer  				if (this.Completed)  				{  					sb.Append("> ");  					flag = false;  					if (this.ReadSize > 0)  					{  						sb.AppendFormat(culture' "Read {0:N0} bytes"' this.ReadSize);  						flag = true;  					}  					if (this.CommitSize > 0)  					{  						if (flag) sb.Append(" and ");  						sb.AppendFormat(culture' "Committed {0:N0} bytes"' this.CommitSize);  						flag = true;  					}  					if (!flag) sb.Append("Completed");  					sb.AppendLine(String.Format(culture' " in {0:N3} ms and {1:N0} attempt(s)"' this.TotalDuration.TotalMilliseconds' attempts));  				}  			}  			else  			{ // empty transaction  				sb.AppendLine(String.Format(culture' "> Completed after {0:N3} ms without performing any operation"' this.TotalDuration.TotalMilliseconds));  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The following statement contains a magic number: if (cmds.Length > 0)  			{  				var bar = new string('─'' width + 2);  				sb.AppendLine(String.Format(culture' "┌  oper. ┬{0}┬──── start ──── end ── duration ──┬─ sent  recv ┐"' bar));    				// look for the timestamps of the first and last commands  				var first = TimeSpan.Zero;  				var last = duration;  				for (int i = 0; i < cmds.Length;i++)  				{  					if (cmds[i].Op == Operation.Log) continue;  					first = cmds[i].StartOffset;  					break;  				}  				for(int i = cmds.Length - 1; i >= 0; i--)  				{  					if (cmds[i].Op == Operation.Log) continue;  					if (cmds[i].EndOffset.HasValue) duration = cmds[i].EndOffset.Value;  					break;  				}  				duration -= first;    				int step = -1;  				bool previousWasOnError = false;  				int attempts = 1;  				int charsToSkip = 0;  				foreach (var cmd in cmds)  				{  					if (previousWasOnError)  					{  						sb.AppendLine(String.Format(culture' "├────────┼{0}┼──────────────────────────────────┼─────────────┤ == Attempt #{1:N0} =="' bar' (++attempts)));  					}    					long ticks = cmd.Duration.Ticks;  					string w = GetFancyGraph(width' (cmd.StartOffset - first).Ticks' ticks' duration.Ticks' charsToSkip);    					if (ticks > 0)  					{  						sb.AppendFormat(  							culture'  							"│{6}{1'-3:##0}{10}{0'2}{7}│ {2} │ T+{3'7:##0.000} ~ {4'7:##0.000} ({5'7:##'##0} µs) │ {8'5} {9'5} │ {11}"'  							/* 0 */ cmd.ShortName'  							/* 1 */ cmd.Step'  							/* 2 */ w'  							/* 3 */ cmd.StartOffset.TotalMilliseconds'  							/* 4 */ (cmd.EndOffset ?? TimeSpan.Zero).TotalMilliseconds'  							/* 5 */ ticks / 10.0'  							/* 6 */ cmd.Step == step ? ":" : " "'  							/* 7 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 8 */ cmd.ArgumentBytes'  							/* 9 */ cmd.ResultBytes'  							/* 10 */ cmd.Error != null ? "!" : " "'  							/* 11 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}  					else  					{ // annotation  						sb.AppendFormat(  							culture'  							"│{0}{1'-3:##0}{2}{3'2}{4}│ {5} │ T+{6'7:##0.000}                        │     -     - │ {7}"'  							/* 0 */ cmd.Step == step ? ":" : " "'  							/* 1 */ cmd.Step'  							/* 2 */ cmd.Error != null ? "!" : " "'  							/* 3 */ cmd.ShortName'  							/* 4 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 5 */ w'  							/* 6 */ cmd.StartOffset.TotalMilliseconds'  							/* 7 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}    					if (showCommands && cmd.CallSite != null)  					{  						var f = GetFirstInterestingStackFrame(cmd.CallSite);  						if (f != null)  						{  							var m = f.GetMethod();  							string name = GetUserFriendlyMethodName(m);  							sb.Append(" // ").Append(name);  							string fn = f.GetFileName();  							if (fn != null) sb.AppendFormat(culture' " at {0}:{1}"' fn' f.GetFileLineNumber());  						}  					}    					sb.AppendLine();    					previousWasOnError = cmd.Op == Operation.OnError;  					if (previousWasOnError)  					{  						charsToSkip = (int)Math.Floor(1.0d * width * (cmd.EndOffset ?? TimeSpan.Zero).Ticks / duration.Ticks);  					}    					step = cmd.Step;  				}    				sb.AppendLine(String.Format(culture' "└────────┴{0}┴──────────────────────────────────┴─────────────┘"' bar));    				// Footer  				if (this.Completed)  				{  					sb.Append("> ");  					flag = false;  					if (this.ReadSize > 0)  					{  						sb.AppendFormat(culture' "Read {0:N0} bytes"' this.ReadSize);  						flag = true;  					}  					if (this.CommitSize > 0)  					{  						if (flag) sb.Append(" and ");  						sb.AppendFormat(culture' "Committed {0:N0} bytes"' this.CommitSize);  						flag = true;  					}  					if (!flag) sb.Append("Completed");  					sb.AppendLine(String.Format(culture' " in {0:N3} ms and {1:N0} attempt(s)"' this.TotalDuration.TotalMilliseconds' attempts));  				}  			}  			else  			{ // empty transaction  				sb.AppendLine(String.Format(culture' "> Completed after {0:N3} ms without performing any operation"' this.TotalDuration.TotalMilliseconds));  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetTimingsReport,The following statement contains a magic number: if (cmds.Length > 0)  			{  				var bar = new string('─'' width + 2);  				sb.AppendLine(String.Format(culture' "┌  oper. ┬{0}┬──── start ──── end ── duration ──┬─ sent  recv ┐"' bar));    				// look for the timestamps of the first and last commands  				var first = TimeSpan.Zero;  				var last = duration;  				for (int i = 0; i < cmds.Length;i++)  				{  					if (cmds[i].Op == Operation.Log) continue;  					first = cmds[i].StartOffset;  					break;  				}  				for(int i = cmds.Length - 1; i >= 0; i--)  				{  					if (cmds[i].Op == Operation.Log) continue;  					if (cmds[i].EndOffset.HasValue) duration = cmds[i].EndOffset.Value;  					break;  				}  				duration -= first;    				int step = -1;  				bool previousWasOnError = false;  				int attempts = 1;  				int charsToSkip = 0;  				foreach (var cmd in cmds)  				{  					if (previousWasOnError)  					{  						sb.AppendLine(String.Format(culture' "├────────┼{0}┼──────────────────────────────────┼─────────────┤ == Attempt #{1:N0} =="' bar' (++attempts)));  					}    					long ticks = cmd.Duration.Ticks;  					string w = GetFancyGraph(width' (cmd.StartOffset - first).Ticks' ticks' duration.Ticks' charsToSkip);    					if (ticks > 0)  					{  						sb.AppendFormat(  							culture'  							"│{6}{1'-3:##0}{10}{0'2}{7}│ {2} │ T+{3'7:##0.000} ~ {4'7:##0.000} ({5'7:##'##0} µs) │ {8'5} {9'5} │ {11}"'  							/* 0 */ cmd.ShortName'  							/* 1 */ cmd.Step'  							/* 2 */ w'  							/* 3 */ cmd.StartOffset.TotalMilliseconds'  							/* 4 */ (cmd.EndOffset ?? TimeSpan.Zero).TotalMilliseconds'  							/* 5 */ ticks / 10.0'  							/* 6 */ cmd.Step == step ? ":" : " "'  							/* 7 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 8 */ cmd.ArgumentBytes'  							/* 9 */ cmd.ResultBytes'  							/* 10 */ cmd.Error != null ? "!" : " "'  							/* 11 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}  					else  					{ // annotation  						sb.AppendFormat(  							culture'  							"│{0}{1'-3:##0}{2}{3'2}{4}│ {5} │ T+{6'7:##0.000}                        │     -     - │ {7}"'  							/* 0 */ cmd.Step == step ? ":" : " "'  							/* 1 */ cmd.Step'  							/* 2 */ cmd.Error != null ? "!" : " "'  							/* 3 */ cmd.ShortName'  							/* 4 */ ticks >= TimeSpan.TicksPerMillisecond * 10 ? '*' : ticks >= TimeSpan.TicksPerMillisecond ? '°' : ' ''  							/* 5 */ w'  							/* 6 */ cmd.StartOffset.TotalMilliseconds'  							/* 7 */ showCommands ? cmd.ToString(keyResolver) : String.Empty  						);  					}    					if (showCommands && cmd.CallSite != null)  					{  						var f = GetFirstInterestingStackFrame(cmd.CallSite);  						if (f != null)  						{  							var m = f.GetMethod();  							string name = GetUserFriendlyMethodName(m);  							sb.Append(" // ").Append(name);  							string fn = f.GetFileName();  							if (fn != null) sb.AppendFormat(culture' " at {0}:{1}"' fn' f.GetFileLineNumber());  						}  					}    					sb.AppendLine();    					previousWasOnError = cmd.Op == Operation.OnError;  					if (previousWasOnError)  					{  						charsToSkip = (int)Math.Floor(1.0d * width * (cmd.EndOffset ?? TimeSpan.Zero).Ticks / duration.Ticks);  					}    					step = cmd.Step;  				}    				sb.AppendLine(String.Format(culture' "└────────┴{0}┴──────────────────────────────────┴─────────────┘"' bar));    				// Footer  				if (this.Completed)  				{  					sb.Append("> ");  					flag = false;  					if (this.ReadSize > 0)  					{  						sb.AppendFormat(culture' "Read {0:N0} bytes"' this.ReadSize);  						flag = true;  					}  					if (this.CommitSize > 0)  					{  						if (flag) sb.Append(" and ");  						sb.AppendFormat(culture' "Committed {0:N0} bytes"' this.CommitSize);  						flag = true;  					}  					if (!flag) sb.Append("Completed");  					sb.AppendLine(String.Format(culture' " in {0:N3} ms and {1:N0} attempt(s)"' this.TotalDuration.TotalMilliseconds' attempts));  				}  			}  			else  			{ // empty transaction  				sb.AppendLine(String.Format(culture' "> Completed after {0:N3} ms without performing any operation"' this.TotalDuration.TotalMilliseconds));  			}
Magic Number,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetFancyChar,The following statement contains a magic number: int p = (int)Math.Round(x * 10' MidpointRounding.AwayFromZero);
Magic Number,FoundationDB.Filters.Logging,Command,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder(255);
Magic Number,FoundationDB.Filters.Logging,Command<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetResult,The following statement contains a magic number: if (res.Length > MAX_LENGTH) res = res.Substring(0' MAX_LENGTH / 2) + "..." + res.Substring(res.Length - (MAX_LENGTH / 2)' MAX_LENGTH / 2);
Magic Number,FoundationDB.Filters.Logging,Command<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetResult,The following statement contains a magic number: if (res.Length > MAX_LENGTH) res = res.Substring(0' MAX_LENGTH / 2) + "..." + res.Substring(res.Length - (MAX_LENGTH / 2)' MAX_LENGTH / 2);
Magic Number,FoundationDB.Filters.Logging,Command<TResult>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetResult,The following statement contains a magic number: if (res.Length > MAX_LENGTH) res = res.Substring(0' MAX_LENGTH / 2) + "..." + res.Substring(res.Length - (MAX_LENGTH / 2)' MAX_LENGTH / 2);
Magic Number,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,BuildFromDirectoryLayer,The following statement contains a magic number: foreach (var entry in keys)  				{  					var t = location.Unpack(entry.Key);  					// look for a tuple of size 3 with 0 as the second element...  					if (t.Count != 3 || t.Get<int>(1) != 0) continue;    					//Slice parent = t.Get<Slice>(0); //TODO: use this to construct the full materialized path of this directory? (would need more than one pass)  					string name = t.Get<string>(2);    					map[entry.Value] = name;  				}
Magic Number,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,BuildFromDirectoryLayer,The following statement contains a magic number: foreach (var entry in keys)  				{  					var t = location.Unpack(entry.Key);  					// look for a tuple of size 3 with 0 as the second element...  					if (t.Count != 3 || t.Get<int>(1) != 0) continue;    					//Slice parent = t.Get<Slice>(0); //TODO: use this to construct the full materialized path of this directory? (would need more than one pass)  					string name = t.Get<string>(2);    					map[entry.Value] = name;  				}
Magic Number,FoundationDB.Filters.Logging,DirectoryKeyResolver,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,Resolve,The following statement contains a magic number: if (s != null && s.Length >= 3 && s[0] == '(' && s[s.Length - 1] == ')')  				{ // that was a tuple  					return String.Concat("(["' path' "]' "' s.Substring(1));  				}
Magic Number,FoundationDB.Filters.Logging,FdbLoggedTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggedTransaction.cs,Grab,The following statement contains a magic number: lock (m_lock)  			{  				if (slice.Count > m_buffer.Length - m_offset)  				{ // not enough ?  					if (slice.Count >= 2048)  					{  						return slice.Memoize();  					}  					m_buffer = new byte[4096];  					m_offset = 0;  				}    				int start = m_offset;  				slice.CopyTo(m_buffer' m_offset);  				m_offset += slice.Count;  				return new Slice(m_buffer' start' slice.Count);  			}
Magic Number,FoundationDB.Filters.Logging,FdbLoggedTransaction,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbLoggedTransaction.cs,Grab,The following statement contains a magic number: lock (m_lock)  			{  				if (slice.Count > m_buffer.Length - m_offset)  				{ // not enough ?  					if (slice.Count >= 2048)  					{  						return slice.Memoize();  					}  					m_buffer = new byte[4096];  					m_offset = 0;  				}    				int start = m_offset;  				slice.CopyTo(m_buffer' m_offset);  				m_offset += slice.Count;  				return new Slice(m_buffer' start' slice.Count);  			}
Magic Number,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,IsWhiteSpace,The following statement contains a magic number: return c <= 32 && (c == ' ' || c == '\t' || c == '\n' || c == '\r');
Magic Number,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,ReadStringLiteral,The following statement contains a magic number: while (cursor < end)  			{  				char c = buffer[cursor++];  				switch (c)  				{  					case '\"':  					{  						m_cursor = cursor;  						return sb.Length == 0 ? String.Empty : sb.ToString();  					}    					case '\\':  					{  						if (cursor >= end) break;  						c = buffer[cursor++];  						switch (c)  						{  							case '\\': sb.Append('\\'); break;  							case 'n': sb.Append('\n'); break;  							case 'r': sb.Append('\r'); break;  							case 't': sb.Append('\t'); break;  							case 'f': sb.Append('\f'); break;  							case 'b': sb.Append('\b'); break;  							case 'u':  							{  								if (cursor + 4 >= end) throw SyntaxError("Truncated unicode escape sequence in string literal");  								int x = 0;  								for (int i = 0; i < 4; i++)  								{  									c = buffer[cursor++];  									x <<= 4;  									if (c >= '0' && c <= '9') x |= (c - '0');  									else if (c >= 'A' && c <= 'F') x |= (c - 'A');  									else if (c >= 'a' && c <= 'f') x |= (c - 'a');  									else throw SyntaxError("Invalid unicode escape character '{0}' in string literal"' c);  								}  								sb.Append((char) x);  								break;  							}  							default:  							{  								throw SyntaxError("Invalid escape character '{0}' in string literal"' new string(c' 1));  							}  						}  						break;  					}    					default:  					{  						sb.Append(c);  						break;  					}    				}  			}
Magic Number,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,ReadStringLiteral,The following statement contains a magic number: while (cursor < end)  			{  				char c = buffer[cursor++];  				switch (c)  				{  					case '\"':  					{  						m_cursor = cursor;  						return sb.Length == 0 ? String.Empty : sb.ToString();  					}    					case '\\':  					{  						if (cursor >= end) break;  						c = buffer[cursor++];  						switch (c)  						{  							case '\\': sb.Append('\\'); break;  							case 'n': sb.Append('\n'); break;  							case 'r': sb.Append('\r'); break;  							case 't': sb.Append('\t'); break;  							case 'f': sb.Append('\f'); break;  							case 'b': sb.Append('\b'); break;  							case 'u':  							{  								if (cursor + 4 >= end) throw SyntaxError("Truncated unicode escape sequence in string literal");  								int x = 0;  								for (int i = 0; i < 4; i++)  								{  									c = buffer[cursor++];  									x <<= 4;  									if (c >= '0' && c <= '9') x |= (c - '0');  									else if (c >= 'A' && c <= 'F') x |= (c - 'A');  									else if (c >= 'a' && c <= 'f') x |= (c - 'a');  									else throw SyntaxError("Invalid unicode escape character '{0}' in string literal"' c);  								}  								sb.Append((char) x);  								break;  							}  							default:  							{  								throw SyntaxError("Invalid escape character '{0}' in string literal"' new string(c' 1));  							}  						}  						break;  					}    					default:  					{  						sb.Append(c);  						break;  					}    				}  			}
Magic Number,FoundationDB.Client.Utils,TinyJsonParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\TinyJsonParser.cs,ReadStringLiteral,The following statement contains a magic number: while (cursor < end)  			{  				char c = buffer[cursor++];  				switch (c)  				{  					case '\"':  					{  						m_cursor = cursor;  						return sb.Length == 0 ? String.Empty : sb.ToString();  					}    					case '\\':  					{  						if (cursor >= end) break;  						c = buffer[cursor++];  						switch (c)  						{  							case '\\': sb.Append('\\'); break;  							case 'n': sb.Append('\n'); break;  							case 'r': sb.Append('\r'); break;  							case 't': sb.Append('\t'); break;  							case 'f': sb.Append('\f'); break;  							case 'b': sb.Append('\b'); break;  							case 'u':  							{  								if (cursor + 4 >= end) throw SyntaxError("Truncated unicode escape sequence in string literal");  								int x = 0;  								for (int i = 0; i < 4; i++)  								{  									c = buffer[cursor++];  									x <<= 4;  									if (c >= '0' && c <= '9') x |= (c - '0');  									else if (c >= 'A' && c <= 'F') x |= (c - 'A');  									else if (c >= 'a' && c <= 'f') x |= (c - 'a');  									else throw SyntaxError("Invalid unicode escape character '{0}' in string literal"' c);  								}  								sb.Append((char) x);  								break;  							}  							default:  							{  								throw SyntaxError("Invalid escape character '{0}' in string literal"' new string(c' 1));  							}  						}  						break;  					}    					default:  					{  						sb.Append(c);  						break;  					}    				}  			}
Magic Number,FoundationDB.Client.Utils,SliceBuffer,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\SliceBuffer.cs,Allocate,The following statement contains a magic number: const int ALIGNMENT = 4;
Missing Default,FoundationDB.Async,AsyncPump<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Async\AsyncPump.cs,PumpAsync,The following switch statement is missing a default case: switch (m_state)  				{  					case STATE_WAITING_FOR_NEXT:  					{ // push the info to the called  						try  						{  							m_target.OnError(ExceptionDispatchInfo.Capture(e));  						}  						catch(Exception x)  						{  							LogPump("Failed to notify target of error: " + x.Message);  							throw;  						}  						break;  					}  					case STATE_PUBLISHING_TO_TARGET: // the error comes from the target itself' push back to caller!  					case STATE_FAILED: // we want to notify the caller of some problem  					{  						throw;  					}  				}
Missing Default,FoundationDB.Client.Converters,ComparisonHelper,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,TryAdaptToDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  				{  					case TypeCode.Int16: { result = (short)value; return true; }  					case TypeCode.UInt16: { result = (ushort)value; return true; }  					case TypeCode.Int32: { result = (int)value; return true; }  					case TypeCode.UInt32: { result = (uint)value; return true; }  					case TypeCode.Int64: { result = (long)value; return true; }  					case TypeCode.UInt64: { result = (ulong)value; return true; }  					case TypeCode.Single: { result = (float)value; return true; }  					case TypeCode.Double: { result = (double)value; return true; }  					//TODO: string?  				}
Missing Default,FoundationDB.Client.Converters,ComparisonHelper,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,TryAdaptToInteger,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  				{  					case TypeCode.Int16: { result = (short)value; return true; }  					case TypeCode.UInt16: { result = (ushort)value; return true; }  					case TypeCode.Int32: { result = (int)value; return true; }  					case TypeCode.UInt32: { result = (uint)value; return true; }  					case TypeCode.Int64: { result = (long)value; return true; }  					case TypeCode.UInt64: { result = (long)(ulong)value; return true; }  					case TypeCode.Single: { result = (long)(float)value; return true; }  					case TypeCode.Double: { result = (long)(double)value; return true; }  				}
Missing Default,FoundationDB.Client.Converters,ComparisonHelper,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Converters\ConversionHelper.cs,CreateTypeComparator,The following switch statement is missing a default case: switch (Type.GetTypeCode(t1))  				{  					case TypeCode.Char: return (x' y) => (char)x == (char)y;  					case TypeCode.Byte: return (x' y) => (byte)x == (byte)y;  					case TypeCode.SByte: return (x' y) => (sbyte)x == (sbyte)y;  					case TypeCode.Int16: return (x' y) => (short)x == (short)y;  					case TypeCode.UInt16: return (x' y) => (ushort)x == (ushort)y;  					case TypeCode.Int32: return (x' y) => (int)x == (int)y;  					case TypeCode.UInt32: return (x' y) => (uint)x == (uint)y;  					case TypeCode.Int64: return (x' y) => (long)x == (long)y;  					case TypeCode.UInt64: return (x' y) => (ulong)x == (ulong)y;  					case TypeCode.Single: return (x' y) => (float)x == (float)y;  					case TypeCode.Double: return (x' y) => (double)x == (double)y;  					case TypeCode.String: return (x' y) => (string)x == (string)y;  				}
Missing Default,FoundationDB.Client,Fdb,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Fdb.System.cs,Start,The following switch statement is missing a default case: switch (err)  				{  					case FdbError.ApiVersionNotSupported:  					{ // bad version was selected ?  						// note: we already bound check the values before' so that means that fdb_c.dll is either an older version or an incompatible new version.  						throw new FdbException(err' String.Format("The API version {0} is not supported by the FoundationDB client library (fdb_c.dll) installed on this system. The binding only supports versions {1} to {2}. You either need to upgrade the .NET binding or the FoundationDB client library to a newer version."' apiVersion' GetMinApiVersion()' GetMaxApiVersion()));  					}  #if DEBUG  					case FdbError.ApiVersionAlreadySet:  					{ // Temporary hack to allow multiple debugging using the cached host process in VS  						Console.WriteLine("REUSING EXISTING PROCESS! IF THINGS BREAK IN WEIRD WAYS' PLEASE RESTART THE PROCESS!");  						err = FdbError.Success;  						break;  					}  #endif  				}
Missing Default,FoundationDB.Client,PagingIterator,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbRangeQuery.PagingIterator.cs,FetchNextPageAsync,The following switch statement is missing a default case: switch(m_mode)  				{  					case FdbAsyncMode.Iterator:  					{  						// the caller is responsible for calling MoveNext(..) and deciding if it wants to continue or not..  						options.Mode = FdbStreamingMode.Iterator;  						break;  					}  					case FdbAsyncMode.All:  					{   						// we are in a ToList or ForEach' we want to read everything in as few chunks as possible  						options.Mode = FdbStreamingMode.WantAll;  						break;  					}  					case FdbAsyncMode.Head:  					{  						// the caller only expect one (or zero) values  						options.Mode = FdbStreamingMode.Iterator;  						break;  					}  				}
Missing Default,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following switch statement is missing a default case: switch (mode)  							{  								case PrettyPrintMode.End:  								{ // the last byte will either be FF' or incremented  									// for tuples' the really bad cases are for byte[]/strings (which normally end with 00)  									// => pack(("string"'))+\xFF => <02>string<00><FF>  									// => string(("string"')) => <02>string<01>  									switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}  									break;  								}  								case PrettyPrintMode.Begin:  								{ // the last byte will usually be 00    									// We can't really know if the tuple ended with NULL (serialized to <00>) or if a <00> was added'  									// but since the ToRange() on tuples add a <00> we can bet on the fact that it is not part of the tuple itself.  									// except maybe if we have "00 FF 00" which would be the expected form of a string that ends with a <00>    									if (key.Count > 2 && key[-1] == 0 && key[-2] != 0xFF)  									{  										//***README*** if you break under here' see README in the last catch() block  										tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  										suffix = ".<00>";  									}  									break;  								}  							}
Missing Default,FoundationDB.Client,FdbKey,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\FdbKey.cs,PrettyPrint,The following switch statement is missing a default case: switch (key[-1])  									{  										case 0xFF:  											{  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(key[0' -1]);  												suffix = ".<FF>";  												break;  											}  										case 0x01:  											{  												var tmp = key[0' -1] + (byte)0;  												//***README*** if you break under here' see README in the last catch() block  												tuple = FoundationDB.Layers.Tuples.FdbTuple.Unpack(tmp);  												suffix = " + 1";  												break;  											}  									}
Missing Default,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,TryParse,The following switch statement is missing a default case: switch (s.Length)  			{  				case 19:  				{ // {xxxxxxxx-xxxxxxxx}  					if (s[0] != '{' || s[18] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' true' out result);  				}  				case 18:  				{ // {xxxxxxxxxxxxxxxx}  					if (s[0] != '{' || s[17] != '}')  					{  						return false;  					}  					return TryDecode16(s.ToCharArray()' 1' false' out result);  				}  				case 17:  				{ // xxxxxxxx-xxxxxxxx  					if (s[8] != '-') return false;  					return TryDecode16(s.ToCharArray()' 0' true' out result);  				}  				case 16:  				{ // xxxxxxxxxxxxxxxx  					return TryDecode16(s.ToCharArray()' 0' false' out result);  				}  			}
Missing Default,FoundationDB.Client,Uuid64,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Uuid64.cs,ToString,The following switch statement is missing a default case: switch(format)  			{  				case "D":  				{ // Default format is "xxxxxxxx-xxxxxxxx"  					return Encode16(m_value' separator: true' quotes: false' upper: true);  				}  				case "d":  				{ // Default format is "xxxxxxxx-xxxxxxxx"  					return Encode16(m_value' separator: true' quotes: false' upper: false);  				}    				case "C":  				case "c":  				{ // base 62' compact' no padding  					return Encode62(m_value' padded: false);  				}  				case "Z":  				case "z":  				{ // base 62' padded with '0' up to 11 chars  					return Encode62(m_value' padded: true);  				}    				case "R":  				case "r":  				{ // Integer: "1234567890"  					return m_value.ToString(null' formatProvider ?? CultureInfo.InvariantCulture);  				}    				case "X": //TODO: Guid.ToString("X") returns "{0x.....'0x.....'...}"  				case "N":  				{ // "XXXXXXXXXXXXXXXX"  					return Encode16(m_value' separator: false' quotes: false' upper: true);  				}  				case "x": //TODO: Guid.ToString("X") returns "{0x.....'0x.....'...}"  				case "n":  				{ // "xxxxxxxxxxxxxxxx"  					return Encode16(m_value' separator: false' quotes: false' upper: false);  				}    				case "B":  				{ // "{xxxxxxxx-xxxxxxxx}"  					return Encode16(m_value' separator: true' quotes: true' upper: true);  				}  				case "b":  				{ // "{xxxxxxxx-xxxxxxxx}"  					return Encode16(m_value' separator: true' quotes: true' upper: false);  				}  			}
Missing Default,FoundationDB.Client,Slice,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Utils\Slice.cs,ToUuid64,The following switch statement is missing a default case: switch (this.Count)  			{  				case 8:  				{ // binary (8 bytes)  					return new Uuid64(this);  				}    				case 16: // hex16  				case 17: // hex8-hex8  				case 19: // {hex8-hex8}  				{  					return Uuid64.Parse(this.ToAscii());  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTupleParser,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleParser.cs,ParseNext,The following switch statement is missing a default case: switch (type)  			{  				case -1:  				{ // End of Stream  					return Slice.Nil;  				}    				case FdbTupleTypes.Nil:  				{ // <00> / <00><FF> => null  					if (reader.Depth > 0)  					{ // must be <00><FF> inside an embedded tuple  						if (reader.Input.PeekByteAt(1) == 0xFF)  						{ // this is a Nil entry  							reader.Input.Skip(2);  							return Slice.Empty;  						}  						else  						{ // this is the end of the embedded tuple  							reader.Input.Skip(1);  							return Slice.Nil;  						}  					}  					else  					{ // can be <00> outside an embedded tuple  						reader.Input.Skip(1);  						return Slice.Empty;  					}  				}    				case FdbTupleTypes.Bytes:  				{ // <01>(bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.Utf8:  				{ // <02>(utf8 bytes)<00>  					return reader.Input.ReadByteString();  				}    				case FdbTupleTypes.TupleStart:  				{ // <03>(packed tuple)<04>    					//PERF: currently' we will first scan to get all the bytes of this tuple' and parse it later.  					// This means that we may need to scan multiple times the bytes' which may not be efficient if there are multiple embedded tuples inside each other  					return ReadEmbeddedTupleBytes(ref reader);  				}  				case FdbTupleTypes.Single:  				{ // <20>(4 bytes)  					return reader.Input.ReadBytes(5);  				}    				case FdbTupleTypes.Double:  				{ // <21>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.Uuid128:  				{ // <30>(16 bytes)  					return reader.Input.ReadBytes(17);  				}    				case FdbTupleTypes.Uuid64:  				{ // <31>(8 bytes)  					return reader.Input.ReadBytes(9);  				}    				case FdbTupleTypes.AliasDirectory:  				case FdbTupleTypes.AliasSystem:  				{ // <FE> or <FF>  					return reader.Input.ReadBytes(1);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTupleTypes,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTupleTypes.cs,DecodeSegmentType,The following switch statement is missing a default case: switch(type)  			{  				case Nil: return FdbTupleSegmentType.Nil;  				case Bytes: return FdbTupleSegmentType.ByteString;  				case Utf8: return FdbTupleSegmentType.UnicodeString;  				case TupleStart: return FdbTupleSegmentType.Tuple;  				case Single: return FdbTupleSegmentType.Single;  				case Double: return FdbTupleSegmentType.Double;  				case Uuid128: return FdbTupleSegmentType.Uuid128;  				case Uuid64: return FdbTupleSegmentType.Uuid64;  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,SerializeObjectTo,The following switch statement is missing a default case: switch (Type.GetTypeCode(value.GetType()))  			{  				case TypeCode.Empty:  				case TypeCode.Object:  				{  					byte[] bytes = value as byte[];  					if (bytes != null)  					{  						SerializeTo(ref writer' bytes);  						return;  					}    					if (value is Slice)  					{  						SerializeTo(ref writer' (Slice)value);  						return;  					}    					if (value is Guid)  					{  						SerializeTo(ref writer' (Guid)value);  						return;  					}    					if (value is Uuid128)  					{  						SerializeTo(ref writer' (Uuid128)value);  						return;  					}    					if (value is Uuid64)  					{  						SerializeTo(ref writer' (Uuid64)value);  						return;  					}    					if (value is TimeSpan)  					{  						SerializeTo(ref writer' (TimeSpan)value);  						return;  					}    					if (value is FdbTupleAlias)  					{  						SerializeTo(ref writer' (FdbTupleAlias)value);  						return;  					}    					break;  				}  				case TypeCode.DBNull:  				{ // same as null  					FdbTupleParser.WriteNil(ref writer);  					return;  				}  				case TypeCode.Boolean:  				{  					SerializeTo(ref writer' (bool)value);  					return;  				}  				case TypeCode.Char:  				{  					// should be treated as a string with only one char  					SerializeTo(ref writer' (char)value);  					return;  				}  				case TypeCode.SByte:  				{  					SerializeTo(ref writer' (sbyte)value);  					return;  				}  				case TypeCode.Byte:  				{  					SerializeTo(ref writer' (byte)value);  					return;  				}  				case TypeCode.Int16:  				{  					SerializeTo(ref writer' (short)value);  					return;  				}  				case TypeCode.UInt16:  				{  					SerializeTo(ref writer' (ushort)value);  					return;  				}  				case TypeCode.Int32:  				{  					SerializeTo(ref writer' (int)value);  					return;  				}  				case TypeCode.UInt32:  				{  					SerializeTo(ref writer' (uint)value);  					return;  				}  				case TypeCode.Int64:  				{  					SerializeTo(ref writer' (long)value);  					return;  				}  				case TypeCode.UInt64:  				{  					SerializeTo(ref writer' (ulong)value);  					return;  				}  				case TypeCode.String:  				{  					SerializeTo(ref writer' value as string);  					return;  				}  				case TypeCode.DateTime:  				{  					SerializeTo(ref writer' (DateTime)value);  					return;  				}  				case TypeCode.Double:  				{  					SerializeTo(ref writer' (double)value);  					return;  				}  				case TypeCode.Single:  				{  					SerializeTo(ref writer' (float)value);  					return;  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeBoxed,The following switch statement is missing a default case: switch (type)  				{  					case FdbTupleTypes.Nil: return null;  					case FdbTupleTypes.Bytes: return FdbTupleParser.ParseBytes(slice);  					case FdbTupleTypes.Utf8: return FdbTupleParser.ParseUnicode(slice);  					case FdbTupleTypes.TupleStart: return FdbTupleParser.ParseTuple(slice);  				}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeBoxed,The following switch statement is missing a default case: switch (type)  				{  					case FdbTupleTypes.Single: return FdbTupleParser.ParseSingle(slice);  					case FdbTupleTypes.Double: return FdbTupleParser.ParseDouble(slice);  					case FdbTupleTypes.Uuid128: return FdbTupleParser.ParseGuid(slice);  					case FdbTupleTypes.Uuid64: return FdbTupleParser.ParseUuid64(slice);  					case FdbTupleTypes.AliasDirectory: return FdbTupleAlias.Directory;  					case FdbTupleTypes.AliasSystem: return FdbTupleAlias.System;  				}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeSlice,The following switch statement is missing a default case: switch(type)  			{  				case FdbTupleTypes.Nil: return Slice.Nil;  				case FdbTupleTypes.Bytes: return FdbTupleParser.ParseBytes(slice);  				case FdbTupleTypes.Utf8: return Slice.FromString(FdbTupleParser.ParseUnicode(slice));    				case FdbTupleTypes.Single: return Slice.FromSingle(FdbTupleParser.ParseSingle(slice));  				case FdbTupleTypes.Double: return Slice.FromDouble(FdbTupleParser.ParseDouble(slice));    				case FdbTupleTypes.Uuid128: return Slice.FromGuid(FdbTupleParser.ParseGuid(slice));  				case FdbTupleTypes.Uuid64: return Slice.FromUuid64(FdbTupleParser.ParseUuid64(slice));  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeTuple,The following switch statement is missing a default case: switch(type)  			{  				case FdbTupleTypes.Nil:  				{  					return null;  				}  				case FdbTupleTypes.Bytes:  				{  					return FdbTuple.Unpack(FdbTupleParser.ParseBytes(slice));  				}  				case FdbTupleTypes.TupleStart:  				{  					return FdbTupleParser.ParseTuple(slice);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeBoolean,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{ // empty is false' all other is true  					return slice.Count != 2; // <01><00>  				}  				case FdbTupleTypes.Utf8:  				{// empty is false' all other is true  					return slice.Count != 2; // <02><00>  				}  				case FdbTupleTypes.Single:  				{  					//TODO: should NaN considered to be false ?  					return 0f != FdbTupleParser.ParseSingle(slice);  				}  				case FdbTupleTypes.Double:  				{  					//TODO: should NaN considered to be false ?  					return 0f != FdbTupleParser.ParseDouble(slice);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeInt64,The following switch statement is missing a default case: switch (type)  				{  					case FdbTupleTypes.Nil: return 0;  					case FdbTupleTypes.Bytes: return long.Parse(FdbTupleParser.ParseAscii(slice)' CultureInfo.InvariantCulture);  					case FdbTupleTypes.Utf8: return long.Parse(FdbTupleParser.ParseUnicode(slice)' CultureInfo.InvariantCulture);  				}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeUInt64,The following switch statement is missing a default case: switch (type)  				{  					case FdbTupleTypes.Nil: return 0;  					case FdbTupleTypes.Bytes: return ulong.Parse(FdbTupleParser.ParseAscii(slice)' CultureInfo.InvariantCulture);  					case FdbTupleTypes.Utf8: return ulong.Parse(FdbTupleParser.ParseUnicode(slice)' CultureInfo.InvariantCulture);  				}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeSingle,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Nil:  				{  					return 0;  				}  				case FdbTupleTypes.Utf8:  				{  					return Single.Parse(FdbTupleParser.ParseUnicode(slice)' CultureInfo.InvariantCulture);  				}  				case FdbTupleTypes.Single:  				{  					return FdbTupleParser.ParseSingle(slice);  				}  				case FdbTupleTypes.Double:  				{  					return (float)FdbTupleParser.ParseDouble(slice);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeDouble,The following switch statement is missing a default case: switch(type)  			{  				case FdbTupleTypes.Nil:  				{  					return 0;  				}  				case FdbTupleTypes.Utf8:  				{  					return Double.Parse(FdbTupleParser.ParseUnicode(slice)' CultureInfo.InvariantCulture);  				}  				case FdbTupleTypes.Single:  				{  					return (double)FdbTupleParser.ParseSingle(slice);  				}  				case FdbTupleTypes.Double:  				{  					return FdbTupleParser.ParseDouble(slice);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeDateTime,The following switch statement is missing a default case: switch(type)  			{  				case FdbTupleTypes.Nil:  				{  					return DateTime.MinValue;  				}    				case FdbTupleTypes.Utf8:  				{ // we only support ISO 8601 dates. For ex: YYYY-MM-DDTHH:MM:SS.fffff"  					string str = FdbTupleParser.ParseUnicode(slice);  					return DateTime.Parse(str' CultureInfo.InvariantCulture' DateTimeStyles.RoundtripKind);  				}    				case FdbTupleTypes.Double:  				{ // Number of days since Epoch  					const long UNIX_EPOCH_TICKS = 621355968000000000L;  					//note: we can't user TimeSpan.FromDays(...) because it rounds to the nearest millisecond!  					long ticks = UNIX_EPOCH_TICKS + (long)(FdbTupleParser.ParseDouble(slice) * TimeSpan.TicksPerDay);  					return new DateTime(ticks' DateTimeKind.Utc);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeTimeSpan,The following switch statement is missing a default case: switch(type)  			{  				case FdbTupleTypes.Nil:  				{  					return TimeSpan.Zero;  				}  				case FdbTupleTypes.Utf8:  				{ // "HH:MM:SS.fffff"  					return TimeSpan.Parse(FdbTupleParser.ParseUnicode(slice)' CultureInfo.InvariantCulture);  				}  				case FdbTupleTypes.Double:  				{ // Number of seconds  					//note: We can't use TimeSpan.FromSeconds(...) because it rounds to the nearest millisecond!  					return new TimeSpan((long)(FdbTupleParser.ParseDouble(slice) * (double)TimeSpan.TicksPerSecond));  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeString,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Nil:  				{  					return null;  				}  				case FdbTupleTypes.Bytes:  				{  					return FdbTupleParser.ParseAscii(slice);  				}  				case FdbTupleTypes.Utf8:  				{  					return FdbTupleParser.ParseUnicode(slice);  				}  				case FdbTupleTypes.Single:  				{  					return FdbTupleParser.ParseSingle(slice).ToString(CultureInfo.InvariantCulture);  				}  				case FdbTupleTypes.Double:  				{  					return FdbTupleParser.ParseDouble(slice).ToString(CultureInfo.InvariantCulture);  				}  				case FdbTupleTypes.Uuid128:  				{  					return FdbTupleParser.ParseGuid(slice).ToString();  				}  				case FdbTupleTypes.Uuid64:  				{  					return FdbTupleParser.ParseUuid64(slice).ToString();  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeGuid,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{  					return Guid.Parse(FdbTupleParser.ParseAscii(slice));  				}  				case FdbTupleTypes.Utf8:  				{  					return Guid.Parse(FdbTupleParser.ParseUnicode(slice));  				}  				case FdbTupleTypes.Uuid128:  				{  					return FdbTupleParser.ParseGuid(slice);  				}  				//REVIEW: should we allow converting a Uuid64 into a Guid? This looks more like a bug than an expected behavior...  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeUuid128,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{ // expect binary representation as a 16-byte array  					return new Uuid128(FdbTupleParser.ParseBytes(slice));  				}  				case FdbTupleTypes.Utf8:  				{ // expect text representation  					return new Uuid128(FdbTupleParser.ParseUnicode(slice));  				}  				case FdbTupleTypes.Uuid128:  				{  					return FdbTupleParser.ParseUuid128(slice);  				}  				//REVIEW: should we allow converting a Uuid64 into a Uuid128? This looks more like a bug than an expected behavior...  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeUuid64,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{ // expect binary representation as a 16-byte array  					return new Uuid64(FdbTupleParser.ParseBytes(slice));  				}  				case FdbTupleTypes.Utf8:  				{ // expect text representation  					return new Uuid64(FdbTupleParser.ParseUnicode(slice));  				}  				case FdbTupleTypes.Uuid64:  				{  					return FdbTupleParser.ParseUuid64(slice);  				}  			}
Missing Default,FoundationDB.Layers.Tuples,FdbTuplePackers,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Layers\Tuples\FdbTuplePackers.cs,DeserializeIPAddress,The following switch statement is missing a default case: switch (type)  			{  				case FdbTupleTypes.Bytes:  				{  					return new System.Net.IPAddress(FdbTupleParser.ParseBytes(slice).GetBytes());  				}  				case FdbTupleTypes.Utf8:  				{  					return System.Net.IPAddress.Parse(FdbTupleParser.ParseUnicode(slice));  				}  				case FdbTupleTypes.Uuid128:  				{ // could be an IPv6 encoded as a 128-bits UUID  					return new System.Net.IPAddress(slice.GetBytes());  				}  			}
Missing Default,FoundationDB.Filters.Logging,FdbTransactionLog,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Client\Filters\Logging\FdbTransactionLog.Commands.cs,GetCommandsReport,The following switch statement is missing a default case: switch (cmd.Mode)  				{  					case FdbTransactionLog.Mode.Read: ++reads; break;  					case FdbTransactionLog.Mode.Write: ++writes; break;  				}
