Implementation smell,Namespace,Class,File,Method,Description
Long Method,FoundationDB.Layers.Collections,FdbQueue<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbQueue`1.cs,PopHighContentionAsync,The method has 107 lines of code.
Long Parameter List,FoundationDB.Layers.Collections,FdbMap<TKey;TValue>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbMap`2.cs,AggregateAsync,The method has 5 parameters. Parameters: db' init' handler' finish' cancellationToken
Long Parameter List,FoundationDB.Layers.Collections,FdbMap<TKey;TValue>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbMap`2.cs,ImportAsync,The method has 5 parameters. Parameters: db' items' keySelector' valueSelector' cancellationToken
Long Parameter List,FoundationDB.Layers.Indexing,FdbIndex<TId;TValue>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Indexes\FdbIndex`2.cs,FdbIndex,The method has 5 parameters. Parameters: name' subspace' valueComparer' indexNullValues' encoder
Long Statement,FoundationDB.Layers.Collections,FdbMultiMap<TKey;TValue>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbMultimap`2.cs,SubtractAsync,The length of the statement  "					//note: since we already read 'k'' the AtomicAdd will be optimized into the equivalent of Set(k' v - 1) by the client' unless RYW has been disabled on the transaction " is 166.
Long Statement,FoundationDB.Layers.Collections,FdbVector<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbVector`1.cs,SwapAsync,The length of the statement  "			if (index1 < 0 || index2 < 0) throw new IndexOutOfRangeException(String.Format("Indices ({0}' {1}) must be positive"' index1' index2)); " is 135.
Long Statement,FoundationDB.Layers.Collections,FdbVector<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbVector`1.cs,SwapAsync,The length of the statement  "			if (index1 >= currentSize || index2 >= currentSize) throw new IndexOutOfRangeException(String.Format("Indices ({0}' {1}) are out of range"' index1' index2)); " is 157.
Long Statement,FoundationDB.Layers.Counters,FdbHighContentionCounter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Counters\FdbHighContentionCounter.cs,Coalesce,The length of the statement  "						// note: contrary to the python impl' we will await the commit' and rely on the caller to not wait to the Coalesce task itself to complete. " is 139.
Long Statement,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,FindUidAsync,The length of the statement  "				// note: we diverge from the python sample layer by not expanding the size at each retry' in order to ensure that value size keeps as small as possible " is 151.
Long Statement,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,InternSlowAsync,The length of the statement  "				if (uid.IsNull) throw new InvalidOperationException("Failed to allocate a new uid while attempting to intern a string"); " is 120.
Long Statement,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,LookupSlowAsync,The length of the statement  "			//BUGBUG: if the uid has just been Interned in the current transaction' and if the transaction fails to commit (conflict' ...) we will insert a bad value in the cache! " is 167.
Magic Number,FoundationDB.Layers.Collections,FdbVector<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbVector`1.cs,PopAsync,The following statement contains a magic number: var lastTwo = await tr  				.GetRange(keyRange' new FdbRangeOptions { Reverse = true' Limit = 2 })  				.ToListAsync()  				.ConfigureAwait(false);
Magic Number,FoundationDB.Layers.Collections,FdbQueue<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbQueue`1.cs,RandId,The following statement contains a magic number: lock (this.Rng)  			{  				return Slice.Random(this.Rng' 20);  			}
Magic Number,FoundationDB.Layers.Collections,FdbQueue<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbQueue`1.cs,FulfillConflictedPops,The following statement contains a magic number: const int numPops = 100;
Magic Number,FoundationDB.Layers.Collections,FdbQueue<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbQueue`1.cs,PopHighContentionAsync,The following statement contains a magic number: int backOff = 10;
Magic Number,FoundationDB.Layers.Collections,FdbQueue<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbQueue`1.cs,PopHighContentionAsync,The following statement contains a magic number: using (var tr = db.BeginTransaction(ct))  			{  #if DEBUG  				tr.Annotate("PopHighContention()");  #endif    				FdbException error = null;  				try  				{  					// Check if there are other people waiting to be popped. If so' we cannot pop before them.  					waitKey = await AddConflictedPopAsync(tr' forced: false).ConfigureAwait(false);  					if (waitKey.IsNull)  					{ // No one else was waiting to be popped  						var item = await PopSimpleAsync(tr).ConfigureAwait(false);  						await tr.CommitAsync().ConfigureAwait(false);  						return item;  					}  					else  					{  						await tr.CommitAsync().ConfigureAwait(false);  					}  				}  				catch (FdbException e)  				{  					// note: cannot await inside a catch(..) block' so flag the error and process it below  					error = e;  				}    				if (error != null)  				{ // If we didn't succeed' then register our pop request  					waitKey = await AddConflictedPopAsync(db' forced: true' ct: ct).ConfigureAwait(false);  				}    				// The result of the pop will be stored at this key once it has been fulfilled  				var resultKey = ConflictedItemKey(this.ConflictedPop.Keys.DecodeLast<Slice>(waitKey));    				tr.Reset();    				// Attempt to fulfill outstanding pops and then poll the database   				// checking if we have been fulfilled    				while (!ct.IsCancellationRequested)  				{  					error = null;  					try  					{  						while (!(await FulfillConflictedPops(db' ct).ConfigureAwait(false)))  						{  							//NOP ?  						}  					}  					catch (FdbException e)  					{  						// cannot await in catch(..) block so process it below  						error = e;  					}    					if (error != null && error.Code != FdbError.NotCommitted)  					{  						// If the error is 1020 (not_committed)' then there is a good chance   						// that somebody else has managed to fulfill some outstanding pops. In  						// that case' we proceed to check whether our request has been fulfilled.  						// Otherwise' we handle the error in the usual fashion.    						await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  						continue;  					}    					error = null;  					try  					{  						tr.Reset();    						var sw = System.Diagnostics.Stopwatch.StartNew();    						var tmp = await tr.GetValuesAsync(new Slice[] { waitKey' resultKey }).ConfigureAwait(false);  						var value = tmp[0];  						var result = tmp[1];    						// If waitKey is present' then we have not been fulfilled  						if (value.HasValue)  						{  #if DEBUG  							tr.Annotate("Wait {0} ms : {1} / {2}"' backOff' Environment.TickCount' sw.ElapsedTicks);  #endif  							//TODO: we should rewrite this using Watches !  							await Task.Delay(backOff' ct).ConfigureAwait(false);  #if DEBUG  							tr.Annotate("After wait : {0} / {1}"' Environment.TickCount' sw.ElapsedTicks);  #endif  							backOff = Math.Min(1000' backOff * 2);  							continue;  						}    						if (result.IsNullOrEmpty)  						{  							return default(Optional<T>);  						}    						tr.Clear(resultKey);  						await tr.CommitAsync().ConfigureAwait(false);  						return this.Encoder.DecodeValue(result);    					}  					catch (FdbException e)  					{  						error = e;  					}    					if (error != null)  					{  						await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  					}  				}    				ct.ThrowIfCancellationRequested();  				// make the compiler happy  				throw new InvalidOperationException();  			}
Magic Number,FoundationDB.Layers.Collections,FdbQueue<T>,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Collections\FdbQueue`1.cs,PopHighContentionAsync,The following statement contains a magic number: using (var tr = db.BeginTransaction(ct))  			{  #if DEBUG  				tr.Annotate("PopHighContention()");  #endif    				FdbException error = null;  				try  				{  					// Check if there are other people waiting to be popped. If so' we cannot pop before them.  					waitKey = await AddConflictedPopAsync(tr' forced: false).ConfigureAwait(false);  					if (waitKey.IsNull)  					{ // No one else was waiting to be popped  						var item = await PopSimpleAsync(tr).ConfigureAwait(false);  						await tr.CommitAsync().ConfigureAwait(false);  						return item;  					}  					else  					{  						await tr.CommitAsync().ConfigureAwait(false);  					}  				}  				catch (FdbException e)  				{  					// note: cannot await inside a catch(..) block' so flag the error and process it below  					error = e;  				}    				if (error != null)  				{ // If we didn't succeed' then register our pop request  					waitKey = await AddConflictedPopAsync(db' forced: true' ct: ct).ConfigureAwait(false);  				}    				// The result of the pop will be stored at this key once it has been fulfilled  				var resultKey = ConflictedItemKey(this.ConflictedPop.Keys.DecodeLast<Slice>(waitKey));    				tr.Reset();    				// Attempt to fulfill outstanding pops and then poll the database   				// checking if we have been fulfilled    				while (!ct.IsCancellationRequested)  				{  					error = null;  					try  					{  						while (!(await FulfillConflictedPops(db' ct).ConfigureAwait(false)))  						{  							//NOP ?  						}  					}  					catch (FdbException e)  					{  						// cannot await in catch(..) block so process it below  						error = e;  					}    					if (error != null && error.Code != FdbError.NotCommitted)  					{  						// If the error is 1020 (not_committed)' then there is a good chance   						// that somebody else has managed to fulfill some outstanding pops. In  						// that case' we proceed to check whether our request has been fulfilled.  						// Otherwise' we handle the error in the usual fashion.    						await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  						continue;  					}    					error = null;  					try  					{  						tr.Reset();    						var sw = System.Diagnostics.Stopwatch.StartNew();    						var tmp = await tr.GetValuesAsync(new Slice[] { waitKey' resultKey }).ConfigureAwait(false);  						var value = tmp[0];  						var result = tmp[1];    						// If waitKey is present' then we have not been fulfilled  						if (value.HasValue)  						{  #if DEBUG  							tr.Annotate("Wait {0} ms : {1} / {2}"' backOff' Environment.TickCount' sw.ElapsedTicks);  #endif  							//TODO: we should rewrite this using Watches !  							await Task.Delay(backOff' ct).ConfigureAwait(false);  #if DEBUG  							tr.Annotate("After wait : {0} / {1}"' Environment.TickCount' sw.ElapsedTicks);  #endif  							backOff = Math.Min(1000' backOff * 2);  							continue;  						}    						if (result.IsNullOrEmpty)  						{  							return default(Optional<T>);  						}    						tr.Clear(resultKey);  						await tr.CommitAsync().ConfigureAwait(false);  						return this.Encoder.DecodeValue(result);    					}  					catch (FdbException e)  					{  						error = e;  					}    					if (error != null)  					{  						await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  					}  				}    				ct.ThrowIfCancellationRequested();  				// make the compiler happy  				throw new InvalidOperationException();  			}
Magic Number,FoundationDB.Layers.Counters,FdbHighContentionCounter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Counters\FdbHighContentionCounter.cs,RandomId,The following statement contains a magic number: lock (this.Rng) //note: the Rng is not thread-safe  			{  				return Slice.Random(this.Rng' 20);  			}
Magic Number,FoundationDB.Layers.Counters,FdbHighContentionCounter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Counters\FdbHighContentionCounter.cs,Coalesce,The following statement contains a magic number: using (var tr = this.Database.BeginTransaction(ct))  			{  				try  				{  					// read N writes from a random place in ID space  					var loc = this.Subspace.Keys.Encode(RandomId());    					bool right;  					lock(this.Rng) { right = this.Rng.NextDouble() < 0.5; }  					var query = right  						? tr.Snapshot.GetRange(loc' this.Subspace.Keys.ToRange().End' limit: N' reverse: false)  						: tr.Snapshot.GetRange(this.Subspace.Keys.ToRange().Begin' loc' limit: N' reverse: true);  					var shards = await query.ToListAsync().ConfigureAwait(false);    					if (shards.Count > 0)  					{  						// remove read shards transaction  						foreach (var shard in shards)  						{  							checked { total += this.Encoder.DecodeValue(shard.Value); }  							await tr.GetAsync(shard.Key).ConfigureAwait(false); // real read for isolation  							tr.Clear(shard.Key);  						}    						tr.Set(this.Subspace.Keys.Encode(RandomId())' this.Encoder.EncodeValue(total));    						// note: contrary to the python impl' we will await the commit' and rely on the caller to not wait to the Coalesce task itself to complete.  						// That way' the transaction will live as long as the task' and we ensure that it gets disposed at some time  						await tr.CommitAsync().ConfigureAwait(false);  					}  				}  				catch (FdbException x)  				{  					//TODO: logging ?  					System.Diagnostics.Debug.WriteLine("Coalesce error: " + x.Message);  					return;  				}  			}
Magic Number,FoundationDB.Layers.Counters,FdbHighContentionCounter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Counters\FdbHighContentionCounter.cs,Add,The following statement contains a magic number: lock (this.Rng) { coalesce = this.Rng.NextDouble() < 0.1; }
Magic Number,FoundationDB.Layers.Counters,FdbHighContentionCounter,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Counters\FdbHighContentionCounter.cs,Add,The following statement contains a magic number: if (coalesce)  			{  				//REVIEW: 20 is too small if there is a lot of activity on the counter !  				BackgroundCoalesce(20' CancellationToken.None);  			}
Magic Number,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,EvictCache,The following statement contains a magic number: try  			{  				if (m_uidsInCache.Count == 0)  				{  					//note: there is probably a desync between the content of the cache' and the value of m_bytesCached !  					throw new InvalidOperationException("Cannot evict from empty cache");  				}    				// Random eviction  				// note: Random is not thread-safe' but we are in a write-lock so we are ok  				int i = m_rnd.Next(m_uidsInCache.Count);    				// remove from uids_in_cache  				var uidKey = m_uidsInCache[i];  				m_uidsInCache[i] = m_uidsInCache[m_uidsInCache.Count - 1];  				m_uidsInCache.RemoveAt(m_uidsInCache.Count - 1);    				// remove from caches' account for bytes  				string value;  				if (!m_uidStringCache.TryGetValue(uidKey' out value) || value == null)  				{  					throw new InvalidOperationException("Error in cache evication: string not found");  				}    				m_uidStringCache.Remove(uidKey);  				m_stringUidCache.Remove(value);    				// tries to get an accurante idea of the in-memory size: chars are 2-byte in .NET' but the UID key is 1-byte  				int size = checked ((value.Length * 2) + uidKey.Slice.Count);  				Interlocked.Add(ref m_bytesCached' -size);  			}  			finally  			{  				m_lock.ExitWriteLock();  			}
Magic Number,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,AddToCache,The following statement contains a magic number: try  			{  				if (!m_uidStringCache.ContainsKey(uidKey))  				{    					m_lock.EnterWriteLock();  					try  					{  						m_stringUidCache[value] = uidKey;  						m_uidStringCache[uidKey] = value;  						m_uidsInCache.Add(uidKey);  					}  					finally  					{  						m_lock.ExitWriteLock();  					}    					int size = (value.Length * 2) + uidKey.Slice.Count;  					Interlocked.Add(ref m_bytesCached' size);    				}  			}  			finally  			{  				m_lock.ExitUpgradeableReadLock();  			}
Magic Number,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,FindUidAsync,The following statement contains a magic number: const int MAX_TRIES = 256;
Magic Number,FoundationDB.Layers.Interning,FdbStringIntern,C:\repos\Doxense_foundationdb-dotnet-client\FoundationDB.Layers.Common\Interning\FdbStringIntern.cs,FindUidAsync,The following statement contains a magic number: while (tries < MAX_TRIES)  			{  				// note: we diverge from the python sample layer by not expanding the size at each retry' in order to ensure that value size keeps as small as possible  				Slice slice;  				lock (m_prng)  				{ // note: not all PRNG implementations are thread-safe !  					slice = Slice.Random(m_prng' 4 + (tries >> 1));  				}    				if (m_uidStringCache.ContainsKey(new Uid(slice)))  					continue;    				var candidate = await trans.GetAsync(UidKey(slice)).ConfigureAwait(false);  				if (candidate.IsNull)  					return slice;    				++tries;  			}
