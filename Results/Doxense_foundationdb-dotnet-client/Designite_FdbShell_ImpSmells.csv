Implementation smell,Namespace,Class,File,Method,Description
Long Method,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The method has 134 lines of code.
Long Method,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The method has 383 lines of code.
Complex Method,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,Cyclomatic complexity of the method is 9
Complex Method,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,Cyclomatic complexity of the method is 8
Complex Method,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,Cyclomatic complexity of the method is 11
Complex Method,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,Cyclomatic complexity of the method is 12
Complex Method,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,Cyclomatic complexity of the method is 82
Complex Method,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,Cyclomatic complexity of the method is 12
Complex Method,Mono.Options,StringCoda,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,CreateWrappedLinesIterator,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,AddSeparators,Cyclomatic complexity of the method is 17
Complex Method,Mono.Options,ArgumentSource,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetArguments,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseBundledValue,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetDescription,Cyclomatic complexity of the method is 20
Complex Method,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,CmdTabOrComplete,Cyclomatic complexity of the method is 14
Complex Method,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,WordForward,Cyclomatic complexity of the method is 8
Complex Method,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,WordBackward,Cyclomatic complexity of the method is 8
Complex Method,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,EditLoop,Cyclomatic complexity of the method is 10
Long Parameter List,FdbShell,FdbCliCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\FdbCliCommands.cs,RunFdbCliCommand,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The method has 6 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,CreateDirectory,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,RemoveDirectory,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,MoveDirectory,The method has 6 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ShowDirectoryLayer,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ChangeDirectoryLayer,The method has 6 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Count,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,The method has 6 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Tree,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Shards,The method has 5 parameters.
Long Parameter List,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The method has 5 parameters.
Long Parameter List,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetOptionParts,The method has 5 parameters.
Long Parameter List,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteDescription,The method has 5 parameters.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "						log.WriteLine ("  {0'-12} {1'-12} {3'9:N0} {2}"' FdbKey.Dump (FdbSubspace.Copy (subfolder).Key)' subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode () + ">")' name' count); " is 192.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "						log.WriteLine ("  {0'-12} {1'-12} {3'9} {2}"' FdbKey.Dump (FdbSubspace.Copy (subfolder).Key)' subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode () + ">")' name' "-"); " is 187.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "					log.WriteLine ("  {0'-12} {1'-12} {2}"' FdbKey.Dump (FdbSubspace.Copy (subfolder).Key)' subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode () + ">")' name); " is 176.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,CreateDirectory,The length of the statement  "	var stuff = await db.ReadAsync (tr => tr.GetRange (folder.Keys.ToRange ()).FirstOrDefaultAsync ()' cancellationToken: ct); " is 122.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,RemoveDirectory,The length of the statement  "		log.WriteLine ("# Cannot remove {0} because it still contains {1} sub-directorie(s)"' string.Join ("/"' path)' subDirs.Count); " is 126.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The length of the statement  "		stream.WriteLine (sb.ToString () + (folder.Layer.ToString () == "partition" ? ("<" + folder.Name + ">") : folder.Name) + (folder.Layer.IsNullOrEmpty ? String.Empty : (" [" + folder.Layer.ToString () + "]"))); " is 208.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "	// we want to merge the map of shards' with the map of directories from the Directory Layer' and count for each directory how many shards intersect " is 147.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "	// note: this may break in future versions of the DL! Maybe we need a custom API to get a flat list of all directories in a DL that span a specific range ? " is 155.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "			var kvs = await Task.WhenAll (tr.GetRange (FdbKeyRange.StartsWith (key)).FirstOrDefaultAsync ()' tr.GetRange (FdbKeyRange.StartsWith (key)).LastOrDefaultAsync ()); " is 163.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "		log.WriteLine ("{0'6} {1'-20} {2}"' kvp.Value' RobustHistogram.FormatHistoBar ((double)kvp.Value / foundShards' 20)' kvp.Key); " is 126.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "		log.WriteLine ("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards); " is 166.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "	var servers = await db.QueryAsync (tr => tr.WithReadAccessToSystemKeys ().GetRange (FdbKeyRange.StartsWith (Fdb.System.ServerList)).Select (kvp => new { " is 152.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "			log.WriteLine (dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First ().Parts [0].Address' machineId); " is 127.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "				log.WriteLine (machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts [0].Address' proc.Parts [0].Port' proc.ProcessId); " is 147.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "				//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4); " is 165.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Shards,The length of the statement  "			//TODO: we can probably get more details on this shard looking in the system keyspace (where it is' how many replicas' ...) " is 123.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "		log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ..."); " is 154.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "						log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median))); " is 316.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "		log.WriteLine ("Sampled " + FormatSize (globalSize) + " (" + globalSize.ToString ("N0") + " bytes) and " + globalCount.ToString ("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString ("N1") + " sec"); " is 201.
Long Statement,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "		log.WriteLine ("Found " + FormatSize (globalSize) + " (" + globalSize.ToString ("N0") + " bytes) and " + globalCount.ToString ("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString ("N1") + " sec"); " is 199.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The length of the statement  "	stream.WriteLine ("# Local Time: " + DateTime.Now.ToString ("O") + " (" + localTime + " local) - Universal Time: " + DateTime.UtcNow.ToString ("O") + " ( " + utcTime + " UTC)"); " is 177.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "					var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult (); " is 128.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "					res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray (); " is 154.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "			res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray (); " is 137.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "				await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel); " is 141.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "				await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel); " is 143.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "					var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel); " is 132.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "					var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel); " is 145.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "				await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel); " is 131.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "					if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) { " is 120.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "					await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel); " is 164.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "				Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")"); " is 172.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "				Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")"); " is 176.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "				var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel); " is 140.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,VersionCommand,The length of the statement  "	log.WriteLine ("Using .NET Binding v{0} with API level {1}"' new System.Reflection.AssemblyName (typeof(Fdb).Assembly.FullName).Version' Fdb.ApiVersion); " is 153.
Long Statement,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,VersionCommand,The length of the statement  "	var res = await RunAsyncCommand ((db' _' ct) => FdbCliCommands.RunFdbCliCommand (null' "-h"' clusterFile' log' ct)' cancel); " is 124.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The length of the statement  "	// I'm using the midpoint of each bucket as the value used to compute the deviation' and the same approximation method used in Percentile(..) to compute the resulting median. " is 174.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The length of the statement  "	return String.Format (CultureInfo.InvariantCulture' "{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"' this.Percentile (5)' this.Percentile (25)' this.Percentile (50)' this.Percentile (75)' this.Percentile (95)); " is 250.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Total : {0:0.0##} sec' {1:N0} ops"' ToTimeSpan (this.Sum).TotalSeconds' this.Count)); " is 147.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "		r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit)); " is 163.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "		r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit)); " is 199.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "		r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95))); " is 243.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "			r.AppendLine ("   _____________________________________________________________________________________________________________________"); " is 138.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "			r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|"); " is 139.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "			r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left " is 299.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "			/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*'" is 190.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "			r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'"); " is 139.
Long Statement,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,ToString,The length of the statement  "	return String.Format (CultureInfo.InvariantCulture' "Count={0}' Avg={1}' Min={2}' Max={3}"' this.Count' this.Average' this.Count > 0 ? this.Min : 0' this.Max); " is 159.
Long Statement,Mono.Options,StringCoda,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetNextWidth,The length of the statement  "			throw new ArgumentOutOfRangeException (nameof (curWidth)' string.Format ("Element must be >= {0}' was {1}."' minWidth.Length' curWidth)); " is 137.
Long Statement,Mono.Options,OptionValueCollection,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,AssertValid,The length of the statement  "		throw new OptionException (string.Format (c.OptionSet.MessageLocalizer ("Missing required value for option '{0}'.")' c.OptionName)' c.OptionName); " is 146.
Long Statement,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,The length of the statement  "	bool nullable = tt.IsValueType && tt.IsGenericType && !tt.IsGenericTypeDefinition && tt.GetGenericTypeDefinition () == typeof(Nullable<>); " is 138.
Long Statement,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,The length of the statement  "		throw new OptionException (string.Format (c.OptionSet.MessageLocalizer ("Could not convert string `{0}' to type {1} for option `{2}'.")' value' targetType.Name' c.OptionName)' c.OptionName' e); " is 193.
Long Statement,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParsePrototype,The length of the statement  "			throw new ArgumentException (string.Format ("Conflicting option types: '{0}' vs. '{1}'."' type' name [end])' "prototype"); " is 122.
Long Statement,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParsePrototype,The length of the statement  "		throw new ArgumentException (string.Format ("Cannot provide key/value separators for Options taking {0} value(s)."' count)' "prototype"); " is 137.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseValue,The length of the statement  "		foreach (string o in c.Option.ValueSeparators != null ? option.Split (c.Option.ValueSeparators' c.Option.MaxValueCount - c.OptionValues.Count' StringSplitOptions.None) : new string[] { " is 184.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseValue,The length of the statement  "		throw new OptionException (localizer (string.Format ("Error: Found {0} option values when expecting {1}."' c.OptionValues.Count' c.Option.MaxValueCount))' c.OptionName); " is 169.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseBool,The length of the statement  "	if (n.Length >= 1 && (n [n.Length - 1] == '+' || n [n.Length - 1] == '-') && Contains ((rn = n.Substring (0' n.Length - 1)))) { " is 127.
Long Statement,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ForceCursor,The length of the statement  "	//log.WriteLine ("Going to cursor={0} row={1} col={2} actual={3} prompt={4} ttr={5} old={6}"' newpos' row' col' actual_pos' prompt.Length' TextToRenderPos (cursor)' cursor); " is 173.
Complex Conditional,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The conditional expression  "prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))"  is complex.
Complex Conditional,Mono.Options,Option,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 && ((names.Length == 1 && this.type != OptionValueType.None) || (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length - 1] == '+' || n [n.Length - 1] == '-') && Contains ((rn = n.Substring (0' n.Length - 1)))"  is complex.
Empty Catch Block,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The method has an empty catch block.
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.Write ("\r" + new string (' '' n + 2));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.Write ("\r" + new string (' '' n + 2));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: foreach (var kvp in map.OrderBy (x => x.Key)) {  	log.WriteLine ("{0'6} {1'-20} {2}"' kvp.Value' RobustHistogram.FormatHistoBar ((double)kvp.Value / foundShards' 20)' kvp.Key);  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.WriteLine ("{0'6} {1'-20} {2}"' kvp.Value' RobustHistogram.FormatHistoBar ((double)kvp.Value / foundShards' 20)' kvp.Key);  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: if (bigBad != null) {  	log.WriteLine ("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards);  	log.WriteLine ();  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: if (bigBad != null) {  	log.WriteLine ("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards);  	log.WriteLine ();  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.WriteLine ("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards);  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.WriteLine ("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards);  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: if (size < 2048)  	return size.ToString ("N0"' ci);  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: if (x < 800)  	return x.ToString ("N1"' ci) + " k";  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x /= 1024.0;  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: if (x < 800)  	return x.ToString ("N2"' ci) + " M";  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x /= 1024.0;  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: return new {  	Address = new IPAddress (kvp.Value.Substring (p' 4).GetBytes ().Reverse ().ToArray ())'  	Port = kvp.Value.Substring (p + 4' 4).ToInt32 ()'  	Unknown1 = kvp.Value.Substring (p + 8' 4).ToInt32 ()'  	Unknown2 = kvp.Value.Substring (p + 12' 4).ToInt32 ()'  	Unknown3 = kvp.Value.Substring (p + 16' 4).ToInt32 ()'  	Unknown4 = kvp.Value.Substring (p + 20' 4).ToInt32 ()  };  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: for (int dcIndex = 0; dcIndex < dcs.Length; dcIndex++) {  	var dc = dcs [dcIndex];  	bool lastDc = dcIndex == dcs.Length - 1;  	string dcId = dc.Key.EndsWith ("0000000000000000") ? dc.Key.Substring (0' 16) : dc.Key;  	log.WriteLine ((lastDc ? "`- " : "|- ") + "[DataCenter] {0} (#{1})"' dcId' dcIndex);  	var machines = dc.GroupBy (x => x.MachineId).ToArray ();  	string dcPrefix = lastDc ? "   " : "|  ";  	for (int machineIndex = 0; machineIndex < machines.Length; machineIndex++) {  		var machine = machines [machineIndex];  		var lastMachine = machineIndex == machines.Length - 1;  		string machineId = machine.Key.EndsWith ("0000000000000000") ? machine.Key.Substring (0' 16) : machine.Key;  		log.WriteLine (dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First ().Parts [0].Address' machineId);  		var procs = machine.ToArray ();  		string machinePrefix = dcPrefix + (lastMachine ? "   " : "|  ");  		for (int procIndex = 0; procIndex < procs.Length; procIndex++) {  			var proc = procs [procIndex];  			bool lastProc = procIndex == procs.Length - 1;  			log.WriteLine (machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts [0].Address' proc.Parts [0].Port' proc.ProcessId);  			//foreach (var part in proc.Parts)  			//{  			//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4);  			//}  		}  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: for (int dcIndex = 0; dcIndex < dcs.Length; dcIndex++) {  	var dc = dcs [dcIndex];  	bool lastDc = dcIndex == dcs.Length - 1;  	string dcId = dc.Key.EndsWith ("0000000000000000") ? dc.Key.Substring (0' 16) : dc.Key;  	log.WriteLine ((lastDc ? "`- " : "|- ") + "[DataCenter] {0} (#{1})"' dcId' dcIndex);  	var machines = dc.GroupBy (x => x.MachineId).ToArray ();  	string dcPrefix = lastDc ? "   " : "|  ";  	for (int machineIndex = 0; machineIndex < machines.Length; machineIndex++) {  		var machine = machines [machineIndex];  		var lastMachine = machineIndex == machines.Length - 1;  		string machineId = machine.Key.EndsWith ("0000000000000000") ? machine.Key.Substring (0' 16) : machine.Key;  		log.WriteLine (dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First ().Parts [0].Address' machineId);  		var procs = machine.ToArray ();  		string machinePrefix = dcPrefix + (lastMachine ? "   " : "|  ");  		for (int procIndex = 0; procIndex < procs.Length; procIndex++) {  			var proc = procs [procIndex];  			bool lastProc = procIndex == procs.Length - 1;  			log.WriteLine (machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts [0].Address' proc.Parts [0].Port' proc.ProcessId);  			//foreach (var part in proc.Parts)  			//{  			//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4);  			//}  		}  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: for (int machineIndex = 0; machineIndex < machines.Length; machineIndex++) {  	var machine = machines [machineIndex];  	var lastMachine = machineIndex == machines.Length - 1;  	string machineId = machine.Key.EndsWith ("0000000000000000") ? machine.Key.Substring (0' 16) : machine.Key;  	log.WriteLine (dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First ().Parts [0].Address' machineId);  	var procs = machine.ToArray ();  	string machinePrefix = dcPrefix + (lastMachine ? "   " : "|  ");  	for (int procIndex = 0; procIndex < procs.Length; procIndex++) {  		var proc = procs [procIndex];  		bool lastProc = procIndex == procs.Length - 1;  		log.WriteLine (machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts [0].Address' proc.Parts [0].Port' proc.ProcessId);  		//foreach (var part in proc.Parts)  		//{  		//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4);  		//}  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32) {  	// small enough to scan it all  	samples.AddRange (ranges);  	log.WriteLine ("Sampling all {0:N0} shards ..."' samples.Count);  } else {  	// need to take a random subset  	var rnd = new Random ();  	int sz = Math.Max ((int)Math.Ceiling (ratio * ranges.Count)' 1);  	if (auto) {  		if (sz > 100)  			sz = 100;  		//SAFETY  		if (sz < 32)  			sz = Math.Max (sz' Math.Min (32' ranges.Count));  	}  	var population = new List<FdbKeyRange> (ranges);  	for (int i = 0; i < sz; i++) {  		int p = rnd.Next (population.Count);  		samples.Add (population [p]);  		population.RemoveAt (p);  	}  	log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32) {  	// small enough to scan it all  	samples.AddRange (ranges);  	log.WriteLine ("Sampling all {0:N0} shards ..."' samples.Count);  } else {  	// need to take a random subset  	var rnd = new Random ();  	int sz = Math.Max ((int)Math.Ceiling (ratio * ranges.Count)' 1);  	if (auto) {  		if (sz > 100)  			sz = 100;  		//SAFETY  		if (sz < 32)  			sz = Math.Max (sz' Math.Min (32' ranges.Count));  	}  	var population = new List<FdbKeyRange> (ranges);  	for (int i = 0; i < sz; i++) {  		int p = rnd.Next (population.Count);  		samples.Add (population [p]);  		population.RemoveAt (p);  	}  	log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32) {  	// small enough to scan it all  	samples.AddRange (ranges);  	log.WriteLine ("Sampling all {0:N0} shards ..."' samples.Count);  } else {  	// need to take a random subset  	var rnd = new Random ();  	int sz = Math.Max ((int)Math.Ceiling (ratio * ranges.Count)' 1);  	if (auto) {  		if (sz > 100)  			sz = 100;  		//SAFETY  		if (sz < 32)  			sz = Math.Max (sz' Math.Min (32' ranges.Count));  	}  	var population = new List<FdbKeyRange> (ranges);  	for (int i = 0; i < sz; i++) {  		int p = rnd.Next (population.Count);  		samples.Add (population [p]);  		population.RemoveAt (p);  	}  	log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32) {  	// small enough to scan it all  	samples.AddRange (ranges);  	log.WriteLine ("Sampling all {0:N0} shards ..."' samples.Count);  } else {  	// need to take a random subset  	var rnd = new Random ();  	int sz = Math.Max ((int)Math.Ceiling (ratio * ranges.Count)' 1);  	if (auto) {  		if (sz > 100)  			sz = 100;  		//SAFETY  		if (sz < 32)  			sz = Math.Max (sz' Math.Min (32' ranges.Count));  	}  	var population = new List<FdbKeyRange> (ranges);  	for (int i = 0; i < sz; i++) {  		int p = rnd.Next (population.Count);  		samples.Add (population [p]);  		population.RemoveAt (p);  	}  	log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32) {  	// small enough to scan it all  	samples.AddRange (ranges);  	log.WriteLine ("Sampling all {0:N0} shards ..."' samples.Count);  } else {  	// need to take a random subset  	var rnd = new Random ();  	int sz = Math.Max ((int)Math.Ceiling (ratio * ranges.Count)' 1);  	if (auto) {  		if (sz > 100)  			sz = 100;  		//SAFETY  		if (sz < 32)  			sz = Math.Max (sz' Math.Min (32' ranges.Count));  	}  	var population = new List<FdbKeyRange> (ranges);  	for (int i = 0; i < sz; i++) {  		int p = rnd.Next (population.Count);  		samples.Add (population [p]);  		population.RemoveAt (p);  	}  	log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32) {  	// small enough to scan it all  	samples.AddRange (ranges);  	log.WriteLine ("Sampling all {0:N0} shards ..."' samples.Count);  } else {  	// need to take a random subset  	var rnd = new Random ();  	int sz = Math.Max ((int)Math.Ceiling (ratio * ranges.Count)' 1);  	if (auto) {  		if (sz > 100)  			sz = 100;  		//SAFETY  		if (sz < 32)  			sz = Math.Max (sz' Math.Min (32' ranges.Count));  	}  	var population = new List<FdbKeyRange> (ranges);  	for (int i = 0; i < sz; i++) {  		int p = rnd.Next (population.Count);  		samples.Add (population [p]);  		population.RemoveAt (p);  	}  	log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (auto) {  	if (sz > 100)  		sz = 100;  	//SAFETY  	if (sz < 32)  		sz = Math.Max (sz' Math.Min (32' ranges.Count));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (auto) {  	if (sz > 100)  		sz = 100;  	//SAFETY  	if (sz < 32)  		sz = Math.Max (sz' Math.Min (32' ranges.Count));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (auto) {  	if (sz > 100)  		sz = 100;  	//SAFETY  	if (sz < 32)  		sz = Math.Max (sz' Math.Min (32' ranges.Count));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (auto) {  	if (sz > 100)  		sz = 100;  	//SAFETY  	if (sz < 32)  		sz = Math.Max (sz' Math.Min (32' ranges.Count));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (sz > 100)  	sz = 100;  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (sz > 100)  	sz = 100;  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: sz = 100;  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (sz < 32)  	sz = Math.Max (sz' Math.Min (32' ranges.Count));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (sz < 32)  	sz = Math.Max (sz' Math.Min (32' ranges.Count));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: sz = Math.Max (sz' Math.Min (32' ranges.Count));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: log.WriteLine ("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString ("N1") + "%) ...");  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0) {  	while (tasks.Count < workers && samples.Count > 0) {  		var range = samples [0];  		samples.RemoveAt (0);  		tasks.Add (Task.Run (async () => {  			var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			#region Method 1: get_range everything...  			using (var tr = db.BeginTransaction (ct)) {  				long keySize = 0;  				long valueSize = 0;  				long count = 0;  				int iter = 0;  				var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  				var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  				while (true) {  					FdbRangeChunk data = default(FdbRangeChunk);  					FdbException error = null;  					try {  						data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  					} catch (FdbException e) {  						error = e;  					}  					if (error != null) {  						await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  						continue;  					}  					if (data.Count == 0)  						break;  					count += data.Count;  					foreach (var kvp in data.Chunk) {  						keySize += kvp.Key.Count;  						valueSize += kvp.Value.Count;  						kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  						vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  					}  					if (!data.HasMore)  						break;  					beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  					++iter;  				}  				long totalSize = keySize + valueSize;  				Interlocked.Add (ref globalSize' totalSize);  				Interlocked.Add (ref globalCount' count);  				lock (log) {  					log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  				}  			}  			#endregion  			#region Method 2: estimate the count using key selectors...  			//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  			//Console.WriteLine("COUNT = " + counter.ToString("N0"));  			#endregion  		}' ct));  	}  	var done = await Task.WhenAny (tasks);  	tasks.Remove (done);  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0) {  	while (tasks.Count < workers && samples.Count > 0) {  		var range = samples [0];  		samples.RemoveAt (0);  		tasks.Add (Task.Run (async () => {  			var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			#region Method 1: get_range everything...  			using (var tr = db.BeginTransaction (ct)) {  				long keySize = 0;  				long valueSize = 0;  				long count = 0;  				int iter = 0;  				var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  				var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  				while (true) {  					FdbRangeChunk data = default(FdbRangeChunk);  					FdbException error = null;  					try {  						data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  					} catch (FdbException e) {  						error = e;  					}  					if (error != null) {  						await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  						continue;  					}  					if (data.Count == 0)  						break;  					count += data.Count;  					foreach (var kvp in data.Chunk) {  						keySize += kvp.Key.Count;  						valueSize += kvp.Value.Count;  						kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  						vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  					}  					if (!data.HasMore)  						break;  					beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  					++iter;  				}  				long totalSize = keySize + valueSize;  				Interlocked.Add (ref globalSize' totalSize);  				Interlocked.Add (ref globalCount' count);  				lock (log) {  					log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  				}  			}  			#endregion  			#region Method 2: estimate the count using key selectors...  			//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  			//Console.WriteLine("COUNT = " + counter.ToString("N0"));  			#endregion  		}' ct));  	}  	var done = await Task.WhenAny (tasks);  	tasks.Remove (done);  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0) {  	while (tasks.Count < workers && samples.Count > 0) {  		var range = samples [0];  		samples.RemoveAt (0);  		tasks.Add (Task.Run (async () => {  			var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			#region Method 1: get_range everything...  			using (var tr = db.BeginTransaction (ct)) {  				long keySize = 0;  				long valueSize = 0;  				long count = 0;  				int iter = 0;  				var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  				var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  				while (true) {  					FdbRangeChunk data = default(FdbRangeChunk);  					FdbException error = null;  					try {  						data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  					} catch (FdbException e) {  						error = e;  					}  					if (error != null) {  						await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  						continue;  					}  					if (data.Count == 0)  						break;  					count += data.Count;  					foreach (var kvp in data.Chunk) {  						keySize += kvp.Key.Count;  						valueSize += kvp.Value.Count;  						kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  						vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  					}  					if (!data.HasMore)  						break;  					beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  					++iter;  				}  				long totalSize = keySize + valueSize;  				Interlocked.Add (ref globalSize' totalSize);  				Interlocked.Add (ref globalCount' count);  				lock (log) {  					log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  				}  			}  			#endregion  			#region Method 2: estimate the count using key selectors...  			//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  			//Console.WriteLine("COUNT = " + counter.ToString("N0"));  			#endregion  		}' ct));  	}  	var done = await Task.WhenAny (tasks);  	tasks.Remove (done);  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0) {  	while (tasks.Count < workers && samples.Count > 0) {  		var range = samples [0];  		samples.RemoveAt (0);  		tasks.Add (Task.Run (async () => {  			var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  			#region Method 1: get_range everything...  			using (var tr = db.BeginTransaction (ct)) {  				long keySize = 0;  				long valueSize = 0;  				long count = 0;  				int iter = 0;  				var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  				var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  				while (true) {  					FdbRangeChunk data = default(FdbRangeChunk);  					FdbException error = null;  					try {  						data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  					} catch (FdbException e) {  						error = e;  					}  					if (error != null) {  						await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  						continue;  					}  					if (data.Count == 0)  						break;  					count += data.Count;  					foreach (var kvp in data.Chunk) {  						keySize += kvp.Key.Count;  						valueSize += kvp.Value.Count;  						kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  						vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  					}  					if (!data.HasMore)  						break;  					beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  					++iter;  				}  				long totalSize = keySize + valueSize;  				Interlocked.Add (ref globalSize' totalSize);  				Interlocked.Add (ref globalCount' count);  				lock (log) {  					log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  				}  			}  			#endregion  			#region Method 2: estimate the count using key selectors...  			//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  			//Console.WriteLine("COUNT = " + counter.ToString("N0"));  			#endregion  		}' ct));  	}  	var done = await Task.WhenAny (tasks);  	tasks.Remove (done);  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (tasks.Count < workers && samples.Count > 0) {  	var range = samples [0];  	samples.RemoveAt (0);  	tasks.Add (Task.Run (async () => {  		var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		#region Method 1: get_range everything...  		using (var tr = db.BeginTransaction (ct)) {  			long keySize = 0;  			long valueSize = 0;  			long count = 0;  			int iter = 0;  			var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  			var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  			while (true) {  				FdbRangeChunk data = default(FdbRangeChunk);  				FdbException error = null;  				try {  					data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  				} catch (FdbException e) {  					error = e;  				}  				if (error != null) {  					await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  					continue;  				}  				if (data.Count == 0)  					break;  				count += data.Count;  				foreach (var kvp in data.Chunk) {  					keySize += kvp.Key.Count;  					valueSize += kvp.Value.Count;  					kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  					vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  				}  				if (!data.HasMore)  					break;  				beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  				++iter;  			}  			long totalSize = keySize + valueSize;  			Interlocked.Add (ref globalSize' totalSize);  			Interlocked.Add (ref globalCount' count);  			lock (log) {  				log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  			}  		}  		#endregion  		#region Method 2: estimate the count using key selectors...  		//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  		//Console.WriteLine("COUNT = " + counter.ToString("N0"));  		#endregion  	}' ct));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (tasks.Count < workers && samples.Count > 0) {  	var range = samples [0];  	samples.RemoveAt (0);  	tasks.Add (Task.Run (async () => {  		var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		#region Method 1: get_range everything...  		using (var tr = db.BeginTransaction (ct)) {  			long keySize = 0;  			long valueSize = 0;  			long count = 0;  			int iter = 0;  			var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  			var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  			while (true) {  				FdbRangeChunk data = default(FdbRangeChunk);  				FdbException error = null;  				try {  					data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  				} catch (FdbException e) {  					error = e;  				}  				if (error != null) {  					await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  					continue;  				}  				if (data.Count == 0)  					break;  				count += data.Count;  				foreach (var kvp in data.Chunk) {  					keySize += kvp.Key.Count;  					valueSize += kvp.Value.Count;  					kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  					vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  				}  				if (!data.HasMore)  					break;  				beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  				++iter;  			}  			long totalSize = keySize + valueSize;  			Interlocked.Add (ref globalSize' totalSize);  			Interlocked.Add (ref globalCount' count);  			lock (log) {  				log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  			}  		}  		#endregion  		#region Method 2: estimate the count using key selectors...  		//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  		//Console.WriteLine("COUNT = " + counter.ToString("N0"));  		#endregion  	}' ct));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (tasks.Count < workers && samples.Count > 0) {  	var range = samples [0];  	samples.RemoveAt (0);  	tasks.Add (Task.Run (async () => {  		var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		#region Method 1: get_range everything...  		using (var tr = db.BeginTransaction (ct)) {  			long keySize = 0;  			long valueSize = 0;  			long count = 0;  			int iter = 0;  			var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  			var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  			while (true) {  				FdbRangeChunk data = default(FdbRangeChunk);  				FdbException error = null;  				try {  					data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  				} catch (FdbException e) {  					error = e;  				}  				if (error != null) {  					await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  					continue;  				}  				if (data.Count == 0)  					break;  				count += data.Count;  				foreach (var kvp in data.Chunk) {  					keySize += kvp.Key.Count;  					valueSize += kvp.Value.Count;  					kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  					vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  				}  				if (!data.HasMore)  					break;  				beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  				++iter;  			}  			long totalSize = keySize + valueSize;  			Interlocked.Add (ref globalSize' totalSize);  			Interlocked.Add (ref globalCount' count);  			lock (log) {  				log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  			}  		}  		#endregion  		#region Method 2: estimate the count using key selectors...  		//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  		//Console.WriteLine("COUNT = " + counter.ToString("N0"));  		#endregion  	}' ct));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (tasks.Count < workers && samples.Count > 0) {  	var range = samples [0];  	samples.RemoveAt (0);  	tasks.Add (Task.Run (async () => {  		var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  		#region Method 1: get_range everything...  		using (var tr = db.BeginTransaction (ct)) {  			long keySize = 0;  			long valueSize = 0;  			long count = 0;  			int iter = 0;  			var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  			var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  			while (true) {  				FdbRangeChunk data = default(FdbRangeChunk);  				FdbException error = null;  				try {  					data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  				} catch (FdbException e) {  					error = e;  				}  				if (error != null) {  					await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  					continue;  				}  				if (data.Count == 0)  					break;  				count += data.Count;  				foreach (var kvp in data.Chunk) {  					keySize += kvp.Key.Count;  					valueSize += kvp.Value.Count;  					kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  					vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  				}  				if (!data.HasMore)  					break;  				beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  				++iter;  			}  			long totalSize = keySize + valueSize;  			Interlocked.Add (ref globalSize' totalSize);  			Interlocked.Add (ref globalCount' count);  			lock (log) {  				log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  			}  		}  		#endregion  		#region Method 2: estimate the count using key selectors...  		//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  		//Console.WriteLine("COUNT = " + counter.ToString("N0"));  		#endregion  	}' ct));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add (Task.Run (async () => {  	var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	#region Method 1: get_range everything...  	using (var tr = db.BeginTransaction (ct)) {  		long keySize = 0;  		long valueSize = 0;  		long count = 0;  		int iter = 0;  		var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  		var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  		while (true) {  			FdbRangeChunk data = default(FdbRangeChunk);  			FdbException error = null;  			try {  				data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  			} catch (FdbException e) {  				error = e;  			}  			if (error != null) {  				await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  				continue;  			}  			if (data.Count == 0)  				break;  			count += data.Count;  			foreach (var kvp in data.Chunk) {  				keySize += kvp.Key.Count;  				valueSize += kvp.Value.Count;  				kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  				vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  			}  			if (!data.HasMore)  				break;  			beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  			++iter;  		}  		long totalSize = keySize + valueSize;  		Interlocked.Add (ref globalSize' totalSize);  		Interlocked.Add (ref globalCount' count);  		lock (log) {  			log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  		}  	}  	#endregion  	#region Method 2: estimate the count using key selectors...  	//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  	//Console.WriteLine("COUNT = " + counter.ToString("N0"));  	#endregion  }' ct));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add (Task.Run (async () => {  	var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	#region Method 1: get_range everything...  	using (var tr = db.BeginTransaction (ct)) {  		long keySize = 0;  		long valueSize = 0;  		long count = 0;  		int iter = 0;  		var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  		var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  		while (true) {  			FdbRangeChunk data = default(FdbRangeChunk);  			FdbException error = null;  			try {  				data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  			} catch (FdbException e) {  				error = e;  			}  			if (error != null) {  				await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  				continue;  			}  			if (data.Count == 0)  				break;  			count += data.Count;  			foreach (var kvp in data.Chunk) {  				keySize += kvp.Key.Count;  				valueSize += kvp.Value.Count;  				kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  				vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  			}  			if (!data.HasMore)  				break;  			beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  			++iter;  		}  		long totalSize = keySize + valueSize;  		Interlocked.Add (ref globalSize' totalSize);  		Interlocked.Add (ref globalCount' count);  		lock (log) {  			log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  		}  	}  	#endregion  	#region Method 2: estimate the count using key selectors...  	//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  	//Console.WriteLine("COUNT = " + counter.ToString("N0"));  	#endregion  }' ct));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add (Task.Run (async () => {  	var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	#region Method 1: get_range everything...  	using (var tr = db.BeginTransaction (ct)) {  		long keySize = 0;  		long valueSize = 0;  		long count = 0;  		int iter = 0;  		var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  		var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  		while (true) {  			FdbRangeChunk data = default(FdbRangeChunk);  			FdbException error = null;  			try {  				data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  			} catch (FdbException e) {  				error = e;  			}  			if (error != null) {  				await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  				continue;  			}  			if (data.Count == 0)  				break;  			count += data.Count;  			foreach (var kvp in data.Chunk) {  				keySize += kvp.Key.Count;  				valueSize += kvp.Value.Count;  				kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  				vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  			}  			if (!data.HasMore)  				break;  			beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  			++iter;  		}  		long totalSize = keySize + valueSize;  		Interlocked.Add (ref globalSize' totalSize);  		Interlocked.Add (ref globalCount' count);  		lock (log) {  			log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  		}  	}  	#endregion  	#region Method 2: estimate the count using key selectors...  	//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  	//Console.WriteLine("COUNT = " + counter.ToString("N0"));  	#endregion  }' ct));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: tasks.Add (Task.Run (async () => {  	var kk = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	var vv = new RobustHistogram (RobustHistogram.TimeScale.Ticks);  	#region Method 1: get_range everything...  	using (var tr = db.BeginTransaction (ct)) {  		long keySize = 0;  		long valueSize = 0;  		long count = 0;  		int iter = 0;  		var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  		var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  		while (true) {  			FdbRangeChunk data = default(FdbRangeChunk);  			FdbException error = null;  			try {  				data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  			} catch (FdbException e) {  				error = e;  			}  			if (error != null) {  				await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  				continue;  			}  			if (data.Count == 0)  				break;  			count += data.Count;  			foreach (var kvp in data.Chunk) {  				keySize += kvp.Key.Count;  				valueSize += kvp.Value.Count;  				kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  				vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  			}  			if (!data.HasMore)  				break;  			beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  			++iter;  		}  		long totalSize = keySize + valueSize;  		Interlocked.Add (ref globalSize' totalSize);  		Interlocked.Add (ref globalCount' count);  		lock (log) {  			log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  		}  	}  	#endregion  	#region Method 2: estimate the count using key selectors...  	//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  	//Console.WriteLine("COUNT = " + counter.ToString("N0"));  	#endregion  }' ct));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: using (var tr = db.BeginTransaction (ct)) {  	long keySize = 0;  	long valueSize = 0;  	long count = 0;  	int iter = 0;  	var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  	var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  	while (true) {  		FdbRangeChunk data = default(FdbRangeChunk);  		FdbException error = null;  		try {  			data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  		} catch (FdbException e) {  			error = e;  		}  		if (error != null) {  			await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  			continue;  		}  		if (data.Count == 0)  			break;  		count += data.Count;  		foreach (var kvp in data.Chunk) {  			keySize += kvp.Key.Count;  			valueSize += kvp.Value.Count;  			kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  			vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  		}  		if (!data.HasMore)  			break;  		beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  		++iter;  	}  	long totalSize = keySize + valueSize;  	Interlocked.Add (ref globalSize' totalSize);  	Interlocked.Add (ref globalCount' count);  	lock (log) {  		log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: using (var tr = db.BeginTransaction (ct)) {  	long keySize = 0;  	long valueSize = 0;  	long count = 0;  	int iter = 0;  	var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  	var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  	while (true) {  		FdbRangeChunk data = default(FdbRangeChunk);  		FdbException error = null;  		try {  			data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  		} catch (FdbException e) {  			error = e;  		}  		if (error != null) {  			await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  			continue;  		}  		if (data.Count == 0)  			break;  		count += data.Count;  		foreach (var kvp in data.Chunk) {  			keySize += kvp.Key.Count;  			valueSize += kvp.Value.Count;  			kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  			vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  		}  		if (!data.HasMore)  			break;  		beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  		++iter;  	}  	long totalSize = keySize + valueSize;  	Interlocked.Add (ref globalSize' totalSize);  	Interlocked.Add (ref globalCount' count);  	lock (log) {  		log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: using (var tr = db.BeginTransaction (ct)) {  	long keySize = 0;  	long valueSize = 0;  	long count = 0;  	int iter = 0;  	var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  	var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  	while (true) {  		FdbRangeChunk data = default(FdbRangeChunk);  		FdbException error = null;  		try {  			data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  		} catch (FdbException e) {  			error = e;  		}  		if (error != null) {  			await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  			continue;  		}  		if (data.Count == 0)  			break;  		count += data.Count;  		foreach (var kvp in data.Chunk) {  			keySize += kvp.Key.Count;  			valueSize += kvp.Value.Count;  			kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  			vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  		}  		if (!data.HasMore)  			break;  		beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  		++iter;  	}  	long totalSize = keySize + valueSize;  	Interlocked.Add (ref globalSize' totalSize);  	Interlocked.Add (ref globalCount' count);  	lock (log) {  		log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: using (var tr = db.BeginTransaction (ct)) {  	long keySize = 0;  	long valueSize = 0;  	long count = 0;  	int iter = 0;  	var beginSelector = FdbKeySelector.FirstGreaterOrEqual (range.Begin);  	var endSelector = FdbKeySelector.FirstGreaterOrEqual (range.End);  	while (true) {  		FdbRangeChunk data = default(FdbRangeChunk);  		FdbException error = null;  		try {  			data = await tr.Snapshot.GetRangeAsync (beginSelector' endSelector' rangeOptions' iter).ConfigureAwait (false);  		} catch (FdbException e) {  			error = e;  		}  		if (error != null) {  			await tr.OnErrorAsync (error.Code).ConfigureAwait (false);  			continue;  		}  		if (data.Count == 0)  			break;  		count += data.Count;  		foreach (var kvp in data.Chunk) {  			keySize += kvp.Key.Count;  			valueSize += kvp.Value.Count;  			kk.Add (TimeSpan.FromTicks (kvp.Key.Count));  			vv.Add (TimeSpan.FromTicks (kvp.Value.Count));  		}  		if (!data.HasMore)  			break;  		beginSelector = FdbKeySelector.FirstGreaterThan (data.Last.Key);  		++iter;  	}  	long totalSize = keySize + valueSize;  	Interlocked.Add (ref globalSize' totalSize);  	Interlocked.Add (ref globalCount' count);  	lock (log) {  		log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  	}  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: lock (log) {  	log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: lock (log) {  	log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: lock (log) {  	log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: lock (log) {  	log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: log.WriteLine (FORMAT_STRING' count.ToString ("N0")' FormatSize (keySize)' kk.GetDistribution (begin: 1' end: 12000' fold: 2)' FormatSize (valueSize)' vv.GetDistribution (begin: 1' end: 120000' fold: 2)' FormatSize (totalSize)' FormatSize ((int)Math.Ceiling (kk.Median))' FormatSize ((int)Math.Ceiling (vv.Median)));  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (n != ranges.Count) {  	log.WriteLine ("Sampled " + FormatSize (globalSize) + " (" + globalSize.ToString ("N0") + " bytes) and " + globalCount.ToString ("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString ("N1") + " sec");  	log.WriteLine ("> Estimated total size is " + FormatSize (globalSize * ranges.Count / n));  } else {  	log.WriteLine ("Found " + FormatSize (globalSize) + " (" + globalSize.ToString ("N0") + " bytes) and " + globalCount.ToString ("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString ("N1") + " sec");  	// compare to the whole cluster  	ranges = await Fdb.System.GetChunksAsync (db' FdbKey.MinValue' FdbKey.MaxValue' ct);  	log.WriteLine ("> This directory contains ~{0:N2}% of all data"' (100.0 * n / ranges.Count));  }  
Magic Number,FdbShell,BasicCommands,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: log.WriteLine ("> This directory contains ~{0:N2}% of all data"' (100.0 * n / ranges.Count));  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: try {  	if (Console.LargestWindowWidth > 0 && Console.LargestWindowHeight > 0) {  		Console.WindowWidth = 160;  		Console.WindowHeight = 60;  	}  } catch (Exception e) {  	// this sometimes fail on small screen sizes  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: try {  	if (Console.LargestWindowWidth > 0 && Console.LargestWindowHeight > 0) {  		Console.WindowWidth = 160;  		Console.WindowHeight = 60;  	}  } catch (Exception e) {  	// this sometimes fail on small screen sizes  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: if (Console.LargestWindowWidth > 0 && Console.LargestWindowHeight > 0) {  	Console.WindowWidth = 160;  	Console.WindowHeight = 60;  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: if (Console.LargestWindowWidth > 0 && Console.LargestWindowHeight > 0) {  	Console.WindowWidth = 160;  	Console.WindowHeight = 60;  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: Console.WindowWidth = 160;  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: Console.WindowHeight = 60;  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try {  	Db = await ChangeDatabase (clusterFile' dbName' partition' cancel);  	Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  	Db.DefaultRetryLimit = Math.Max (0' maxRetries);  	Console.WriteLine ("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion () + ")");  	Console.WriteLine ("Cluster file: " + (clusterFile ?? "<default>"));  	Console.WriteLine ();  	Console.WriteLine ("FoundationDB Shell menu:");  	Console.WriteLine ("\tdir\tShow the content of the current directory");  	Console.WriteLine ("\ttree\tShow all the directories under the current directory");  	Console.WriteLine ("\tsampling\tDisplay statistics on random shards from the database");  	Console.WriteLine ("\tcoordinators\tShow the current coordinators for the cluster");  	Console.WriteLine ("\tmem\tShow memory usage statistics");  	Console.WriteLine ("\tgc\tTrigger garbage collection");  	Console.WriteLine ("\tquit\tQuit");  	Console.WriteLine ("Ready...");  	var le = new LineEditor ("FDBShell");  	string[] cmds = new string[] {  		"cd"'  		"coordinators"'  		"count"'  		"dir"'  		"exit"'  		"gc"'  		"help"'  		"layer"'  		"map"'  		"mem"'  		"mkdir"'  		"mv"'  		"partition"'  		"pwd"'  		"quit"'  		"ren"'  		"rmdir"'  		"sampling"'  		"shards"'  		"show"'  		"status"'  		"topology"'  		"tree"'  		"version"'  		"wide"'  	};  	le.AutoCompleteEvent = (txt' pos) => {  		string[] res;  		int p = txt.IndexOf (' ');  		if (p > 0) {  			string cmd = txt.Substring (0' p);  			string arg = txt.Substring (p + 1);  			if (cmd == "cd") {  				// handle completion for directories  				// txt: "cd foo" => prefix = "foo"  				// txt: "cd foobar/b" => prefix = "b"  				string path = CurrentDirectoryPath;  				string prefix = "";  				string search = arg;  				p = arg.LastIndexOf ('/');  				if (p > 0) {  					path = Path.Combine (path' arg.Substring (0' p));  					search = arg.Substring (p + 1);  					prefix = arg.Substring (0' p + 1);  				}  				var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult ();  				if (!subdirs.HasValue || subdirs.Value == null)  					return new LineEditor.Completion (txt' null);  				res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray ();  				return new LineEditor.Completion (txt' res);  			}  			// unknown command  			return new LineEditor.Completion (txt' null);  		}  		// list of commands  		res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray ();  		return new LineEditor.Completion (txt' res);  	};  	le.TabAtStartCompletes = true;  	string prompt = null;  	Action<string> updatePrompt = path => {  		prompt = String.Format ("fdb:{0}> "' path);  	};  	updatePrompt (CurrentDirectoryPath);  	while (!stop) {  		string s = startCommand != null ? startCommand : le.Edit (prompt' "");  		startCommand = null;  		if (s == null)  			break;  		var tokens = s.Trim ().Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  		string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  		var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  		var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  		switch (trimmedCommand) {  		case "": {  			continue;  		}  		case "log": {  			LogCommand (prm' Console.Out);  			break;  		}  		case "version": {  			await VersionCommand (prm' clusterFile' Console.Out' cancel);  			break;  		}  		case "tree": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  			break;  		}  		case "map": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  			break;  		}  		case "dir":  		case "ls": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  			break;  		}  		case "ll": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  			break;  		}  		case "count": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  			break;  		}  		case "show":  		case "top": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  			break;  		}  		case "last": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  			break;  		}  		case "cd":  		case "pwd": {  			if (!string.IsNullOrEmpty (prm)) {  				var newPath = CombinePath (CurrentDirectoryPath' prm);  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  				if (res == null) {  					Console.WriteLine ("# Directory {0} does not exist!"' newPath);  					Console.Beep ();  				} else {  					CurrentDirectoryPath = newPath;  					updatePrompt (CurrentDirectoryPath);  				}  			} else {  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  				if (res.GetValueOrDefault () == null) {  					Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  				} else {  					Console.WriteLine ("# {0}"' res);  				}  			}  			break;  		}  		case "mkdir":  		case "md": {  			// "mkdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "rmdir": {  			// "rmdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mv":  		case "ren": {  			// "mv SOURCE DESTINATION"  			var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  			break;  		}  		case "layer": {  			if (string.IsNullOrEmpty (prm)) {  				// displays the layer id of the current folder  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  			} else {  				// change the layer id of the current folder  				prm = prm.Trim ();  				// double or single quotes can be used to escape the value  				if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  					prm = prm.Substring (1' prm.Length - 2);  				}  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mkpart": {  			// "mkpart PARTITIONNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  			}  			break;  		}  		case "topology": {  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  			break;  		}  		case "shards": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  			break;  		}  		case "sampling": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  			break;  		}  		case "coordinators": {  			await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  			break;  		}  		case "partition": {  			if (string.IsNullOrEmpty (prm)) {  				Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  				//TODO: browse existing partitions ?  				break;  			}  			var newPartition = prm.Split (new[] {  				'/'  			}' StringSplitOptions.RemoveEmptyEntries);  			IFdbDatabase newDb = null;  			try {  				newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  			} catch (Exception) {  				if (newDb != null)  					newDb.Dispose ();  				newDb = null;  				throw;  			} finally {  				if (newDb != null) {  					if (Db != null) {  						Db.Dispose ();  						Db = null;  					}  					Db = newDb;  					partition = newPartition;  					Console.WriteLine ("# Changed partition to {0}"' partition);  				}  			}  			break;  		}  		case "q":  		case "x":  		case "quit":  		case "exit":  		case "bye": {  			stop = true;  			break;  		}  		case "gc": {  			long before = GC.GetTotalMemory (false);  			Console.Write ("Collecting garbage...");  			GC.Collect ();  			GC.WaitForPendingFinalizers ();  			GC.Collect ();  			Console.WriteLine (" Done");  			long after = GC.GetTotalMemory (false);  			Console.WriteLine ("- before = " + before.ToString ("N0"));  			Console.WriteLine ("- after  = " + after.ToString ("N0"));  			Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  			break;  		}  		case "mem": {  			Console.WriteLine ("Memory usage:");  			Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  			Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  			Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  			break;  		}  		case "wide": {  			Console.WindowWidth = 160;  			break;  		}  		case "status":  		case "wtf": {  			var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  			if (result.HasFailed)  				break;  			if (result.Value.ExitCode != 0) {  				Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  				Console.WriteLine ("> StdErr:");  				Console.WriteLine (result.Value.StdErr);  				Console.WriteLine ("> StdOut:");  			}  			Console.WriteLine (result.Value.StdOut);  			break;  		}  		default: {  			Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  			break;  		}  		}  		if (!string.IsNullOrEmpty (execCommand)) {  			// only run one command' and then exit  			break;  		}  	}  } finally {  	if (Db != null)  		Db.Dispose ();  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try {  	Db = await ChangeDatabase (clusterFile' dbName' partition' cancel);  	Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  	Db.DefaultRetryLimit = Math.Max (0' maxRetries);  	Console.WriteLine ("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion () + ")");  	Console.WriteLine ("Cluster file: " + (clusterFile ?? "<default>"));  	Console.WriteLine ();  	Console.WriteLine ("FoundationDB Shell menu:");  	Console.WriteLine ("\tdir\tShow the content of the current directory");  	Console.WriteLine ("\ttree\tShow all the directories under the current directory");  	Console.WriteLine ("\tsampling\tDisplay statistics on random shards from the database");  	Console.WriteLine ("\tcoordinators\tShow the current coordinators for the cluster");  	Console.WriteLine ("\tmem\tShow memory usage statistics");  	Console.WriteLine ("\tgc\tTrigger garbage collection");  	Console.WriteLine ("\tquit\tQuit");  	Console.WriteLine ("Ready...");  	var le = new LineEditor ("FDBShell");  	string[] cmds = new string[] {  		"cd"'  		"coordinators"'  		"count"'  		"dir"'  		"exit"'  		"gc"'  		"help"'  		"layer"'  		"map"'  		"mem"'  		"mkdir"'  		"mv"'  		"partition"'  		"pwd"'  		"quit"'  		"ren"'  		"rmdir"'  		"sampling"'  		"shards"'  		"show"'  		"status"'  		"topology"'  		"tree"'  		"version"'  		"wide"'  	};  	le.AutoCompleteEvent = (txt' pos) => {  		string[] res;  		int p = txt.IndexOf (' ');  		if (p > 0) {  			string cmd = txt.Substring (0' p);  			string arg = txt.Substring (p + 1);  			if (cmd == "cd") {  				// handle completion for directories  				// txt: "cd foo" => prefix = "foo"  				// txt: "cd foobar/b" => prefix = "b"  				string path = CurrentDirectoryPath;  				string prefix = "";  				string search = arg;  				p = arg.LastIndexOf ('/');  				if (p > 0) {  					path = Path.Combine (path' arg.Substring (0' p));  					search = arg.Substring (p + 1);  					prefix = arg.Substring (0' p + 1);  				}  				var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult ();  				if (!subdirs.HasValue || subdirs.Value == null)  					return new LineEditor.Completion (txt' null);  				res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray ();  				return new LineEditor.Completion (txt' res);  			}  			// unknown command  			return new LineEditor.Completion (txt' null);  		}  		// list of commands  		res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray ();  		return new LineEditor.Completion (txt' res);  	};  	le.TabAtStartCompletes = true;  	string prompt = null;  	Action<string> updatePrompt = path => {  		prompt = String.Format ("fdb:{0}> "' path);  	};  	updatePrompt (CurrentDirectoryPath);  	while (!stop) {  		string s = startCommand != null ? startCommand : le.Edit (prompt' "");  		startCommand = null;  		if (s == null)  			break;  		var tokens = s.Trim ().Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  		string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  		var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  		var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  		switch (trimmedCommand) {  		case "": {  			continue;  		}  		case "log": {  			LogCommand (prm' Console.Out);  			break;  		}  		case "version": {  			await VersionCommand (prm' clusterFile' Console.Out' cancel);  			break;  		}  		case "tree": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  			break;  		}  		case "map": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  			break;  		}  		case "dir":  		case "ls": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  			break;  		}  		case "ll": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  			break;  		}  		case "count": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  			break;  		}  		case "show":  		case "top": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  			break;  		}  		case "last": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  			break;  		}  		case "cd":  		case "pwd": {  			if (!string.IsNullOrEmpty (prm)) {  				var newPath = CombinePath (CurrentDirectoryPath' prm);  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  				if (res == null) {  					Console.WriteLine ("# Directory {0} does not exist!"' newPath);  					Console.Beep ();  				} else {  					CurrentDirectoryPath = newPath;  					updatePrompt (CurrentDirectoryPath);  				}  			} else {  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  				if (res.GetValueOrDefault () == null) {  					Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  				} else {  					Console.WriteLine ("# {0}"' res);  				}  			}  			break;  		}  		case "mkdir":  		case "md": {  			// "mkdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "rmdir": {  			// "rmdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mv":  		case "ren": {  			// "mv SOURCE DESTINATION"  			var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  			break;  		}  		case "layer": {  			if (string.IsNullOrEmpty (prm)) {  				// displays the layer id of the current folder  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  			} else {  				// change the layer id of the current folder  				prm = prm.Trim ();  				// double or single quotes can be used to escape the value  				if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  					prm = prm.Substring (1' prm.Length - 2);  				}  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mkpart": {  			// "mkpart PARTITIONNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  			}  			break;  		}  		case "topology": {  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  			break;  		}  		case "shards": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  			break;  		}  		case "sampling": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  			break;  		}  		case "coordinators": {  			await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  			break;  		}  		case "partition": {  			if (string.IsNullOrEmpty (prm)) {  				Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  				//TODO: browse existing partitions ?  				break;  			}  			var newPartition = prm.Split (new[] {  				'/'  			}' StringSplitOptions.RemoveEmptyEntries);  			IFdbDatabase newDb = null;  			try {  				newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  			} catch (Exception) {  				if (newDb != null)  					newDb.Dispose ();  				newDb = null;  				throw;  			} finally {  				if (newDb != null) {  					if (Db != null) {  						Db.Dispose ();  						Db = null;  					}  					Db = newDb;  					partition = newPartition;  					Console.WriteLine ("# Changed partition to {0}"' partition);  				}  			}  			break;  		}  		case "q":  		case "x":  		case "quit":  		case "exit":  		case "bye": {  			stop = true;  			break;  		}  		case "gc": {  			long before = GC.GetTotalMemory (false);  			Console.Write ("Collecting garbage...");  			GC.Collect ();  			GC.WaitForPendingFinalizers ();  			GC.Collect ();  			Console.WriteLine (" Done");  			long after = GC.GetTotalMemory (false);  			Console.WriteLine ("- before = " + before.ToString ("N0"));  			Console.WriteLine ("- after  = " + after.ToString ("N0"));  			Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  			break;  		}  		case "mem": {  			Console.WriteLine ("Memory usage:");  			Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  			Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  			Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  			break;  		}  		case "wide": {  			Console.WindowWidth = 160;  			break;  		}  		case "status":  		case "wtf": {  			var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  			if (result.HasFailed)  				break;  			if (result.Value.ExitCode != 0) {  				Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  				Console.WriteLine ("> StdErr:");  				Console.WriteLine (result.Value.StdErr);  				Console.WriteLine ("> StdOut:");  			}  			Console.WriteLine (result.Value.StdOut);  			break;  		}  		default: {  			Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  			break;  		}  		}  		if (!string.IsNullOrEmpty (execCommand)) {  			// only run one command' and then exit  			break;  		}  	}  } finally {  	if (Db != null)  		Db.Dispose ();  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try {  	Db = await ChangeDatabase (clusterFile' dbName' partition' cancel);  	Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  	Db.DefaultRetryLimit = Math.Max (0' maxRetries);  	Console.WriteLine ("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion () + ")");  	Console.WriteLine ("Cluster file: " + (clusterFile ?? "<default>"));  	Console.WriteLine ();  	Console.WriteLine ("FoundationDB Shell menu:");  	Console.WriteLine ("\tdir\tShow the content of the current directory");  	Console.WriteLine ("\ttree\tShow all the directories under the current directory");  	Console.WriteLine ("\tsampling\tDisplay statistics on random shards from the database");  	Console.WriteLine ("\tcoordinators\tShow the current coordinators for the cluster");  	Console.WriteLine ("\tmem\tShow memory usage statistics");  	Console.WriteLine ("\tgc\tTrigger garbage collection");  	Console.WriteLine ("\tquit\tQuit");  	Console.WriteLine ("Ready...");  	var le = new LineEditor ("FDBShell");  	string[] cmds = new string[] {  		"cd"'  		"coordinators"'  		"count"'  		"dir"'  		"exit"'  		"gc"'  		"help"'  		"layer"'  		"map"'  		"mem"'  		"mkdir"'  		"mv"'  		"partition"'  		"pwd"'  		"quit"'  		"ren"'  		"rmdir"'  		"sampling"'  		"shards"'  		"show"'  		"status"'  		"topology"'  		"tree"'  		"version"'  		"wide"'  	};  	le.AutoCompleteEvent = (txt' pos) => {  		string[] res;  		int p = txt.IndexOf (' ');  		if (p > 0) {  			string cmd = txt.Substring (0' p);  			string arg = txt.Substring (p + 1);  			if (cmd == "cd") {  				// handle completion for directories  				// txt: "cd foo" => prefix = "foo"  				// txt: "cd foobar/b" => prefix = "b"  				string path = CurrentDirectoryPath;  				string prefix = "";  				string search = arg;  				p = arg.LastIndexOf ('/');  				if (p > 0) {  					path = Path.Combine (path' arg.Substring (0' p));  					search = arg.Substring (p + 1);  					prefix = arg.Substring (0' p + 1);  				}  				var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult ();  				if (!subdirs.HasValue || subdirs.Value == null)  					return new LineEditor.Completion (txt' null);  				res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray ();  				return new LineEditor.Completion (txt' res);  			}  			// unknown command  			return new LineEditor.Completion (txt' null);  		}  		// list of commands  		res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray ();  		return new LineEditor.Completion (txt' res);  	};  	le.TabAtStartCompletes = true;  	string prompt = null;  	Action<string> updatePrompt = path => {  		prompt = String.Format ("fdb:{0}> "' path);  	};  	updatePrompt (CurrentDirectoryPath);  	while (!stop) {  		string s = startCommand != null ? startCommand : le.Edit (prompt' "");  		startCommand = null;  		if (s == null)  			break;  		var tokens = s.Trim ().Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  		string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  		var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  		var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  		switch (trimmedCommand) {  		case "": {  			continue;  		}  		case "log": {  			LogCommand (prm' Console.Out);  			break;  		}  		case "version": {  			await VersionCommand (prm' clusterFile' Console.Out' cancel);  			break;  		}  		case "tree": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  			break;  		}  		case "map": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  			break;  		}  		case "dir":  		case "ls": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  			break;  		}  		case "ll": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  			break;  		}  		case "count": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  			break;  		}  		case "show":  		case "top": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  			break;  		}  		case "last": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  			break;  		}  		case "cd":  		case "pwd": {  			if (!string.IsNullOrEmpty (prm)) {  				var newPath = CombinePath (CurrentDirectoryPath' prm);  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  				if (res == null) {  					Console.WriteLine ("# Directory {0} does not exist!"' newPath);  					Console.Beep ();  				} else {  					CurrentDirectoryPath = newPath;  					updatePrompt (CurrentDirectoryPath);  				}  			} else {  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  				if (res.GetValueOrDefault () == null) {  					Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  				} else {  					Console.WriteLine ("# {0}"' res);  				}  			}  			break;  		}  		case "mkdir":  		case "md": {  			// "mkdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "rmdir": {  			// "rmdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mv":  		case "ren": {  			// "mv SOURCE DESTINATION"  			var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  			break;  		}  		case "layer": {  			if (string.IsNullOrEmpty (prm)) {  				// displays the layer id of the current folder  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  			} else {  				// change the layer id of the current folder  				prm = prm.Trim ();  				// double or single quotes can be used to escape the value  				if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  					prm = prm.Substring (1' prm.Length - 2);  				}  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mkpart": {  			// "mkpart PARTITIONNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  			}  			break;  		}  		case "topology": {  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  			break;  		}  		case "shards": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  			break;  		}  		case "sampling": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  			break;  		}  		case "coordinators": {  			await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  			break;  		}  		case "partition": {  			if (string.IsNullOrEmpty (prm)) {  				Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  				//TODO: browse existing partitions ?  				break;  			}  			var newPartition = prm.Split (new[] {  				'/'  			}' StringSplitOptions.RemoveEmptyEntries);  			IFdbDatabase newDb = null;  			try {  				newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  			} catch (Exception) {  				if (newDb != null)  					newDb.Dispose ();  				newDb = null;  				throw;  			} finally {  				if (newDb != null) {  					if (Db != null) {  						Db.Dispose ();  						Db = null;  					}  					Db = newDb;  					partition = newPartition;  					Console.WriteLine ("# Changed partition to {0}"' partition);  				}  			}  			break;  		}  		case "q":  		case "x":  		case "quit":  		case "exit":  		case "bye": {  			stop = true;  			break;  		}  		case "gc": {  			long before = GC.GetTotalMemory (false);  			Console.Write ("Collecting garbage...");  			GC.Collect ();  			GC.WaitForPendingFinalizers ();  			GC.Collect ();  			Console.WriteLine (" Done");  			long after = GC.GetTotalMemory (false);  			Console.WriteLine ("- before = " + before.ToString ("N0"));  			Console.WriteLine ("- after  = " + after.ToString ("N0"));  			Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  			break;  		}  		case "mem": {  			Console.WriteLine ("Memory usage:");  			Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  			Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  			Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  			break;  		}  		case "wide": {  			Console.WindowWidth = 160;  			break;  		}  		case "status":  		case "wtf": {  			var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  			if (result.HasFailed)  				break;  			if (result.Value.ExitCode != 0) {  				Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  				Console.WriteLine ("> StdErr:");  				Console.WriteLine (result.Value.StdErr);  				Console.WriteLine ("> StdOut:");  			}  			Console.WriteLine (result.Value.StdOut);  			break;  		}  		default: {  			Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  			break;  		}  		}  		if (!string.IsNullOrEmpty (execCommand)) {  			// only run one command' and then exit  			break;  		}  	}  } finally {  	if (Db != null)  		Db.Dispose ();  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try {  	Db = await ChangeDatabase (clusterFile' dbName' partition' cancel);  	Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  	Db.DefaultRetryLimit = Math.Max (0' maxRetries);  	Console.WriteLine ("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion () + ")");  	Console.WriteLine ("Cluster file: " + (clusterFile ?? "<default>"));  	Console.WriteLine ();  	Console.WriteLine ("FoundationDB Shell menu:");  	Console.WriteLine ("\tdir\tShow the content of the current directory");  	Console.WriteLine ("\ttree\tShow all the directories under the current directory");  	Console.WriteLine ("\tsampling\tDisplay statistics on random shards from the database");  	Console.WriteLine ("\tcoordinators\tShow the current coordinators for the cluster");  	Console.WriteLine ("\tmem\tShow memory usage statistics");  	Console.WriteLine ("\tgc\tTrigger garbage collection");  	Console.WriteLine ("\tquit\tQuit");  	Console.WriteLine ("Ready...");  	var le = new LineEditor ("FDBShell");  	string[] cmds = new string[] {  		"cd"'  		"coordinators"'  		"count"'  		"dir"'  		"exit"'  		"gc"'  		"help"'  		"layer"'  		"map"'  		"mem"'  		"mkdir"'  		"mv"'  		"partition"'  		"pwd"'  		"quit"'  		"ren"'  		"rmdir"'  		"sampling"'  		"shards"'  		"show"'  		"status"'  		"topology"'  		"tree"'  		"version"'  		"wide"'  	};  	le.AutoCompleteEvent = (txt' pos) => {  		string[] res;  		int p = txt.IndexOf (' ');  		if (p > 0) {  			string cmd = txt.Substring (0' p);  			string arg = txt.Substring (p + 1);  			if (cmd == "cd") {  				// handle completion for directories  				// txt: "cd foo" => prefix = "foo"  				// txt: "cd foobar/b" => prefix = "b"  				string path = CurrentDirectoryPath;  				string prefix = "";  				string search = arg;  				p = arg.LastIndexOf ('/');  				if (p > 0) {  					path = Path.Combine (path' arg.Substring (0' p));  					search = arg.Substring (p + 1);  					prefix = arg.Substring (0' p + 1);  				}  				var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult ();  				if (!subdirs.HasValue || subdirs.Value == null)  					return new LineEditor.Completion (txt' null);  				res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray ();  				return new LineEditor.Completion (txt' res);  			}  			// unknown command  			return new LineEditor.Completion (txt' null);  		}  		// list of commands  		res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray ();  		return new LineEditor.Completion (txt' res);  	};  	le.TabAtStartCompletes = true;  	string prompt = null;  	Action<string> updatePrompt = path => {  		prompt = String.Format ("fdb:{0}> "' path);  	};  	updatePrompt (CurrentDirectoryPath);  	while (!stop) {  		string s = startCommand != null ? startCommand : le.Edit (prompt' "");  		startCommand = null;  		if (s == null)  			break;  		var tokens = s.Trim ().Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  		string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  		var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  		var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  		switch (trimmedCommand) {  		case "": {  			continue;  		}  		case "log": {  			LogCommand (prm' Console.Out);  			break;  		}  		case "version": {  			await VersionCommand (prm' clusterFile' Console.Out' cancel);  			break;  		}  		case "tree": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  			break;  		}  		case "map": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  			break;  		}  		case "dir":  		case "ls": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  			break;  		}  		case "ll": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  			break;  		}  		case "count": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  			break;  		}  		case "show":  		case "top": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  			break;  		}  		case "last": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  			break;  		}  		case "cd":  		case "pwd": {  			if (!string.IsNullOrEmpty (prm)) {  				var newPath = CombinePath (CurrentDirectoryPath' prm);  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  				if (res == null) {  					Console.WriteLine ("# Directory {0} does not exist!"' newPath);  					Console.Beep ();  				} else {  					CurrentDirectoryPath = newPath;  					updatePrompt (CurrentDirectoryPath);  				}  			} else {  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  				if (res.GetValueOrDefault () == null) {  					Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  				} else {  					Console.WriteLine ("# {0}"' res);  				}  			}  			break;  		}  		case "mkdir":  		case "md": {  			// "mkdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "rmdir": {  			// "rmdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mv":  		case "ren": {  			// "mv SOURCE DESTINATION"  			var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  			break;  		}  		case "layer": {  			if (string.IsNullOrEmpty (prm)) {  				// displays the layer id of the current folder  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  			} else {  				// change the layer id of the current folder  				prm = prm.Trim ();  				// double or single quotes can be used to escape the value  				if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  					prm = prm.Substring (1' prm.Length - 2);  				}  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mkpart": {  			// "mkpart PARTITIONNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  			}  			break;  		}  		case "topology": {  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  			break;  		}  		case "shards": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  			break;  		}  		case "sampling": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  			break;  		}  		case "coordinators": {  			await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  			break;  		}  		case "partition": {  			if (string.IsNullOrEmpty (prm)) {  				Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  				//TODO: browse existing partitions ?  				break;  			}  			var newPartition = prm.Split (new[] {  				'/'  			}' StringSplitOptions.RemoveEmptyEntries);  			IFdbDatabase newDb = null;  			try {  				newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  			} catch (Exception) {  				if (newDb != null)  					newDb.Dispose ();  				newDb = null;  				throw;  			} finally {  				if (newDb != null) {  					if (Db != null) {  						Db.Dispose ();  						Db = null;  					}  					Db = newDb;  					partition = newPartition;  					Console.WriteLine ("# Changed partition to {0}"' partition);  				}  			}  			break;  		}  		case "q":  		case "x":  		case "quit":  		case "exit":  		case "bye": {  			stop = true;  			break;  		}  		case "gc": {  			long before = GC.GetTotalMemory (false);  			Console.Write ("Collecting garbage...");  			GC.Collect ();  			GC.WaitForPendingFinalizers ();  			GC.Collect ();  			Console.WriteLine (" Done");  			long after = GC.GetTotalMemory (false);  			Console.WriteLine ("- before = " + before.ToString ("N0"));  			Console.WriteLine ("- after  = " + after.ToString ("N0"));  			Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  			break;  		}  		case "mem": {  			Console.WriteLine ("Memory usage:");  			Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  			Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  			Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  			break;  		}  		case "wide": {  			Console.WindowWidth = 160;  			break;  		}  		case "status":  		case "wtf": {  			var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  			if (result.HasFailed)  				break;  			if (result.Value.ExitCode != 0) {  				Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  				Console.WriteLine ("> StdErr:");  				Console.WriteLine (result.Value.StdErr);  				Console.WriteLine ("> StdOut:");  			}  			Console.WriteLine (result.Value.StdOut);  			break;  		}  		default: {  			Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  			break;  		}  		}  		if (!string.IsNullOrEmpty (execCommand)) {  			// only run one command' and then exit  			break;  		}  	}  } finally {  	if (Db != null)  		Db.Dispose ();  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try {  	Db = await ChangeDatabase (clusterFile' dbName' partition' cancel);  	Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  	Db.DefaultRetryLimit = Math.Max (0' maxRetries);  	Console.WriteLine ("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion () + ")");  	Console.WriteLine ("Cluster file: " + (clusterFile ?? "<default>"));  	Console.WriteLine ();  	Console.WriteLine ("FoundationDB Shell menu:");  	Console.WriteLine ("\tdir\tShow the content of the current directory");  	Console.WriteLine ("\ttree\tShow all the directories under the current directory");  	Console.WriteLine ("\tsampling\tDisplay statistics on random shards from the database");  	Console.WriteLine ("\tcoordinators\tShow the current coordinators for the cluster");  	Console.WriteLine ("\tmem\tShow memory usage statistics");  	Console.WriteLine ("\tgc\tTrigger garbage collection");  	Console.WriteLine ("\tquit\tQuit");  	Console.WriteLine ("Ready...");  	var le = new LineEditor ("FDBShell");  	string[] cmds = new string[] {  		"cd"'  		"coordinators"'  		"count"'  		"dir"'  		"exit"'  		"gc"'  		"help"'  		"layer"'  		"map"'  		"mem"'  		"mkdir"'  		"mv"'  		"partition"'  		"pwd"'  		"quit"'  		"ren"'  		"rmdir"'  		"sampling"'  		"shards"'  		"show"'  		"status"'  		"topology"'  		"tree"'  		"version"'  		"wide"'  	};  	le.AutoCompleteEvent = (txt' pos) => {  		string[] res;  		int p = txt.IndexOf (' ');  		if (p > 0) {  			string cmd = txt.Substring (0' p);  			string arg = txt.Substring (p + 1);  			if (cmd == "cd") {  				// handle completion for directories  				// txt: "cd foo" => prefix = "foo"  				// txt: "cd foobar/b" => prefix = "b"  				string path = CurrentDirectoryPath;  				string prefix = "";  				string search = arg;  				p = arg.LastIndexOf ('/');  				if (p > 0) {  					path = Path.Combine (path' arg.Substring (0' p));  					search = arg.Substring (p + 1);  					prefix = arg.Substring (0' p + 1);  				}  				var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult ();  				if (!subdirs.HasValue || subdirs.Value == null)  					return new LineEditor.Completion (txt' null);  				res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray ();  				return new LineEditor.Completion (txt' res);  			}  			// unknown command  			return new LineEditor.Completion (txt' null);  		}  		// list of commands  		res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray ();  		return new LineEditor.Completion (txt' res);  	};  	le.TabAtStartCompletes = true;  	string prompt = null;  	Action<string> updatePrompt = path => {  		prompt = String.Format ("fdb:{0}> "' path);  	};  	updatePrompt (CurrentDirectoryPath);  	while (!stop) {  		string s = startCommand != null ? startCommand : le.Edit (prompt' "");  		startCommand = null;  		if (s == null)  			break;  		var tokens = s.Trim ().Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  		string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  		var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  		var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  		switch (trimmedCommand) {  		case "": {  			continue;  		}  		case "log": {  			LogCommand (prm' Console.Out);  			break;  		}  		case "version": {  			await VersionCommand (prm' clusterFile' Console.Out' cancel);  			break;  		}  		case "tree": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  			break;  		}  		case "map": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  			break;  		}  		case "dir":  		case "ls": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  			break;  		}  		case "ll": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  			break;  		}  		case "count": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  			break;  		}  		case "show":  		case "top": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  			break;  		}  		case "last": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  			break;  		}  		case "cd":  		case "pwd": {  			if (!string.IsNullOrEmpty (prm)) {  				var newPath = CombinePath (CurrentDirectoryPath' prm);  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  				if (res == null) {  					Console.WriteLine ("# Directory {0} does not exist!"' newPath);  					Console.Beep ();  				} else {  					CurrentDirectoryPath = newPath;  					updatePrompt (CurrentDirectoryPath);  				}  			} else {  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  				if (res.GetValueOrDefault () == null) {  					Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  				} else {  					Console.WriteLine ("# {0}"' res);  				}  			}  			break;  		}  		case "mkdir":  		case "md": {  			// "mkdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "rmdir": {  			// "rmdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mv":  		case "ren": {  			// "mv SOURCE DESTINATION"  			var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  			break;  		}  		case "layer": {  			if (string.IsNullOrEmpty (prm)) {  				// displays the layer id of the current folder  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  			} else {  				// change the layer id of the current folder  				prm = prm.Trim ();  				// double or single quotes can be used to escape the value  				if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  					prm = prm.Substring (1' prm.Length - 2);  				}  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mkpart": {  			// "mkpart PARTITIONNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  			}  			break;  		}  		case "topology": {  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  			break;  		}  		case "shards": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  			break;  		}  		case "sampling": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  			break;  		}  		case "coordinators": {  			await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  			break;  		}  		case "partition": {  			if (string.IsNullOrEmpty (prm)) {  				Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  				//TODO: browse existing partitions ?  				break;  			}  			var newPartition = prm.Split (new[] {  				'/'  			}' StringSplitOptions.RemoveEmptyEntries);  			IFdbDatabase newDb = null;  			try {  				newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  			} catch (Exception) {  				if (newDb != null)  					newDb.Dispose ();  				newDb = null;  				throw;  			} finally {  				if (newDb != null) {  					if (Db != null) {  						Db.Dispose ();  						Db = null;  					}  					Db = newDb;  					partition = newPartition;  					Console.WriteLine ("# Changed partition to {0}"' partition);  				}  			}  			break;  		}  		case "q":  		case "x":  		case "quit":  		case "exit":  		case "bye": {  			stop = true;  			break;  		}  		case "gc": {  			long before = GC.GetTotalMemory (false);  			Console.Write ("Collecting garbage...");  			GC.Collect ();  			GC.WaitForPendingFinalizers ();  			GC.Collect ();  			Console.WriteLine (" Done");  			long after = GC.GetTotalMemory (false);  			Console.WriteLine ("- before = " + before.ToString ("N0"));  			Console.WriteLine ("- after  = " + after.ToString ("N0"));  			Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  			break;  		}  		case "mem": {  			Console.WriteLine ("Memory usage:");  			Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  			Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  			Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  			break;  		}  		case "wide": {  			Console.WindowWidth = 160;  			break;  		}  		case "status":  		case "wtf": {  			var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  			if (result.HasFailed)  				break;  			if (result.Value.ExitCode != 0) {  				Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  				Console.WriteLine ("> StdErr:");  				Console.WriteLine (result.Value.StdErr);  				Console.WriteLine ("> StdOut:");  			}  			Console.WriteLine (result.Value.StdOut);  			break;  		}  		default: {  			Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  			break;  		}  		}  		if (!string.IsNullOrEmpty (execCommand)) {  			// only run one command' and then exit  			break;  		}  	}  } finally {  	if (Db != null)  		Db.Dispose ();  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try {  	Db = await ChangeDatabase (clusterFile' dbName' partition' cancel);  	Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  	Db.DefaultRetryLimit = Math.Max (0' maxRetries);  	Console.WriteLine ("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion () + ")");  	Console.WriteLine ("Cluster file: " + (clusterFile ?? "<default>"));  	Console.WriteLine ();  	Console.WriteLine ("FoundationDB Shell menu:");  	Console.WriteLine ("\tdir\tShow the content of the current directory");  	Console.WriteLine ("\ttree\tShow all the directories under the current directory");  	Console.WriteLine ("\tsampling\tDisplay statistics on random shards from the database");  	Console.WriteLine ("\tcoordinators\tShow the current coordinators for the cluster");  	Console.WriteLine ("\tmem\tShow memory usage statistics");  	Console.WriteLine ("\tgc\tTrigger garbage collection");  	Console.WriteLine ("\tquit\tQuit");  	Console.WriteLine ("Ready...");  	var le = new LineEditor ("FDBShell");  	string[] cmds = new string[] {  		"cd"'  		"coordinators"'  		"count"'  		"dir"'  		"exit"'  		"gc"'  		"help"'  		"layer"'  		"map"'  		"mem"'  		"mkdir"'  		"mv"'  		"partition"'  		"pwd"'  		"quit"'  		"ren"'  		"rmdir"'  		"sampling"'  		"shards"'  		"show"'  		"status"'  		"topology"'  		"tree"'  		"version"'  		"wide"'  	};  	le.AutoCompleteEvent = (txt' pos) => {  		string[] res;  		int p = txt.IndexOf (' ');  		if (p > 0) {  			string cmd = txt.Substring (0' p);  			string arg = txt.Substring (p + 1);  			if (cmd == "cd") {  				// handle completion for directories  				// txt: "cd foo" => prefix = "foo"  				// txt: "cd foobar/b" => prefix = "b"  				string path = CurrentDirectoryPath;  				string prefix = "";  				string search = arg;  				p = arg.LastIndexOf ('/');  				if (p > 0) {  					path = Path.Combine (path' arg.Substring (0' p));  					search = arg.Substring (p + 1);  					prefix = arg.Substring (0' p + 1);  				}  				var subdirs = RunAsyncCommand ((db' log' ct) => AutoCompleteDirectories (path' db' log' ct)' cancel).GetAwaiter ().GetResult ();  				if (!subdirs.HasValue || subdirs.Value == null)  					return new LineEditor.Completion (txt' null);  				res = subdirs.Value.Where (s => s.StartsWith (search' StringComparison.Ordinal)).Select (s => (cmd + " " + prefix + s).Substring (txt.Length)).ToArray ();  				return new LineEditor.Completion (txt' res);  			}  			// unknown command  			return new LineEditor.Completion (txt' null);  		}  		// list of commands  		res = cmds.Where (cmd => cmd.StartsWith (txt' StringComparison.OrdinalIgnoreCase)).Select (cmd => cmd.Substring (txt.Length)).ToArray ();  		return new LineEditor.Completion (txt' res);  	};  	le.TabAtStartCompletes = true;  	string prompt = null;  	Action<string> updatePrompt = path => {  		prompt = String.Format ("fdb:{0}> "' path);  	};  	updatePrompt (CurrentDirectoryPath);  	while (!stop) {  		string s = startCommand != null ? startCommand : le.Edit (prompt' "");  		startCommand = null;  		if (s == null)  			break;  		var tokens = s.Trim ().Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  		string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  		var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  		var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  		switch (trimmedCommand) {  		case "": {  			continue;  		}  		case "log": {  			LogCommand (prm' Console.Out);  			break;  		}  		case "version": {  			await VersionCommand (prm' clusterFile' Console.Out' cancel);  			break;  		}  		case "tree": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  			break;  		}  		case "map": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  			break;  		}  		case "dir":  		case "ls": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  			break;  		}  		case "ll": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  			break;  		}  		case "count": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  			break;  		}  		case "show":  		case "top": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  			break;  		}  		case "last": {  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  			break;  		}  		case "cd":  		case "pwd": {  			if (!string.IsNullOrEmpty (prm)) {  				var newPath = CombinePath (CurrentDirectoryPath' prm);  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  				if (res == null) {  					Console.WriteLine ("# Directory {0} does not exist!"' newPath);  					Console.Beep ();  				} else {  					CurrentDirectoryPath = newPath;  					updatePrompt (CurrentDirectoryPath);  				}  			} else {  				var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  				if (res.GetValueOrDefault () == null) {  					Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  				} else {  					Console.WriteLine ("# {0}"' res);  				}  			}  			break;  		}  		case "mkdir":  		case "md": {  			// "mkdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "rmdir": {  			// "rmdir DIRECTORYNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mv":  		case "ren": {  			// "mv SOURCE DESTINATION"  			var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  			break;  		}  		case "layer": {  			if (string.IsNullOrEmpty (prm)) {  				// displays the layer id of the current folder  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  			} else {  				// change the layer id of the current folder  				prm = prm.Trim ();  				// double or single quotes can be used to escape the value  				if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  					prm = prm.Substring (1' prm.Length - 2);  				}  				var path = ParsePath (CurrentDirectoryPath);  				await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  			}  			break;  		}  		case "mkpart": {  			// "mkpart PARTITIONNAME"  			if (!string.IsNullOrEmpty (prm)) {  				var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  				await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  			}  			break;  		}  		case "topology": {  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  			break;  		}  		case "shards": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  			break;  		}  		case "sampling": {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  			break;  		}  		case "coordinators": {  			await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  			break;  		}  		case "partition": {  			if (string.IsNullOrEmpty (prm)) {  				Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  				//TODO: browse existing partitions ?  				break;  			}  			var newPartition = prm.Split (new[] {  				'/'  			}' StringSplitOptions.RemoveEmptyEntries);  			IFdbDatabase newDb = null;  			try {  				newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  			} catch (Exception) {  				if (newDb != null)  					newDb.Dispose ();  				newDb = null;  				throw;  			} finally {  				if (newDb != null) {  					if (Db != null) {  						Db.Dispose ();  						Db = null;  					}  					Db = newDb;  					partition = newPartition;  					Console.WriteLine ("# Changed partition to {0}"' partition);  				}  			}  			break;  		}  		case "q":  		case "x":  		case "quit":  		case "exit":  		case "bye": {  			stop = true;  			break;  		}  		case "gc": {  			long before = GC.GetTotalMemory (false);  			Console.Write ("Collecting garbage...");  			GC.Collect ();  			GC.WaitForPendingFinalizers ();  			GC.Collect ();  			Console.WriteLine (" Done");  			long after = GC.GetTotalMemory (false);  			Console.WriteLine ("- before = " + before.ToString ("N0"));  			Console.WriteLine ("- after  = " + after.ToString ("N0"));  			Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  			break;  		}  		case "mem": {  			Console.WriteLine ("Memory usage:");  			Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  			Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  			Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  			Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  			break;  		}  		case "wide": {  			Console.WindowWidth = 160;  			break;  		}  		case "status":  		case "wtf": {  			var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  			if (result.HasFailed)  				break;  			if (result.Value.ExitCode != 0) {  				Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  				Console.WriteLine ("> StdErr:");  				Console.WriteLine (result.Value.StdErr);  				Console.WriteLine ("> StdOut:");  			}  			Console.WriteLine (result.Value.StdOut);  			break;  		}  		default: {  			Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  			break;  		}  		}  		if (!string.IsNullOrEmpty (execCommand)) {  			// only run one command' and then exit  			break;  		}  	}  } finally {  	if (Db != null)  		Db.Dispose ();  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: Db.DefaultTimeout = Math.Max (0' timeout) * 1000;  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: while (!stop) {  	string s = startCommand != null ? startCommand : le.Edit (prompt' "");  	startCommand = null;  	if (s == null)  		break;  	var tokens = s.Trim ().Split (new[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  	string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  	var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  	var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  	switch (trimmedCommand) {  	case "": {  		continue;  	}  	case "log": {  		LogCommand (prm' Console.Out);  		break;  	}  	case "version": {  		await VersionCommand (prm' clusterFile' Console.Out' cancel);  		break;  	}  	case "tree": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  		break;  	}  	case "map": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  		break;  	}  	case "dir":  	case "ls": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  		break;  	}  	case "ll": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  		break;  	}  	case "count": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  		break;  	}  	case "show":  	case "top": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  		break;  	}  	case "last": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  		break;  	}  	case "cd":  	case "pwd": {  		if (!string.IsNullOrEmpty (prm)) {  			var newPath = CombinePath (CurrentDirectoryPath' prm);  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  			if (res == null) {  				Console.WriteLine ("# Directory {0} does not exist!"' newPath);  				Console.Beep ();  			} else {  				CurrentDirectoryPath = newPath;  				updatePrompt (CurrentDirectoryPath);  			}  		} else {  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  			if (res.GetValueOrDefault () == null) {  				Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  			} else {  				Console.WriteLine ("# {0}"' res);  			}  		}  		break;  	}  	case "mkdir":  	case "md": {  		// "mkdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "rmdir": {  		// "rmdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mv":  	case "ren": {  		// "mv SOURCE DESTINATION"  		var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  		break;  	}  	case "layer": {  		if (string.IsNullOrEmpty (prm)) {  			// displays the layer id of the current folder  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  		} else {  			// change the layer id of the current folder  			prm = prm.Trim ();  			// double or single quotes can be used to escape the value  			if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  				prm = prm.Substring (1' prm.Length - 2);  			}  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mkpart": {  		// "mkpart PARTITIONNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  		}  		break;  	}  	case "topology": {  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  		break;  	}  	case "shards": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  		break;  	}  	case "sampling": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  		break;  	}  	case "coordinators": {  		await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  		break;  	}  	case "partition": {  		if (string.IsNullOrEmpty (prm)) {  			Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  			//TODO: browse existing partitions ?  			break;  		}  		var newPartition = prm.Split (new[] {  			'/'  		}' StringSplitOptions.RemoveEmptyEntries);  		IFdbDatabase newDb = null;  		try {  			newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  		} catch (Exception) {  			if (newDb != null)  				newDb.Dispose ();  			newDb = null;  			throw;  		} finally {  			if (newDb != null) {  				if (Db != null) {  					Db.Dispose ();  					Db = null;  				}  				Db = newDb;  				partition = newPartition;  				Console.WriteLine ("# Changed partition to {0}"' partition);  			}  		}  		break;  	}  	case "q":  	case "x":  	case "quit":  	case "exit":  	case "bye": {  		stop = true;  		break;  	}  	case "gc": {  		long before = GC.GetTotalMemory (false);  		Console.Write ("Collecting garbage...");  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  		Console.WriteLine (" Done");  		long after = GC.GetTotalMemory (false);  		Console.WriteLine ("- before = " + before.ToString ("N0"));  		Console.WriteLine ("- after  = " + after.ToString ("N0"));  		Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  		break;  	}  	case "mem": {  		Console.WriteLine ("Memory usage:");  		Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  		Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  		Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  		break;  	}  	case "wide": {  		Console.WindowWidth = 160;  		break;  	}  	case "status":  	case "wtf": {  		var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  		if (result.HasFailed)  			break;  		if (result.Value.ExitCode != 0) {  			Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  			Console.WriteLine ("> StdErr:");  			Console.WriteLine (result.Value.StdErr);  			Console.WriteLine ("> StdOut:");  		}  		Console.WriteLine (result.Value.StdOut);  		break;  	}  	default: {  		Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  		break;  	}  	}  	if (!string.IsNullOrEmpty (execCommand)) {  		// only run one command' and then exit  		break;  	}  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: while (!stop) {  	string s = startCommand != null ? startCommand : le.Edit (prompt' "");  	startCommand = null;  	if (s == null)  		break;  	var tokens = s.Trim ().Split (new[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  	string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  	var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  	var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  	switch (trimmedCommand) {  	case "": {  		continue;  	}  	case "log": {  		LogCommand (prm' Console.Out);  		break;  	}  	case "version": {  		await VersionCommand (prm' clusterFile' Console.Out' cancel);  		break;  	}  	case "tree": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  		break;  	}  	case "map": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  		break;  	}  	case "dir":  	case "ls": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  		break;  	}  	case "ll": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  		break;  	}  	case "count": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  		break;  	}  	case "show":  	case "top": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  		break;  	}  	case "last": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  		break;  	}  	case "cd":  	case "pwd": {  		if (!string.IsNullOrEmpty (prm)) {  			var newPath = CombinePath (CurrentDirectoryPath' prm);  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  			if (res == null) {  				Console.WriteLine ("# Directory {0} does not exist!"' newPath);  				Console.Beep ();  			} else {  				CurrentDirectoryPath = newPath;  				updatePrompt (CurrentDirectoryPath);  			}  		} else {  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  			if (res.GetValueOrDefault () == null) {  				Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  			} else {  				Console.WriteLine ("# {0}"' res);  			}  		}  		break;  	}  	case "mkdir":  	case "md": {  		// "mkdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "rmdir": {  		// "rmdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mv":  	case "ren": {  		// "mv SOURCE DESTINATION"  		var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  		break;  	}  	case "layer": {  		if (string.IsNullOrEmpty (prm)) {  			// displays the layer id of the current folder  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  		} else {  			// change the layer id of the current folder  			prm = prm.Trim ();  			// double or single quotes can be used to escape the value  			if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  				prm = prm.Substring (1' prm.Length - 2);  			}  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mkpart": {  		// "mkpart PARTITIONNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  		}  		break;  	}  	case "topology": {  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  		break;  	}  	case "shards": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  		break;  	}  	case "sampling": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  		break;  	}  	case "coordinators": {  		await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  		break;  	}  	case "partition": {  		if (string.IsNullOrEmpty (prm)) {  			Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  			//TODO: browse existing partitions ?  			break;  		}  		var newPartition = prm.Split (new[] {  			'/'  		}' StringSplitOptions.RemoveEmptyEntries);  		IFdbDatabase newDb = null;  		try {  			newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  		} catch (Exception) {  			if (newDb != null)  				newDb.Dispose ();  			newDb = null;  			throw;  		} finally {  			if (newDb != null) {  				if (Db != null) {  					Db.Dispose ();  					Db = null;  				}  				Db = newDb;  				partition = newPartition;  				Console.WriteLine ("# Changed partition to {0}"' partition);  			}  		}  		break;  	}  	case "q":  	case "x":  	case "quit":  	case "exit":  	case "bye": {  		stop = true;  		break;  	}  	case "gc": {  		long before = GC.GetTotalMemory (false);  		Console.Write ("Collecting garbage...");  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  		Console.WriteLine (" Done");  		long after = GC.GetTotalMemory (false);  		Console.WriteLine ("- before = " + before.ToString ("N0"));  		Console.WriteLine ("- after  = " + after.ToString ("N0"));  		Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  		break;  	}  	case "mem": {  		Console.WriteLine ("Memory usage:");  		Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  		Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  		Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  		break;  	}  	case "wide": {  		Console.WindowWidth = 160;  		break;  	}  	case "status":  	case "wtf": {  		var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  		if (result.HasFailed)  			break;  		if (result.Value.ExitCode != 0) {  			Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  			Console.WriteLine ("> StdErr:");  			Console.WriteLine (result.Value.StdErr);  			Console.WriteLine ("> StdOut:");  		}  		Console.WriteLine (result.Value.StdOut);  		break;  	}  	default: {  		Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  		break;  	}  	}  	if (!string.IsNullOrEmpty (execCommand)) {  		// only run one command' and then exit  		break;  	}  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: while (!stop) {  	string s = startCommand != null ? startCommand : le.Edit (prompt' "");  	startCommand = null;  	if (s == null)  		break;  	var tokens = s.Trim ().Split (new[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  	string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  	var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  	var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  	switch (trimmedCommand) {  	case "": {  		continue;  	}  	case "log": {  		LogCommand (prm' Console.Out);  		break;  	}  	case "version": {  		await VersionCommand (prm' clusterFile' Console.Out' cancel);  		break;  	}  	case "tree": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  		break;  	}  	case "map": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  		break;  	}  	case "dir":  	case "ls": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  		break;  	}  	case "ll": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  		break;  	}  	case "count": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  		break;  	}  	case "show":  	case "top": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  		break;  	}  	case "last": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  		break;  	}  	case "cd":  	case "pwd": {  		if (!string.IsNullOrEmpty (prm)) {  			var newPath = CombinePath (CurrentDirectoryPath' prm);  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  			if (res == null) {  				Console.WriteLine ("# Directory {0} does not exist!"' newPath);  				Console.Beep ();  			} else {  				CurrentDirectoryPath = newPath;  				updatePrompt (CurrentDirectoryPath);  			}  		} else {  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  			if (res.GetValueOrDefault () == null) {  				Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  			} else {  				Console.WriteLine ("# {0}"' res);  			}  		}  		break;  	}  	case "mkdir":  	case "md": {  		// "mkdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "rmdir": {  		// "rmdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mv":  	case "ren": {  		// "mv SOURCE DESTINATION"  		var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  		break;  	}  	case "layer": {  		if (string.IsNullOrEmpty (prm)) {  			// displays the layer id of the current folder  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  		} else {  			// change the layer id of the current folder  			prm = prm.Trim ();  			// double or single quotes can be used to escape the value  			if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  				prm = prm.Substring (1' prm.Length - 2);  			}  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mkpart": {  		// "mkpart PARTITIONNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  		}  		break;  	}  	case "topology": {  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  		break;  	}  	case "shards": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  		break;  	}  	case "sampling": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  		break;  	}  	case "coordinators": {  		await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  		break;  	}  	case "partition": {  		if (string.IsNullOrEmpty (prm)) {  			Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  			//TODO: browse existing partitions ?  			break;  		}  		var newPartition = prm.Split (new[] {  			'/'  		}' StringSplitOptions.RemoveEmptyEntries);  		IFdbDatabase newDb = null;  		try {  			newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  		} catch (Exception) {  			if (newDb != null)  				newDb.Dispose ();  			newDb = null;  			throw;  		} finally {  			if (newDb != null) {  				if (Db != null) {  					Db.Dispose ();  					Db = null;  				}  				Db = newDb;  				partition = newPartition;  				Console.WriteLine ("# Changed partition to {0}"' partition);  			}  		}  		break;  	}  	case "q":  	case "x":  	case "quit":  	case "exit":  	case "bye": {  		stop = true;  		break;  	}  	case "gc": {  		long before = GC.GetTotalMemory (false);  		Console.Write ("Collecting garbage...");  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  		Console.WriteLine (" Done");  		long after = GC.GetTotalMemory (false);  		Console.WriteLine ("- before = " + before.ToString ("N0"));  		Console.WriteLine ("- after  = " + after.ToString ("N0"));  		Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  		break;  	}  	case "mem": {  		Console.WriteLine ("Memory usage:");  		Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  		Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  		Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  		break;  	}  	case "wide": {  		Console.WindowWidth = 160;  		break;  	}  	case "status":  	case "wtf": {  		var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  		if (result.HasFailed)  			break;  		if (result.Value.ExitCode != 0) {  			Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  			Console.WriteLine ("> StdErr:");  			Console.WriteLine (result.Value.StdErr);  			Console.WriteLine ("> StdOut:");  		}  		Console.WriteLine (result.Value.StdOut);  		break;  	}  	default: {  		Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  		break;  	}  	}  	if (!string.IsNullOrEmpty (execCommand)) {  		// only run one command' and then exit  		break;  	}  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: while (!stop) {  	string s = startCommand != null ? startCommand : le.Edit (prompt' "");  	startCommand = null;  	if (s == null)  		break;  	var tokens = s.Trim ().Split (new[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  	string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  	var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  	var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  	switch (trimmedCommand) {  	case "": {  		continue;  	}  	case "log": {  		LogCommand (prm' Console.Out);  		break;  	}  	case "version": {  		await VersionCommand (prm' clusterFile' Console.Out' cancel);  		break;  	}  	case "tree": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  		break;  	}  	case "map": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  		break;  	}  	case "dir":  	case "ls": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  		break;  	}  	case "ll": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  		break;  	}  	case "count": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  		break;  	}  	case "show":  	case "top": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  		break;  	}  	case "last": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  		break;  	}  	case "cd":  	case "pwd": {  		if (!string.IsNullOrEmpty (prm)) {  			var newPath = CombinePath (CurrentDirectoryPath' prm);  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  			if (res == null) {  				Console.WriteLine ("# Directory {0} does not exist!"' newPath);  				Console.Beep ();  			} else {  				CurrentDirectoryPath = newPath;  				updatePrompt (CurrentDirectoryPath);  			}  		} else {  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  			if (res.GetValueOrDefault () == null) {  				Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  			} else {  				Console.WriteLine ("# {0}"' res);  			}  		}  		break;  	}  	case "mkdir":  	case "md": {  		// "mkdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "rmdir": {  		// "rmdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mv":  	case "ren": {  		// "mv SOURCE DESTINATION"  		var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  		break;  	}  	case "layer": {  		if (string.IsNullOrEmpty (prm)) {  			// displays the layer id of the current folder  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  		} else {  			// change the layer id of the current folder  			prm = prm.Trim ();  			// double or single quotes can be used to escape the value  			if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  				prm = prm.Substring (1' prm.Length - 2);  			}  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mkpart": {  		// "mkpart PARTITIONNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  		}  		break;  	}  	case "topology": {  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  		break;  	}  	case "shards": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  		break;  	}  	case "sampling": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  		break;  	}  	case "coordinators": {  		await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  		break;  	}  	case "partition": {  		if (string.IsNullOrEmpty (prm)) {  			Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  			//TODO: browse existing partitions ?  			break;  		}  		var newPartition = prm.Split (new[] {  			'/'  		}' StringSplitOptions.RemoveEmptyEntries);  		IFdbDatabase newDb = null;  		try {  			newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  		} catch (Exception) {  			if (newDb != null)  				newDb.Dispose ();  			newDb = null;  			throw;  		} finally {  			if (newDb != null) {  				if (Db != null) {  					Db.Dispose ();  					Db = null;  				}  				Db = newDb;  				partition = newPartition;  				Console.WriteLine ("# Changed partition to {0}"' partition);  			}  		}  		break;  	}  	case "q":  	case "x":  	case "quit":  	case "exit":  	case "bye": {  		stop = true;  		break;  	}  	case "gc": {  		long before = GC.GetTotalMemory (false);  		Console.Write ("Collecting garbage...");  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  		Console.WriteLine (" Done");  		long after = GC.GetTotalMemory (false);  		Console.WriteLine ("- before = " + before.ToString ("N0"));  		Console.WriteLine ("- after  = " + after.ToString ("N0"));  		Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  		break;  	}  	case "mem": {  		Console.WriteLine ("Memory usage:");  		Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  		Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  		Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  		break;  	}  	case "wide": {  		Console.WindowWidth = 160;  		break;  	}  	case "status":  	case "wtf": {  		var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  		if (result.HasFailed)  			break;  		if (result.Value.ExitCode != 0) {  			Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  			Console.WriteLine ("> StdErr:");  			Console.WriteLine (result.Value.StdErr);  			Console.WriteLine ("> StdOut:");  		}  		Console.WriteLine (result.Value.StdOut);  		break;  	}  	default: {  		Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  		break;  	}  	}  	if (!string.IsNullOrEmpty (execCommand)) {  		// only run one command' and then exit  		break;  	}  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: while (!stop) {  	string s = startCommand != null ? startCommand : le.Edit (prompt' "");  	startCommand = null;  	if (s == null)  		break;  	var tokens = s.Trim ().Split (new[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	string cmd = tokens.Length > 0 ? tokens [0] : String.Empty;  	string prm = tokens.Length > 1 ? tokens [1] : String.Empty;  	var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string> (tokens.Skip (2)) : FdbTuple.Empty;  	var trimmedCommand = cmd.Trim ().ToLowerInvariant ();  	switch (trimmedCommand) {  	case "": {  		continue;  	}  	case "log": {  		LogCommand (prm' Console.Out);  		break;  	}  	case "version": {  		await VersionCommand (prm' clusterFile' Console.Out' cancel);  		break;  	}  	case "tree": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  		break;  	}  	case "map": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  		break;  	}  	case "dir":  	case "ls": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  		break;  	}  	case "ll": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  		break;  	}  	case "count": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  		break;  	}  	case "show":  	case "top": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  		break;  	}  	case "last": {  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  		break;  	}  	case "cd":  	case "pwd": {  		if (!string.IsNullOrEmpty (prm)) {  			var newPath = CombinePath (CurrentDirectoryPath' prm);  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  			if (res == null) {  				Console.WriteLine ("# Directory {0} does not exist!"' newPath);  				Console.Beep ();  			} else {  				CurrentDirectoryPath = newPath;  				updatePrompt (CurrentDirectoryPath);  			}  		} else {  			var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  			if (res.GetValueOrDefault () == null) {  				Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  			} else {  				Console.WriteLine ("# {0}"' res);  			}  		}  		break;  	}  	case "mkdir":  	case "md": {  		// "mkdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "rmdir": {  		// "rmdir DIRECTORYNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mv":  	case "ren": {  		// "mv SOURCE DESTINATION"  		var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  		break;  	}  	case "layer": {  		if (string.IsNullOrEmpty (prm)) {  			// displays the layer id of the current folder  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  		} else {  			// change the layer id of the current folder  			prm = prm.Trim ();  			// double or single quotes can be used to escape the value  			if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  				prm = prm.Substring (1' prm.Length - 2);  			}  			var path = ParsePath (CurrentDirectoryPath);  			await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  		}  		break;  	}  	case "mkpart": {  		// "mkpart PARTITIONNAME"  		if (!string.IsNullOrEmpty (prm)) {  			var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  			await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  		}  		break;  	}  	case "topology": {  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  		break;  	}  	case "shards": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  		break;  	}  	case "sampling": {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  		break;  	}  	case "coordinators": {  		await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  		break;  	}  	case "partition": {  		if (string.IsNullOrEmpty (prm)) {  			Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  			//TODO: browse existing partitions ?  			break;  		}  		var newPartition = prm.Split (new[] {  			'/'  		}' StringSplitOptions.RemoveEmptyEntries);  		IFdbDatabase newDb = null;  		try {  			newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  		} catch (Exception) {  			if (newDb != null)  				newDb.Dispose ();  			newDb = null;  			throw;  		} finally {  			if (newDb != null) {  				if (Db != null) {  					Db.Dispose ();  					Db = null;  				}  				Db = newDb;  				partition = newPartition;  				Console.WriteLine ("# Changed partition to {0}"' partition);  			}  		}  		break;  	}  	case "q":  	case "x":  	case "quit":  	case "exit":  	case "bye": {  		stop = true;  		break;  	}  	case "gc": {  		long before = GC.GetTotalMemory (false);  		Console.Write ("Collecting garbage...");  		GC.Collect ();  		GC.WaitForPendingFinalizers ();  		GC.Collect ();  		Console.WriteLine (" Done");  		long after = GC.GetTotalMemory (false);  		Console.WriteLine ("- before = " + before.ToString ("N0"));  		Console.WriteLine ("- after  = " + after.ToString ("N0"));  		Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  		break;  	}  	case "mem": {  		Console.WriteLine ("Memory usage:");  		Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  		Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  		Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  		Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  		break;  	}  	case "wide": {  		Console.WindowWidth = 160;  		break;  	}  	case "status":  	case "wtf": {  		var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  		if (result.HasFailed)  			break;  		if (result.Value.ExitCode != 0) {  			Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  			Console.WriteLine ("> StdErr:");  			Console.WriteLine (result.Value.StdErr);  			Console.WriteLine ("> StdOut:");  		}  		Console.WriteLine (result.Value.StdOut);  		break;  	}  	default: {  		Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  		break;  	}  	}  	if (!string.IsNullOrEmpty (execCommand)) {  		// only run one command' and then exit  		break;  	}  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: switch (trimmedCommand) {  case "": {  	continue;  }  case "log": {  	LogCommand (prm' Console.Out);  	break;  }  case "version": {  	await VersionCommand (prm' clusterFile' Console.Out' cancel);  	break;  }  case "tree": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  	break;  }  case "map": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  	break;  }  case "dir":  case "ls": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  	break;  }  case "ll": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  	break;  }  case "count": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  	break;  }  case "show":  case "top": {  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  	break;  }  case "last": {  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  	break;  }  case "cd":  case "pwd": {  	if (!string.IsNullOrEmpty (prm)) {  		var newPath = CombinePath (CurrentDirectoryPath' prm);  		var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  		if (res == null) {  			Console.WriteLine ("# Directory {0} does not exist!"' newPath);  			Console.Beep ();  		} else {  			CurrentDirectoryPath = newPath;  			updatePrompt (CurrentDirectoryPath);  		}  	} else {  		var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  		if (res.GetValueOrDefault () == null) {  			Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  		} else {  			Console.WriteLine ("# {0}"' res);  		}  	}  	break;  }  case "mkdir":  case "md": {  	// "mkdir DIRECTORYNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  	}  	break;  }  case "rmdir": {  	// "rmdir DIRECTORYNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  	}  	break;  }  case "mv":  case "ren": {  	// "mv SOURCE DESTINATION"  	var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  	break;  }  case "layer": {  	if (string.IsNullOrEmpty (prm)) {  		// displays the layer id of the current folder  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  	} else {  		// change the layer id of the current folder  		prm = prm.Trim ();  		// double or single quotes can be used to escape the value  		if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  			prm = prm.Substring (1' prm.Length - 2);  		}  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  	}  	break;  }  case "mkpart": {  	// "mkpart PARTITIONNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  	}  	break;  }  case "topology": {  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  	break;  }  case "shards": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  	break;  }  case "sampling": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  	break;  }  case "coordinators": {  	await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  	break;  }  case "partition": {  	if (string.IsNullOrEmpty (prm)) {  		Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  		//TODO: browse existing partitions ?  		break;  	}  	var newPartition = prm.Split (new[] {  		'/'  	}' StringSplitOptions.RemoveEmptyEntries);  	IFdbDatabase newDb = null;  	try {  		newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  	} catch (Exception) {  		if (newDb != null)  			newDb.Dispose ();  		newDb = null;  		throw;  	} finally {  		if (newDb != null) {  			if (Db != null) {  				Db.Dispose ();  				Db = null;  			}  			Db = newDb;  			partition = newPartition;  			Console.WriteLine ("# Changed partition to {0}"' partition);  		}  	}  	break;  }  case "q":  case "x":  case "quit":  case "exit":  case "bye": {  	stop = true;  	break;  }  case "gc": {  	long before = GC.GetTotalMemory (false);  	Console.Write ("Collecting garbage...");  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  	Console.WriteLine (" Done");  	long after = GC.GetTotalMemory (false);  	Console.WriteLine ("- before = " + before.ToString ("N0"));  	Console.WriteLine ("- after  = " + after.ToString ("N0"));  	Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  	break;  }  case "mem": {  	Console.WriteLine ("Memory usage:");  	Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  	Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  	Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  	Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  	Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  	break;  }  case "wide": {  	Console.WindowWidth = 160;  	break;  }  case "status":  case "wtf": {  	var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  	if (result.HasFailed)  		break;  	if (result.Value.ExitCode != 0) {  		Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  		Console.WriteLine ("> StdErr:");  		Console.WriteLine (result.Value.StdErr);  		Console.WriteLine ("> StdOut:");  	}  	Console.WriteLine (result.Value.StdOut);  	break;  }  default: {  	Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  	break;  }  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: switch (trimmedCommand) {  case "": {  	continue;  }  case "log": {  	LogCommand (prm' Console.Out);  	break;  }  case "version": {  	await VersionCommand (prm' clusterFile' Console.Out' cancel);  	break;  }  case "tree": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  	break;  }  case "map": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  	break;  }  case "dir":  case "ls": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  	break;  }  case "ll": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  	break;  }  case "count": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  	break;  }  case "show":  case "top": {  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  	break;  }  case "last": {  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  	break;  }  case "cd":  case "pwd": {  	if (!string.IsNullOrEmpty (prm)) {  		var newPath = CombinePath (CurrentDirectoryPath' prm);  		var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  		if (res == null) {  			Console.WriteLine ("# Directory {0} does not exist!"' newPath);  			Console.Beep ();  		} else {  			CurrentDirectoryPath = newPath;  			updatePrompt (CurrentDirectoryPath);  		}  	} else {  		var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  		if (res.GetValueOrDefault () == null) {  			Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  		} else {  			Console.WriteLine ("# {0}"' res);  		}  	}  	break;  }  case "mkdir":  case "md": {  	// "mkdir DIRECTORYNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  	}  	break;  }  case "rmdir": {  	// "rmdir DIRECTORYNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  	}  	break;  }  case "mv":  case "ren": {  	// "mv SOURCE DESTINATION"  	var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  	break;  }  case "layer": {  	if (string.IsNullOrEmpty (prm)) {  		// displays the layer id of the current folder  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  	} else {  		// change the layer id of the current folder  		prm = prm.Trim ();  		// double or single quotes can be used to escape the value  		if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  			prm = prm.Substring (1' prm.Length - 2);  		}  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  	}  	break;  }  case "mkpart": {  	// "mkpart PARTITIONNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  	}  	break;  }  case "topology": {  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  	break;  }  case "shards": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  	break;  }  case "sampling": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  	break;  }  case "coordinators": {  	await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  	break;  }  case "partition": {  	if (string.IsNullOrEmpty (prm)) {  		Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  		//TODO: browse existing partitions ?  		break;  	}  	var newPartition = prm.Split (new[] {  		'/'  	}' StringSplitOptions.RemoveEmptyEntries);  	IFdbDatabase newDb = null;  	try {  		newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  	} catch (Exception) {  		if (newDb != null)  			newDb.Dispose ();  		newDb = null;  		throw;  	} finally {  		if (newDb != null) {  			if (Db != null) {  				Db.Dispose ();  				Db = null;  			}  			Db = newDb;  			partition = newPartition;  			Console.WriteLine ("# Changed partition to {0}"' partition);  		}  	}  	break;  }  case "q":  case "x":  case "quit":  case "exit":  case "bye": {  	stop = true;  	break;  }  case "gc": {  	long before = GC.GetTotalMemory (false);  	Console.Write ("Collecting garbage...");  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  	Console.WriteLine (" Done");  	long after = GC.GetTotalMemory (false);  	Console.WriteLine ("- before = " + before.ToString ("N0"));  	Console.WriteLine ("- after  = " + after.ToString ("N0"));  	Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  	break;  }  case "mem": {  	Console.WriteLine ("Memory usage:");  	Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  	Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  	Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  	Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  	Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  	break;  }  case "wide": {  	Console.WindowWidth = 160;  	break;  }  case "status":  case "wtf": {  	var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  	if (result.HasFailed)  		break;  	if (result.Value.ExitCode != 0) {  		Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  		Console.WriteLine ("> StdErr:");  		Console.WriteLine (result.Value.StdErr);  		Console.WriteLine ("> StdOut:");  	}  	Console.WriteLine (result.Value.StdOut);  	break;  }  default: {  	Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  	break;  }  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: switch (trimmedCommand) {  case "": {  	continue;  }  case "log": {  	LogCommand (prm' Console.Out);  	break;  }  case "version": {  	await VersionCommand (prm' clusterFile' Console.Out' cancel);  	break;  }  case "tree": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Tree (path' extras' db' log' ct)' cancel);  	break;  }  case "map": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Map (path' extras' db' log' ct)' cancel);  	break;  }  case "dir":  case "ls": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  	break;  }  case "ll": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Dir (path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  	break;  }  case "count": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Count (path' extras' db' log' ct)' cancel);  	break;  }  case "show":  case "top": {  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' false' db' log' ct)' cancel);  	break;  }  case "last": {  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Show (path' extras' true' db' log' ct)' cancel);  	break;  }  case "cd":  case "pwd": {  	if (!string.IsNullOrEmpty (prm)) {  		var newPath = CombinePath (CurrentDirectoryPath' prm);  		var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (newPath)' db' ct)' cancel);  		if (res == null) {  			Console.WriteLine ("# Directory {0} does not exist!"' newPath);  			Console.Beep ();  		} else {  			CurrentDirectoryPath = newPath;  			updatePrompt (CurrentDirectoryPath);  		}  	} else {  		var res = await RunAsyncCommand ((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync (ParsePath (CurrentDirectoryPath)' db' ct)' cancel);  		if (res.GetValueOrDefault () == null) {  			Console.WriteLine ("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  		} else {  			Console.WriteLine ("# {0}"' res);  		}  	}  	break;  }  case "mkdir":  case "md": {  	// "mkdir DIRECTORYNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' extras' db' log' ct)' cancel);  	}  	break;  }  case "rmdir": {  	// "rmdir DIRECTORYNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.RemoveDirectory (path' extras' db' log' ct)' cancel);  	}  	break;  }  case "mv":  case "ren": {  	// "mv SOURCE DESTINATION"  	var srcPath = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	var dstPath = ParsePath (CombinePath (CurrentDirectoryPath' extras.Get<string> (0)));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.MoveDirectory (srcPath' dstPath' extras.Substring (1)' db' log' ct)' cancel);  	break;  }  case "layer": {  	if (string.IsNullOrEmpty (prm)) {  		// displays the layer id of the current folder  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  	} else {  		// change the layer id of the current folder  		prm = prm.Trim ();  		// double or single quotes can be used to escape the value  		if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  			prm = prm.Substring (1' prm.Length - 2);  		}  		var path = ParsePath (CurrentDirectoryPath);  		await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  	}  	break;  }  case "mkpart": {  	// "mkpart PARTITIONNAME"  	if (!string.IsNullOrEmpty (prm)) {  		var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  		await RunAsyncCommand ((db' log' ct) => BasicCommands.CreateDirectory (path' FdbTuple.Create (FdbDirectoryPartition.LayerId).Concat (extras)' db' log' ct)' cancel);  	}  	break;  }  case "topology": {  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Topology (null' extras' db' log' ct)' cancel);  	break;  }  case "shards": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Shards (path' extras' db' log' ct)' cancel);  	break;  }  case "sampling": {  	var path = ParsePath (CombinePath (CurrentDirectoryPath' prm));  	await RunAsyncCommand ((db' log' ct) => BasicCommands.Sampling (path' extras' db' log' ct)' cancel);  	break;  }  case "coordinators": {  	await RunAsyncCommand ((db' log' ct) => CoordinatorsCommand (db' log' ct)' cancel);  	break;  }  case "partition": {  	if (string.IsNullOrEmpty (prm)) {  		Console.WriteLine ("# Current partition is {0}"' String.Join ("/"' partition));  		//TODO: browse existing partitions ?  		break;  	}  	var newPartition = prm.Split (new[] {  		'/'  	}' StringSplitOptions.RemoveEmptyEntries);  	IFdbDatabase newDb = null;  	try {  		newDb = await ChangeDatabase (clusterFile' dbName' newPartition' cancel);  	} catch (Exception) {  		if (newDb != null)  			newDb.Dispose ();  		newDb = null;  		throw;  	} finally {  		if (newDb != null) {  			if (Db != null) {  				Db.Dispose ();  				Db = null;  			}  			Db = newDb;  			partition = newPartition;  			Console.WriteLine ("# Changed partition to {0}"' partition);  		}  	}  	break;  }  case "q":  case "x":  case "quit":  case "exit":  case "bye": {  	stop = true;  	break;  }  case "gc": {  	long before = GC.GetTotalMemory (false);  	Console.Write ("Collecting garbage...");  	GC.Collect ();  	GC.WaitForPendingFinalizers ();  	GC.Collect ();  	Console.WriteLine (" Done");  	long after = GC.GetTotalMemory (false);  	Console.WriteLine ("- before = " + before.ToString ("N0"));  	Console.WriteLine ("- after  = " + after.ToString ("N0"));  	Console.WriteLine ("- delta  = " + (before - after).ToString ("N0"));  	break;  }  case "mem": {  	Console.WriteLine ("Memory usage:");  	Console.WriteLine ("- Working Set  : " + PerfCounters.WorkingSet.NextValue ().ToString ("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue ().ToString ("N0") + ")");  	Console.WriteLine ("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue ().ToString ("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue ().ToString ("N0") + ")");  	Console.WriteLine ("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue ().ToString ("N0"));  	Console.WriteLine ("- Managed Mem  : " + GC.GetTotalMemory (false).ToString ("N0"));  	Console.WriteLine ("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue ().ToString ("N0"));  	break;  }  case "wide": {  	Console.WindowWidth = 160;  	break;  }  case "status":  case "wtf": {  	var result = await RunAsyncCommand ((_' log' ct) => FdbCliCommands.RunFdbCliCommand ("status details"' null' clusterFile' log' ct)' cancel);  	if (result.HasFailed)  		break;  	if (result.Value.ExitCode != 0) {  		Console.WriteLine ("# fdbcli exited with code {0}"' result.Value.ExitCode);  		Console.WriteLine ("> StdErr:");  		Console.WriteLine (result.Value.StdErr);  		Console.WriteLine ("> StdOut:");  	}  	Console.WriteLine (result.Value.StdOut);  	break;  }  default: {  	Console.WriteLine (string.Format ("Unknown command : '{0}'"' trimmedCommand));  	break;  }  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: if (string.IsNullOrEmpty (prm)) {  	// displays the layer id of the current folder  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  } else {  	// change the layer id of the current folder  	prm = prm.Trim ();  	// double or single quotes can be used to escape the value  	if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  		prm = prm.Substring (1' prm.Length - 2);  	}  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: if (string.IsNullOrEmpty (prm)) {  	// displays the layer id of the current folder  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.ShowDirectoryLayer (path' extras' db' log' ct)' cancel);  } else {  	// change the layer id of the current folder  	prm = prm.Trim ();  	// double or single quotes can be used to escape the value  	if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  		prm = prm.Substring (1' prm.Length - 2);  	}  	var path = ParsePath (CurrentDirectoryPath);  	await RunAsyncCommand ((db' log' ct) => BasicCommands.ChangeDirectoryLayer (path' prm' extras' db' log' ct)' cancel);  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  	prm = prm.Substring (1' prm.Length - 2);  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: if (prm.Length >= 2 && (prm.StartsWith ("'") && prm.EndsWith ("'")) || (prm.StartsWith ("\"") && prm.EndsWith ("\""))) {  	prm = prm.Substring (1' prm.Length - 2);  }  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: prm = prm.Substring (1' prm.Length - 2);  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: Console.WindowWidth = 160;  
Magic Number,FdbShell,Program,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,CombinePath,The following statement contains a magic number: return System.IO.Path.GetFullPath (System.IO.Path.Combine (parent' children)).Replace ("\\"' "/").Substring (2);  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (value < -double.Epsilon) {  	s [p++] = '[';  	s [p++] = 'N';  	s [p++] = 'E';  	s [p++] = 'G';  	s [p++] = ']';  } else if (marks == 0) {  	if (value > double.Epsilon)  		s [p++] = '`';  } else if (marks > 0) {  	while (marks > 10) {  		s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  		marks -= 10;  	}  	if (marks > 0) {  		if (sparse)  			s [p++] = BarTicksChars [marks];  		else  			s [p++] = BarChartChars [marks];  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (value < -double.Epsilon) {  	s [p++] = '[';  	s [p++] = 'N';  	s [p++] = 'E';  	s [p++] = 'G';  	s [p++] = ']';  } else if (marks == 0) {  	if (value > double.Epsilon)  		s [p++] = '`';  } else if (marks > 0) {  	while (marks > 10) {  		s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  		marks -= 10;  	}  	if (marks > 0) {  		if (sparse)  			s [p++] = BarTicksChars [marks];  		else  			s [p++] = BarChartChars [marks];  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (marks == 0) {  	if (value > double.Epsilon)  		s [p++] = '`';  } else if (marks > 0) {  	while (marks > 10) {  		s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  		marks -= 10;  	}  	if (marks > 0) {  		if (sparse)  			s [p++] = BarTicksChars [marks];  		else  			s [p++] = BarChartChars [marks];  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (marks == 0) {  	if (value > double.Epsilon)  		s [p++] = '`';  } else if (marks > 0) {  	while (marks > 10) {  		s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  		marks -= 10;  	}  	if (marks > 0) {  		if (sparse)  			s [p++] = BarTicksChars [marks];  		else  			s [p++] = BarChartChars [marks];  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (marks > 0) {  	while (marks > 10) {  		s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  		marks -= 10;  	}  	if (marks > 0) {  		if (sparse)  			s [p++] = BarTicksChars [marks];  		else  			s [p++] = BarChartChars [marks];  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (marks > 0) {  	while (marks > 10) {  		s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  		marks -= 10;  	}  	if (marks > 0) {  		if (sparse)  			s [p++] = BarTicksChars [marks];  		else  			s [p++] = BarChartChars [marks];  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: while (marks > 10) {  	s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  	marks -= 10;  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: while (marks > 10) {  	s [p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  	marks -= 10;  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: marks -= 10;  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: max = (3 * max + this.Count) / 4;  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: max = (3 * max + this.Count) / 4;  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: for (int i = 0; i < cs.Length; i++) {  	int p = Math.Min ((int)Math.Ceiling (rr * data [i])' 10);  	cs [i] = VerticalChartChars [p];  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"' this.Percentile (5)' this.Percentile (25)' this.Percentile (50)' this.Percentile (75)' this.Percentile (95));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"' this.Percentile (5)' this.Percentile (25)' this.Percentile (50)' this.Percentile (75)' this.Percentile (95));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"' this.Percentile (5)' this.Percentile (25)' this.Percentile (50)' this.Percentile (75)' this.Percentile (95));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"' this.Percentile (5)' this.Percentile (25)' this.Percentile (50)' this.Percentile (75)' this.Percentile (95));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"' this.Percentile (5)' this.Percentile (25)' this.Percentile (50)' this.Percentile (75)' this.Percentile (95));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0) {  	double min = this.Count == 0 ? 0d : this.Min;  	double max = this.Max;  	double median = this.Median;  	// MAD  	for (int i = 0; i < this.Buckets.Length; i++) {  	}  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"' min' max' this.Average' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"' median' this.MedianAbsoluteDeviation ()' this.StandardDeviation' unit));  	r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  	if (detailed) {  		r.AppendLine ("   _____________________________________________________________________________________________________________________");  		//_________");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");  		//____kOps_|");  	} else {  		r.AppendLine ("   ________________________________________________________________________ ");  		r.AppendLine ("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  	}  	double mult = 100.0d / this.Count;  	double sum = 0;  	for (int b = 0; b < NumBuckets; b++) {  		if (this.Buckets [b] <= 0)  			continue;  		sum += this.Buckets [b];  		r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  		/* 1 */BucketLimits [b]' // right  		/* 2 */this.Buckets [b]' // count  		/* 3 */mult * this.Buckets [b]' // percentage  		/* 4 */mult * sum' // cumulative percentage  		/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  		r.AppendLine (" |");  	}  	if (detailed) {  		r.AppendLine ("  `---------------------------------------------------------------------------------------------------------------------'");  		// ---------  	} else {  		r.AppendLine ("  `------------------------------------------------------------------------'");  	}  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.AppendLine (String.Format (CultureInfo.InvariantCulture' "- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"' this.Percentile (5)' this.Percentile (25)' median' this.Percentile (75)' this.Percentile (95)));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: for (int b = 0; b < NumBuckets; b++) {  	if (this.Buckets [b] <= 0)  		continue;  	sum += this.Buckets [b];  	r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  	/* 1 */BucketLimits [b]' // right  	/* 2 */this.Buckets [b]' // count  	/* 3 */mult * this.Buckets [b]' // percentage  	/* 4 */mult * sum' // cumulative percentage  	/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  	r.AppendLine (" |");  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: for (int b = 0; b < NumBuckets; b++) {  	if (this.Buckets [b] <= 0)  		continue;  	sum += this.Buckets [b];  	r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  	/* 1 */BucketLimits [b]' // right  	/* 2 */this.Buckets [b]' // count  	/* 3 */mult * this.Buckets [b]' // percentage  	/* 4 */mult * sum' // cumulative percentage  	/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  	r.AppendLine (" |");  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: for (int b = 0; b < NumBuckets; b++) {  	if (this.Buckets [b] <= 0)  		continue;  	sum += this.Buckets [b];  	r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  	/* 1 */BucketLimits [b]' // right  	/* 2 */this.Buckets [b]' // count  	/* 3 */mult * this.Buckets [b]' // percentage  	/* 4 */mult * sum' // cumulative percentage  	/* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  	r.AppendLine (" |");  }  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  /* 1 */BucketLimits [b]' // right  /* 2 */this.Buckets [b]' // count  /* 3 */mult * this.Buckets [b]' // percentage  /* 4 */mult * sum' // cumulative percentage  /* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  /* 1 */BucketLimits [b]' // right  /* 2 */this.Buckets [b]' // count  /* 3 */mult * this.Buckets [b]' // percentage  /* 4 */mult * sum' // cumulative percentage  /* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  
Magic Number,FdbShell,RobustHistogram,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: r.Append (String.Format (CultureInfo.InvariantCulture' "  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}" /*" | {7'7:0.0}"*/: "")' /* 0 */((b == 0) ? 0.0 : BucketLimits [b - 1])' // left  /* 1 */BucketLimits [b]' // right  /* 2 */this.Buckets [b]' // count  /* 3 */mult * this.Buckets [b]' // percentage  /* 4 */mult * sum' // cumulative percentage  /* 5 */FormatHistoBar ((double)this.Buckets [b] / this.Count' detailed ? 50 : 16' pad: ' ')' /* 6 */detailed ? FormatHistoBar (sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty/*' 						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/));  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	if (p.Hidden)  		continue;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	if (p.Hidden)  		continue;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	if (p.Hidden)  		continue;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: if (c != null) {  	WriteDescription (o' p.Description' ""' 80' 80);  	continue;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: if (c != null) {  	WriteDescription (o' p.Description' ""' 80' 80);  	continue;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (ArgumentSource s in sources) {  	string[] names = s.GetNames ();  	if (names == null || names.Length == 0)  		continue;  	int written = 0;  	Write (o' ref written' "  ");  	Write (o' ref written' names [0]);  	for (int i = 1; i < names.Length; ++i) {  		Write (o' ref written' "' ");  		Write (o' ref written' names [i]);  	}  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' s.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' s.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,LineEditor,The following statement contains a magic number: handlers = new Handler[] {  	new Handler (ConsoleKey.Home' CmdHome)'  	new Handler (ConsoleKey.End' CmdEnd)'  	new Handler (ConsoleKey.LeftArrow' CmdLeft)'  	new Handler (ConsoleKey.RightArrow' CmdRight)'  	new Handler (ConsoleKey.UpArrow' CmdHistoryPrev)'  	new Handler (ConsoleKey.DownArrow' CmdHistoryNext)'  	new Handler (ConsoleKey.Enter' CmdDone)'  	new Handler (ConsoleKey.Backspace' CmdBackspace)'  	new Handler (ConsoleKey.Delete' CmdDeleteChar)'  	new Handler (ConsoleKey.Tab' CmdTabOrComplete)'  	// Emacs keys  	Handler.Control ('A'' CmdHome)'  	Handler.Control ('E'' CmdEnd)'  	Handler.Control ('B'' CmdLeft)'  	Handler.Control ('F'' CmdRight)'  	Handler.Control ('P'' CmdHistoryPrev)'  	Handler.Control ('N'' CmdHistoryNext)'  	Handler.Control ('K'' CmdKillToEOF)'  	Handler.Control ('Y'' CmdYank)'  	Handler.Control ('D'' CmdDeleteChar)'  	Handler.Control ('L'' CmdRefresh)'  	Handler.Control ('R'' CmdReverseSearch)'  	Handler.Control ('G'' delegate {  	})'  	Handler.Control ('C'' () => Console.WriteLine ("YOU CANNOT ESCAPE!!!!"))'  	Handler.Alt ('B'' ConsoleKey.B' CmdBackwardWord)'  	Handler.Alt ('F'' ConsoleKey.F' CmdForwardWord)'  	Handler.Alt ('D'' ConsoleKey.D' CmdDeleteWord)'  	Handler.Alt ((char)8' ConsoleKey.Backspace' CmdDeleteBackword)'  	// DEBUG  	//Handler.Control ('T'' CmdDebug)'  	// quote  	Handler.Control ('Q'' delegate {  		HandleChar (Console.ReadKey (true).KeyChar);  	})  };  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ComputeRendered,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	int c = (int)text [i];  	if (c < 26) {  		if (c == '\t')  			rendered_text.Append ("    ");  		else {  			rendered_text.Append ('^');  			rendered_text.Append ((char)(c + (int)'A' - 1));  		}  	} else  		rendered_text.Append ((char)c);  }  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ComputeRendered,The following statement contains a magic number: if (c < 26) {  	if (c == '\t')  		rendered_text.Append ("    ");  	else {  		rendered_text.Append ('^');  		rendered_text.Append ((char)(c + (int)'A' - 1));  	}  } else  	rendered_text.Append ((char)c);  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++) {  	int c;  	c = (int)text [i];  	if (c < 26) {  		if (c == 9)  			p += 4;  		else  			p += 2;  	} else  		p++;  }  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++) {  	int c;  	c = (int)text [i];  	if (c < 26) {  		if (c == 9)  			p += 4;  		else  			p += 2;  	} else  		p++;  }  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++) {  	int c;  	c = (int)text [i];  	if (c < 26) {  		if (c == 9)  			p += 4;  		else  			p += 2;  	} else  		p++;  }  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++) {  	int c;  	c = (int)text [i];  	if (c < 26) {  		if (c == 9)  			p += 4;  		else  			p += 2;  	} else  		p++;  }  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c < 26) {  	if (c == 9)  		p += 4;  	else  		p += 2;  } else  	p++;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c < 26) {  	if (c == 9)  		p += 4;  	else  		p += 2;  } else  	p++;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c < 26) {  	if (c == 9)  		p += 4;  	else  		p += 2;  } else  	p++;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c < 26) {  	if (c == 9)  		p += 4;  	else  		p += 2;  } else  	p++;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c == 9)  	p += 4;  else  	p += 2;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c == 9)  	p += 4;  else  	p += 2;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: if (c == 9)  	p += 4;  else  	p += 2;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: p += 4;  
Magic Number,Mono.Terminal,LineEditor,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: p += 2;  
Missing Default,Mono.Options,OptionSet,F:\newReposMay17\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  case OptionValueType.None:  	c.OptionValues.Add (n);  	c.Option.Invoke (c);  	break;  case OptionValueType.Optional:  case OptionValueType.Required:  	ParseValue (v' c);  	break;  }  
