Implementation smell,Namespace,Class,File,Method,Description
Long Method,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The method has 106 lines of code.
Long Method,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The method has 151 lines of code.
Long Method,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The method has 435 lines of code.
Complex Method,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,Cyclomatic complexity of the method is 9
Complex Method,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,Cyclomatic complexity of the method is 8
Complex Method,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,Cyclomatic complexity of the method is 11
Complex Method,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Option,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionPrototype,Cyclomatic complexity of the method is 8
Complex Method,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,WordForward,Cyclomatic complexity of the method is 8
Complex Method,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,WordBackward,Cyclomatic complexity of the method is 9
Complex Method,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,EditLoop,Cyclomatic complexity of the method is 9
Long Parameter List,FdbShell,FdbCliCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\FdbCliCommands.cs,RunFdbCliCommand,The method has 5 parameters. Parameters: command' options' clusterFile' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The method has 6 parameters. Parameters: path' extras' options' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,CreateDirectory,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,RemoveDirectory,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,MoveDirectory,The method has 6 parameters. Parameters: srcPath' dstPath' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ShowDirectoryLayer,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,ChangeDirectoryLayer,The method has 6 parameters. Parameters: path' layer' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Count,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,The method has 6 parameters. Parameters: path' extras' reverse' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Tree,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The method has 5 parameters. Parameters: folder' last' db' stream' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Shards,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The method has 5 parameters. Parameters: path' extras' db' log' ct
Long Parameter List,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,GetOptionParts,The method has 5 parameters. Parameters: argument' flag' name' sep' value
Long Parameter List,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteDescription,The method has 5 parameters. Parameters: o' value' prefix' firstWidth' remWidth
Long Parameter List,Mono.Options,ActionOption,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ActionOption,The method has 5 parameters. Parameters: prototype' description' count' action' hidden
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "								log.WriteLine("  {0'-12} {1'-12} {3'9:N0} {2}"' FdbKey.Dump(FdbSubspace.Copy(subfolder).Key)' subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">")' name' count); " is 188.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "								log.WriteLine("  {0'-12} {1'-12} {3'9} {2}"' FdbKey.Dump(FdbSubspace.Copy(subfolder).Key)' subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">")' name' "-"); " is 183.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Dir,The length of the statement  "							log.WriteLine("  {0'-12} {1'-12} {2}"' FdbKey.Dump(FdbSubspace.Copy(subfolder).Key)' subfolder.Layer.IsNullOrEmpty ? "-" : ("<" + subfolder.Layer.ToUnicode() + ">")' name); " is 172.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,CreateDirectory,The length of the statement  "			var stuff = await db.ReadAsync((tr) => tr.GetRange(folder.Keys.ToRange()).FirstOrDefaultAsync()' cancellationToken: ct); " is 120.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,RemoveDirectory,The length of the statement  "				log.WriteLine("# Cannot remove {0} because it still contains {1} sub-directorie(s)"' string.Join("/"' path)' subDirs.Count); " is 124.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The length of the statement  "				stream.WriteLine(sb.ToString() + (folder.Layer.ToString() == "partition" ? ("<" + folder.Name + ">") : folder.Name) + (folder.Layer.IsNullOrEmpty ? String.Empty : (" [" + folder.Layer.ToString() + "]"))); " is 204.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "			// we want to merge the map of shards' with the map of directories from the Directory Layer' and count for each directory how many shards intersect " is 147.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "			// note: this may break in future versions of the DL! Maybe we need a custom API to get a flat list of all directories in a DL that span a specific range ? " is 155.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "				log.WriteLine("{0'6} {1'-20} {2}"' kvp.Value' RobustHistogram.FormatHistoBar((double)kvp.Value / foundShards' 20)' kvp.Key); " is 124.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The length of the statement  "				log.WriteLine("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards); " is 165.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "					log.WriteLine(dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First().Parts[0].Address' machineId); " is 124.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "						log.WriteLine(machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts[0].Address' proc.Parts[0].Port' proc.ProcessId); " is 144.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The length of the statement  "						//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4); " is 165.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Shards,The length of the statement  "					//TODO: we can probably get more details on this shard looking in the system keyspace (where it is' how many replicas' ...) " is 123.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ..."); " is 152.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median))); " is 305.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "				log.WriteLine("Sampled " + FormatSize(globalSize) + " (" + globalSize.ToString("N0") + " bytes) and " + globalCount.ToString("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString("N1") + " sec"); " is 196.
Long Statement,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The length of the statement  "				log.WriteLine("Found " + FormatSize(globalSize) + " (" + globalSize.ToString("N0") + " bytes) and " + globalCount.ToString("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString("N1") + " sec"); " is 194.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The length of the statement  "			stream.WriteLine("# Local Time: " + DateTime.Now.ToString("O") + " (" + localTime + " local) - Universal Time: " + DateTime.UtcNow.ToString("O") + " ( " + utcTime + " UTC)"); " is 174.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult(); " is 124.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel); " is 139.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel); " is 141.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel); " is 129.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel); " is 142.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel); " is 128.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel); " is 160.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")"); " is 167.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")"); " is 171.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The length of the statement  "							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel); " is 138.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,VersionCommand,The length of the statement  "			log.WriteLine("Using .NET Binding v{0} with API level {1}"' new System.Reflection.AssemblyName(typeof(Fdb).Assembly.FullName).Version' Fdb.ApiVersion); " is 151.
Long Statement,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,VersionCommand,The length of the statement  "			var res = await RunAsyncCommand((db' _' ct) => FdbCliCommands.RunFdbCliCommand(null' "-h"' clusterFile' log' ct)' cancel); " is 122.
Long Statement,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The length of the statement  "			// I'm using the midpoint of each bucket as the value used to compute the deviation' and the same approximation method used in Percentile(..) to compute the resulting median. " is 174.
Long Statement,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________"); " is 152.
Long Statement,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|"); " is 153.
Long Statement,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")' " is 188.
Long Statement,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The length of the statement  "					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // --------- " is 151.
Long Statement,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,ToString,The length of the statement  "			return String.Format(CultureInfo.InvariantCulture' "Count={0}' Avg={1}' Min={2}' Max={3}"' this.Count' this.Average' this.Count > 0 ? this.Min : 0' this.Max); " is 158.
Long Statement,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ForceCursor,The length of the statement  "			//log.WriteLine ("Going to cursor={0} row={1} col={2} actual={3} prompt={4} ttr={5} old={6}"' newpos' row' col' actual_pos' prompt.Length' TextToRenderPos (cursor)' cursor); " is 173.
Complex Conditional,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The conditional expression  "prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\""))"  is complex.
Complex Conditional,Mono.Options,Option,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 &&  					((names.Length == 1 && this.type != OptionValueType.None) ||  					 (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length-1] == '+' || n [n.Length-1] == '-') &&  					Contains ((rn = n.Substring (0' n.Length-1)))"  is complex.
Empty Catch Block,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The method has an empty catch block.
Empty Catch Block,Mono.Terminal,History,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,Close,The method has an empty catch block.
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Show,The following statement contains a magic number: int count = 20;
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,TreeDirectoryWalk,The following statement contains a magic number: var sb = new StringBuilder(last.Count * 4);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.Write("\r" + new string(' '' n + 2));
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: log.Write("\r" + new string(' '' n + 2));
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: foreach(var kvp in map.OrderBy(x => x.Key))  			{  				log.WriteLine("{0'6} {1'-20} {2}"' kvp.Value' RobustHistogram.FormatHistoBar((double)kvp.Value / foundShards' 20)' kvp.Key);  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: if (bigBad != null)  			{  				log.WriteLine("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards);  				log.WriteLine();  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Map,The following statement contains a magic number: if (bigBad != null)  			{  				log.WriteLine("Biggest folder is /{0} with {1} shards ({2:N1}% total' {3:N1}% subtree)"' bigBad.FullName' max' 100.0 * max / totalShards' 100.0 * max / foundShards);  				log.WriteLine();  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: if (size < 2048) return size.ToString("N0"' ci);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: double x = size / 1024.0;
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: if (x < 800) return x.ToString("N1"' ci) + " k";
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x /= 1024.0;
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: if (x < 800) return x.ToString("N2"' ci) + " M";
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,FormatSize,The following statement contains a magic number: x /= 1024.0;
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: var servers = await db.QueryAsync(tr => tr  				.WithReadAccessToSystemKeys()  				.GetRange(FdbKeyRange.StartsWith(Fdb.System.ServerList))  				.Select(kvp => new  				{  					// Offsets		Size	Type	Name		Description  					//    0			 2		Word	Version?	0100 (1.0 ?)  					//    2			 4		DWord	???			0x00 0x20 0xA2 0x00  					//    6			 2		Word	FDBMagic	0xDB 0x0F "FDB"  					//    8			16		Guid	NodeId		Unique Process ID  					//   24			16		Guid	Machine		"machine_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   40			16		Guid	DataCenter	"datacenter_id" field in foundationdb.conf (ends with 8x0 if manually specified)  					//   56			 4		???		??			4 x 0  					//   60			12 x24	ARRAY[] ??			array of 12x the same 24-byte struct defined below    					// ...0			 4		DWord	IPAddress	01 00 00 7F => 127.0.0.1  					// ...4			 4		DWord	Port		94 11 00 00 -> 4500  					// ...8			 4		DWord	??			randomish' changes every reboot  					// ..12			 4		DWord	??			randomish' changes every reboot  					// ..16			 4		DWord	Size?		small L-E integer' usually between 0x20 and 0x40...  					// ..20			 4		DWord	??			randmoish' changes every reboot    					ProcessId = kvp.Value.Substring(8' 16).ToHexaString()'  					MachineId = kvp.Value.Substring(24' 16).ToHexaString()'  					DataCenterId = kvp.Value.Substring(40' 16).ToHexaString()'    					Parts = Enumerable.Range(0' 12).Select(i =>  					{  						int p = 60 + 24 * i;  						return new  						{  							Address = new IPAddress(kvp.Value.Substring(p' 4).GetBytes().Reverse().ToArray())'  							Port = kvp.Value.Substring(p + 4' 4).ToInt32()'  							Unknown1 = kvp.Value.Substring(p + 8' 4).ToInt32()'  							Unknown2 = kvp.Value.Substring(p + 12' 4).ToInt32()'  							Unknown3 = kvp.Value.Substring(p + 16' 4).ToInt32()'  							Unknown4 = kvp.Value.Substring(p + 20' 4).ToInt32()'  						};  					}).ToList()'  					Raw = kvp.Value'  				})'  				ct  			);
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: for (int dcIndex = 0; dcIndex < dcs.Length;dcIndex++)  			{  				var dc = dcs[dcIndex];  				bool lastDc = dcIndex == dcs.Length - 1;    				string dcId = dc.Key.EndsWith("0000000000000000") ? dc.Key.Substring(0' 16) : dc.Key;  				log.WriteLine((lastDc ? "`- " : "|- ") + "[DataCenter] {0} (#{1})"' dcId' dcIndex);    				var machines = dc.GroupBy(x => x.MachineId).ToArray();  				string dcPrefix = lastDc ? "   " : "|  ";  				for (int machineIndex = 0; machineIndex < machines.Length; machineIndex++)  				{  					var machine = machines[machineIndex];  					var lastMachine = machineIndex == machines.Length - 1;    					string machineId = machine.Key.EndsWith("0000000000000000") ? machine.Key.Substring(0' 16) : machine.Key;  					log.WriteLine(dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First().Parts[0].Address' machineId);    					var procs = machine.ToArray();  					string machinePrefix = dcPrefix + (lastMachine ? "   " : "|  ");  					for (int procIndex = 0; procIndex < procs.Length; procIndex++)  					{  						var proc = procs[procIndex];  						bool lastProc = procIndex == procs.Length - 1;    						log.WriteLine(machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts[0].Address' proc.Parts[0].Port' proc.ProcessId);  						//foreach (var part in proc.Parts)  						//{  						//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4);  						//}  					}  				}  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Topology,The following statement contains a magic number: for (int dcIndex = 0; dcIndex < dcs.Length;dcIndex++)  			{  				var dc = dcs[dcIndex];  				bool lastDc = dcIndex == dcs.Length - 1;    				string dcId = dc.Key.EndsWith("0000000000000000") ? dc.Key.Substring(0' 16) : dc.Key;  				log.WriteLine((lastDc ? "`- " : "|- ") + "[DataCenter] {0} (#{1})"' dcId' dcIndex);    				var machines = dc.GroupBy(x => x.MachineId).ToArray();  				string dcPrefix = lastDc ? "   " : "|  ";  				for (int machineIndex = 0; machineIndex < machines.Length; machineIndex++)  				{  					var machine = machines[machineIndex];  					var lastMachine = machineIndex == machines.Length - 1;    					string machineId = machine.Key.EndsWith("0000000000000000") ? machine.Key.Substring(0' 16) : machine.Key;  					log.WriteLine(dcPrefix + (lastMachine ? "`- " : "|- ") + "[Machine] {0}' {1}"' machine.First().Parts[0].Address' machineId);    					var procs = machine.ToArray();  					string machinePrefix = dcPrefix + (lastMachine ? "   " : "|  ");  					for (int procIndex = 0; procIndex < procs.Length; procIndex++)  					{  						var proc = procs[procIndex];  						bool lastProc = procIndex == procs.Length - 1;    						log.WriteLine(machinePrefix + (lastProc ? "`- " : "|- ") + "[Process] {0}:{1}' {2}"' proc.Parts[0].Address' proc.Parts[0].Port' proc.ProcessId);  						//foreach (var part in proc.Parts)  						//{  						//	log.WriteLine(machinePrefix + "|  -> {0}' {1}' {2:X8}' {3:X8}' {4}' {5:X8}"' part.Address' part.Port' part.Unknown1' part.Unknown2' part.Unknown3' part.Unknown4);  						//}  					}  				}  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32)  			{ // small enough to scan it all  				samples.AddRange(ranges);  				log.WriteLine("Sampling all {0:N0} shards ..."' samples.Count);  			}  			else  			{ // need to take a random subset  				var rnd = new Random();  				int sz = Math.Max((int)Math.Ceiling(ratio * ranges.Count)' 1);  				if (auto)  				{  					if (sz > 100) sz = 100; //SAFETY  					if (sz < 32) sz = Math.Max(sz' Math.Min(32' ranges.Count));  				}    				var population = new List<FdbKeyRange>(ranges);  				for (int i = 0; i < sz; i++)  				{  					int p = rnd.Next(population.Count);  					samples.Add(population[p]);  					population.RemoveAt(p);  				}  				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ...");  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32)  			{ // small enough to scan it all  				samples.AddRange(ranges);  				log.WriteLine("Sampling all {0:N0} shards ..."' samples.Count);  			}  			else  			{ // need to take a random subset  				var rnd = new Random();  				int sz = Math.Max((int)Math.Ceiling(ratio * ranges.Count)' 1);  				if (auto)  				{  					if (sz > 100) sz = 100; //SAFETY  					if (sz < 32) sz = Math.Max(sz' Math.Min(32' ranges.Count));  				}    				var population = new List<FdbKeyRange>(ranges);  				for (int i = 0; i < sz; i++)  				{  					int p = rnd.Next(population.Count);  					samples.Add(population[p]);  					population.RemoveAt(p);  				}  				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ...");  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32)  			{ // small enough to scan it all  				samples.AddRange(ranges);  				log.WriteLine("Sampling all {0:N0} shards ..."' samples.Count);  			}  			else  			{ // need to take a random subset  				var rnd = new Random();  				int sz = Math.Max((int)Math.Ceiling(ratio * ranges.Count)' 1);  				if (auto)  				{  					if (sz > 100) sz = 100; //SAFETY  					if (sz < 32) sz = Math.Max(sz' Math.Min(32' ranges.Count));  				}    				var population = new List<FdbKeyRange>(ranges);  				for (int i = 0; i < sz; i++)  				{  					int p = rnd.Next(population.Count);  					samples.Add(population[p]);  					population.RemoveAt(p);  				}  				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ...");  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32)  			{ // small enough to scan it all  				samples.AddRange(ranges);  				log.WriteLine("Sampling all {0:N0} shards ..."' samples.Count);  			}  			else  			{ // need to take a random subset  				var rnd = new Random();  				int sz = Math.Max((int)Math.Ceiling(ratio * ranges.Count)' 1);  				if (auto)  				{  					if (sz > 100) sz = 100; //SAFETY  					if (sz < 32) sz = Math.Max(sz' Math.Min(32' ranges.Count));  				}    				var population = new List<FdbKeyRange>(ranges);  				for (int i = 0; i < sz; i++)  				{  					int p = rnd.Next(population.Count);  					samples.Add(population[p]);  					population.RemoveAt(p);  				}  				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ...");  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32)  			{ // small enough to scan it all  				samples.AddRange(ranges);  				log.WriteLine("Sampling all {0:N0} shards ..."' samples.Count);  			}  			else  			{ // need to take a random subset  				var rnd = new Random();  				int sz = Math.Max((int)Math.Ceiling(ratio * ranges.Count)' 1);  				if (auto)  				{  					if (sz > 100) sz = 100; //SAFETY  					if (sz < 32) sz = Math.Max(sz' Math.Min(32' ranges.Count));  				}    				var population = new List<FdbKeyRange>(ranges);  				for (int i = 0; i < sz; i++)  				{  					int p = rnd.Next(population.Count);  					samples.Add(population[p]);  					population.RemoveAt(p);  				}  				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ...");  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (ranges.Count <= 32)  			{ // small enough to scan it all  				samples.AddRange(ranges);  				log.WriteLine("Sampling all {0:N0} shards ..."' samples.Count);  			}  			else  			{ // need to take a random subset  				var rnd = new Random();  				int sz = Math.Max((int)Math.Ceiling(ratio * ranges.Count)' 1);  				if (auto)  				{  					if (sz > 100) sz = 100; //SAFETY  					if (sz < 32) sz = Math.Max(sz' Math.Min(32' ranges.Count));  				}    				var population = new List<FdbKeyRange>(ranges);  				for (int i = 0; i < sz; i++)  				{  					int p = rnd.Next(population.Count);  					samples.Add(population[p]);  					population.RemoveAt(p);  				}  				log.WriteLine("Sampling " + samples.Count + " out of " + ranges.Count + " shards (" + (100.0 * samples.Count / ranges.Count).ToString("N1") + "%) ...");  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: int workers = 8;
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0)  			{  				while (tasks.Count < workers && samples.Count > 0)  				{  					var range = samples[0];  					samples.RemoveAt(0);  					tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = FdbKeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = FdbKeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data.Chunk)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = FdbKeySelector.FirstGreaterThan(data.Last.Key);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));  				}    				var done = await Task.WhenAny(tasks);  				tasks.Remove(done);  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0)  			{  				while (tasks.Count < workers && samples.Count > 0)  				{  					var range = samples[0];  					samples.RemoveAt(0);  					tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = FdbKeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = FdbKeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data.Chunk)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = FdbKeySelector.FirstGreaterThan(data.Last.Key);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));  				}    				var done = await Task.WhenAny(tasks);  				tasks.Remove(done);  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0)  			{  				while (tasks.Count < workers && samples.Count > 0)  				{  					var range = samples[0];  					samples.RemoveAt(0);  					tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = FdbKeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = FdbKeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data.Chunk)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = FdbKeySelector.FirstGreaterThan(data.Last.Key);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));  				}    				var done = await Task.WhenAny(tasks);  				tasks.Remove(done);  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: while (samples.Count > 0)  			{  				while (tasks.Count < workers && samples.Count > 0)  				{  					var range = samples[0];  					samples.RemoveAt(0);  					tasks.Add(Task.Run(async () =>  					{  						var kk = new RobustHistogram(RobustHistogram.TimeScale.Ticks);  						var vv = new RobustHistogram(RobustHistogram.TimeScale.Ticks);    						#region Method 1: get_range everything...    						using (var tr = db.BeginTransaction(ct))  						{  							long keySize = 0;  							long valueSize = 0;  							long count = 0;    							int iter = 0;  							var beginSelector = FdbKeySelector.FirstGreaterOrEqual(range.Begin);  							var endSelector = FdbKeySelector.FirstGreaterOrEqual(range.End);  							while (true)  							{  								FdbRangeChunk data = default(FdbRangeChunk);  								FdbException error = null;  								try  								{  									data = await tr.Snapshot.GetRangeAsync(  										beginSelector'  										endSelector'  										rangeOptions'  										iter  									).ConfigureAwait(false);  								}  								catch (FdbException e)  								{  									error = e;  								}    								if (error != null)  								{  									await tr.OnErrorAsync(error.Code).ConfigureAwait(false);  									continue;  								}    								if (data.Count == 0) break;    								count += data.Count;  								foreach (var kvp in data.Chunk)  								{  									keySize += kvp.Key.Count;  									valueSize += kvp.Value.Count;    									kk.Add(TimeSpan.FromTicks(kvp.Key.Count));  									vv.Add(TimeSpan.FromTicks(kvp.Value.Count));  								}    								if (!data.HasMore) break;    								beginSelector = FdbKeySelector.FirstGreaterThan(data.Last.Key);  								++iter;  							}    							long totalSize = keySize + valueSize;  							Interlocked.Add(ref globalSize' totalSize);  							Interlocked.Add(ref globalCount' count);    							lock (log)  							{  								log.WriteLine(FORMAT_STRING' count.ToString("N0")' FormatSize(keySize)' kk.GetDistribution(begin: 1' end: 12000' fold: 2)' FormatSize(valueSize)' vv.GetDistribution(begin: 1' end: 120000' fold: 2)' FormatSize(totalSize)' FormatSize((int)Math.Ceiling(kk.Median))' FormatSize((int)Math.Ceiling(vv.Median)));  							}  						}  						#endregion    						#region Method 2: estimate the count using key selectors...    						//long counter = await Fdb.System.EstimateCountAsync(db' range' ct);  						//Console.WriteLine("COUNT = " + counter.ToString("N0"));    						#endregion  					}' ct));  				}    				var done = await Task.WhenAny(tasks);  				tasks.Remove(done);  			}
Magic Number,FdbShell,BasicCommands,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Commands\BasicCommands.cs,Sampling,The following statement contains a magic number: if (n != ranges.Count)  			{  				log.WriteLine("Sampled " + FormatSize(globalSize) + " (" + globalSize.ToString("N0") + " bytes) and " + globalCount.ToString("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString("N1") + " sec");  				log.WriteLine("> Estimated total size is " + FormatSize(globalSize * ranges.Count / n));  			}  			else  			{  				log.WriteLine("Found " + FormatSize(globalSize) + " (" + globalSize.ToString("N0") + " bytes) and " + globalCount.ToString("N0") + " keys in " + sw.Elapsed.TotalSeconds.ToString("N1") + " sec");  				// compare to the whole cluster  				ranges = await Fdb.System.GetChunksAsync(db' FdbKey.MinValue' FdbKey.MaxValue' ct);  				log.WriteLine("> This directory contains ~{0:N2}% of all data"' (100.0 * n / ranges.Count));  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The following statement contains a magic number: long localTime = (DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - 62135596800000;
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,GetLogFile,The following statement contains a magic number: long utcTime = (DateTime.UtcNow.Ticks / TimeSpan.TicksPerMillisecond) - 62135596800000;
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: try  			{  				if (Console.LargestWindowWidth > 0 && Console.LargestWindowHeight > 0)  				{  					Console.WindowWidth = 160;  					Console.WindowHeight = 60;  				}  			}  			catch (Exception e)  			{  				// this sometimes fail on small screen sizes  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,Main,The following statement contains a magic number: try  			{  				if (Console.LargestWindowWidth > 0 && Console.LargestWindowHeight > 0)  				{  					Console.WindowWidth = 160;  					Console.WindowHeight = 60;  				}  			}  			catch (Exception e)  			{  				// this sometimes fail on small screen sizes  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: int timeout = 30;
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: int maxRetries = 10;
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try  			{  				Db = await ChangeDatabase(clusterFile' dbName' partition' cancel);  				Db.DefaultTimeout = Math.Max(0' timeout) * 1000;  				Db.DefaultRetryLimit = Math.Max(0' maxRetries);    				Console.WriteLine("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion() + ")");  				Console.WriteLine("Cluster file: " + (clusterFile ?? "<default>"));  				Console.WriteLine();  				Console.WriteLine("FoundationDB Shell menu:");  				Console.WriteLine("\tdir\tShow the content of the current directory");  				Console.WriteLine("\ttree\tShow all the directories under the current directory");  				Console.WriteLine("\tsampling\tDisplay statistics on random shards from the database");  				Console.WriteLine("\tcoordinators\tShow the current coordinators for the cluster");  				Console.WriteLine("\tmem\tShow memory usage statistics");  				Console.WriteLine("\tgc\tTrigger garbage collection");  				Console.WriteLine("\tquit\tQuit");    				Console.WriteLine("Ready...");      				var le = new LineEditor("FDBShell");    				string[] cmds = new string[]  				{  					"cd"'  					"coordinators"'  					"count"'  					"dir"'  					"exit"'  					"gc"'  					"help"'  					"layer"'  					"map"'  					"mem"'  					"mkdir"'  					"mv"'  					"partition"'  					"pwd"'  					"quit"'  					"ren"'  					"rmdir"'  					"sampling"'  					"shards"'  					"show"'  					"status"'  					"topology"'  					"tree"'  					"version"'  					"wide"'  				};    				le.AutoCompleteEvent = (txt' pos) =>  				{  					string[] res;  					int p = txt.IndexOf(' ');  					if (p > 0)  					{  						string cmd = txt.Substring(0' p);  						string arg = txt.Substring(p + 1);    						if (cmd == "cd")  						{ // handle completion for directories    							// txt: "cd foo" => prefix = "foo"  							// txt: "cd foobar/b" => prefix = "b"    							string path = CurrentDirectoryPath;  							string prefix = "";  							string search = arg;  							p = arg.LastIndexOf('/');  							if (p > 0)  							{  								path = Path.Combine(path' arg.Substring(0' p));  								search = arg.Substring(p + 1);  								prefix = arg.Substring(0' p + 1);  							}    							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult();  							if (!subdirs.HasValue || subdirs.Value == null) return new LineEditor.Completion(txt' null);    							res = subdirs.Value  								.Where(s => s.StartsWith(search' StringComparison.Ordinal))  								.Select(s => (cmd + " " + prefix + s).Substring(txt.Length))  								.ToArray();  							return new LineEditor.Completion(txt' res);  						}    						// unknown command  						return new LineEditor.Completion(txt' null);  					}    					// list of commands  					res = cmds  						.Where(cmd => cmd.StartsWith(txt' StringComparison.OrdinalIgnoreCase))  						.Select(cmd => cmd.Substring(txt.Length))  						.ToArray();  					return new LineEditor.Completion(txt' res);  				};  				le.TabAtStartCompletes = true;    				string prompt = null;  				Action<string> updatePrompt = (path) => { prompt = String.Format("fdb:{0}> "' path); };  				updatePrompt(CurrentDirectoryPath);    				while (!stop)  				{  					string s = startCommand != null ? startCommand : le.Edit(prompt' "");  					startCommand = null;    					if (s == null) break;    					var tokens = s.Trim().Split(new [] { ' ' }' StringSplitOptions.RemoveEmptyEntries);  					string cmd = tokens.Length > 0 ? tokens[0] : String.Empty;  					string prm = tokens.Length > 1 ? tokens[1] : String.Empty;  					var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string>(tokens.Skip(2)) : FdbTuple.Empty;    					var trimmedCommand = cmd.Trim().ToLowerInvariant();  					switch (trimmedCommand)  					{  						case "":  						{  							continue;  						}  						case "log":  						{  							LogCommand(prm' Console.Out);    							break;  						}    						case "version":  						{  							await VersionCommand(prm' clusterFile' Console.Out' cancel);  							break;  						}    						case "tree":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  							break;  						}  						case "map":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  							break;  						}    						case "dir":  						case "ls":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  							break;  						}  						case "ll":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  							break;  						}    						case "count":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  							break;  						}    						case "show":  						case "top":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  							break;  						}  						case "last":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  							break;  						}    						case "cd":  						case "pwd":  						{  							if (!string.IsNullOrEmpty(prm))  							{  								var newPath = CombinePath(CurrentDirectoryPath' prm);  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  								if (res == null)  								{  									Console.WriteLine("# Directory {0} does not exist!"' newPath);  									Console.Beep();  								}  								else  								{  									CurrentDirectoryPath = newPath;  									updatePrompt(CurrentDirectoryPath);  								}  							}  							else  							{  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  								if (res.GetValueOrDefault() == null)  								{  									Console.WriteLine("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  								}  								else  								{  									Console.WriteLine("# {0}"' res);  								}  							}  							break;  						}  						case "mkdir":  						case "md":  						{ // "mkdir DIRECTORYNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}  						case "rmdir":  						{ // "rmdir DIRECTORYNAME"  							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mv":  						case "ren":  						{ // "mv SOURCE DESTINATION"  							  							var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    							break;  						}    						case "layer":  						{  							if (string.IsNullOrEmpty(prm))  							{ // displays the layer id of the current folder  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    							}  							else  							{ // change the layer id of the current folder  								prm = prm.Trim();  								// double or single quotes can be used to escape the value  								if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  								{  									prm = prm.Substring(1' prm.Length - 2);  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mkpart":  						{ // "mkpart PARTITIONNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  							}    							break;  						}    						case "topology":  						{  							await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  							break;  						}    						case "shards":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  							break;  						}    						case "sampling":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  							break;  						}    						case "coordinators":  						{  							await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  							break;  						}    						case "partition":  						{  							if (string.IsNullOrEmpty(prm))  							{  								Console.WriteLine("# Current partition is {0}"' String.Join("/"' partition));  								//TODO: browse existing partitions ?  								break;  							}    							var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  							IFdbDatabase newDb = null;  							try  							{  								newDb = await ChangeDatabase(clusterFile' dbName' newPartition' cancel);  							}  							catch (Exception)  							{  								if (newDb != null) newDb.Dispose();  								newDb = null;  								throw;  							}  							finally  							{  								if (newDb != null)  								{  									if (Db != null) { Db.Dispose(); Db = null; }  									Db = newDb;  									partition = newPartition;  									Console.WriteLine("# Changed partition to {0}"' partition);  								}  							}  							break;  						}    						case "q":  						case "x":  						case "quit":  						case "exit":  						case "bye":  						{  							stop = true;  							break;  						}    						case "gc":  						{  							long before = GC.GetTotalMemory(false);  							Console.Write("Collecting garbage...");  							GC.Collect();  							GC.WaitForPendingFinalizers();  							GC.Collect();  							Console.WriteLine(" Done");  							long after = GC.GetTotalMemory(false);  							Console.WriteLine("- before = " + before.ToString("N0"));  							Console.WriteLine("- after  = " + after.ToString("N0"));  							Console.WriteLine("- delta  = " + (before - after).ToString("N0"));  							break;  						}    						case "mem":  						{  							Console.WriteLine("Memory usage:");  							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  							Console.WriteLine("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  							Console.WriteLine("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  							break;  						}    						case "wide":  						{  							Console.WindowWidth = 160;  							break;  						}    						case "status":  						case "wtf":  						{  							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  							if (result.HasFailed) break;  							if (result.Value.ExitCode != 0)  							{  								Console.WriteLine("# fdbcli exited with code {0}"' result.Value.ExitCode);  								Console.WriteLine("> StdErr:");  								Console.WriteLine(result.Value.StdErr);  								Console.WriteLine("> StdOut:");  							}  							Console.WriteLine(result.Value.StdOut);  							break;  						}    						default:  						{  							Console.WriteLine(string.Format("Unknown command : '{0}'"' trimmedCommand));  							break;  						}  					}    					if (!string.IsNullOrEmpty(execCommand))  					{ // only run one command' and then exit  						break;  					}    				}  			}  			finally  			{  				if (Db != null) Db.Dispose();  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try  			{  				Db = await ChangeDatabase(clusterFile' dbName' partition' cancel);  				Db.DefaultTimeout = Math.Max(0' timeout) * 1000;  				Db.DefaultRetryLimit = Math.Max(0' maxRetries);    				Console.WriteLine("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion() + ")");  				Console.WriteLine("Cluster file: " + (clusterFile ?? "<default>"));  				Console.WriteLine();  				Console.WriteLine("FoundationDB Shell menu:");  				Console.WriteLine("\tdir\tShow the content of the current directory");  				Console.WriteLine("\ttree\tShow all the directories under the current directory");  				Console.WriteLine("\tsampling\tDisplay statistics on random shards from the database");  				Console.WriteLine("\tcoordinators\tShow the current coordinators for the cluster");  				Console.WriteLine("\tmem\tShow memory usage statistics");  				Console.WriteLine("\tgc\tTrigger garbage collection");  				Console.WriteLine("\tquit\tQuit");    				Console.WriteLine("Ready...");      				var le = new LineEditor("FDBShell");    				string[] cmds = new string[]  				{  					"cd"'  					"coordinators"'  					"count"'  					"dir"'  					"exit"'  					"gc"'  					"help"'  					"layer"'  					"map"'  					"mem"'  					"mkdir"'  					"mv"'  					"partition"'  					"pwd"'  					"quit"'  					"ren"'  					"rmdir"'  					"sampling"'  					"shards"'  					"show"'  					"status"'  					"topology"'  					"tree"'  					"version"'  					"wide"'  				};    				le.AutoCompleteEvent = (txt' pos) =>  				{  					string[] res;  					int p = txt.IndexOf(' ');  					if (p > 0)  					{  						string cmd = txt.Substring(0' p);  						string arg = txt.Substring(p + 1);    						if (cmd == "cd")  						{ // handle completion for directories    							// txt: "cd foo" => prefix = "foo"  							// txt: "cd foobar/b" => prefix = "b"    							string path = CurrentDirectoryPath;  							string prefix = "";  							string search = arg;  							p = arg.LastIndexOf('/');  							if (p > 0)  							{  								path = Path.Combine(path' arg.Substring(0' p));  								search = arg.Substring(p + 1);  								prefix = arg.Substring(0' p + 1);  							}    							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult();  							if (!subdirs.HasValue || subdirs.Value == null) return new LineEditor.Completion(txt' null);    							res = subdirs.Value  								.Where(s => s.StartsWith(search' StringComparison.Ordinal))  								.Select(s => (cmd + " " + prefix + s).Substring(txt.Length))  								.ToArray();  							return new LineEditor.Completion(txt' res);  						}    						// unknown command  						return new LineEditor.Completion(txt' null);  					}    					// list of commands  					res = cmds  						.Where(cmd => cmd.StartsWith(txt' StringComparison.OrdinalIgnoreCase))  						.Select(cmd => cmd.Substring(txt.Length))  						.ToArray();  					return new LineEditor.Completion(txt' res);  				};  				le.TabAtStartCompletes = true;    				string prompt = null;  				Action<string> updatePrompt = (path) => { prompt = String.Format("fdb:{0}> "' path); };  				updatePrompt(CurrentDirectoryPath);    				while (!stop)  				{  					string s = startCommand != null ? startCommand : le.Edit(prompt' "");  					startCommand = null;    					if (s == null) break;    					var tokens = s.Trim().Split(new [] { ' ' }' StringSplitOptions.RemoveEmptyEntries);  					string cmd = tokens.Length > 0 ? tokens[0] : String.Empty;  					string prm = tokens.Length > 1 ? tokens[1] : String.Empty;  					var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string>(tokens.Skip(2)) : FdbTuple.Empty;    					var trimmedCommand = cmd.Trim().ToLowerInvariant();  					switch (trimmedCommand)  					{  						case "":  						{  							continue;  						}  						case "log":  						{  							LogCommand(prm' Console.Out);    							break;  						}    						case "version":  						{  							await VersionCommand(prm' clusterFile' Console.Out' cancel);  							break;  						}    						case "tree":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  							break;  						}  						case "map":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  							break;  						}    						case "dir":  						case "ls":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  							break;  						}  						case "ll":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  							break;  						}    						case "count":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  							break;  						}    						case "show":  						case "top":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  							break;  						}  						case "last":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  							break;  						}    						case "cd":  						case "pwd":  						{  							if (!string.IsNullOrEmpty(prm))  							{  								var newPath = CombinePath(CurrentDirectoryPath' prm);  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  								if (res == null)  								{  									Console.WriteLine("# Directory {0} does not exist!"' newPath);  									Console.Beep();  								}  								else  								{  									CurrentDirectoryPath = newPath;  									updatePrompt(CurrentDirectoryPath);  								}  							}  							else  							{  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  								if (res.GetValueOrDefault() == null)  								{  									Console.WriteLine("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  								}  								else  								{  									Console.WriteLine("# {0}"' res);  								}  							}  							break;  						}  						case "mkdir":  						case "md":  						{ // "mkdir DIRECTORYNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}  						case "rmdir":  						{ // "rmdir DIRECTORYNAME"  							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mv":  						case "ren":  						{ // "mv SOURCE DESTINATION"  							  							var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    							break;  						}    						case "layer":  						{  							if (string.IsNullOrEmpty(prm))  							{ // displays the layer id of the current folder  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    							}  							else  							{ // change the layer id of the current folder  								prm = prm.Trim();  								// double or single quotes can be used to escape the value  								if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  								{  									prm = prm.Substring(1' prm.Length - 2);  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mkpart":  						{ // "mkpart PARTITIONNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  							}    							break;  						}    						case "topology":  						{  							await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  							break;  						}    						case "shards":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  							break;  						}    						case "sampling":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  							break;  						}    						case "coordinators":  						{  							await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  							break;  						}    						case "partition":  						{  							if (string.IsNullOrEmpty(prm))  							{  								Console.WriteLine("# Current partition is {0}"' String.Join("/"' partition));  								//TODO: browse existing partitions ?  								break;  							}    							var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  							IFdbDatabase newDb = null;  							try  							{  								newDb = await ChangeDatabase(clusterFile' dbName' newPartition' cancel);  							}  							catch (Exception)  							{  								if (newDb != null) newDb.Dispose();  								newDb = null;  								throw;  							}  							finally  							{  								if (newDb != null)  								{  									if (Db != null) { Db.Dispose(); Db = null; }  									Db = newDb;  									partition = newPartition;  									Console.WriteLine("# Changed partition to {0}"' partition);  								}  							}  							break;  						}    						case "q":  						case "x":  						case "quit":  						case "exit":  						case "bye":  						{  							stop = true;  							break;  						}    						case "gc":  						{  							long before = GC.GetTotalMemory(false);  							Console.Write("Collecting garbage...");  							GC.Collect();  							GC.WaitForPendingFinalizers();  							GC.Collect();  							Console.WriteLine(" Done");  							long after = GC.GetTotalMemory(false);  							Console.WriteLine("- before = " + before.ToString("N0"));  							Console.WriteLine("- after  = " + after.ToString("N0"));  							Console.WriteLine("- delta  = " + (before - after).ToString("N0"));  							break;  						}    						case "mem":  						{  							Console.WriteLine("Memory usage:");  							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  							Console.WriteLine("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  							Console.WriteLine("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  							break;  						}    						case "wide":  						{  							Console.WindowWidth = 160;  							break;  						}    						case "status":  						case "wtf":  						{  							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  							if (result.HasFailed) break;  							if (result.Value.ExitCode != 0)  							{  								Console.WriteLine("# fdbcli exited with code {0}"' result.Value.ExitCode);  								Console.WriteLine("> StdErr:");  								Console.WriteLine(result.Value.StdErr);  								Console.WriteLine("> StdOut:");  							}  							Console.WriteLine(result.Value.StdOut);  							break;  						}    						default:  						{  							Console.WriteLine(string.Format("Unknown command : '{0}'"' trimmedCommand));  							break;  						}  					}    					if (!string.IsNullOrEmpty(execCommand))  					{ // only run one command' and then exit  						break;  					}    				}  			}  			finally  			{  				if (Db != null) Db.Dispose();  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try  			{  				Db = await ChangeDatabase(clusterFile' dbName' partition' cancel);  				Db.DefaultTimeout = Math.Max(0' timeout) * 1000;  				Db.DefaultRetryLimit = Math.Max(0' maxRetries);    				Console.WriteLine("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion() + ")");  				Console.WriteLine("Cluster file: " + (clusterFile ?? "<default>"));  				Console.WriteLine();  				Console.WriteLine("FoundationDB Shell menu:");  				Console.WriteLine("\tdir\tShow the content of the current directory");  				Console.WriteLine("\ttree\tShow all the directories under the current directory");  				Console.WriteLine("\tsampling\tDisplay statistics on random shards from the database");  				Console.WriteLine("\tcoordinators\tShow the current coordinators for the cluster");  				Console.WriteLine("\tmem\tShow memory usage statistics");  				Console.WriteLine("\tgc\tTrigger garbage collection");  				Console.WriteLine("\tquit\tQuit");    				Console.WriteLine("Ready...");      				var le = new LineEditor("FDBShell");    				string[] cmds = new string[]  				{  					"cd"'  					"coordinators"'  					"count"'  					"dir"'  					"exit"'  					"gc"'  					"help"'  					"layer"'  					"map"'  					"mem"'  					"mkdir"'  					"mv"'  					"partition"'  					"pwd"'  					"quit"'  					"ren"'  					"rmdir"'  					"sampling"'  					"shards"'  					"show"'  					"status"'  					"topology"'  					"tree"'  					"version"'  					"wide"'  				};    				le.AutoCompleteEvent = (txt' pos) =>  				{  					string[] res;  					int p = txt.IndexOf(' ');  					if (p > 0)  					{  						string cmd = txt.Substring(0' p);  						string arg = txt.Substring(p + 1);    						if (cmd == "cd")  						{ // handle completion for directories    							// txt: "cd foo" => prefix = "foo"  							// txt: "cd foobar/b" => prefix = "b"    							string path = CurrentDirectoryPath;  							string prefix = "";  							string search = arg;  							p = arg.LastIndexOf('/');  							if (p > 0)  							{  								path = Path.Combine(path' arg.Substring(0' p));  								search = arg.Substring(p + 1);  								prefix = arg.Substring(0' p + 1);  							}    							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult();  							if (!subdirs.HasValue || subdirs.Value == null) return new LineEditor.Completion(txt' null);    							res = subdirs.Value  								.Where(s => s.StartsWith(search' StringComparison.Ordinal))  								.Select(s => (cmd + " " + prefix + s).Substring(txt.Length))  								.ToArray();  							return new LineEditor.Completion(txt' res);  						}    						// unknown command  						return new LineEditor.Completion(txt' null);  					}    					// list of commands  					res = cmds  						.Where(cmd => cmd.StartsWith(txt' StringComparison.OrdinalIgnoreCase))  						.Select(cmd => cmd.Substring(txt.Length))  						.ToArray();  					return new LineEditor.Completion(txt' res);  				};  				le.TabAtStartCompletes = true;    				string prompt = null;  				Action<string> updatePrompt = (path) => { prompt = String.Format("fdb:{0}> "' path); };  				updatePrompt(CurrentDirectoryPath);    				while (!stop)  				{  					string s = startCommand != null ? startCommand : le.Edit(prompt' "");  					startCommand = null;    					if (s == null) break;    					var tokens = s.Trim().Split(new [] { ' ' }' StringSplitOptions.RemoveEmptyEntries);  					string cmd = tokens.Length > 0 ? tokens[0] : String.Empty;  					string prm = tokens.Length > 1 ? tokens[1] : String.Empty;  					var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string>(tokens.Skip(2)) : FdbTuple.Empty;    					var trimmedCommand = cmd.Trim().ToLowerInvariant();  					switch (trimmedCommand)  					{  						case "":  						{  							continue;  						}  						case "log":  						{  							LogCommand(prm' Console.Out);    							break;  						}    						case "version":  						{  							await VersionCommand(prm' clusterFile' Console.Out' cancel);  							break;  						}    						case "tree":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  							break;  						}  						case "map":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  							break;  						}    						case "dir":  						case "ls":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  							break;  						}  						case "ll":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  							break;  						}    						case "count":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  							break;  						}    						case "show":  						case "top":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  							break;  						}  						case "last":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  							break;  						}    						case "cd":  						case "pwd":  						{  							if (!string.IsNullOrEmpty(prm))  							{  								var newPath = CombinePath(CurrentDirectoryPath' prm);  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  								if (res == null)  								{  									Console.WriteLine("# Directory {0} does not exist!"' newPath);  									Console.Beep();  								}  								else  								{  									CurrentDirectoryPath = newPath;  									updatePrompt(CurrentDirectoryPath);  								}  							}  							else  							{  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  								if (res.GetValueOrDefault() == null)  								{  									Console.WriteLine("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  								}  								else  								{  									Console.WriteLine("# {0}"' res);  								}  							}  							break;  						}  						case "mkdir":  						case "md":  						{ // "mkdir DIRECTORYNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}  						case "rmdir":  						{ // "rmdir DIRECTORYNAME"  							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mv":  						case "ren":  						{ // "mv SOURCE DESTINATION"  							  							var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    							break;  						}    						case "layer":  						{  							if (string.IsNullOrEmpty(prm))  							{ // displays the layer id of the current folder  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    							}  							else  							{ // change the layer id of the current folder  								prm = prm.Trim();  								// double or single quotes can be used to escape the value  								if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  								{  									prm = prm.Substring(1' prm.Length - 2);  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mkpart":  						{ // "mkpart PARTITIONNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  							}    							break;  						}    						case "topology":  						{  							await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  							break;  						}    						case "shards":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  							break;  						}    						case "sampling":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  							break;  						}    						case "coordinators":  						{  							await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  							break;  						}    						case "partition":  						{  							if (string.IsNullOrEmpty(prm))  							{  								Console.WriteLine("# Current partition is {0}"' String.Join("/"' partition));  								//TODO: browse existing partitions ?  								break;  							}    							var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  							IFdbDatabase newDb = null;  							try  							{  								newDb = await ChangeDatabase(clusterFile' dbName' newPartition' cancel);  							}  							catch (Exception)  							{  								if (newDb != null) newDb.Dispose();  								newDb = null;  								throw;  							}  							finally  							{  								if (newDb != null)  								{  									if (Db != null) { Db.Dispose(); Db = null; }  									Db = newDb;  									partition = newPartition;  									Console.WriteLine("# Changed partition to {0}"' partition);  								}  							}  							break;  						}    						case "q":  						case "x":  						case "quit":  						case "exit":  						case "bye":  						{  							stop = true;  							break;  						}    						case "gc":  						{  							long before = GC.GetTotalMemory(false);  							Console.Write("Collecting garbage...");  							GC.Collect();  							GC.WaitForPendingFinalizers();  							GC.Collect();  							Console.WriteLine(" Done");  							long after = GC.GetTotalMemory(false);  							Console.WriteLine("- before = " + before.ToString("N0"));  							Console.WriteLine("- after  = " + after.ToString("N0"));  							Console.WriteLine("- delta  = " + (before - after).ToString("N0"));  							break;  						}    						case "mem":  						{  							Console.WriteLine("Memory usage:");  							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  							Console.WriteLine("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  							Console.WriteLine("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  							break;  						}    						case "wide":  						{  							Console.WindowWidth = 160;  							break;  						}    						case "status":  						case "wtf":  						{  							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  							if (result.HasFailed) break;  							if (result.Value.ExitCode != 0)  							{  								Console.WriteLine("# fdbcli exited with code {0}"' result.Value.ExitCode);  								Console.WriteLine("> StdErr:");  								Console.WriteLine(result.Value.StdErr);  								Console.WriteLine("> StdOut:");  							}  							Console.WriteLine(result.Value.StdOut);  							break;  						}    						default:  						{  							Console.WriteLine(string.Format("Unknown command : '{0}'"' trimmedCommand));  							break;  						}  					}    					if (!string.IsNullOrEmpty(execCommand))  					{ // only run one command' and then exit  						break;  					}    				}  			}  			finally  			{  				if (Db != null) Db.Dispose();  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try  			{  				Db = await ChangeDatabase(clusterFile' dbName' partition' cancel);  				Db.DefaultTimeout = Math.Max(0' timeout) * 1000;  				Db.DefaultRetryLimit = Math.Max(0' maxRetries);    				Console.WriteLine("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion() + ")");  				Console.WriteLine("Cluster file: " + (clusterFile ?? "<default>"));  				Console.WriteLine();  				Console.WriteLine("FoundationDB Shell menu:");  				Console.WriteLine("\tdir\tShow the content of the current directory");  				Console.WriteLine("\ttree\tShow all the directories under the current directory");  				Console.WriteLine("\tsampling\tDisplay statistics on random shards from the database");  				Console.WriteLine("\tcoordinators\tShow the current coordinators for the cluster");  				Console.WriteLine("\tmem\tShow memory usage statistics");  				Console.WriteLine("\tgc\tTrigger garbage collection");  				Console.WriteLine("\tquit\tQuit");    				Console.WriteLine("Ready...");      				var le = new LineEditor("FDBShell");    				string[] cmds = new string[]  				{  					"cd"'  					"coordinators"'  					"count"'  					"dir"'  					"exit"'  					"gc"'  					"help"'  					"layer"'  					"map"'  					"mem"'  					"mkdir"'  					"mv"'  					"partition"'  					"pwd"'  					"quit"'  					"ren"'  					"rmdir"'  					"sampling"'  					"shards"'  					"show"'  					"status"'  					"topology"'  					"tree"'  					"version"'  					"wide"'  				};    				le.AutoCompleteEvent = (txt' pos) =>  				{  					string[] res;  					int p = txt.IndexOf(' ');  					if (p > 0)  					{  						string cmd = txt.Substring(0' p);  						string arg = txt.Substring(p + 1);    						if (cmd == "cd")  						{ // handle completion for directories    							// txt: "cd foo" => prefix = "foo"  							// txt: "cd foobar/b" => prefix = "b"    							string path = CurrentDirectoryPath;  							string prefix = "";  							string search = arg;  							p = arg.LastIndexOf('/');  							if (p > 0)  							{  								path = Path.Combine(path' arg.Substring(0' p));  								search = arg.Substring(p + 1);  								prefix = arg.Substring(0' p + 1);  							}    							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult();  							if (!subdirs.HasValue || subdirs.Value == null) return new LineEditor.Completion(txt' null);    							res = subdirs.Value  								.Where(s => s.StartsWith(search' StringComparison.Ordinal))  								.Select(s => (cmd + " " + prefix + s).Substring(txt.Length))  								.ToArray();  							return new LineEditor.Completion(txt' res);  						}    						// unknown command  						return new LineEditor.Completion(txt' null);  					}    					// list of commands  					res = cmds  						.Where(cmd => cmd.StartsWith(txt' StringComparison.OrdinalIgnoreCase))  						.Select(cmd => cmd.Substring(txt.Length))  						.ToArray();  					return new LineEditor.Completion(txt' res);  				};  				le.TabAtStartCompletes = true;    				string prompt = null;  				Action<string> updatePrompt = (path) => { prompt = String.Format("fdb:{0}> "' path); };  				updatePrompt(CurrentDirectoryPath);    				while (!stop)  				{  					string s = startCommand != null ? startCommand : le.Edit(prompt' "");  					startCommand = null;    					if (s == null) break;    					var tokens = s.Trim().Split(new [] { ' ' }' StringSplitOptions.RemoveEmptyEntries);  					string cmd = tokens.Length > 0 ? tokens[0] : String.Empty;  					string prm = tokens.Length > 1 ? tokens[1] : String.Empty;  					var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string>(tokens.Skip(2)) : FdbTuple.Empty;    					var trimmedCommand = cmd.Trim().ToLowerInvariant();  					switch (trimmedCommand)  					{  						case "":  						{  							continue;  						}  						case "log":  						{  							LogCommand(prm' Console.Out);    							break;  						}    						case "version":  						{  							await VersionCommand(prm' clusterFile' Console.Out' cancel);  							break;  						}    						case "tree":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  							break;  						}  						case "map":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  							break;  						}    						case "dir":  						case "ls":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  							break;  						}  						case "ll":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  							break;  						}    						case "count":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  							break;  						}    						case "show":  						case "top":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  							break;  						}  						case "last":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  							break;  						}    						case "cd":  						case "pwd":  						{  							if (!string.IsNullOrEmpty(prm))  							{  								var newPath = CombinePath(CurrentDirectoryPath' prm);  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  								if (res == null)  								{  									Console.WriteLine("# Directory {0} does not exist!"' newPath);  									Console.Beep();  								}  								else  								{  									CurrentDirectoryPath = newPath;  									updatePrompt(CurrentDirectoryPath);  								}  							}  							else  							{  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  								if (res.GetValueOrDefault() == null)  								{  									Console.WriteLine("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  								}  								else  								{  									Console.WriteLine("# {0}"' res);  								}  							}  							break;  						}  						case "mkdir":  						case "md":  						{ // "mkdir DIRECTORYNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}  						case "rmdir":  						{ // "rmdir DIRECTORYNAME"  							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mv":  						case "ren":  						{ // "mv SOURCE DESTINATION"  							  							var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    							break;  						}    						case "layer":  						{  							if (string.IsNullOrEmpty(prm))  							{ // displays the layer id of the current folder  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    							}  							else  							{ // change the layer id of the current folder  								prm = prm.Trim();  								// double or single quotes can be used to escape the value  								if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  								{  									prm = prm.Substring(1' prm.Length - 2);  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mkpart":  						{ // "mkpart PARTITIONNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  							}    							break;  						}    						case "topology":  						{  							await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  							break;  						}    						case "shards":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  							break;  						}    						case "sampling":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  							break;  						}    						case "coordinators":  						{  							await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  							break;  						}    						case "partition":  						{  							if (string.IsNullOrEmpty(prm))  							{  								Console.WriteLine("# Current partition is {0}"' String.Join("/"' partition));  								//TODO: browse existing partitions ?  								break;  							}    							var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  							IFdbDatabase newDb = null;  							try  							{  								newDb = await ChangeDatabase(clusterFile' dbName' newPartition' cancel);  							}  							catch (Exception)  							{  								if (newDb != null) newDb.Dispose();  								newDb = null;  								throw;  							}  							finally  							{  								if (newDb != null)  								{  									if (Db != null) { Db.Dispose(); Db = null; }  									Db = newDb;  									partition = newPartition;  									Console.WriteLine("# Changed partition to {0}"' partition);  								}  							}  							break;  						}    						case "q":  						case "x":  						case "quit":  						case "exit":  						case "bye":  						{  							stop = true;  							break;  						}    						case "gc":  						{  							long before = GC.GetTotalMemory(false);  							Console.Write("Collecting garbage...");  							GC.Collect();  							GC.WaitForPendingFinalizers();  							GC.Collect();  							Console.WriteLine(" Done");  							long after = GC.GetTotalMemory(false);  							Console.WriteLine("- before = " + before.ToString("N0"));  							Console.WriteLine("- after  = " + after.ToString("N0"));  							Console.WriteLine("- delta  = " + (before - after).ToString("N0"));  							break;  						}    						case "mem":  						{  							Console.WriteLine("Memory usage:");  							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  							Console.WriteLine("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  							Console.WriteLine("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  							break;  						}    						case "wide":  						{  							Console.WindowWidth = 160;  							break;  						}    						case "status":  						case "wtf":  						{  							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  							if (result.HasFailed) break;  							if (result.Value.ExitCode != 0)  							{  								Console.WriteLine("# fdbcli exited with code {0}"' result.Value.ExitCode);  								Console.WriteLine("> StdErr:");  								Console.WriteLine(result.Value.StdErr);  								Console.WriteLine("> StdOut:");  							}  							Console.WriteLine(result.Value.StdOut);  							break;  						}    						default:  						{  							Console.WriteLine(string.Format("Unknown command : '{0}'"' trimmedCommand));  							break;  						}  					}    					if (!string.IsNullOrEmpty(execCommand))  					{ // only run one command' and then exit  						break;  					}    				}  			}  			finally  			{  				if (Db != null) Db.Dispose();  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try  			{  				Db = await ChangeDatabase(clusterFile' dbName' partition' cancel);  				Db.DefaultTimeout = Math.Max(0' timeout) * 1000;  				Db.DefaultRetryLimit = Math.Max(0' maxRetries);    				Console.WriteLine("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion() + ")");  				Console.WriteLine("Cluster file: " + (clusterFile ?? "<default>"));  				Console.WriteLine();  				Console.WriteLine("FoundationDB Shell menu:");  				Console.WriteLine("\tdir\tShow the content of the current directory");  				Console.WriteLine("\ttree\tShow all the directories under the current directory");  				Console.WriteLine("\tsampling\tDisplay statistics on random shards from the database");  				Console.WriteLine("\tcoordinators\tShow the current coordinators for the cluster");  				Console.WriteLine("\tmem\tShow memory usage statistics");  				Console.WriteLine("\tgc\tTrigger garbage collection");  				Console.WriteLine("\tquit\tQuit");    				Console.WriteLine("Ready...");      				var le = new LineEditor("FDBShell");    				string[] cmds = new string[]  				{  					"cd"'  					"coordinators"'  					"count"'  					"dir"'  					"exit"'  					"gc"'  					"help"'  					"layer"'  					"map"'  					"mem"'  					"mkdir"'  					"mv"'  					"partition"'  					"pwd"'  					"quit"'  					"ren"'  					"rmdir"'  					"sampling"'  					"shards"'  					"show"'  					"status"'  					"topology"'  					"tree"'  					"version"'  					"wide"'  				};    				le.AutoCompleteEvent = (txt' pos) =>  				{  					string[] res;  					int p = txt.IndexOf(' ');  					if (p > 0)  					{  						string cmd = txt.Substring(0' p);  						string arg = txt.Substring(p + 1);    						if (cmd == "cd")  						{ // handle completion for directories    							// txt: "cd foo" => prefix = "foo"  							// txt: "cd foobar/b" => prefix = "b"    							string path = CurrentDirectoryPath;  							string prefix = "";  							string search = arg;  							p = arg.LastIndexOf('/');  							if (p > 0)  							{  								path = Path.Combine(path' arg.Substring(0' p));  								search = arg.Substring(p + 1);  								prefix = arg.Substring(0' p + 1);  							}    							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult();  							if (!subdirs.HasValue || subdirs.Value == null) return new LineEditor.Completion(txt' null);    							res = subdirs.Value  								.Where(s => s.StartsWith(search' StringComparison.Ordinal))  								.Select(s => (cmd + " " + prefix + s).Substring(txt.Length))  								.ToArray();  							return new LineEditor.Completion(txt' res);  						}    						// unknown command  						return new LineEditor.Completion(txt' null);  					}    					// list of commands  					res = cmds  						.Where(cmd => cmd.StartsWith(txt' StringComparison.OrdinalIgnoreCase))  						.Select(cmd => cmd.Substring(txt.Length))  						.ToArray();  					return new LineEditor.Completion(txt' res);  				};  				le.TabAtStartCompletes = true;    				string prompt = null;  				Action<string> updatePrompt = (path) => { prompt = String.Format("fdb:{0}> "' path); };  				updatePrompt(CurrentDirectoryPath);    				while (!stop)  				{  					string s = startCommand != null ? startCommand : le.Edit(prompt' "");  					startCommand = null;    					if (s == null) break;    					var tokens = s.Trim().Split(new [] { ' ' }' StringSplitOptions.RemoveEmptyEntries);  					string cmd = tokens.Length > 0 ? tokens[0] : String.Empty;  					string prm = tokens.Length > 1 ? tokens[1] : String.Empty;  					var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string>(tokens.Skip(2)) : FdbTuple.Empty;    					var trimmedCommand = cmd.Trim().ToLowerInvariant();  					switch (trimmedCommand)  					{  						case "":  						{  							continue;  						}  						case "log":  						{  							LogCommand(prm' Console.Out);    							break;  						}    						case "version":  						{  							await VersionCommand(prm' clusterFile' Console.Out' cancel);  							break;  						}    						case "tree":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  							break;  						}  						case "map":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  							break;  						}    						case "dir":  						case "ls":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  							break;  						}  						case "ll":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  							break;  						}    						case "count":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  							break;  						}    						case "show":  						case "top":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  							break;  						}  						case "last":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  							break;  						}    						case "cd":  						case "pwd":  						{  							if (!string.IsNullOrEmpty(prm))  							{  								var newPath = CombinePath(CurrentDirectoryPath' prm);  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  								if (res == null)  								{  									Console.WriteLine("# Directory {0} does not exist!"' newPath);  									Console.Beep();  								}  								else  								{  									CurrentDirectoryPath = newPath;  									updatePrompt(CurrentDirectoryPath);  								}  							}  							else  							{  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  								if (res.GetValueOrDefault() == null)  								{  									Console.WriteLine("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  								}  								else  								{  									Console.WriteLine("# {0}"' res);  								}  							}  							break;  						}  						case "mkdir":  						case "md":  						{ // "mkdir DIRECTORYNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}  						case "rmdir":  						{ // "rmdir DIRECTORYNAME"  							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mv":  						case "ren":  						{ // "mv SOURCE DESTINATION"  							  							var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    							break;  						}    						case "layer":  						{  							if (string.IsNullOrEmpty(prm))  							{ // displays the layer id of the current folder  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    							}  							else  							{ // change the layer id of the current folder  								prm = prm.Trim();  								// double or single quotes can be used to escape the value  								if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  								{  									prm = prm.Substring(1' prm.Length - 2);  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mkpart":  						{ // "mkpart PARTITIONNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  							}    							break;  						}    						case "topology":  						{  							await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  							break;  						}    						case "shards":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  							break;  						}    						case "sampling":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  							break;  						}    						case "coordinators":  						{  							await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  							break;  						}    						case "partition":  						{  							if (string.IsNullOrEmpty(prm))  							{  								Console.WriteLine("# Current partition is {0}"' String.Join("/"' partition));  								//TODO: browse existing partitions ?  								break;  							}    							var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  							IFdbDatabase newDb = null;  							try  							{  								newDb = await ChangeDatabase(clusterFile' dbName' newPartition' cancel);  							}  							catch (Exception)  							{  								if (newDb != null) newDb.Dispose();  								newDb = null;  								throw;  							}  							finally  							{  								if (newDb != null)  								{  									if (Db != null) { Db.Dispose(); Db = null; }  									Db = newDb;  									partition = newPartition;  									Console.WriteLine("# Changed partition to {0}"' partition);  								}  							}  							break;  						}    						case "q":  						case "x":  						case "quit":  						case "exit":  						case "bye":  						{  							stop = true;  							break;  						}    						case "gc":  						{  							long before = GC.GetTotalMemory(false);  							Console.Write("Collecting garbage...");  							GC.Collect();  							GC.WaitForPendingFinalizers();  							GC.Collect();  							Console.WriteLine(" Done");  							long after = GC.GetTotalMemory(false);  							Console.WriteLine("- before = " + before.ToString("N0"));  							Console.WriteLine("- after  = " + after.ToString("N0"));  							Console.WriteLine("- delta  = " + (before - after).ToString("N0"));  							break;  						}    						case "mem":  						{  							Console.WriteLine("Memory usage:");  							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  							Console.WriteLine("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  							Console.WriteLine("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  							break;  						}    						case "wide":  						{  							Console.WindowWidth = 160;  							break;  						}    						case "status":  						case "wtf":  						{  							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  							if (result.HasFailed) break;  							if (result.Value.ExitCode != 0)  							{  								Console.WriteLine("# fdbcli exited with code {0}"' result.Value.ExitCode);  								Console.WriteLine("> StdErr:");  								Console.WriteLine(result.Value.StdErr);  								Console.WriteLine("> StdOut:");  							}  							Console.WriteLine(result.Value.StdOut);  							break;  						}    						default:  						{  							Console.WriteLine(string.Format("Unknown command : '{0}'"' trimmedCommand));  							break;  						}  					}    					if (!string.IsNullOrEmpty(execCommand))  					{ // only run one command' and then exit  						break;  					}    				}  			}  			finally  			{  				if (Db != null) Db.Dispose();  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,MainAsync,The following statement contains a magic number: try  			{  				Db = await ChangeDatabase(clusterFile' dbName' partition' cancel);  				Db.DefaultTimeout = Math.Max(0' timeout) * 1000;  				Db.DefaultRetryLimit = Math.Max(0' maxRetries);    				Console.WriteLine("Using API v" + Fdb.ApiVersion + " (max " + Fdb.GetMaxApiVersion() + ")");  				Console.WriteLine("Cluster file: " + (clusterFile ?? "<default>"));  				Console.WriteLine();  				Console.WriteLine("FoundationDB Shell menu:");  				Console.WriteLine("\tdir\tShow the content of the current directory");  				Console.WriteLine("\ttree\tShow all the directories under the current directory");  				Console.WriteLine("\tsampling\tDisplay statistics on random shards from the database");  				Console.WriteLine("\tcoordinators\tShow the current coordinators for the cluster");  				Console.WriteLine("\tmem\tShow memory usage statistics");  				Console.WriteLine("\tgc\tTrigger garbage collection");  				Console.WriteLine("\tquit\tQuit");    				Console.WriteLine("Ready...");      				var le = new LineEditor("FDBShell");    				string[] cmds = new string[]  				{  					"cd"'  					"coordinators"'  					"count"'  					"dir"'  					"exit"'  					"gc"'  					"help"'  					"layer"'  					"map"'  					"mem"'  					"mkdir"'  					"mv"'  					"partition"'  					"pwd"'  					"quit"'  					"ren"'  					"rmdir"'  					"sampling"'  					"shards"'  					"show"'  					"status"'  					"topology"'  					"tree"'  					"version"'  					"wide"'  				};    				le.AutoCompleteEvent = (txt' pos) =>  				{  					string[] res;  					int p = txt.IndexOf(' ');  					if (p > 0)  					{  						string cmd = txt.Substring(0' p);  						string arg = txt.Substring(p + 1);    						if (cmd == "cd")  						{ // handle completion for directories    							// txt: "cd foo" => prefix = "foo"  							// txt: "cd foobar/b" => prefix = "b"    							string path = CurrentDirectoryPath;  							string prefix = "";  							string search = arg;  							p = arg.LastIndexOf('/');  							if (p > 0)  							{  								path = Path.Combine(path' arg.Substring(0' p));  								search = arg.Substring(p + 1);  								prefix = arg.Substring(0' p + 1);  							}    							var subdirs = RunAsyncCommand((db' log' ct) => AutoCompleteDirectories(path' db' log' ct)' cancel).GetAwaiter().GetResult();  							if (!subdirs.HasValue || subdirs.Value == null) return new LineEditor.Completion(txt' null);    							res = subdirs.Value  								.Where(s => s.StartsWith(search' StringComparison.Ordinal))  								.Select(s => (cmd + " " + prefix + s).Substring(txt.Length))  								.ToArray();  							return new LineEditor.Completion(txt' res);  						}    						// unknown command  						return new LineEditor.Completion(txt' null);  					}    					// list of commands  					res = cmds  						.Where(cmd => cmd.StartsWith(txt' StringComparison.OrdinalIgnoreCase))  						.Select(cmd => cmd.Substring(txt.Length))  						.ToArray();  					return new LineEditor.Completion(txt' res);  				};  				le.TabAtStartCompletes = true;    				string prompt = null;  				Action<string> updatePrompt = (path) => { prompt = String.Format("fdb:{0}> "' path); };  				updatePrompt(CurrentDirectoryPath);    				while (!stop)  				{  					string s = startCommand != null ? startCommand : le.Edit(prompt' "");  					startCommand = null;    					if (s == null) break;    					var tokens = s.Trim().Split(new [] { ' ' }' StringSplitOptions.RemoveEmptyEntries);  					string cmd = tokens.Length > 0 ? tokens[0] : String.Empty;  					string prm = tokens.Length > 1 ? tokens[1] : String.Empty;  					var extras = tokens.Length > 2 ? FdbTuple.FromEnumerable<string>(tokens.Skip(2)) : FdbTuple.Empty;    					var trimmedCommand = cmd.Trim().ToLowerInvariant();  					switch (trimmedCommand)  					{  						case "":  						{  							continue;  						}  						case "log":  						{  							LogCommand(prm' Console.Out);    							break;  						}    						case "version":  						{  							await VersionCommand(prm' clusterFile' Console.Out' cancel);  							break;  						}    						case "tree":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Tree(path' extras' db' log' ct)' cancel);  							break;  						}  						case "map":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Map(path' extras' db' log' ct)' cancel);  							break;  						}    						case "dir":  						case "ls":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.Default' db' log' ct)' cancel);  							break;  						}  						case "ll":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Dir(path' extras' BasicCommands.DirectoryBrowseOptions.ShowCount' db' log' ct)' cancel);  							break;  						}    						case "count":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Count(path' extras' db' log' ct)' cancel);  							break;  						}    						case "show":  						case "top":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' false' db' log' ct)' cancel);  							break;  						}  						case "last":  						{  							var path = ParsePath(CurrentDirectoryPath);  							await RunAsyncCommand((db' log' ct) => BasicCommands.Show(path' extras' true' db' log' ct)' cancel);  							break;  						}    						case "cd":  						case "pwd":  						{  							if (!string.IsNullOrEmpty(prm))  							{  								var newPath = CombinePath(CurrentDirectoryPath' prm);  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(newPath)' db' ct)' cancel);  								if (res == null)  								{  									Console.WriteLine("# Directory {0} does not exist!"' newPath);  									Console.Beep();  								}  								else  								{  									CurrentDirectoryPath = newPath;  									updatePrompt(CurrentDirectoryPath);  								}  							}  							else  							{  								var res = await RunAsyncCommand((db' log' ct) => BasicCommands.TryOpenCurrentDirectoryAsync(ParsePath(CurrentDirectoryPath)' db' ct)' cancel);  								if (res.GetValueOrDefault() == null)  								{  									Console.WriteLine("# Directory {0} does not exist anymore"' CurrentDirectoryPath);  								}  								else  								{  									Console.WriteLine("# {0}"' res);  								}  							}  							break;  						}  						case "mkdir":  						case "md":  						{ // "mkdir DIRECTORYNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}  						case "rmdir":  						{ // "rmdir DIRECTORYNAME"  							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.RemoveDirectory(path' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mv":  						case "ren":  						{ // "mv SOURCE DESTINATION"  							  							var srcPath = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							var dstPath = ParsePath(CombinePath(CurrentDirectoryPath' extras.Get<string>(0)));  							await RunAsyncCommand((db' log' ct) => BasicCommands.MoveDirectory(srcPath' dstPath' extras.Substring(1)' db' log' ct)' cancel);    							break;  						}    						case "layer":  						{  							if (string.IsNullOrEmpty(prm))  							{ // displays the layer id of the current folder  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ShowDirectoryLayer(path' extras' db' log' ct)' cancel);    							}  							else  							{ // change the layer id of the current folder  								prm = prm.Trim();  								// double or single quotes can be used to escape the value  								if (prm.Length >= 2 && (prm.StartsWith("'") && prm.EndsWith("'")) || (prm.StartsWith("\"") && prm.EndsWith("\"")))  								{  									prm = prm.Substring(1' prm.Length - 2);  								}  								var path = ParsePath(CurrentDirectoryPath);  								await RunAsyncCommand((db' log' ct) => BasicCommands.ChangeDirectoryLayer(path' prm' extras' db' log' ct)' cancel);  							}  							break;  						}    						case "mkpart":  						{ // "mkpart PARTITIONNAME"    							if (!string.IsNullOrEmpty(prm))  							{  								var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  								await RunAsyncCommand((db' log' ct) => BasicCommands.CreateDirectory(path' FdbTuple.Create(FdbDirectoryPartition.LayerId).Concat(extras)' db' log' ct)' cancel);  							}    							break;  						}    						case "topology":  						{  							await RunAsyncCommand((db' log' ct) => BasicCommands.Topology(null' extras' db' log' ct)' cancel);  							break;  						}    						case "shards":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Shards(path' extras' db' log' ct)' cancel);  							break;  						}    						case "sampling":  						{  							var path = ParsePath(CombinePath(CurrentDirectoryPath' prm));  							await RunAsyncCommand((db' log' ct) => BasicCommands.Sampling(path' extras' db' log' ct)' cancel);  							break;  						}    						case "coordinators":  						{  							await RunAsyncCommand((db' log' ct) => CoordinatorsCommand(db' log' ct)' cancel);  							break;  						}    						case "partition":  						{  							if (string.IsNullOrEmpty(prm))  							{  								Console.WriteLine("# Current partition is {0}"' String.Join("/"' partition));  								//TODO: browse existing partitions ?  								break;  							}    							var newPartition = prm.Split(new[] { '/' }' StringSplitOptions.RemoveEmptyEntries);  							IFdbDatabase newDb = null;  							try  							{  								newDb = await ChangeDatabase(clusterFile' dbName' newPartition' cancel);  							}  							catch (Exception)  							{  								if (newDb != null) newDb.Dispose();  								newDb = null;  								throw;  							}  							finally  							{  								if (newDb != null)  								{  									if (Db != null) { Db.Dispose(); Db = null; }  									Db = newDb;  									partition = newPartition;  									Console.WriteLine("# Changed partition to {0}"' partition);  								}  							}  							break;  						}    						case "q":  						case "x":  						case "quit":  						case "exit":  						case "bye":  						{  							stop = true;  							break;  						}    						case "gc":  						{  							long before = GC.GetTotalMemory(false);  							Console.Write("Collecting garbage...");  							GC.Collect();  							GC.WaitForPendingFinalizers();  							GC.Collect();  							Console.WriteLine(" Done");  							long after = GC.GetTotalMemory(false);  							Console.WriteLine("- before = " + before.ToString("N0"));  							Console.WriteLine("- after  = " + after.ToString("N0"));  							Console.WriteLine("- delta  = " + (before - after).ToString("N0"));  							break;  						}    						case "mem":  						{  							Console.WriteLine("Memory usage:");  							Console.WriteLine("- Working Set  : " + PerfCounters.WorkingSet.NextValue().ToString("N0") + " (peak " + PerfCounters.WorkingSetPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Virtual Bytes: " + PerfCounters.VirtualBytes.NextValue().ToString("N0") + " (peak " + PerfCounters.VirtualBytesPeak.NextValue().ToString("N0") + ")");  							Console.WriteLine("- Private Bytes: " + PerfCounters.PrivateBytes.NextValue().ToString("N0"));  							Console.WriteLine("- Managed Mem  : " + GC.GetTotalMemory(false).ToString("N0"));  							Console.WriteLine("- BytesInAlHeap: " + PerfCounters.ClrBytesInAllHeaps.NextValue().ToString("N0"));  							break;  						}    						case "wide":  						{  							Console.WindowWidth = 160;  							break;  						}    						case "status":  						case "wtf":  						{  							var result = await RunAsyncCommand((_' log' ct) => FdbCliCommands.RunFdbCliCommand("status details"' null' clusterFile' log' ct)' cancel);  							if (result.HasFailed) break;  							if (result.Value.ExitCode != 0)  							{  								Console.WriteLine("# fdbcli exited with code {0}"' result.Value.ExitCode);  								Console.WriteLine("> StdErr:");  								Console.WriteLine(result.Value.StdErr);  								Console.WriteLine("> StdOut:");  							}  							Console.WriteLine(result.Value.StdOut);  							break;  						}    						default:  						{  							Console.WriteLine(string.Format("Unknown command : '{0}'"' trimmedCommand));  							break;  						}  					}    					if (!string.IsNullOrEmpty(execCommand))  					{ // only run one command' and then exit  						break;  					}    				}  			}  			finally  			{  				if (Db != null) Db.Dispose();  			}
Magic Number,FdbShell,Program,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Program.cs,CombinePath,The following statement contains a magic number: return System.IO.Path.GetFullPath(System.IO.Path.Combine(parent' children)).Replace("\\"' "/").Substring(2);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,MedianAbsoluteDeviation,The following statement contains a magic number: var median = Percentile(50);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: int marks = (int)Math.Round((value * chars * 10)' MidpointRounding.AwayFromZero);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (value < -double.Epsilon)  			{  				s[p++] = '[';  				s[p++] = 'N';  				s[p++] = 'E';  				s[p++] = 'G';   				s[p++] = ']';  			}  			else if (marks == 0)  			{  				if (value > double.Epsilon) s[p++] = '`';  			}  			else if (marks > 0)  			{  				while (marks > 10)  				{  					s[p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  					marks -= 10;  				}    				if (marks > 0)  				{  					if (sparse)   						s[p++] = BarTicksChars[marks];  					else  						s[p++] = BarChartChars[marks];  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,FormatHistoBar,The following statement contains a magic number: if (value < -double.Epsilon)  			{  				s[p++] = '[';  				s[p++] = 'N';  				s[p++] = 'E';  				s[p++] = 'G';   				s[p++] = ']';  			}  			else if (marks == 0)  			{  				if (value > double.Epsilon) s[p++] = '`';  			}  			else if (marks > 0)  			{  				while (marks > 10)  				{  					s[p++] = !sparse ? '#' : pad == '\0' ? ' ' : pad;  					marks -= 10;  				}    				if (marks > 0)  				{  					if (sparse)   						s[p++] = BarTicksChars[marks];  					else  						s[p++] = BarChartChars[marks];  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: max = (3 * max + this.Count) / 4;
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: max = (3 * max + this.Count) / 4;
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetDistribution,The following statement contains a magic number: for (int i = 0; i < cs.Length; i++)  			{  				int p = Math.Min((int)Math.Ceiling(rr * data[i])' 10);  				cs[i] = VerticalChartChars[p];  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetPercentiles,The following statement contains a magic number: return String.Format(  				CultureInfo.InvariantCulture'  				"{0:5'#'##0.0} --| {1:5'#'##0.0} ==[ {2:5'#'##0.0} ]== {3:5'#'##0.0} |-- {4:5'#'##0.0}"'  				this.Percentile(5)'  				this.Percentile(25)'  				this.Percentile(50)'  				this.Percentile(75)'  				this.Percentile(95)  			);
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,FdbShell,RobustHistogram,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Utils\Histogram.cs,GetReport,The following statement contains a magic number: if (this.Count > 0)  			{  				double min = this.Count == 0 ? 0d : this.Min;  				double max = this.Max;  				double median = this.Median;    				// MAD  				for (int i = 0; i < this.Buckets.Length; i++)  				{  				}    				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Min/Max: {0'6:0.000} {3} .. {1'6:0.000} {3}' Average: {2:0.000} {3}"'  					min' max' this.Average' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Median : {0'6:0.000} {3} (+/-{1:0.000} {3})' StdDev: {2:0.000}"'  					median' this.MedianAbsoluteDeviation()' this.StandardDeviation' unit  				));  				r.AppendLine(String.Format(CultureInfo.InvariantCulture'  					"- Distrib: ({0:#'##0.0}) - {1:#'##0.0} =[ {2:#'##0.0} ]= {3:#'##0.0} - ({4:#'##0.0})"'  					this.Percentile(5)' this.Percentile(25)' median' this.Percentile(75)' this.Percentile(95)  				));    				if (detailed)  				{  					r.AppendLine("   _____________________________________________________________________________________________________________________"); //_________");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent____________________________________________________|___Cumulative________|");//____kOps_|");  				}  				else  				{  					r.AppendLine("   ________________________________________________________________________ ");  					r.AppendLine("  |____[ Min ' Max )____|___Count___|__Percent__________________|__Cumul.__|");  				}  				double mult = 100.0d / this.Count;  				double sum = 0;  				for (int b = 0; b < NumBuckets; b++)  				{  					if (this.Buckets[b] <= 0) continue;  					sum += this.Buckets[b];  					r.Append(String.Format(CultureInfo.InvariantCulture'  						"  | {0'8:###'##0.###} - {1'-8:###'##0.###} | {2'9:#'###'###} | {3'7:##0.000}% " + (detailed ? "{5'50} " : "{5' 16} ") + "| {4'7:##0.000}%" + (detailed ? " {6'10}"/*" | {7'7:0.0}"*/ : "")'  						/* 0 */ ((b == 0) ? 0.0 : BucketLimits[b - 1])'     // left  						/* 1 */ BucketLimits[b]'							// right  						/* 2 */ this.Buckets[b]'							// count  						/* 3 */ mult * this.Buckets[b]'						// percentage  						/* 4 */ mult * sum'									// cumulative percentage  						/* 5 */ FormatHistoBar((double)this.Buckets[b] / this.Count' detailed ? 50 : 16' pad: ' ')'  						/* 6 */ detailed ? FormatHistoBar(sum / this.Count' 10' pad: '-'' sparse: true) : string.Empty /*'  						(0.001d / ToTimeSpan(BucketLimits[b]).TotalSeconds)*/  					));  					r.AppendLine(" |");  				}  				if (detailed)  				{  					r.AppendLine("  `---------------------------------------------------------------------------------------------------------------------'"); // ---------  				}  				else  				{  					r.AppendLine("  `------------------------------------------------------------------------'");  				}  			}
Magic Number,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Add,The following statement contains a magic number: Option p = new ActionOption (prototype' description' 2'  					delegate (OptionValueCollection v) {action (v [0]' v [1]);}' hidden);
Magic Number,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  				int written = 0;    				if (p.Hidden)  					continue;    				Category c = p as Category;  				if (c != null) {  					WriteDescription (o' p.Description' ""' 80' 80);  					continue;  				}    				if (!WriteOptionPrototype (o' p' ref written))  					continue;    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  				int written = 0;    				if (p.Hidden)  					continue;    				Category c = p as Category;  				if (c != null) {  					WriteDescription (o' p.Description' ""' 80' 80);  					continue;  				}    				if (!WriteOptionPrototype (o' p' ref written))  					continue;    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  				int written = 0;    				if (p.Hidden)  					continue;    				Category c = p as Category;  				if (c != null) {  					WriteDescription (o' p.Description' ""' 80' 80);  					continue;  				}    				if (!WriteOptionPrototype (o' p' ref written))  					continue;    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (ArgumentSource s in sources) {  				string[] names = s.GetNames ();  				if (names == null || names.Length == 0)  					continue;    				int written = 0;    				Write (o' ref written' "  ");  				Write (o' ref written' names [0]);  				for (int i = 1; i < names.Length; ++i) {  					Write (o' ref written' "' ");  					Write (o' ref written' names [i]);  				}    				if (written < OptionWidth)  					o.Write (new string (' '' OptionWidth - written));  				else {  					o.WriteLine ();  					o.Write (new string (' '' OptionWidth));  				}    				WriteDescription (o' s.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);  			}
Magic Number,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,LineEditor,The following statement contains a magic number: handlers = new Handler[] {  				new Handler (ConsoleKey.Home'       CmdHome)'  				new Handler (ConsoleKey.End'        CmdEnd)'  				new Handler (ConsoleKey.LeftArrow'  CmdLeft)'  				new Handler (ConsoleKey.RightArrow' CmdRight)'  				new Handler (ConsoleKey.UpArrow'    CmdHistoryPrev)'  				new Handler (ConsoleKey.DownArrow'  CmdHistoryNext)'  				new Handler (ConsoleKey.Enter'      CmdDone)'  				new Handler (ConsoleKey.Backspace'  CmdBackspace)'  				new Handler (ConsoleKey.Delete'     CmdDeleteChar)'  				new Handler (ConsoleKey.Tab'        CmdTabOrComplete)'  				  				// Emacs keys  				Handler.Control ('A'' CmdHome)'  				Handler.Control ('E'' CmdEnd)'  				Handler.Control ('B'' CmdLeft)'  				Handler.Control ('F'' CmdRight)'  				Handler.Control ('P'' CmdHistoryPrev)'  				Handler.Control ('N'' CmdHistoryNext)'  				Handler.Control ('K'' CmdKillToEOF)'  				Handler.Control ('Y'' CmdYank)'  				Handler.Control ('D'' CmdDeleteChar)'  				Handler.Control ('L'' CmdRefresh)'  				Handler.Control ('R'' CmdReverseSearch)'  				Handler.Control ('G'' delegate {} )'  				Handler.Control ('C'' () => Console.WriteLine("YOU CANNOT ESCAPE!!!!") )'  				Handler.Alt ('B'' ConsoleKey.B' CmdBackwardWord)'  				Handler.Alt ('F'' ConsoleKey.F' CmdForwardWord)'  				  				Handler.Alt ('D'' ConsoleKey.D' CmdDeleteWord)'  				Handler.Alt ((char) 8' ConsoleKey.Backspace' CmdDeleteBackword)'  				  				// DEBUG  				//Handler.Control ('T'' CmdDebug)'    				// quote  				Handler.Control ('Q'' delegate { HandleChar (Console.ReadKey (true).KeyChar); })  			};
Magic Number,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,ComputeRendered,The following statement contains a magic number: for (int i = 0; i < text.Length; i++)  			{  				int c = (int)text[i];  				if (c < 26)  				{  					if (c == '\t')  						rendered_text.Append("    ");  					else  					{  						rendered_text.Append('^');  						rendered_text.Append((char)(c + (int)'A' - 1));  					}  				}  				else  					rendered_text.Append((char)c);  			}
Magic Number,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++)  			{  				int c;    				c = (int)text[i];    				if (c < 26)  				{  					if (c == 9)  						p += 4;  					else  						p += 2;  				}  				else  					p++;  			}
Magic Number,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++)  			{  				int c;    				c = (int)text[i];    				if (c < 26)  				{  					if (c == 9)  						p += 4;  					else  						p += 2;  				}  				else  					p++;  			}
Magic Number,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++)  			{  				int c;    				c = (int)text[i];    				if (c < 26)  				{  					if (c == 9)  						p += 4;  					else  						p += 2;  				}  				else  					p++;  			}
Magic Number,Mono.Terminal,LineEditor,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\getline.cs,TextToRenderPos,The following statement contains a magic number: for (int i = 0; i < pos; i++)  			{  				int c;    				c = (int)text[i];    				if (c < 26)  				{  					if (c == 9)  						p += 4;  					else  						p += 2;  				}  				else  					p++;  			}
Missing Default,Mono.Options,OptionSet,C:\repos\Doxense_foundationdb-dotnet-client\FdbShell\Mono.Options\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  					case OptionValueType.None:  						c.OptionValues.Add (n);  						c.Option.Invoke (c);  						break;  					case OptionValueType.Optional:  					case OptionValueType.Required:  						ParseValue (v' c);  						break;  				}
