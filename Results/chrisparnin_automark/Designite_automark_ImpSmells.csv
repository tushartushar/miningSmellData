Implementation smell,Namespace,Class,File,Method,Description
Long Method,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The method has 127 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The method has 106 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The method has 102 lines of code.
Complex Method,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,Cyclomatic complexity of the method is 16
Complex Method,automark.Git,UnifiedDiffToMyersDifference,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,DifferenceFromHunk,Cyclomatic complexity of the method is 20
Complex Method,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,Cyclomatic complexity of the method is 23
Complex Method,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,ExportHistory,Cyclomatic complexity of the method is 10
Complex Method,DiffMatchPatch,Patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,ToString,Cyclomatic complexity of the method is 14
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_lineMode,Cyclomatic complexity of the method is 17
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,Cyclomatic complexity of the method is 20
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_commonOverlap,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,Cyclomatic complexity of the method is 12
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticLossless,Cyclomatic complexity of the method is 9
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,Cyclomatic complexity of the method is 9
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,Cyclomatic complexity of the method is 32
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_prettyHtml,Cyclomatic complexity of the method is 10
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_levenshtein,Cyclomatic complexity of the method is 12
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_toDelta,Cyclomatic complexity of the method is 11
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_fromDelta,Cyclomatic complexity of the method is 23
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,Cyclomatic complexity of the method is 13
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,Cyclomatic complexity of the method is 23
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_apply,Cyclomatic complexity of the method is 15
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,Cyclomatic complexity of the method is 14
Complex Method,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,Cyclomatic complexity of the method is 14
Long Parameter List,automark.Git,UnifiedDiffToMyersDifference,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,EmitNew,The method has 7 parameters.
Long Parameter List,automark.Git,UnifiedDiffToMyersDifference,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,EmitChange,The method has 9 parameters.
Long Parameter List,automark.Git,UnifiedDiffToMyersDifference,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,EmitRemove,The method has 5 parameters.
Long Parameter List,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisectSplit,The method has 5 parameters.
Long Statement,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The length of the statement  "	using (var connection = new System.Data.SQLite.SQLiteConnection ("Data Source=" + dbPath + ";Version=3;Read Only=True")) { " is 122.
Long Statement,automark.Connections.Browser,FirefoxConnector,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,RecentStackoverflow,The length of the statement  "	using (var connection = new System.Data.SQLite.SQLiteConnection ("Data Source=" + dbPath + ";Version=3;Read Only=True")) { " is 122.
Long Statement,automark.Connections.Browser,FirefoxConnector,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,RecentStackoverflow,The length of the statement  "		var command = @"SELECT moz_places.url' datetime(moz_historyvisits.visit_date/1000000''unixepoch') as visit_time' moz_places.title" is 129.
Long Statement,automark.Connections.Browser,FirefoxConnector,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,FindDbPath,The length of the statement  "		string ffPath = System.IO.Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' @"Mozilla\Firefox\Profiles\"); " is 141.
Long Statement,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "		w.WriteLine ("Please make sure that *autogit* is properly saving changes in your solution directory in the hidden folder `.HistoryData/LocalHistory`"); " is 151.
Long Statement,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "		if (isFirstCommit || (span != TimeSpan.MaxValue && span.TotalHours > 2) || !IsCommitOnSameDay (commit' previousCommit)) { " is 121.
Long Statement,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "			w.WriteLine (string.Format ("<div class='section'>{0}<div></div><div class='summary'></div></div>"' EmitTime (commit.CommitTimeStamp))); " is 136.
Long Statement,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "					w.WriteLine ("Type {0} Left {1}:{2} Right {3}:{4}"' diff.DifferenceType' diff.Left.Start' diff.Left.End' diff.Right.Start' diff.Right.End); " is 139.
Long Statement,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "							w.WriteLine (string.Join ("'"' innerDiffs.Where (d => d.operation != DiffMatchPatch.Operation.EQUAL).Select (d => d.text))); " is 124.
Long Statement,automark.Generate.Export,AsMarkdownHtml,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdownHtml.cs,Export,The length of the statement  "		var res = template + "<body>" + html + "<div class='modal'><div class='msg'><span>Loading...pretty printing...diff highlighting...</span></div></div>\n" + "</body></html>"; " is 172.
Long Statement,automark.Git,GitDiffParser,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,Parse,The length of the statement  "		var hunks = GetUnifiedFormatHunkLines (split).Where (line => !string.IsNullOrEmpty (line.Item1)).Select (line => new HunkRangeInfo (new HunkRange (GetHunkOriginalFile (line.Item1))' new HunkRange (GetHunkNewFile (line.Item1))' line.Item2' GetFileName (split))).ToList (); " is 271.
Long Statement,automark.Git,UnifiedDiffToMyersDifference,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,DifferenceFromHunk,The length of the statement  "					yield return EmitChange (leftStart' leftLineOffset' rightStart' rightLineOffset' leftDiffStart' leftDiffEnd' rightDiffStart' rightDiffEnd' hunk); " is 145.
Long Statement,automark.Git,UnifiedDiffToMyersDifference,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,DifferenceFromHunk,The length of the statement  "					yield return EmitChange (leftStart' leftLineOffset' rightStart' rightLineOffset' leftDiffStart' leftDiffEnd' rightDiffStart' rightDiffEnd' hunk); " is 145.
Long Statement,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The length of the statement  "	string path = System.IO.Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' "autogit"); " is 120.
Long Statement,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The length of the statement  "			if (accumalatedDifference.TotalMinutes <= 3 && prevCommit.Files.All (f => commit.Files.Select (c => c.File).Contains (f.File)) && prevCommit.Files.Any (f => f.Status != "A" || f.Status != "D")) { " is 195.
Long Statement,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The length of the statement  "			fileDiff.Hunks = fileDiff.Hunks.Where (hunk => !(hunk.DiffLines.Where (l => l.Trim ().StartsWith ("+")).All (l => l.Trim () == "+") && hunk.IsAddition) && !(hunk.DiffLines.Where (l => l.Trim ().StartsWith ("-")).All (l => l.Trim () == "-") && hunk.IsDeletion)).ToList (); " is 271.
Long Statement,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,CodeWebHistory,The length of the statement  "	string dbPath = System.IO.Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.LocalApplicationData)' @"Google\Chrome\User Data\Default\History"); " is 160.
Long Statement,automark.Transformations.Rewrite,MergeFixOnFix,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Transformations\Rewrite\MergeFixOnFix.cs,Apply,The length of the statement  "		if (previous.Hunks.Count == next.Hunks.Count && previous.Hunks.Count == 1 && next.MyerDiffs [0].Left.Length == next.MyerDiffs [0].Right.Length) { " is 145.
Long Statement,automark.Transformations.Rewrite,MergeFixOnFix,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Transformations\Rewrite\MergeFixOnFix.cs,Apply,The length of the statement  "			if (previous.MyerDiffs.All (m => m.DifferenceType == Models.Diff.DifferenceType.Add) && next.MyerDiffs.All (m => m.DifferenceType == Models.Diff.DifferenceType.Change)) { " is 170.
Long Statement,automark.Transformations.Rewrite,MergeFixOnFix,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Transformations\Rewrite\MergeFixOnFix.cs,Apply,The length of the statement  "				if (next.MyerDiffs [0].Left.TextLines.All (t => previous.MyerDiffs [0].Right.TextLines.Contains ("+" + t.Remove (0' 1)))) { " is 123.
Long Statement,automark.Util,GitCommands,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ListSha,The length of the statement  "	var output = RunProcess (string.Format (" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" log --name-only"' path.Replace ("\\"' "/")' path.Replace ("\\"' "/"))); " is 156.
Long Statement,automark.Util,GitCommands,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ListShaWithFiles,The length of the statement  "	var output = RunProcess (string.Format (" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" log --name-status"' path.Replace ("\\"' "/")' path.Replace ("\\"' "/"))); " is 158.
Long Statement,automark.Util,GitCommands,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowDiffRange,The length of the statement  "	var output = RunProcess (string.Format (" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" diff {2} {3} --ignore-all-space"' path.Replace ("\\"' "/")' path.Replace ("\\"' "/")' shaBefore' shaAfter)); " is 193.
Long Statement,automark.Util,GitCommands,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowSha,The length of the statement  "	var output = RunProcess (string.Format (" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" show {2} --ignore-all-space"' path.Replace ("\\"' "/")' path.Replace ("\\"' "/")' sha)); " is 173.
Long Statement,automark.Util,GitCommands,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowFileAfterCommit,The length of the statement  "	var output = RunProcess (string.Format (" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" show {2}:\"{3}\""' path.Replace ("\\"' "/")' path.Replace ("\\"' "/")' sha' file)); " is 168.
Long Statement,automark.Util,GitCommands,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowFileBeforeCommit,The length of the statement  "	var output = RunProcess (string.Format (" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" show {2}~1:\"{3}\""' path.Replace ("\\"' "/")' path.Replace ("\\"' "/")' sha' file)); " is 170.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The length of the statement  "			if (lastequality != null && (lastequality.Length <= Math.Max (length_insertions1' length_deletions1)) && (lastequality.Length <= Math.Max (length_insertions2' length_deletions2))) { " is 181.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The length of the statement  "           */if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) { " is 227.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The length of the statement  "						if ((pointer - count_delete - count_insert) > 0 && diffs [pointer - count_delete - count_insert - 1].operation == Operation.EQUAL) { " is 132.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The length of the statement  "					diffs.Splice (pointer - count_delete - count_insert' count_delete + count_insert' new Diff (Operation.DELETE' text_delete)' new Diff (Operation.INSERT' text_insert)); " is 166.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The length of the statement  "				diffs [pointer].text = diffs [pointer - 1].text + diffs [pointer].text.Substring (0' diffs [pointer].text.Length - diffs [pointer - 1].text.Length); " is 148.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_prettyHtml,The length of the statement  "		string text = aDiff.text.Replace ("&"' "&amp;").Replace ("<"' "&lt;").Replace (">"' "&gt;").Replace ("\n"' "&para;<br>"); " is 121.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_fromDelta,The length of the statement  "				throw new ArgumentException ("Delta length (" + pointer + ") larger than source text length (" + text1.Length + ")."' e); " is 121.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_addContext,The length of the statement  "	while (text.IndexOf (pattern' StringComparison.Ordinal) != text.LastIndexOf (pattern' StringComparison.Ordinal) && pattern.Length < Match_MaxBits - Patch_Margin - Patch_Margin) { " is 178.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_addContext,The length of the statement  "		pattern = text.JavaSubstring (Math.Max (0' patch.start2 - padding)' Math.Min (text.Length' patch.start2 + patch.length1 + padding)); " is 132.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_addContext,The length of the statement  "	string suffix = text.JavaSubstring (patch.start2 + patch.length1' Math.Min (text.Length' patch.start2 + patch.length1 + padding)); " is 130.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_apply,The length of the statement  "				end_loc = match_main (text' text1.Substring (text1.Length - this.Match_MaxBits)' expected_loc + text1.Length - this.Match_MaxBits); " is 131.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_apply,The length of the statement  "				if (text1.Length > this.Match_MaxBits && this.diff_levenshtein (diffs) / (float)text1.Length > this.Patch_DeleteThreshold) { " is 124.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The length of the statement  "				} else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) { " is 159.
Long Statement,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,unescapeForEncodeUriCompatability,The length of the statement  "	return str.Replace ("%21"' "!").Replace ("%7e"' "~").Replace ("%27"' "'").Replace ("%28"' "(").Replace ("%29"' ")").Replace ("%3b"' ";").Replace ("%2f"' "/").Replace ("%3f"' "?").Replace ("%3a"' ":").Replace ("%40"' "@").Replace ("%26"' "&").Replace ("%3d"' "=").Replace ("%2b"' "+").Replace ("%24"' "$").Replace ("%2c"' "'").Replace ("%23"' "#"); " is 347.
Complex Conditional,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The conditional expression  "isFirstCommit || (span != TimeSpan.MaxValue && span.TotalHours > 2) || !IsCommitOnSameDay (commit' previousCommit)"  is complex.
Complex Conditional,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The conditional expression  "line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))"  is complex.
Complex Conditional,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The conditional expression  "accumalatedDifference.TotalMinutes <= 3 && prevCommit.Files.All (f => commit.Files.Select (c => c.File).Contains (f.File)) && prevCommit.Files.Any (f => f.Status != "A" || f.Status != "D")"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The conditional expression  "(lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The conditional expression  "diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size"  is complex.
Magic Number,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var connection = new System.Data.SQLite.SQLiteConnection ("Data Source=" + dbPath + ";Version=3;Read Only=True")) {  	connection.Open ();  	var command = @"SELECT urls.url' visits.visit_time' urls.title                   FROM visits' urls                   WHERE visits.url = urls.id AND urls.url LIKE '%stackoverflow%'                 ";  	using (var c = connection.CreateCommand ()) {  		c.CommandText = command;  		var reader = c.ExecuteReader ();  		var urls = new HashSet<string> ();  		while (reader.Read ()) {  			var url = reader.GetString (0);  			var timeEpoch = reader.GetInt64 (1) / 1000;  			var visitTime = FromGoogleTime (timeEpoch);  			var title = reader.GetString (2);  			if (!urls.Contains (url)) {  				list.Add (new WebVisit () {  					Url = url'  					Timestamp = visitTime'  					Title = title  				});  			}  			urls.Add (url);  		}  	}  	connection.Close ();  }  
Magic Number,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var connection = new System.Data.SQLite.SQLiteConnection ("Data Source=" + dbPath + ";Version=3;Read Only=True")) {  	connection.Open ();  	var command = @"SELECT urls.url' visits.visit_time' urls.title                   FROM visits' urls                   WHERE visits.url = urls.id AND urls.url LIKE '%stackoverflow%'                 ";  	using (var c = connection.CreateCommand ()) {  		c.CommandText = command;  		var reader = c.ExecuteReader ();  		var urls = new HashSet<string> ();  		while (reader.Read ()) {  			var url = reader.GetString (0);  			var timeEpoch = reader.GetInt64 (1) / 1000;  			var visitTime = FromGoogleTime (timeEpoch);  			var title = reader.GetString (2);  			if (!urls.Contains (url)) {  				list.Add (new WebVisit () {  					Url = url'  					Timestamp = visitTime'  					Title = title  				});  			}  			urls.Add (url);  		}  	}  	connection.Close ();  }  
Magic Number,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var c = connection.CreateCommand ()) {  	c.CommandText = command;  	var reader = c.ExecuteReader ();  	var urls = new HashSet<string> ();  	while (reader.Read ()) {  		var url = reader.GetString (0);  		var timeEpoch = reader.GetInt64 (1) / 1000;  		var visitTime = FromGoogleTime (timeEpoch);  		var title = reader.GetString (2);  		if (!urls.Contains (url)) {  			list.Add (new WebVisit () {  				Url = url'  				Timestamp = visitTime'  				Title = title  			});  		}  		urls.Add (url);  	}  }  
Magic Number,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var c = connection.CreateCommand ()) {  	c.CommandText = command;  	var reader = c.ExecuteReader ();  	var urls = new HashSet<string> ();  	while (reader.Read ()) {  		var url = reader.GetString (0);  		var timeEpoch = reader.GetInt64 (1) / 1000;  		var visitTime = FromGoogleTime (timeEpoch);  		var title = reader.GetString (2);  		if (!urls.Contains (url)) {  			list.Add (new WebVisit () {  				Url = url'  				Timestamp = visitTime'  				Title = title  			});  		}  		urls.Add (url);  	}  }  
Magic Number,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: while (reader.Read ()) {  	var url = reader.GetString (0);  	var timeEpoch = reader.GetInt64 (1) / 1000;  	var visitTime = FromGoogleTime (timeEpoch);  	var title = reader.GetString (2);  	if (!urls.Contains (url)) {  		list.Add (new WebVisit () {  			Url = url'  			Timestamp = visitTime'  			Title = title  		});  	}  	urls.Add (url);  }  
Magic Number,automark.Connections.Browser,ChromeHistory,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: while (reader.Read ()) {  	var url = reader.GetString (0);  	var timeEpoch = reader.GetInt64 (1) / 1000;  	var visitTime = FromGoogleTime (timeEpoch);  	var title = reader.GetString (2);  	if (!urls.Contains (url)) {  		list.Add (new WebVisit () {  			Url = url'  			Timestamp = visitTime'  			Title = title  		});  	}  	urls.Add (url);  }  
Magic Number,automark.Connections.Browser,FirefoxConnector,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var connection = new System.Data.SQLite.SQLiteConnection ("Data Source=" + dbPath + ";Version=3;Read Only=True")) {  	connection.Open ();  	var command = @"SELECT moz_places.url' datetime(moz_historyvisits.visit_date/1000000''unixepoch') as visit_time' moz_places.title 	FROM moz_places' moz_historyvisits  	WHERE moz_places.id = moz_historyvisits.place_id AND moz_places.url LIKE '%stackoverflow%'                 ";  	using (var c = connection.CreateCommand ()) {  		c.CommandText = command;  		var reader = c.ExecuteReader ();  		var urls = new HashSet<string> ();  		while (reader.Read ()) {  			var url = reader.GetString (0);  			var visitTime = reader.GetDateTime (1);  			//var visitTime = FromGoogleTime(timeEpoch);  			var title = reader.GetString (2);  			if (!urls.Contains (url)) {  				list.Add (new WebVisit () {  					Url = url'  					Timestamp = visitTime'  					Title = title  				});  			}  			urls.Add (url);  		}  	}  	connection.Close ();  }  
Magic Number,automark.Connections.Browser,FirefoxConnector,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var c = connection.CreateCommand ()) {  	c.CommandText = command;  	var reader = c.ExecuteReader ();  	var urls = new HashSet<string> ();  	while (reader.Read ()) {  		var url = reader.GetString (0);  		var visitTime = reader.GetDateTime (1);  		//var visitTime = FromGoogleTime(timeEpoch);  		var title = reader.GetString (2);  		if (!urls.Contains (url)) {  			list.Add (new WebVisit () {  				Url = url'  				Timestamp = visitTime'  				Title = title  			});  		}  		urls.Add (url);  	}  }  
Magic Number,automark.Connections.Browser,FirefoxConnector,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,RecentStackoverflow,The following statement contains a magic number: while (reader.Read ()) {  	var url = reader.GetString (0);  	var visitTime = reader.GetDateTime (1);  	//var visitTime = FromGoogleTime(timeEpoch);  	var title = reader.GetString (2);  	if (!urls.Contains (url)) {  		list.Add (new WebVisit () {  			Url = url'  			Timestamp = visitTime'  			Title = title  		});  	}  	urls.Add (url);  }  
Magic Number,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The following statement contains a magic number: foreach (var commit in commits) {  	var span = TimeSinceLastCommit (commit' previousCommit);  	if (span != TimeSpan.MaxValue && !IsCommitOnSameDay (commit' previousCommit)) {  		w.WriteLine (EmitDate (commit.CommitTimeStamp));  	}  	if (isFirstCommit || (span != TimeSpan.MaxValue && span.TotalHours > 2) || !IsCommitOnSameDay (commit' previousCommit)) {  		w.WriteLine ("");  		w.WriteLine (string.Format ("<div class='section'>{0}<div></div><div class='summary'></div></div>"' EmitTime (commit.CommitTimeStamp)));  		isFirstCommit = false;  	}  	// Sunday' October 6 2013  	// 10:44 AM  	//if (span != TimeSpan.MaxValue && span.TotalHours > 2)  	//{  	//    w.WriteLine("<div class='divider'></div>");  	//    w.WriteLine(EmitTime(commit.CommitTimeStamp));                      	//}  	if (commit.Visits.Any ()) {  		//w.WriteLine("#### Visited ");  		w.WriteLine ("   ");  		foreach (var visit in commit.Visits) {  			w.WriteLine ("* [{0}]({1})"' string.IsNullOrEmpty (visit.Title) ? visit.Url : visit.Title' visit.Url);  		}  		w.WriteLine ("   ");  		if (commit.Visits.Count == 1) {  			w.WriteLine ("<div></div>");  		}  	}  	foreach (var fileDiff in commit.Difflets) {  		//w.WriteLine("> {0} to {1}"' file.Status' file.File);  		w.WriteLine ("#### {0}"' fileDiff.FileName);  		w.WriteLine ();  		foreach (var hunk in fileDiff.Hunks) {  			foreach (var line in hunk.DiffLines) {  				// http://stackoverflow.com/questions/8301207/microsoft-ides-source-file-encodings-boms-and-the-unicode-character-ufeff  				// default filter: skip context of adding using.  				if (line.Trim ().StartsWith ("using "))  					continue;  				w.WriteLine ("    {0}"' line.TrimEnd ());  			}  		}  		// test space  		if (debug) {  			w.WriteLine ("##### Myers Version");  			var diffs = fileDiff.MyerDiffs;  			foreach (var diff in diffs) {  				w.WriteLine ("Type {0} Left {1}:{2} Right {3}:{4}"' diff.DifferenceType' diff.Left.Start' diff.Left.End' diff.Right.Start' diff.Right.End);  				if (diff.DifferenceType == Models.Diff.DifferenceType.Change && diff.Left.Length == diff.Right.Length) {  					w.WriteLine ();  					for (var i = 0; i < diff.Left.Length; i++) {  						var left = diff.Left.TextLines [i];  						var right = diff.Right.TextLines [i];  						var innerDiffs = diffEngine.diff_main (left' right' false);  						diffEngine.Diff_Timeout = 0;  						diffEngine.diff_cleanupSemantic (innerDiffs);  						w.WriteLine (string.Join ("'"' innerDiffs.Where (d => d.operation != DiffMatchPatch.Operation.EQUAL).Select (d => d.text)));  					}  				}  			}  		}  	}  	previousCommit = commit;  }  
Magic Number,automark.Generate.Export,AsMarkdown,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The following statement contains a magic number: if (isFirstCommit || (span != TimeSpan.MaxValue && span.TotalHours > 2) || !IsCommitOnSameDay (commit' previousCommit)) {  	w.WriteLine ("");  	w.WriteLine (string.Format ("<div class='section'>{0}<div></div><div class='summary'></div></div>"' EmitTime (commit.CommitTimeStamp)));  	isFirstCommit = false;  }  
Magic Number,automark.Git,GitDiffParser,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: if (fileA.StartsWith ("a/"))  	return fileA.Remove (0' 2).Trim ();  
Magic Number,automark.Git,GitDiffParser,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: return fileA.Remove (0' 2).Trim ();  
Magic Number,automark.Git,GitDiffParser,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: if (fileB.StartsWith ("b/"))  	return fileB.Remove (0' 2).Trim ();  
Magic Number,automark.Git,GitDiffParser,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: return fileB.Remove (0' 2).Trim ();  
Magic Number,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: using (var strReader = new StringReader (output)) {  	do {  		var line = strReader.ReadLine ();  		if (line == null)  			break;  		if (line.StartsWith ("commit ")) {  			if (commit != null)  				commits.Add (commit);  			commit = new GitCommit ();  			commit.Sha = line.Split (' ') [1];  		}  		if (StartsWithHeader (line)) {  			var header = line.Split (':') [0];  			var val = string.Join (":"' line.Split (':').Skip (1)).Trim ();  			// headers  			commit.Headers.Add (header' val);  		}  		if (string.IsNullOrEmpty (line)) {  			// commit message divider  			processingMessage = !processingMessage;  		}  		if (line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))) {  			// commit message.  			commit.Message += line;  		}  		if (line.Length > 1 && Char.IsLetter (line [0]) && line [1] == '\t') {  			var status = line.Split ('\t') [0];  			var file = line.Split ('\t') [1];  			commit.Files.Add (new GitFileStatus () {  				Status = status'  				File = file  			});  		}  	} while (strReader.Peek () != -1);  }  
Magic Number,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: using (var strReader = new StringReader (output)) {  	do {  		var line = strReader.ReadLine ();  		if (line == null)  			break;  		if (line.StartsWith ("commit ")) {  			if (commit != null)  				commits.Add (commit);  			commit = new GitCommit ();  			commit.Sha = line.Split (' ') [1];  		}  		if (StartsWithHeader (line)) {  			var header = line.Split (':') [0];  			var val = string.Join (":"' line.Split (':').Skip (1)).Trim ();  			// headers  			commit.Headers.Add (header' val);  		}  		if (string.IsNullOrEmpty (line)) {  			// commit message divider  			processingMessage = !processingMessage;  		}  		if (line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))) {  			// commit message.  			commit.Message += line;  		}  		if (line.Length > 1 && Char.IsLetter (line [0]) && line [1] == '\t') {  			var status = line.Split ('\t') [0];  			var file = line.Split ('\t') [1];  			commit.Files.Add (new GitFileStatus () {  				Status = status'  				File = file  			});  		}  	} while (strReader.Peek () != -1);  }  
Magic Number,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: do {  	var line = strReader.ReadLine ();  	if (line == null)  		break;  	if (line.StartsWith ("commit ")) {  		if (commit != null)  			commits.Add (commit);  		commit = new GitCommit ();  		commit.Sha = line.Split (' ') [1];  	}  	if (StartsWithHeader (line)) {  		var header = line.Split (':') [0];  		var val = string.Join (":"' line.Split (':').Skip (1)).Trim ();  		// headers  		commit.Headers.Add (header' val);  	}  	if (string.IsNullOrEmpty (line)) {  		// commit message divider  		processingMessage = !processingMessage;  	}  	if (line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))) {  		// commit message.  		commit.Message += line;  	}  	if (line.Length > 1 && Char.IsLetter (line [0]) && line [1] == '\t') {  		var status = line.Split ('\t') [0];  		var file = line.Split ('\t') [1];  		commit.Files.Add (new GitFileStatus () {  			Status = status'  			File = file  		});  	}  } while (strReader.Peek () != -1);  
Magic Number,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: do {  	var line = strReader.ReadLine ();  	if (line == null)  		break;  	if (line.StartsWith ("commit ")) {  		if (commit != null)  			commits.Add (commit);  		commit = new GitCommit ();  		commit.Sha = line.Split (' ') [1];  	}  	if (StartsWithHeader (line)) {  		var header = line.Split (':') [0];  		var val = string.Join (":"' line.Split (':').Skip (1)).Trim ();  		// headers  		commit.Headers.Add (header' val);  	}  	if (string.IsNullOrEmpty (line)) {  		// commit message divider  		processingMessage = !processingMessage;  	}  	if (line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))) {  		// commit message.  		commit.Message += line;  	}  	if (line.Length > 1 && Char.IsLetter (line [0]) && line [1] == '\t') {  		var status = line.Split ('\t') [0];  		var file = line.Split ('\t') [1];  		commit.Files.Add (new GitFileStatus () {  			Status = status'  			File = file  		});  	}  } while (strReader.Peek () != -1);  
Magic Number,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: if (line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))) {  	// commit message.  	commit.Message += line;  }  
Magic Number,automark.Git,ParseGitLog,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: if (line.Length > 0 && line [0] == '\t' || (line.Length > 4 && line.Substring (0' 4).All (ch => ch == ' '))) {  	// commit message.  	commit.Message += line;  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: foreach (var commit in commits) {  	commit.UnifiedDiff = GitCommands.ShowSha (path' commit.Sha);  	// skip big files for arbiturary definition of big.  	if (commit.UnifiedDiff.Length > 500000)  		continue;  	ParseUnifiedDiff (path' diffParser' commit);  	//commit.Print();  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: if (commit.UnifiedDiff.Length > 500000)  	continue;  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: if (fuzz) {  	var commitsToPrune = new List<GitCommit> ();  	// Do processing of commits in order' just easier on the brain...  	var inOrderCommits = commits.ToList ();  	inOrderCommits.Reverse ();  	var prevCommit = inOrderCommits.FirstOrDefault ();  	var accumalatedDifference = new TimeSpan ();  	var startOfFuzz = prevCommit;  	var endOfFuzz = prevCommit;  	foreach (var commit in inOrderCommits.Skip (1)) {  		var lastTime = ParseGitLog.GetDateFromGitFormat (prevCommit.Headers ["Date"]);  		var commitTime = ParseGitLog.GetDateFromGitFormat (commit.Headers ["Date"]);  		var span = (lastTime - commitTime).Duration ();  		accumalatedDifference += span;  		if (accumalatedDifference.TotalMinutes <= 3 && prevCommit.Files.All (f => commit.Files.Select (c => c.File).Contains (f.File)) && prevCommit.Files.Any (f => f.Status != "A" || f.Status != "D")) {  			commitsToPrune.Add (prevCommit);  			endOfFuzz = commit;  		} else {  			// endOfFuzz will be only surviving commit in range' others will be pruned.    			// Get a new unified diff' and then reparse.  			if (startOfFuzz != endOfFuzz) {  				try {  					endOfFuzz.UnifiedDiff = GitCommands.ShowDiffRange (path' startOfFuzz.Sha + "~1"' endOfFuzz.Sha);  					ParseUnifiedDiff (path' diffParser' endOfFuzz);  				} catch (Exception ex) {  					Trace.WriteLine (ex.Message);  				}  			}  			accumalatedDifference = new TimeSpan ();  			startOfFuzz = commit;  			endOfFuzz = commit;  		}  		prevCommit = commit;  	}  	if (startOfFuzz != endOfFuzz) {  		try {  			endOfFuzz.UnifiedDiff = GitCommands.ShowDiffRange (path' startOfFuzz.Sha + "~1"' endOfFuzz.Sha);  			ParseUnifiedDiff (path' diffParser' endOfFuzz);  		} catch (Exception ex) {  			Trace.WriteLine (ex.Message);  		}  	}  	foreach (var commitToRemove in commitsToPrune) {  		commits.Remove (commitToRemove);  	}  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: foreach (var commit in inOrderCommits.Skip (1)) {  	var lastTime = ParseGitLog.GetDateFromGitFormat (prevCommit.Headers ["Date"]);  	var commitTime = ParseGitLog.GetDateFromGitFormat (commit.Headers ["Date"]);  	var span = (lastTime - commitTime).Duration ();  	accumalatedDifference += span;  	if (accumalatedDifference.TotalMinutes <= 3 && prevCommit.Files.All (f => commit.Files.Select (c => c.File).Contains (f.File)) && prevCommit.Files.Any (f => f.Status != "A" || f.Status != "D")) {  		commitsToPrune.Add (prevCommit);  		endOfFuzz = commit;  	} else {  		// endOfFuzz will be only surviving commit in range' others will be pruned.    		// Get a new unified diff' and then reparse.  		if (startOfFuzz != endOfFuzz) {  			try {  				endOfFuzz.UnifiedDiff = GitCommands.ShowDiffRange (path' startOfFuzz.Sha + "~1"' endOfFuzz.Sha);  				ParseUnifiedDiff (path' diffParser' endOfFuzz);  			} catch (Exception ex) {  				Trace.WriteLine (ex.Message);  			}  		}  		accumalatedDifference = new TimeSpan ();  		startOfFuzz = commit;  		endOfFuzz = commit;  	}  	prevCommit = commit;  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: if (accumalatedDifference.TotalMinutes <= 3 && prevCommit.Files.All (f => commit.Files.Select (c => c.File).Contains (f.File)) && prevCommit.Files.Any (f => f.Status != "A" || f.Status != "D")) {  	commitsToPrune.Add (prevCommit);  	endOfFuzz = commit;  } else {  	// endOfFuzz will be only surviving commit in range' others will be pruned.    	// Get a new unified diff' and then reparse.  	if (startOfFuzz != endOfFuzz) {  		try {  			endOfFuzz.UnifiedDiff = GitCommands.ShowDiffRange (path' startOfFuzz.Sha + "~1"' endOfFuzz.Sha);  			ParseUnifiedDiff (path' diffParser' endOfFuzz);  		} catch (Exception ex) {  			Trace.WriteLine (ex.Message);  		}  	}  	accumalatedDifference = new TimeSpan ();  	startOfFuzz = commit;  	endOfFuzz = commit;  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: if (args.Length == 0) {  	Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture ("sv-SE");  	Thread.CurrentThread.CurrentUICulture = new CultureInfo ("sv-SE");  	Console.WriteLine (string.Format ("## {0:dddd' MMMM dd' yyyy}\u00e5"' DateTime.Now.AddDays (-2)));  	Console.ReadKey ();  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: Console.WriteLine (string.Format ("## {0:dddd' MMMM dd' yyyy}\u00e5"' DateTime.Now.AddDays (-2)));  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,GetWebVisits,The following statement contains a magic number: if (System.IO.File.Exists (dbPath)) {  	try {  		// Chrome keeps an exclusive lock on database while open; copy-local  		var tempPath = tempName;  		System.IO.File.Copy (dbPath' tempPath' true);  		visits = connector.RecentStackoverflow (tempPath);  		// Clean up  		GC.Collect ();  		connector = null;  		new System.Threading.Thread (db => {  			System.Threading.Thread.Sleep (1000);  			System.IO.File.Delete ((string)db);  		}).Start (tempPath);  	} catch (Exception ex) {  		Trace.Write (ex.Message);  	}  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,GetWebVisits,The following statement contains a magic number: try {  	// Chrome keeps an exclusive lock on database while open; copy-local  	var tempPath = tempName;  	System.IO.File.Copy (dbPath' tempPath' true);  	visits = connector.RecentStackoverflow (tempPath);  	// Clean up  	GC.Collect ();  	connector = null;  	new System.Threading.Thread (db => {  		System.Threading.Thread.Sleep (1000);  		System.IO.File.Delete ((string)db);  	}).Start (tempPath);  } catch (Exception ex) {  	Trace.Write (ex.Message);  }  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,GetWebVisits,The following statement contains a magic number: new System.Threading.Thread (db => {  	System.Threading.Thread.Sleep (1000);  	System.IO.File.Delete ((string)db);  }).Start (tempPath);  
Magic Number,automark,Program,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Program.cs,GetWebVisits,The following statement contains a magic number: System.Threading.Thread.Sleep (1000);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0) {  	deadline = DateTime.MaxValue;  } else {  	deadline = DateTime.Now + new TimeSpan (((long)(Diff_Timeout * 1000)) * 10000);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0) {  	deadline = DateTime.MaxValue;  } else {  	deadline = DateTime.Now + new TimeSpan (((long)(Diff_Timeout * 1000)) * 10000);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: deadline = DateTime.Now + new TimeSpan (((long)(Diff_Timeout * 1000)) * 10000);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: deadline = DateTime.Now + new TimeSpan (((long)(Diff_Timeout * 1000)) * 10000);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {  	// A half-match was found' sort out the return data.  	string text1_a = hm [0];  	string text1_b = hm [1];  	string text2_a = hm [2];  	string text2_b = hm [3];  	string mid_common = hm [4];  	// Send both pairs off for separate processing.  	List<Diff> diffs_a = diff_main (text1_a' text2_a' checklines' deadline);  	List<Diff> diffs_b = diff_main (text1_b' text2_b' checklines' deadline);  	// Merge the results.  	diffs = diffs_a;  	diffs.Add (new Diff (Operation.EQUAL' mid_common));  	diffs.AddRange (diffs_b);  	return diffs;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {  	// A half-match was found' sort out the return data.  	string text1_a = hm [0];  	string text1_b = hm [1];  	string text2_a = hm [2];  	string text2_b = hm [3];  	string mid_common = hm [4];  	// Send both pairs off for separate processing.  	List<Diff> diffs_a = diff_main (text1_a' text2_a' checklines' deadline);  	List<Diff> diffs_b = diff_main (text1_b' text2_b' checklines' deadline);  	// Merge the results.  	diffs = diffs_a;  	diffs.Add (new Diff (Operation.EQUAL' mid_common));  	diffs.AddRange (diffs_b);  	return diffs;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {  	// A half-match was found' sort out the return data.  	string text1_a = hm [0];  	string text1_b = hm [1];  	string text2_a = hm [2];  	string text2_b = hm [3];  	string mid_common = hm [4];  	// Send both pairs off for separate processing.  	List<Diff> diffs_a = diff_main (text1_a' text2_a' checklines' deadline);  	List<Diff> diffs_b = diff_main (text1_b' text2_b' checklines' deadline);  	// Merge the results.  	diffs = diffs_a;  	diffs.Add (new Diff (Operation.EQUAL' mid_common));  	diffs.AddRange (diffs_b);  	return diffs;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100) {  	return diff_lineMode (text1' text2' deadline);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100) {  	return diff_lineMode (text1' text2' deadline);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {  	// Bail out if deadline is reached.  	if (DateTime.Now > deadline) {  		break;  	}  	// Walk the front path one step.  	for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  		int k1_offset = v_offset + k1;  		int x1;  		if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  			x1 = v1 [k1_offset + 1];  		} else {  			x1 = v1 [k1_offset - 1] + 1;  		}  		int y1 = x1 - k1;  		while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  			x1++;  			y1++;  		}  		v1 [k1_offset] = x1;  		if (x1 > text1_length) {  			// Ran off the right of the graph.  			k1end += 2;  		} else if (y1 > text2_length) {  			// Ran off the bottom of the graph.  			k1start += 2;  		} else if (front) {  			int k2_offset = v_offset + delta - k1;  			if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  				// Mirror x2 onto top-left coordinate system.  				int x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  	// Walk the reverse path one step.  	for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  		int k2_offset = v_offset + k2;  		int x2;  		if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  			x2 = v2 [k2_offset + 1];  		} else {  			x2 = v2 [k2_offset - 1] + 1;  		}  		int y2 = x2 - k2;  		while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  			x2++;  			y2++;  		}  		v2 [k2_offset] = x2;  		if (x2 > text1_length) {  			// Ran off the left of the graph.  			k2end += 2;  		} else if (y2 > text2_length) {  			// Ran off the top of the graph.  			k2start += 2;  		} else if (!front) {  			int k1_offset = v_offset + delta - k2;  			if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  				int x1 = v1 [k1_offset];  				int y1 = v_offset + x1 - k1_offset;  				// Mirror x2 onto top-left coordinate system.  				x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {  	// Bail out if deadline is reached.  	if (DateTime.Now > deadline) {  		break;  	}  	// Walk the front path one step.  	for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  		int k1_offset = v_offset + k1;  		int x1;  		if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  			x1 = v1 [k1_offset + 1];  		} else {  			x1 = v1 [k1_offset - 1] + 1;  		}  		int y1 = x1 - k1;  		while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  			x1++;  			y1++;  		}  		v1 [k1_offset] = x1;  		if (x1 > text1_length) {  			// Ran off the right of the graph.  			k1end += 2;  		} else if (y1 > text2_length) {  			// Ran off the bottom of the graph.  			k1start += 2;  		} else if (front) {  			int k2_offset = v_offset + delta - k1;  			if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  				// Mirror x2 onto top-left coordinate system.  				int x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  	// Walk the reverse path one step.  	for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  		int k2_offset = v_offset + k2;  		int x2;  		if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  			x2 = v2 [k2_offset + 1];  		} else {  			x2 = v2 [k2_offset - 1] + 1;  		}  		int y2 = x2 - k2;  		while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  			x2++;  			y2++;  		}  		v2 [k2_offset] = x2;  		if (x2 > text1_length) {  			// Ran off the left of the graph.  			k2end += 2;  		} else if (y2 > text2_length) {  			// Ran off the top of the graph.  			k2start += 2;  		} else if (!front) {  			int k1_offset = v_offset + delta - k2;  			if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  				int x1 = v1 [k1_offset];  				int y1 = v_offset + x1 - k1_offset;  				// Mirror x2 onto top-left coordinate system.  				x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {  	// Bail out if deadline is reached.  	if (DateTime.Now > deadline) {  		break;  	}  	// Walk the front path one step.  	for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  		int k1_offset = v_offset + k1;  		int x1;  		if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  			x1 = v1 [k1_offset + 1];  		} else {  			x1 = v1 [k1_offset - 1] + 1;  		}  		int y1 = x1 - k1;  		while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  			x1++;  			y1++;  		}  		v1 [k1_offset] = x1;  		if (x1 > text1_length) {  			// Ran off the right of the graph.  			k1end += 2;  		} else if (y1 > text2_length) {  			// Ran off the bottom of the graph.  			k1start += 2;  		} else if (front) {  			int k2_offset = v_offset + delta - k1;  			if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  				// Mirror x2 onto top-left coordinate system.  				int x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  	// Walk the reverse path one step.  	for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  		int k2_offset = v_offset + k2;  		int x2;  		if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  			x2 = v2 [k2_offset + 1];  		} else {  			x2 = v2 [k2_offset - 1] + 1;  		}  		int y2 = x2 - k2;  		while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  			x2++;  			y2++;  		}  		v2 [k2_offset] = x2;  		if (x2 > text1_length) {  			// Ran off the left of the graph.  			k2end += 2;  		} else if (y2 > text2_length) {  			// Ran off the top of the graph.  			k2start += 2;  		} else if (!front) {  			int k1_offset = v_offset + delta - k2;  			if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  				int x1 = v1 [k1_offset];  				int y1 = v_offset + x1 - k1_offset;  				// Mirror x2 onto top-left coordinate system.  				x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {  	// Bail out if deadline is reached.  	if (DateTime.Now > deadline) {  		break;  	}  	// Walk the front path one step.  	for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  		int k1_offset = v_offset + k1;  		int x1;  		if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  			x1 = v1 [k1_offset + 1];  		} else {  			x1 = v1 [k1_offset - 1] + 1;  		}  		int y1 = x1 - k1;  		while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  			x1++;  			y1++;  		}  		v1 [k1_offset] = x1;  		if (x1 > text1_length) {  			// Ran off the right of the graph.  			k1end += 2;  		} else if (y1 > text2_length) {  			// Ran off the bottom of the graph.  			k1start += 2;  		} else if (front) {  			int k2_offset = v_offset + delta - k1;  			if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  				// Mirror x2 onto top-left coordinate system.  				int x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  	// Walk the reverse path one step.  	for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  		int k2_offset = v_offset + k2;  		int x2;  		if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  			x2 = v2 [k2_offset + 1];  		} else {  			x2 = v2 [k2_offset - 1] + 1;  		}  		int y2 = x2 - k2;  		while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  			x2++;  			y2++;  		}  		v2 [k2_offset] = x2;  		if (x2 > text1_length) {  			// Ran off the left of the graph.  			k2end += 2;  		} else if (y2 > text2_length) {  			// Ran off the top of the graph.  			k2start += 2;  		} else if (!front) {  			int k1_offset = v_offset + delta - k2;  			if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  				int x1 = v1 [k1_offset];  				int y1 = v_offset + x1 - k1_offset;  				// Mirror x2 onto top-left coordinate system.  				x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {  	// Bail out if deadline is reached.  	if (DateTime.Now > deadline) {  		break;  	}  	// Walk the front path one step.  	for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  		int k1_offset = v_offset + k1;  		int x1;  		if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  			x1 = v1 [k1_offset + 1];  		} else {  			x1 = v1 [k1_offset - 1] + 1;  		}  		int y1 = x1 - k1;  		while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  			x1++;  			y1++;  		}  		v1 [k1_offset] = x1;  		if (x1 > text1_length) {  			// Ran off the right of the graph.  			k1end += 2;  		} else if (y1 > text2_length) {  			// Ran off the bottom of the graph.  			k1start += 2;  		} else if (front) {  			int k2_offset = v_offset + delta - k1;  			if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  				// Mirror x2 onto top-left coordinate system.  				int x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  	// Walk the reverse path one step.  	for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  		int k2_offset = v_offset + k2;  		int x2;  		if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  			x2 = v2 [k2_offset + 1];  		} else {  			x2 = v2 [k2_offset - 1] + 1;  		}  		int y2 = x2 - k2;  		while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  			x2++;  			y2++;  		}  		v2 [k2_offset] = x2;  		if (x2 > text1_length) {  			// Ran off the left of the graph.  			k2end += 2;  		} else if (y2 > text2_length) {  			// Ran off the top of the graph.  			k2start += 2;  		} else if (!front) {  			int k1_offset = v_offset + delta - k2;  			if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  				int x1 = v1 [k1_offset];  				int y1 = v_offset + x1 - k1_offset;  				// Mirror x2 onto top-left coordinate system.  				x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {  	// Bail out if deadline is reached.  	if (DateTime.Now > deadline) {  		break;  	}  	// Walk the front path one step.  	for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  		int k1_offset = v_offset + k1;  		int x1;  		if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  			x1 = v1 [k1_offset + 1];  		} else {  			x1 = v1 [k1_offset - 1] + 1;  		}  		int y1 = x1 - k1;  		while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  			x1++;  			y1++;  		}  		v1 [k1_offset] = x1;  		if (x1 > text1_length) {  			// Ran off the right of the graph.  			k1end += 2;  		} else if (y1 > text2_length) {  			// Ran off the bottom of the graph.  			k1start += 2;  		} else if (front) {  			int k2_offset = v_offset + delta - k1;  			if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  				// Mirror x2 onto top-left coordinate system.  				int x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  	// Walk the reverse path one step.  	for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  		int k2_offset = v_offset + k2;  		int x2;  		if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  			x2 = v2 [k2_offset + 1];  		} else {  			x2 = v2 [k2_offset - 1] + 1;  		}  		int y2 = x2 - k2;  		while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  			x2++;  			y2++;  		}  		v2 [k2_offset] = x2;  		if (x2 > text1_length) {  			// Ran off the left of the graph.  			k2end += 2;  		} else if (y2 > text2_length) {  			// Ran off the top of the graph.  			k2start += 2;  		} else if (!front) {  			int k1_offset = v_offset + delta - k2;  			if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  				int x1 = v1 [k1_offset];  				int y1 = v_offset + x1 - k1_offset;  				// Mirror x2 onto top-left coordinate system.  				x2 = text1_length - v2 [k2_offset];  				if (x1 >= x2) {  					// Overlap detected.  					return diff_bisectSplit (text1' text2' x1' y1' deadline);  				}  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  	int k1_offset = v_offset + k1;  	int x1;  	if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  		x1 = v1 [k1_offset + 1];  	} else {  		x1 = v1 [k1_offset - 1] + 1;  	}  	int y1 = x1 - k1;  	while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  		x1++;  		y1++;  	}  	v1 [k1_offset] = x1;  	if (x1 > text1_length) {  		// Ran off the right of the graph.  		k1end += 2;  	} else if (y1 > text2_length) {  		// Ran off the bottom of the graph.  		k1start += 2;  	} else if (front) {  		int k2_offset = v_offset + delta - k1;  		if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  			// Mirror x2 onto top-left coordinate system.  			int x2 = text1_length - v2 [k2_offset];  			if (x1 >= x2) {  				// Overlap detected.  				return diff_bisectSplit (text1' text2' x1' y1' deadline);  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  	int k1_offset = v_offset + k1;  	int x1;  	if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  		x1 = v1 [k1_offset + 1];  	} else {  		x1 = v1 [k1_offset - 1] + 1;  	}  	int y1 = x1 - k1;  	while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  		x1++;  		y1++;  	}  	v1 [k1_offset] = x1;  	if (x1 > text1_length) {  		// Ran off the right of the graph.  		k1end += 2;  	} else if (y1 > text2_length) {  		// Ran off the bottom of the graph.  		k1start += 2;  	} else if (front) {  		int k2_offset = v_offset + delta - k1;  		if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  			// Mirror x2 onto top-left coordinate system.  			int x2 = text1_length - v2 [k2_offset];  			if (x1 >= x2) {  				// Overlap detected.  				return diff_bisectSplit (text1' text2' x1' y1' deadline);  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {  	int k1_offset = v_offset + k1;  	int x1;  	if (k1 == -d || k1 != d && v1 [k1_offset - 1] < v1 [k1_offset + 1]) {  		x1 = v1 [k1_offset + 1];  	} else {  		x1 = v1 [k1_offset - 1] + 1;  	}  	int y1 = x1 - k1;  	while (x1 < text1_length && y1 < text2_length && text1 [x1] == text2 [y1]) {  		x1++;  		y1++;  	}  	v1 [k1_offset] = x1;  	if (x1 > text1_length) {  		// Ran off the right of the graph.  		k1end += 2;  	} else if (y1 > text2_length) {  		// Ran off the bottom of the graph.  		k1start += 2;  	} else if (front) {  		int k2_offset = v_offset + delta - k1;  		if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  			// Mirror x2 onto top-left coordinate system.  			int x2 = text1_length - v2 [k2_offset];  			if (x1 >= x2) {  				// Overlap detected.  				return diff_bisectSplit (text1' text2' x1' y1' deadline);  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k1 += 2
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: if (x1 > text1_length) {  	// Ran off the right of the graph.  	k1end += 2;  } else if (y1 > text2_length) {  	// Ran off the bottom of the graph.  	k1start += 2;  } else if (front) {  	int k2_offset = v_offset + delta - k1;  	if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  		// Mirror x2 onto top-left coordinate system.  		int x2 = text1_length - v2 [k2_offset];  		if (x1 >= x2) {  			// Overlap detected.  			return diff_bisectSplit (text1' text2' x1' y1' deadline);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: if (x1 > text1_length) {  	// Ran off the right of the graph.  	k1end += 2;  } else if (y1 > text2_length) {  	// Ran off the bottom of the graph.  	k1start += 2;  } else if (front) {  	int k2_offset = v_offset + delta - k1;  	if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  		// Mirror x2 onto top-left coordinate system.  		int x2 = text1_length - v2 [k2_offset];  		if (x1 >= x2) {  			// Overlap detected.  			return diff_bisectSplit (text1' text2' x1' y1' deadline);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k1end += 2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: if (y1 > text2_length) {  	// Ran off the bottom of the graph.  	k1start += 2;  } else if (front) {  	int k2_offset = v_offset + delta - k1;  	if (k2_offset >= 0 && k2_offset < v_length && v2 [k2_offset] != -1) {  		// Mirror x2 onto top-left coordinate system.  		int x2 = text1_length - v2 [k2_offset];  		if (x1 >= x2) {  			// Overlap detected.  			return diff_bisectSplit (text1' text2' x1' y1' deadline);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k1start += 2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  	int k2_offset = v_offset + k2;  	int x2;  	if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  		x2 = v2 [k2_offset + 1];  	} else {  		x2 = v2 [k2_offset - 1] + 1;  	}  	int y2 = x2 - k2;  	while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  		x2++;  		y2++;  	}  	v2 [k2_offset] = x2;  	if (x2 > text1_length) {  		// Ran off the left of the graph.  		k2end += 2;  	} else if (y2 > text2_length) {  		// Ran off the top of the graph.  		k2start += 2;  	} else if (!front) {  		int k1_offset = v_offset + delta - k2;  		if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  			int x1 = v1 [k1_offset];  			int y1 = v_offset + x1 - k1_offset;  			// Mirror x2 onto top-left coordinate system.  			x2 = text1_length - v2 [k2_offset];  			if (x1 >= x2) {  				// Overlap detected.  				return diff_bisectSplit (text1' text2' x1' y1' deadline);  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  	int k2_offset = v_offset + k2;  	int x2;  	if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  		x2 = v2 [k2_offset + 1];  	} else {  		x2 = v2 [k2_offset - 1] + 1;  	}  	int y2 = x2 - k2;  	while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  		x2++;  		y2++;  	}  	v2 [k2_offset] = x2;  	if (x2 > text1_length) {  		// Ran off the left of the graph.  		k2end += 2;  	} else if (y2 > text2_length) {  		// Ran off the top of the graph.  		k2start += 2;  	} else if (!front) {  		int k1_offset = v_offset + delta - k2;  		if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  			int x1 = v1 [k1_offset];  			int y1 = v_offset + x1 - k1_offset;  			// Mirror x2 onto top-left coordinate system.  			x2 = text1_length - v2 [k2_offset];  			if (x1 >= x2) {  				// Overlap detected.  				return diff_bisectSplit (text1' text2' x1' y1' deadline);  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {  	int k2_offset = v_offset + k2;  	int x2;  	if (k2 == -d || k2 != d && v2 [k2_offset - 1] < v2 [k2_offset + 1]) {  		x2 = v2 [k2_offset + 1];  	} else {  		x2 = v2 [k2_offset - 1] + 1;  	}  	int y2 = x2 - k2;  	while (x2 < text1_length && y2 < text2_length && text1 [text1_length - x2 - 1] == text2 [text2_length - y2 - 1]) {  		x2++;  		y2++;  	}  	v2 [k2_offset] = x2;  	if (x2 > text1_length) {  		// Ran off the left of the graph.  		k2end += 2;  	} else if (y2 > text2_length) {  		// Ran off the top of the graph.  		k2start += 2;  	} else if (!front) {  		int k1_offset = v_offset + delta - k2;  		if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  			int x1 = v1 [k1_offset];  			int y1 = v_offset + x1 - k1_offset;  			// Mirror x2 onto top-left coordinate system.  			x2 = text1_length - v2 [k2_offset];  			if (x1 >= x2) {  				// Overlap detected.  				return diff_bisectSplit (text1' text2' x1' y1' deadline);  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k2 += 2
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: if (x2 > text1_length) {  	// Ran off the left of the graph.  	k2end += 2;  } else if (y2 > text2_length) {  	// Ran off the top of the graph.  	k2start += 2;  } else if (!front) {  	int k1_offset = v_offset + delta - k2;  	if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  		int x1 = v1 [k1_offset];  		int y1 = v_offset + x1 - k1_offset;  		// Mirror x2 onto top-left coordinate system.  		x2 = text1_length - v2 [k2_offset];  		if (x1 >= x2) {  			// Overlap detected.  			return diff_bisectSplit (text1' text2' x1' y1' deadline);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: if (x2 > text1_length) {  	// Ran off the left of the graph.  	k2end += 2;  } else if (y2 > text2_length) {  	// Ran off the top of the graph.  	k2start += 2;  } else if (!front) {  	int k1_offset = v_offset + delta - k2;  	if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  		int x1 = v1 [k1_offset];  		int y1 = v_offset + x1 - k1_offset;  		// Mirror x2 onto top-left coordinate system.  		x2 = text1_length - v2 [k2_offset];  		if (x1 >= x2) {  			// Overlap detected.  			return diff_bisectSplit (text1' text2' x1' y1' deadline);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k2end += 2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: if (y2 > text2_length) {  	// Ran off the top of the graph.  	k2start += 2;  } else if (!front) {  	int k1_offset = v_offset + delta - k2;  	if (k1_offset >= 0 && k1_offset < v_length && v1 [k1_offset] != -1) {  		int x1 = v1 [k1_offset];  		int y1 = v_offset + x1 - k1_offset;  		// Mirror x2 onto top-left coordinate system.  		x2 = text1_length - v2 [k2_offset];  		if (x1 >= x2) {  			// Overlap detected.  			return diff_bisectSplit (text1' text2' x1' y1' deadline);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: k2start += 2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length) {  	return null;  	// Pointless.  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length) {  	return null;  	// Pointless.  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null) {  	return null;  } else if (hm2 == null) {  	hm = hm1;  } else if (hm1 == null) {  	hm = hm2;  } else {  	// Both matched.  Select the longest.  	hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null) {  	return null;  } else if (hm2 == null) {  	hm = hm1;  } else if (hm1 == null) {  	hm = hm2;  } else {  	// Both matched.  Select the longest.  	hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm2 == null) {  	hm = hm1;  } else if (hm1 == null) {  	hm = hm2;  } else {  	// Both matched.  Select the longest.  	hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm2 == null) {  	hm = hm1;  } else if (hm1 == null) {  	hm = hm2;  } else {  	// Both matched.  Select the longest.  	hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null) {  	hm = hm2;  } else {  	// Both matched.  Select the longest.  	hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null) {  	hm = hm2;  } else {  	// Both matched.  Select the longest.  	hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: hm = hm1 [4].Length > hm2 [4].Length ? hm1 : hm2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {  	return hm;  	//return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};  } else {  	return new string[] {  		hm [2]'  		hm [3]'  		hm [0]'  		hm [1]'  		hm [4]  	};  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {  	return hm;  	//return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};  } else {  	return new string[] {  		hm [2]'  		hm [3]'  		hm [0]'  		hm [1]'  		hm [4]  	};  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {  	return hm;  	//return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};  } else {  	return new string[] {  		hm [2]'  		hm [3]'  		hm [0]'  		hm [1]'  		hm [4]  	};  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: return new string[] {  	hm [2]'  	hm [3]'  	hm [0]'  	hm [1]'  	hm [4]  };  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: return new string[] {  	hm [2]'  	hm [3]'  	hm [0]'  	hm [1]'  	hm [4]  };  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: return new string[] {  	hm [2]'  	hm [3]'  	hm [0]'  	hm [1]'  	hm [4]  };  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: if (best_common.Length * 2 >= longtext.Length) {  	return new string[] {  		best_longtext_a'  		best_longtext_b'  		best_shorttext_a'  		best_shorttext_b'  		best_common  	};  } else {  	return null;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {  	if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  		string deletion = diffs [pointer - 1].text;  		string insertion = diffs [pointer].text;  		int overlap_length1 = diff_commonOverlap (deletion' insertion);  		int overlap_length2 = diff_commonOverlap (insertion' deletion);  		if (overlap_length1 >= overlap_length2) {  			if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  				// Overlap found.  				// Insert an equality and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  				diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  				diffs [pointer + 1].text = insertion.Substring (overlap_length1);  				pointer++;  			}  		} else {  			if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  				// Reverse overlap found.  				// Insert an equality and swap and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  				diffs [pointer - 1].operation = Operation.INSERT;  				diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  				diffs [pointer + 1].operation = Operation.DELETE;  				diffs [pointer + 1].text = deletion.Substring (overlap_length2);  				pointer++;  			}  		}  		pointer++;  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {  	if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  		string deletion = diffs [pointer - 1].text;  		string insertion = diffs [pointer].text;  		int overlap_length1 = diff_commonOverlap (deletion' insertion);  		int overlap_length2 = diff_commonOverlap (insertion' deletion);  		if (overlap_length1 >= overlap_length2) {  			if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  				// Overlap found.  				// Insert an equality and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  				diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  				diffs [pointer + 1].text = insertion.Substring (overlap_length1);  				pointer++;  			}  		} else {  			if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  				// Reverse overlap found.  				// Insert an equality and swap and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  				diffs [pointer - 1].operation = Operation.INSERT;  				diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  				diffs [pointer + 1].operation = Operation.DELETE;  				diffs [pointer + 1].text = deletion.Substring (overlap_length2);  				pointer++;  			}  		}  		pointer++;  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {  	if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  		string deletion = diffs [pointer - 1].text;  		string insertion = diffs [pointer].text;  		int overlap_length1 = diff_commonOverlap (deletion' insertion);  		int overlap_length2 = diff_commonOverlap (insertion' deletion);  		if (overlap_length1 >= overlap_length2) {  			if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  				// Overlap found.  				// Insert an equality and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  				diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  				diffs [pointer + 1].text = insertion.Substring (overlap_length1);  				pointer++;  			}  		} else {  			if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  				// Reverse overlap found.  				// Insert an equality and swap and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  				diffs [pointer - 1].operation = Operation.INSERT;  				diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  				diffs [pointer + 1].operation = Operation.DELETE;  				diffs [pointer + 1].text = deletion.Substring (overlap_length2);  				pointer++;  			}  		}  		pointer++;  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {  	if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  		string deletion = diffs [pointer - 1].text;  		string insertion = diffs [pointer].text;  		int overlap_length1 = diff_commonOverlap (deletion' insertion);  		int overlap_length2 = diff_commonOverlap (insertion' deletion);  		if (overlap_length1 >= overlap_length2) {  			if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  				// Overlap found.  				// Insert an equality and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  				diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  				diffs [pointer + 1].text = insertion.Substring (overlap_length1);  				pointer++;  			}  		} else {  			if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  				// Reverse overlap found.  				// Insert an equality and swap and trim the surrounding edits.  				diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  				diffs [pointer - 1].operation = Operation.INSERT;  				diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  				diffs [pointer + 1].operation = Operation.DELETE;  				diffs [pointer + 1].text = deletion.Substring (overlap_length2);  				pointer++;  			}  		}  		pointer++;  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  	string deletion = diffs [pointer - 1].text;  	string insertion = diffs [pointer].text;  	int overlap_length1 = diff_commonOverlap (deletion' insertion);  	int overlap_length2 = diff_commonOverlap (insertion' deletion);  	if (overlap_length1 >= overlap_length2) {  		if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  			// Overlap found.  			// Insert an equality and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  			diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  			diffs [pointer + 1].text = insertion.Substring (overlap_length1);  			pointer++;  		}  	} else {  		if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  			// Reverse overlap found.  			// Insert an equality and swap and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  			diffs [pointer - 1].operation = Operation.INSERT;  			diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  			diffs [pointer + 1].operation = Operation.DELETE;  			diffs [pointer + 1].text = deletion.Substring (overlap_length2);  			pointer++;  		}  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  	string deletion = diffs [pointer - 1].text;  	string insertion = diffs [pointer].text;  	int overlap_length1 = diff_commonOverlap (deletion' insertion);  	int overlap_length2 = diff_commonOverlap (insertion' deletion);  	if (overlap_length1 >= overlap_length2) {  		if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  			// Overlap found.  			// Insert an equality and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  			diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  			diffs [pointer + 1].text = insertion.Substring (overlap_length1);  			pointer++;  		}  	} else {  		if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  			// Reverse overlap found.  			// Insert an equality and swap and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  			diffs [pointer - 1].operation = Operation.INSERT;  			diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  			diffs [pointer + 1].operation = Operation.DELETE;  			diffs [pointer + 1].text = deletion.Substring (overlap_length2);  			pointer++;  		}  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  	string deletion = diffs [pointer - 1].text;  	string insertion = diffs [pointer].text;  	int overlap_length1 = diff_commonOverlap (deletion' insertion);  	int overlap_length2 = diff_commonOverlap (insertion' deletion);  	if (overlap_length1 >= overlap_length2) {  		if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  			// Overlap found.  			// Insert an equality and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  			diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  			diffs [pointer + 1].text = insertion.Substring (overlap_length1);  			pointer++;  		}  	} else {  		if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  			// Reverse overlap found.  			// Insert an equality and swap and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  			diffs [pointer - 1].operation = Operation.INSERT;  			diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  			diffs [pointer + 1].operation = Operation.DELETE;  			diffs [pointer + 1].text = deletion.Substring (overlap_length2);  			pointer++;  		}  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (diffs [pointer - 1].operation == Operation.DELETE && diffs [pointer].operation == Operation.INSERT) {  	string deletion = diffs [pointer - 1].text;  	string insertion = diffs [pointer].text;  	int overlap_length1 = diff_commonOverlap (deletion' insertion);  	int overlap_length2 = diff_commonOverlap (insertion' deletion);  	if (overlap_length1 >= overlap_length2) {  		if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  			// Overlap found.  			// Insert an equality and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  			diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  			diffs [pointer + 1].text = insertion.Substring (overlap_length1);  			pointer++;  		}  	} else {  		if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  			// Reverse overlap found.  			// Insert an equality and swap and trim the surrounding edits.  			diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  			diffs [pointer - 1].operation = Operation.INSERT;  			diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  			diffs [pointer + 1].operation = Operation.DELETE;  			diffs [pointer + 1].text = deletion.Substring (overlap_length2);  			pointer++;  		}  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length1 >= overlap_length2) {  	if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  		// Overlap found.  		// Insert an equality and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  		diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  		diffs [pointer + 1].text = insertion.Substring (overlap_length1);  		pointer++;  	}  } else {  	if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  		// Reverse overlap found.  		// Insert an equality and swap and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  		diffs [pointer - 1].operation = Operation.INSERT;  		diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  		diffs [pointer + 1].operation = Operation.DELETE;  		diffs [pointer + 1].text = deletion.Substring (overlap_length2);  		pointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length1 >= overlap_length2) {  	if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  		// Overlap found.  		// Insert an equality and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  		diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  		diffs [pointer + 1].text = insertion.Substring (overlap_length1);  		pointer++;  	}  } else {  	if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  		// Reverse overlap found.  		// Insert an equality and swap and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  		diffs [pointer - 1].operation = Operation.INSERT;  		diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  		diffs [pointer + 1].operation = Operation.DELETE;  		diffs [pointer + 1].text = deletion.Substring (overlap_length2);  		pointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length1 >= overlap_length2) {  	if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  		// Overlap found.  		// Insert an equality and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  		diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  		diffs [pointer + 1].text = insertion.Substring (overlap_length1);  		pointer++;  	}  } else {  	if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  		// Reverse overlap found.  		// Insert an equality and swap and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  		diffs [pointer - 1].operation = Operation.INSERT;  		diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  		diffs [pointer + 1].operation = Operation.DELETE;  		diffs [pointer + 1].text = deletion.Substring (overlap_length2);  		pointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length1 >= overlap_length2) {  	if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  		// Overlap found.  		// Insert an equality and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  		diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  		diffs [pointer + 1].text = insertion.Substring (overlap_length1);  		pointer++;  	}  } else {  	if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  		// Reverse overlap found.  		// Insert an equality and swap and trim the surrounding edits.  		diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  		diffs [pointer - 1].operation = Operation.INSERT;  		diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  		diffs [pointer + 1].operation = Operation.DELETE;  		diffs [pointer + 1].text = deletion.Substring (overlap_length2);  		pointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  	// Overlap found.  	// Insert an equality and trim the surrounding edits.  	diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  	diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  	diffs [pointer + 1].text = insertion.Substring (overlap_length1);  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0) {  	// Overlap found.  	// Insert an equality and trim the surrounding edits.  	diffs.Insert (pointer' new Diff (Operation.EQUAL' insertion.Substring (0' overlap_length1)));  	diffs [pointer - 1].text = deletion.Substring (0' deletion.Length - overlap_length1);  	diffs [pointer + 1].text = insertion.Substring (overlap_length1);  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  	// Reverse overlap found.  	// Insert an equality and swap and trim the surrounding edits.  	diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  	diffs [pointer - 1].operation = Operation.INSERT;  	diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  	diffs [pointer + 1].operation = Operation.DELETE;  	diffs [pointer + 1].text = deletion.Substring (overlap_length2);  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0) {  	// Reverse overlap found.  	// Insert an equality and swap and trim the surrounding edits.  	diffs.Insert (pointer' new Diff (Operation.EQUAL' deletion.Substring (0' overlap_length2)));  	diffs [pointer - 1].operation = Operation.INSERT;  	diffs [pointer - 1].text = insertion.Substring (0' insertion.Length - overlap_length2);  	diffs [pointer + 1].operation = Operation.DELETE;  	diffs [pointer + 1].text = deletion.Substring (overlap_length2);  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (one.Length == 0 || two.Length == 0) {  	// Edges are the best.  	return 6;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 6;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {  	// Five points for blank lines.  	return 5;  } else if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {  	// Five points for blank lines.  	return 5;  } else if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {  	// Five points for blank lines.  	return 5;  } else if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {  	// Five points for blank lines.  	return 5;  } else if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 5;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (lineBreak1 || lineBreak2) {  	// Four points for line breaks.  	return 4;  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 4;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {  	// Three points for end of sentences.  	return 3;  } else if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 3;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (whitespace1 || whitespace2) {  	// Two points for whitespace.  	return 2;  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {  	// One point for non-alphanumeric.  	return 1;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: return 2;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count) {  	if (diffs [pointer].operation == Operation.EQUAL) {  		// Equality found.  		if (diffs [pointer].text.Length < this.Diff_EditCost && (post_ins || post_del)) {  			// Candidate found.  			equalities.Push (pointer);  			pre_ins = post_ins;  			pre_del = post_del;  			lastequality = diffs [pointer].text;  		} else {  			// Not a candidate' and can never become one.  			equalities.Clear ();  			lastequality = string.Empty;  		}  		post_ins = post_del = false;  	} else {  		// An insertion or deletion.  		if (diffs [pointer].operation == Operation.DELETE) {  			post_del = true;  		} else {  			post_ins = true;  		}  		/*            * Five types to be split:            * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>            * <ins>A</ins>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<ins>C</ins>            * <ins>A</del>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<del>C</del>            */if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {  			// Duplicate record.  			diffs.Insert (equalities.Peek ()' new Diff (Operation.DELETE' lastequality));  			// Change second copy to insert.  			diffs [equalities.Peek () + 1].operation = Operation.INSERT;  			equalities.Pop ();  			// Throw away the equality we just deleted.  			lastequality = string.Empty;  			if (pre_ins && pre_del) {  				// No changes made which could affect previous entry' keep going.  				post_ins = post_del = true;  				equalities.Clear ();  			} else {  				if (equalities.Count > 0) {  					equalities.Pop ();  				}  				pointer = equalities.Count > 0 ? equalities.Peek () : -1;  				post_ins = post_del = false;  			}  			changes = true;  		}  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count) {  	if (diffs [pointer].operation == Operation.EQUAL) {  		// Equality found.  		if (diffs [pointer].text.Length < this.Diff_EditCost && (post_ins || post_del)) {  			// Candidate found.  			equalities.Push (pointer);  			pre_ins = post_ins;  			pre_del = post_del;  			lastequality = diffs [pointer].text;  		} else {  			// Not a candidate' and can never become one.  			equalities.Clear ();  			lastequality = string.Empty;  		}  		post_ins = post_del = false;  	} else {  		// An insertion or deletion.  		if (diffs [pointer].operation == Operation.DELETE) {  			post_del = true;  		} else {  			post_ins = true;  		}  		/*            * Five types to be split:            * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>            * <ins>A</ins>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<ins>C</ins>            * <ins>A</del>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<del>C</del>            */if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {  			// Duplicate record.  			diffs.Insert (equalities.Peek ()' new Diff (Operation.DELETE' lastequality));  			// Change second copy to insert.  			diffs [equalities.Peek () + 1].operation = Operation.INSERT;  			equalities.Pop ();  			// Throw away the equality we just deleted.  			lastequality = string.Empty;  			if (pre_ins && pre_del) {  				// No changes made which could affect previous entry' keep going.  				post_ins = post_del = true;  				equalities.Clear ();  			} else {  				if (equalities.Count > 0) {  					equalities.Pop ();  				}  				pointer = equalities.Count > 0 ? equalities.Peek () : -1;  				post_ins = post_del = false;  			}  			changes = true;  		}  	}  	pointer++;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: if (diffs [pointer].operation == Operation.EQUAL) {  	// Equality found.  	if (diffs [pointer].text.Length < this.Diff_EditCost && (post_ins || post_del)) {  		// Candidate found.  		equalities.Push (pointer);  		pre_ins = post_ins;  		pre_del = post_del;  		lastequality = diffs [pointer].text;  	} else {  		// Not a candidate' and can never become one.  		equalities.Clear ();  		lastequality = string.Empty;  	}  	post_ins = post_del = false;  } else {  	// An insertion or deletion.  	if (diffs [pointer].operation == Operation.DELETE) {  		post_del = true;  	} else {  		post_ins = true;  	}  	/*            * Five types to be split:            * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>            * <ins>A</ins>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<ins>C</ins>            * <ins>A</del>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<del>C</del>            */if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {  		// Duplicate record.  		diffs.Insert (equalities.Peek ()' new Diff (Operation.DELETE' lastequality));  		// Change second copy to insert.  		diffs [equalities.Peek () + 1].operation = Operation.INSERT;  		equalities.Pop ();  		// Throw away the equality we just deleted.  		lastequality = string.Empty;  		if (pre_ins && pre_del) {  			// No changes made which could affect previous entry' keep going.  			post_ins = post_del = true;  			equalities.Clear ();  		} else {  			if (equalities.Count > 0) {  				equalities.Pop ();  			}  			pointer = equalities.Count > 0 ? equalities.Peek () : -1;  			post_ins = post_del = false;  		}  		changes = true;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: if (diffs [pointer].operation == Operation.EQUAL) {  	// Equality found.  	if (diffs [pointer].text.Length < this.Diff_EditCost && (post_ins || post_del)) {  		// Candidate found.  		equalities.Push (pointer);  		pre_ins = post_ins;  		pre_del = post_del;  		lastequality = diffs [pointer].text;  	} else {  		// Not a candidate' and can never become one.  		equalities.Clear ();  		lastequality = string.Empty;  	}  	post_ins = post_del = false;  } else {  	// An insertion or deletion.  	if (diffs [pointer].operation == Operation.DELETE) {  		post_del = true;  	} else {  		post_ins = true;  	}  	/*            * Five types to be split:            * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>            * <ins>A</ins>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<ins>C</ins>            * <ins>A</del>X<ins>C</ins><del>D</del>            * <ins>A</ins><del>B</del>X<del>C</del>            */if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {  		// Duplicate record.  		diffs.Insert (equalities.Peek ()' new Diff (Operation.DELETE' lastequality));  		// Change second copy to insert.  		diffs [equalities.Peek () + 1].operation = Operation.INSERT;  		equalities.Pop ();  		// Throw away the equality we just deleted.  		lastequality = string.Empty;  		if (pre_ins && pre_del) {  			// No changes made which could affect previous entry' keep going.  			post_ins = post_del = true;  			equalities.Clear ();  		} else {  			if (equalities.Count > 0) {  				equalities.Pop ();  			}  			pointer = equalities.Count > 0 ? equalities.Peek () : -1;  			post_ins = post_del = false;  		}  		changes = true;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {  	// Duplicate record.  	diffs.Insert (equalities.Peek ()' new Diff (Operation.DELETE' lastequality));  	// Change second copy to insert.  	diffs [equalities.Peek () + 1].operation = Operation.INSERT;  	equalities.Pop ();  	// Throw away the equality we just deleted.  	lastequality = string.Empty;  	if (pre_ins && pre_del) {  		// No changes made which could affect previous entry' keep going.  		post_ins = post_del = true;  		equalities.Clear ();  	} else {  		if (equalities.Count > 0) {  			equalities.Pop ();  		}  		pointer = equalities.Count > 0 ? equalities.Peek () : -1;  		post_ins = post_del = false;  	}  	changes = true;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {  	// Duplicate record.  	diffs.Insert (equalities.Peek ()' new Diff (Operation.DELETE' lastequality));  	// Change second copy to insert.  	diffs [equalities.Peek () + 1].operation = Operation.INSERT;  	equalities.Pop ();  	// Throw away the equality we just deleted.  	lastequality = string.Empty;  	if (pre_ins && pre_del) {  		// No changes made which could affect previous entry' keep going.  		post_ins = post_del = true;  		equalities.Clear ();  	} else {  		if (equalities.Count > 0) {  			equalities.Pop ();  		}  		pointer = equalities.Count > 0 ? equalities.Peek () : -1;  		post_ins = post_del = false;  	}  	changes = true;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {  	// Scan for the best match; each iteration allows for one more error.  	// Run a binary search to determine how far from 'loc' we can stray at  	// this error level.  	bin_min = 0;  	bin_mid = bin_max;  	while (bin_min < bin_mid) {  		if (match_bitapScore (d' loc + bin_mid' loc' pattern) <= score_threshold) {  			bin_min = bin_mid;  		} else {  			bin_max = bin_mid;  		}  		bin_mid = (bin_max - bin_min) / 2 + bin_min;  	}  	// Use the result from this iteration as the maximum for the next.  	bin_max = bin_mid;  	int start = Math.Max (1' loc - bin_mid + 1);  	int finish = Math.Min (loc + bin_mid' text.Length) + pattern.Length;  	int[] rd = new int[finish + 2];  	rd [finish + 1] = (1 << d) - 1;  	for (int j = finish; j >= start; j--) {  		int charMatch;  		if (text.Length <= j - 1 || !s.ContainsKey (text [j - 1])) {  			// Out of range.  			charMatch = 0;  		} else {  			charMatch = s [text [j - 1]];  		}  		if (d == 0) {  			// First pass: exact match.  			rd [j] = ((rd [j + 1] << 1) | 1) & charMatch;  		} else {  			// Subsequent passes: fuzzy match.  			rd [j] = ((rd [j + 1] << 1) | 1) & charMatch | (((last_rd [j + 1] | last_rd [j]) << 1) | 1) | last_rd [j + 1];  		}  		if ((rd [j] & matchmask) != 0) {  			double score = match_bitapScore (d' j - 1' loc' pattern);  			// This match will almost certainly be better than any existing  			// match.  But check anyway.  			if (score <= score_threshold) {  				// Told you so.  				score_threshold = score;  				best_loc = j - 1;  				if (best_loc > loc) {  					// When passing loc' don't exceed our current distance from loc.  					start = Math.Max (1' 2 * loc - best_loc);  				} else {  					// Already passed loc' downhill from here on in.  					break;  				}  			}  		}  	}  	if (match_bitapScore (d + 1' loc' loc' pattern) > score_threshold) {  		// No hope for a (better) match at greater error levels.  		break;  	}  	last_rd = rd;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {  	// Scan for the best match; each iteration allows for one more error.  	// Run a binary search to determine how far from 'loc' we can stray at  	// this error level.  	bin_min = 0;  	bin_mid = bin_max;  	while (bin_min < bin_mid) {  		if (match_bitapScore (d' loc + bin_mid' loc' pattern) <= score_threshold) {  			bin_min = bin_mid;  		} else {  			bin_max = bin_mid;  		}  		bin_mid = (bin_max - bin_min) / 2 + bin_min;  	}  	// Use the result from this iteration as the maximum for the next.  	bin_max = bin_mid;  	int start = Math.Max (1' loc - bin_mid + 1);  	int finish = Math.Min (loc + bin_mid' text.Length) + pattern.Length;  	int[] rd = new int[finish + 2];  	rd [finish + 1] = (1 << d) - 1;  	for (int j = finish; j >= start; j--) {  		int charMatch;  		if (text.Length <= j - 1 || !s.ContainsKey (text [j - 1])) {  			// Out of range.  			charMatch = 0;  		} else {  			charMatch = s [text [j - 1]];  		}  		if (d == 0) {  			// First pass: exact match.  			rd [j] = ((rd [j + 1] << 1) | 1) & charMatch;  		} else {  			// Subsequent passes: fuzzy match.  			rd [j] = ((rd [j + 1] << 1) | 1) & charMatch | (((last_rd [j + 1] | last_rd [j]) << 1) | 1) | last_rd [j + 1];  		}  		if ((rd [j] & matchmask) != 0) {  			double score = match_bitapScore (d' j - 1' loc' pattern);  			// This match will almost certainly be better than any existing  			// match.  But check anyway.  			if (score <= score_threshold) {  				// Told you so.  				score_threshold = score;  				best_loc = j - 1;  				if (best_loc > loc) {  					// When passing loc' don't exceed our current distance from loc.  					start = Math.Max (1' 2 * loc - best_loc);  				} else {  					// Already passed loc' downhill from here on in.  					break;  				}  			}  		}  	}  	if (match_bitapScore (d + 1' loc' loc' pattern) > score_threshold) {  		// No hope for a (better) match at greater error levels.  		break;  	}  	last_rd = rd;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {  	// Scan for the best match; each iteration allows for one more error.  	// Run a binary search to determine how far from 'loc' we can stray at  	// this error level.  	bin_min = 0;  	bin_mid = bin_max;  	while (bin_min < bin_mid) {  		if (match_bitapScore (d' loc + bin_mid' loc' pattern) <= score_threshold) {  			bin_min = bin_mid;  		} else {  			bin_max = bin_mid;  		}  		bin_mid = (bin_max - bin_min) / 2 + bin_min;  	}  	// Use the result from this iteration as the maximum for the next.  	bin_max = bin_mid;  	int start = Math.Max (1' loc - bin_mid + 1);  	int finish = Math.Min (loc + bin_mid' text.Length) + pattern.Length;  	int[] rd = new int[finish + 2];  	rd [finish + 1] = (1 << d) - 1;  	for (int j = finish; j >= start; j--) {  		int charMatch;  		if (text.Length <= j - 1 || !s.ContainsKey (text [j - 1])) {  			// Out of range.  			charMatch = 0;  		} else {  			charMatch = s [text [j - 1]];  		}  		if (d == 0) {  			// First pass: exact match.  			rd [j] = ((rd [j + 1] << 1) | 1) & charMatch;  		} else {  			// Subsequent passes: fuzzy match.  			rd [j] = ((rd [j + 1] << 1) | 1) & charMatch | (((last_rd [j + 1] | last_rd [j]) << 1) | 1) | last_rd [j + 1];  		}  		if ((rd [j] & matchmask) != 0) {  			double score = match_bitapScore (d' j - 1' loc' pattern);  			// This match will almost certainly be better than any existing  			// match.  But check anyway.  			if (score <= score_threshold) {  				// Told you so.  				score_threshold = score;  				best_loc = j - 1;  				if (best_loc > loc) {  					// When passing loc' don't exceed our current distance from loc.  					start = Math.Max (1' 2 * loc - best_loc);  				} else {  					// Already passed loc' downhill from here on in.  					break;  				}  			}  		}  	}  	if (match_bitapScore (d + 1' loc' loc' pattern) > score_threshold) {  		// No hope for a (better) match at greater error levels.  		break;  	}  	last_rd = rd;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: while (bin_min < bin_mid) {  	if (match_bitapScore (d' loc + bin_mid' loc' pattern) <= score_threshold) {  		bin_min = bin_mid;  	} else {  		bin_max = bin_mid;  	}  	bin_mid = (bin_max - bin_min) / 2 + bin_min;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: bin_mid = (bin_max - bin_min) / 2 + bin_min;  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int j = finish; j >= start; j--) {  	int charMatch;  	if (text.Length <= j - 1 || !s.ContainsKey (text [j - 1])) {  		// Out of range.  		charMatch = 0;  	} else {  		charMatch = s [text [j - 1]];  	}  	if (d == 0) {  		// First pass: exact match.  		rd [j] = ((rd [j + 1] << 1) | 1) & charMatch;  	} else {  		// Subsequent passes: fuzzy match.  		rd [j] = ((rd [j + 1] << 1) | 1) & charMatch | (((last_rd [j + 1] | last_rd [j]) << 1) | 1) | last_rd [j + 1];  	}  	if ((rd [j] & matchmask) != 0) {  		double score = match_bitapScore (d' j - 1' loc' pattern);  		// This match will almost certainly be better than any existing  		// match.  But check anyway.  		if (score <= score_threshold) {  			// Told you so.  			score_threshold = score;  			best_loc = j - 1;  			if (best_loc > loc) {  				// When passing loc' don't exceed our current distance from loc.  				start = Math.Max (1' 2 * loc - best_loc);  			} else {  				// Already passed loc' downhill from here on in.  				break;  			}  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: if ((rd [j] & matchmask) != 0) {  	double score = match_bitapScore (d' j - 1' loc' pattern);  	// This match will almost certainly be better than any existing  	// match.  But check anyway.  	if (score <= score_threshold) {  		// Told you so.  		score_threshold = score;  		best_loc = j - 1;  		if (best_loc > loc) {  			// When passing loc' don't exceed our current distance from loc.  			start = Math.Max (1' 2 * loc - best_loc);  		} else {  			// Already passed loc' downhill from here on in.  			break;  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: if (score <= score_threshold) {  	// Told you so.  	score_threshold = score;  	best_loc = j - 1;  	if (best_loc > loc) {  		// When passing loc' don't exceed our current distance from loc.  		start = Math.Max (1' 2 * loc - best_loc);  	} else {  		// Already passed loc' downhill from here on in.  		break;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: if (best_loc > loc) {  	// When passing loc' don't exceed our current distance from loc.  	start = Math.Max (1' 2 * loc - best_loc);  } else {  	// Already passed loc' downhill from here on in.  	break;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: start = Math.Max (1' 2 * loc - best_loc);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: if (diffs.Count > 2) {  	diff_cleanupSemantic (diffs);  	diff_cleanupEfficiency (diffs);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs) {  	if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL) {  		// A new patch starts here.  		patch.start1 = char_count1;  		patch.start2 = char_count2;  	}  	switch (aDiff.operation) {  	case Operation.INSERT:  		patch.diffs.Add (aDiff);  		patch.length2 += aDiff.text.Length;  		postpatch_text = postpatch_text.Insert (char_count2' aDiff.text);  		break;  	case Operation.DELETE:  		patch.length1 += aDiff.text.Length;  		patch.diffs.Add (aDiff);  		postpatch_text = postpatch_text.Remove (char_count2' aDiff.text.Length);  		break;  	case Operation.EQUAL:  		if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count () != 0 && aDiff != diffs.Last ()) {  			// Small equality inside a patch.  			patch.diffs.Add (aDiff);  			patch.length1 += aDiff.text.Length;  			patch.length2 += aDiff.text.Length;  		}  		if (aDiff.text.Length >= 2 * Patch_Margin) {  			// Time for a new patch.  			if (patch.diffs.Count != 0) {  				patch_addContext (patch' prepatch_text);  				patches.Add (patch);  				patch = new Patch ();  				// Unlike Unidiff' our patch lists have a rolling context.  				// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff  				// Update prepatch text & pos to reflect the application of the  				// just completed patch.  				prepatch_text = postpatch_text;  				char_count1 = char_count2;  			}  		}  		break;  	}  	// Update the current character count.  	if (aDiff.operation != Operation.INSERT) {  		char_count1 += aDiff.text.Length;  	}  	if (aDiff.operation != Operation.DELETE) {  		char_count2 += aDiff.text.Length;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs) {  	if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL) {  		// A new patch starts here.  		patch.start1 = char_count1;  		patch.start2 = char_count2;  	}  	switch (aDiff.operation) {  	case Operation.INSERT:  		patch.diffs.Add (aDiff);  		patch.length2 += aDiff.text.Length;  		postpatch_text = postpatch_text.Insert (char_count2' aDiff.text);  		break;  	case Operation.DELETE:  		patch.length1 += aDiff.text.Length;  		patch.diffs.Add (aDiff);  		postpatch_text = postpatch_text.Remove (char_count2' aDiff.text.Length);  		break;  	case Operation.EQUAL:  		if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count () != 0 && aDiff != diffs.Last ()) {  			// Small equality inside a patch.  			patch.diffs.Add (aDiff);  			patch.length1 += aDiff.text.Length;  			patch.length2 += aDiff.text.Length;  		}  		if (aDiff.text.Length >= 2 * Patch_Margin) {  			// Time for a new patch.  			if (patch.diffs.Count != 0) {  				patch_addContext (patch' prepatch_text);  				patches.Add (patch);  				patch = new Patch ();  				// Unlike Unidiff' our patch lists have a rolling context.  				// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff  				// Update prepatch text & pos to reflect the application of the  				// just completed patch.  				prepatch_text = postpatch_text;  				char_count1 = char_count2;  			}  		}  		break;  	}  	// Update the current character count.  	if (aDiff.operation != Operation.INSERT) {  		char_count1 += aDiff.text.Length;  	}  	if (aDiff.operation != Operation.DELETE) {  		char_count2 += aDiff.text.Length;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: switch (aDiff.operation) {  case Operation.INSERT:  	patch.diffs.Add (aDiff);  	patch.length2 += aDiff.text.Length;  	postpatch_text = postpatch_text.Insert (char_count2' aDiff.text);  	break;  case Operation.DELETE:  	patch.length1 += aDiff.text.Length;  	patch.diffs.Add (aDiff);  	postpatch_text = postpatch_text.Remove (char_count2' aDiff.text.Length);  	break;  case Operation.EQUAL:  	if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count () != 0 && aDiff != diffs.Last ()) {  		// Small equality inside a patch.  		patch.diffs.Add (aDiff);  		patch.length1 += aDiff.text.Length;  		patch.length2 += aDiff.text.Length;  	}  	if (aDiff.text.Length >= 2 * Patch_Margin) {  		// Time for a new patch.  		if (patch.diffs.Count != 0) {  			patch_addContext (patch' prepatch_text);  			patches.Add (patch);  			patch = new Patch ();  			// Unlike Unidiff' our patch lists have a rolling context.  			// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff  			// Update prepatch text & pos to reflect the application of the  			// just completed patch.  			prepatch_text = postpatch_text;  			char_count1 = char_count2;  		}  	}  	break;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: switch (aDiff.operation) {  case Operation.INSERT:  	patch.diffs.Add (aDiff);  	patch.length2 += aDiff.text.Length;  	postpatch_text = postpatch_text.Insert (char_count2' aDiff.text);  	break;  case Operation.DELETE:  	patch.length1 += aDiff.text.Length;  	patch.diffs.Add (aDiff);  	postpatch_text = postpatch_text.Remove (char_count2' aDiff.text.Length);  	break;  case Operation.EQUAL:  	if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count () != 0 && aDiff != diffs.Last ()) {  		// Small equality inside a patch.  		patch.diffs.Add (aDiff);  		patch.length1 += aDiff.text.Length;  		patch.length2 += aDiff.text.Length;  	}  	if (aDiff.text.Length >= 2 * Patch_Margin) {  		// Time for a new patch.  		if (patch.diffs.Count != 0) {  			patch_addContext (patch' prepatch_text);  			patches.Add (patch);  			patch = new Patch ();  			// Unlike Unidiff' our patch lists have a rolling context.  			// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff  			// Update prepatch text & pos to reflect the application of the  			// just completed patch.  			prepatch_text = postpatch_text;  			char_count1 = char_count2;  		}  	}  	break;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count () != 0 && aDiff != diffs.Last ()) {  	// Small equality inside a patch.  	patch.diffs.Add (aDiff);  	patch.length1 += aDiff.text.Length;  	patch.length2 += aDiff.text.Length;  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: if (aDiff.text.Length >= 2 * Patch_Margin) {  	// Time for a new patch.  	if (patch.diffs.Count != 0) {  		patch_addContext (patch' prepatch_text);  		patches.Add (patch);  		patch = new Patch ();  		// Unlike Unidiff' our patch lists have a rolling context.  		// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff  		// Update prepatch text & pos to reflect the application of the  		// just completed patch.  		prepatch_text = postpatch_text;  		char_count1 = char_count2;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_apply,The following statement contains a magic number: text = text.Substring (nullPadding.Length' text.Length - 2 * nullPadding.Length);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: for (int x = 0; x < patches.Count; x++) {  	if (patches [x].length1 <= patch_size) {  		continue;  	}  	Patch bigpatch = patches [x];  	// Remove the big old patch.  	patches.Splice (x--' 1);  	int start1 = bigpatch.start1;  	int start2 = bigpatch.start2;  	string precontext = string.Empty;  	while (bigpatch.diffs.Count != 0) {  		// Create one of several smaller patches.  		Patch patch = new Patch ();  		bool empty = true;  		patch.start1 = start1 - precontext.Length;  		patch.start2 = start2 - precontext.Length;  		if (precontext.Length != 0) {  			patch.length1 = patch.length2 = precontext.Length;  			patch.diffs.Add (new Diff (Operation.EQUAL' precontext));  		}  		while (bigpatch.diffs.Count != 0 && patch.length1 < patch_size - this.Patch_Margin) {  			Operation diff_type = bigpatch.diffs [0].operation;  			string diff_text = bigpatch.diffs [0].text;  			if (diff_type == Operation.INSERT) {  				// Insertions are harmless.  				patch.length2 += diff_text.Length;  				start2 += diff_text.Length;  				patch.diffs.Add (bigpatch.diffs.First ());  				bigpatch.diffs.RemoveAt (0);  				empty = false;  			} else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) {  				// This is a large deletion.  Let it pass in one chunk.  				patch.length1 += diff_text.Length;  				start1 += diff_text.Length;  				empty = false;  				patch.diffs.Add (new Diff (diff_type' diff_text));  				bigpatch.diffs.RemoveAt (0);  			} else {  				// Deletion or equality.  Only take as much as we can stomach.  				diff_text = diff_text.Substring (0' Math.Min (diff_text.Length' patch_size - patch.length1 - Patch_Margin));  				patch.length1 += diff_text.Length;  				start1 += diff_text.Length;  				if (diff_type == Operation.EQUAL) {  					patch.length2 += diff_text.Length;  					start2 += diff_text.Length;  				} else {  					empty = false;  				}  				patch.diffs.Add (new Diff (diff_type' diff_text));  				if (diff_text == bigpatch.diffs [0].text) {  					bigpatch.diffs.RemoveAt (0);  				} else {  					bigpatch.diffs [0].text = bigpatch.diffs [0].text.Substring (diff_text.Length);  				}  			}  		}  		// Compute the head context for the next patch.  		precontext = this.diff_text2 (patch.diffs);  		precontext = precontext.Substring (Math.Max (0' precontext.Length - this.Patch_Margin));  		string postcontext = null;  		// Append the end context for this patch.  		if (diff_text1 (bigpatch.diffs).Length > Patch_Margin) {  			postcontext = diff_text1 (bigpatch.diffs).Substring (0' Patch_Margin);  		} else {  			postcontext = diff_text1 (bigpatch.diffs);  		}  		if (postcontext.Length != 0) {  			patch.length1 += postcontext.Length;  			patch.length2 += postcontext.Length;  			if (patch.diffs.Count != 0 && patch.diffs [patch.diffs.Count - 1].operation == Operation.EQUAL) {  				patch.diffs [patch.diffs.Count - 1].text += postcontext;  			} else {  				patch.diffs.Add (new Diff (Operation.EQUAL' postcontext));  			}  		}  		if (!empty) {  			patches.Splice (++x' 0' patch);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: while (bigpatch.diffs.Count != 0) {  	// Create one of several smaller patches.  	Patch patch = new Patch ();  	bool empty = true;  	patch.start1 = start1 - precontext.Length;  	patch.start2 = start2 - precontext.Length;  	if (precontext.Length != 0) {  		patch.length1 = patch.length2 = precontext.Length;  		patch.diffs.Add (new Diff (Operation.EQUAL' precontext));  	}  	while (bigpatch.diffs.Count != 0 && patch.length1 < patch_size - this.Patch_Margin) {  		Operation diff_type = bigpatch.diffs [0].operation;  		string diff_text = bigpatch.diffs [0].text;  		if (diff_type == Operation.INSERT) {  			// Insertions are harmless.  			patch.length2 += diff_text.Length;  			start2 += diff_text.Length;  			patch.diffs.Add (bigpatch.diffs.First ());  			bigpatch.diffs.RemoveAt (0);  			empty = false;  		} else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) {  			// This is a large deletion.  Let it pass in one chunk.  			patch.length1 += diff_text.Length;  			start1 += diff_text.Length;  			empty = false;  			patch.diffs.Add (new Diff (diff_type' diff_text));  			bigpatch.diffs.RemoveAt (0);  		} else {  			// Deletion or equality.  Only take as much as we can stomach.  			diff_text = diff_text.Substring (0' Math.Min (diff_text.Length' patch_size - patch.length1 - Patch_Margin));  			patch.length1 += diff_text.Length;  			start1 += diff_text.Length;  			if (diff_type == Operation.EQUAL) {  				patch.length2 += diff_text.Length;  				start2 += diff_text.Length;  			} else {  				empty = false;  			}  			patch.diffs.Add (new Diff (diff_type' diff_text));  			if (diff_text == bigpatch.diffs [0].text) {  				bigpatch.diffs.RemoveAt (0);  			} else {  				bigpatch.diffs [0].text = bigpatch.diffs [0].text.Substring (diff_text.Length);  			}  		}  	}  	// Compute the head context for the next patch.  	precontext = this.diff_text2 (patch.diffs);  	precontext = precontext.Substring (Math.Max (0' precontext.Length - this.Patch_Margin));  	string postcontext = null;  	// Append the end context for this patch.  	if (diff_text1 (bigpatch.diffs).Length > Patch_Margin) {  		postcontext = diff_text1 (bigpatch.diffs).Substring (0' Patch_Margin);  	} else {  		postcontext = diff_text1 (bigpatch.diffs);  	}  	if (postcontext.Length != 0) {  		patch.length1 += postcontext.Length;  		patch.length2 += postcontext.Length;  		if (patch.diffs.Count != 0 && patch.diffs [patch.diffs.Count - 1].operation == Operation.EQUAL) {  			patch.diffs [patch.diffs.Count - 1].text += postcontext;  		} else {  			patch.diffs.Add (new Diff (Operation.EQUAL' postcontext));  		}  	}  	if (!empty) {  		patches.Splice (++x' 0' patch);  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: while (bigpatch.diffs.Count != 0 && patch.length1 < patch_size - this.Patch_Margin) {  	Operation diff_type = bigpatch.diffs [0].operation;  	string diff_text = bigpatch.diffs [0].text;  	if (diff_type == Operation.INSERT) {  		// Insertions are harmless.  		patch.length2 += diff_text.Length;  		start2 += diff_text.Length;  		patch.diffs.Add (bigpatch.diffs.First ());  		bigpatch.diffs.RemoveAt (0);  		empty = false;  	} else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) {  		// This is a large deletion.  Let it pass in one chunk.  		patch.length1 += diff_text.Length;  		start1 += diff_text.Length;  		empty = false;  		patch.diffs.Add (new Diff (diff_type' diff_text));  		bigpatch.diffs.RemoveAt (0);  	} else {  		// Deletion or equality.  Only take as much as we can stomach.  		diff_text = diff_text.Substring (0' Math.Min (diff_text.Length' patch_size - patch.length1 - Patch_Margin));  		patch.length1 += diff_text.Length;  		start1 += diff_text.Length;  		if (diff_type == Operation.EQUAL) {  			patch.length2 += diff_text.Length;  			start2 += diff_text.Length;  		} else {  			empty = false;  		}  		patch.diffs.Add (new Diff (diff_type' diff_text));  		if (diff_text == bigpatch.diffs [0].text) {  			bigpatch.diffs.RemoveAt (0);  		} else {  			bigpatch.diffs [0].text = bigpatch.diffs [0].text.Substring (diff_text.Length);  		}  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: if (diff_type == Operation.INSERT) {  	// Insertions are harmless.  	patch.length2 += diff_text.Length;  	start2 += diff_text.Length;  	patch.diffs.Add (bigpatch.diffs.First ());  	bigpatch.diffs.RemoveAt (0);  	empty = false;  } else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) {  	// This is a large deletion.  Let it pass in one chunk.  	patch.length1 += diff_text.Length;  	start1 += diff_text.Length;  	empty = false;  	patch.diffs.Add (new Diff (diff_type' diff_text));  	bigpatch.diffs.RemoveAt (0);  } else {  	// Deletion or equality.  Only take as much as we can stomach.  	diff_text = diff_text.Substring (0' Math.Min (diff_text.Length' patch_size - patch.length1 - Patch_Margin));  	patch.length1 += diff_text.Length;  	start1 += diff_text.Length;  	if (diff_type == Operation.EQUAL) {  		patch.length2 += diff_text.Length;  		start2 += diff_text.Length;  	} else {  		empty = false;  	}  	patch.diffs.Add (new Diff (diff_type' diff_text));  	if (diff_text == bigpatch.diffs [0].text) {  		bigpatch.diffs.RemoveAt (0);  	} else {  		bigpatch.diffs [0].text = bigpatch.diffs [0].text.Substring (diff_text.Length);  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First ().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) {  	// This is a large deletion.  Let it pass in one chunk.  	patch.length1 += diff_text.Length;  	start1 += diff_text.Length;  	empty = false;  	patch.diffs.Add (new Diff (diff_type' diff_text));  	bigpatch.diffs.RemoveAt (0);  } else {  	// Deletion or equality.  Only take as much as we can stomach.  	diff_text = diff_text.Substring (0' Math.Min (diff_text.Length' patch_size - patch.length1 - Patch_Margin));  	patch.length1 += diff_text.Length;  	start1 += diff_text.Length;  	if (diff_type == Operation.EQUAL) {  		patch.length2 += diff_text.Length;  		start2 += diff_text.Length;  	} else {  		empty = false;  	}  	patch.diffs.Add (new Diff (diff_type' diff_text));  	if (diff_text == bigpatch.diffs [0].text) {  		bigpatch.diffs.RemoveAt (0);  	} else {  		bigpatch.diffs [0].text = bigpatch.diffs [0].text.Substring (diff_text.Length);  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {  	m = patchHeader.Match (text [textPointer]);  	if (!m.Success) {  		throw new ArgumentException ("Invalid patch string: " + text [textPointer]);  	}  	patch = new Patch ();  	patches.Add (patch);  	patch.start1 = Convert.ToInt32 (m.Groups [1].Value);  	if (m.Groups [2].Length == 0) {  		patch.start1--;  		patch.length1 = 1;  	} else if (m.Groups [2].Value == "0") {  		patch.length1 = 0;  	} else {  		patch.start1--;  		patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  	}  	patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  	if (m.Groups [4].Length == 0) {  		patch.start2--;  		patch.length2 = 1;  	} else if (m.Groups [4].Value == "0") {  		patch.length2 = 0;  	} else {  		patch.start2--;  		patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  	}  	textPointer++;  	while (textPointer < text.Length) {  		try {  			sign = text [textPointer] [0];  		} catch (IndexOutOfRangeException) {  			// Blank line?  Whatever.  			textPointer++;  			continue;  		}  		line = text [textPointer].Substring (1);  		line = line.Replace ("+"' "%2b");  		line = HttpUtility.UrlDecode (line' new UTF8Encoding (false' true));  		if (sign == '-') {  			// Deletion.  			patch.diffs.Add (new Diff (Operation.DELETE' line));  		} else if (sign == '+') {  			// Insertion.  			patch.diffs.Add (new Diff (Operation.INSERT' line));  		} else if (sign == ' ') {  			// Minor equality.  			patch.diffs.Add (new Diff (Operation.EQUAL' line));  		} else if (sign == '@') {  			// Start of next patch.  			break;  		} else {  			// WTF?  			throw new ArgumentException ("Invalid patch mode '" + sign + "' in: " + line);  		}  		textPointer++;  	}  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [2].Length == 0) {  	patch.start1--;  	patch.length1 = 1;  } else if (m.Groups [2].Value == "0") {  	patch.length1 = 0;  } else {  	patch.start1--;  	patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [2].Length == 0) {  	patch.start1--;  	patch.length1 = 1;  } else if (m.Groups [2].Value == "0") {  	patch.length1 = 0;  } else {  	patch.start1--;  	patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [2].Length == 0) {  	patch.start1--;  	patch.length1 = 1;  } else if (m.Groups [2].Value == "0") {  	patch.length1 = 0;  } else {  	patch.start1--;  	patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [2].Value == "0") {  	patch.length1 = 0;  } else {  	patch.start1--;  	patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [2].Value == "0") {  	patch.length1 = 0;  } else {  	patch.start1--;  	patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: patch.length1 = Convert.ToInt32 (m.Groups [2].Value);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: patch.start2 = Convert.ToInt32 (m.Groups [3].Value);  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [4].Length == 0) {  	patch.start2--;  	patch.length2 = 1;  } else if (m.Groups [4].Value == "0") {  	patch.length2 = 0;  } else {  	patch.start2--;  	patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [4].Length == 0) {  	patch.start2--;  	patch.length2 = 1;  } else if (m.Groups [4].Value == "0") {  	patch.length2 = 0;  } else {  	patch.start2--;  	patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [4].Length == 0) {  	patch.start2--;  	patch.length2 = 1;  } else if (m.Groups [4].Value == "0") {  	patch.length2 = 0;  } else {  	patch.start2--;  	patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [4].Value == "0") {  	patch.length2 = 0;  } else {  	patch.start2--;  	patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: if (m.Groups [4].Value == "0") {  	patch.length2 = 0;  } else {  	patch.start2--;  	patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  }  
Magic Number,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: patch.length2 = Convert.ToInt32 (m.Groups [4].Value);  
Missing Default,DiffMatchPatch,Patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,ToString,The following switch statement is missing a default case: switch (aDiff.operation) {  case Operation.INSERT:  	text.Append ('+');  	break;  case Operation.DELETE:  	text.Append ('-');  	break;  case Operation.EQUAL:  	text.Append (' ');  	break;  }  
Missing Default,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_lineMode,The following switch statement is missing a default case: switch (diffs [pointer].operation) {  case Operation.INSERT:  	count_insert++;  	text_insert += diffs [pointer].text;  	break;  case Operation.DELETE:  	count_delete++;  	text_delete += diffs [pointer].text;  	break;  case Operation.EQUAL:  	// Upon reaching an equality' check for prior redundancies.  	if (count_delete >= 1 && count_insert >= 1) {  		// Delete the offending records and add the merged ones.  		diffs.RemoveRange (pointer - count_delete - count_insert' count_delete + count_insert);  		pointer = pointer - count_delete - count_insert;  		List<Diff> a = this.diff_main (text_delete' text_insert' false' deadline);  		diffs.InsertRange (pointer' a);  		pointer = pointer + a.Count;  	}  	count_insert = 0;  	count_delete = 0;  	text_delete = string.Empty;  	text_insert = string.Empty;  	break;  }  
Missing Default,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The following switch statement is missing a default case: switch (diffs [pointer].operation) {  case Operation.INSERT:  	count_insert++;  	text_insert += diffs [pointer].text;  	pointer++;  	break;  case Operation.DELETE:  	count_delete++;  	text_delete += diffs [pointer].text;  	pointer++;  	break;  case Operation.EQUAL:  	// Upon reaching an equality' check for prior redundancies.  	if (count_delete + count_insert > 1) {  		if (count_delete != 0 && count_insert != 0) {  			// Factor out any common prefixies.  			commonlength = this.diff_commonPrefix (text_insert' text_delete);  			if (commonlength != 0) {  				if ((pointer - count_delete - count_insert) > 0 && diffs [pointer - count_delete - count_insert - 1].operation == Operation.EQUAL) {  					diffs [pointer - count_delete - count_insert - 1].text += text_insert.Substring (0' commonlength);  				} else {  					diffs.Insert (0' new Diff (Operation.EQUAL' text_insert.Substring (0' commonlength)));  					pointer++;  				}  				text_insert = text_insert.Substring (commonlength);  				text_delete = text_delete.Substring (commonlength);  			}  			// Factor out any common suffixies.  			commonlength = this.diff_commonSuffix (text_insert' text_delete);  			if (commonlength != 0) {  				diffs [pointer].text = text_insert.Substring (text_insert.Length - commonlength) + diffs [pointer].text;  				text_insert = text_insert.Substring (0' text_insert.Length - commonlength);  				text_delete = text_delete.Substring (0' text_delete.Length - commonlength);  			}  		}  		// Delete the offending records and add the merged ones.  		if (count_delete == 0) {  			diffs.Splice (pointer - count_insert' count_delete + count_insert' new Diff (Operation.INSERT' text_insert));  		} else if (count_insert == 0) {  			diffs.Splice (pointer - count_delete' count_delete + count_insert' new Diff (Operation.DELETE' text_delete));  		} else {  			diffs.Splice (pointer - count_delete - count_insert' count_delete + count_insert' new Diff (Operation.DELETE' text_delete)' new Diff (Operation.INSERT' text_insert));  		}  		pointer = pointer - count_delete - count_insert + (count_delete != 0 ? 1 : 0) + (count_insert != 0 ? 1 : 0) + 1;  	} else if (pointer != 0 && diffs [pointer - 1].operation == Operation.EQUAL) {  		// Merge this equality with the previous one.  		diffs [pointer - 1].text += diffs [pointer].text;  		diffs.RemoveAt (pointer);  	} else {  		pointer++;  	}  	count_insert = 0;  	count_delete = 0;  	text_delete = string.Empty;  	text_insert = string.Empty;  	break;  }  
Missing Default,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_prettyHtml,The following switch statement is missing a default case: switch (aDiff.operation) {  case Operation.INSERT:  	html.Append ("<ins style=\"background:#e6ffe6;\">").Append (text).Append ("</ins>");  	break;  case Operation.DELETE:  	html.Append ("<del style=\"background:#ffe6e6;\">").Append (text).Append ("</del>");  	break;  case Operation.EQUAL:  	html.Append ("<span>").Append (text).Append ("</span>");  	break;  }  
Missing Default,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_levenshtein,The following switch statement is missing a default case: switch (aDiff.operation) {  case Operation.INSERT:  	insertions += aDiff.text.Length;  	break;  case Operation.DELETE:  	deletions += aDiff.text.Length;  	break;  case Operation.EQUAL:  	// A deletion and an insertion is one substitution.  	levenshtein += Math.Max (insertions' deletions);  	insertions = 0;  	deletions = 0;  	break;  }  
Missing Default,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_toDelta,The following switch statement is missing a default case: switch (aDiff.operation) {  case Operation.INSERT:  	text.Append ("+").Append (HttpUtility.UrlEncode (aDiff.text' new UTF8Encoding ()).Replace ('+'' ' ')).Append ("\t");  	break;  case Operation.DELETE:  	text.Append ("-").Append (aDiff.text.Length).Append ("\t");  	break;  case Operation.EQUAL:  	text.Append ("=").Append (aDiff.text.Length).Append ("\t");  	break;  }  
Missing Default,DiffMatchPatch,diff_match_patch,F:\newReposMay17\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following switch statement is missing a default case: switch (aDiff.operation) {  case Operation.INSERT:  	patch.diffs.Add (aDiff);  	patch.length2 += aDiff.text.Length;  	postpatch_text = postpatch_text.Insert (char_count2' aDiff.text);  	break;  case Operation.DELETE:  	patch.length1 += aDiff.text.Length;  	patch.diffs.Add (aDiff);  	postpatch_text = postpatch_text.Remove (char_count2' aDiff.text.Length);  	break;  case Operation.EQUAL:  	if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count () != 0 && aDiff != diffs.Last ()) {  		// Small equality inside a patch.  		patch.diffs.Add (aDiff);  		patch.length1 += aDiff.text.Length;  		patch.length2 += aDiff.text.Length;  	}  	if (aDiff.text.Length >= 2 * Patch_Margin) {  		// Time for a new patch.  		if (patch.diffs.Count != 0) {  			patch_addContext (patch' prepatch_text);  			patches.Add (patch);  			patch = new Patch ();  			// Unlike Unidiff' our patch lists have a rolling context.  			// http://code.google.com/p/google-diff-match-patch/wiki/Unidiff  			// Update prepatch text & pos to reflect the application of the  			// just completed patch.  			prepatch_text = postpatch_text;  			char_count1 = char_count2;  		}  	}  	break;  }  
