Implementation smell,Namespace,Class,File,Method,Description
Long Method,automark.Git,UnifiedDiffToMyersDifference,C:\repos\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,DifferenceFromHunk,The method has 143 lines of code.
Long Method,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The method has 165 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The method has 109 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The method has 105 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The method has 125 lines of code.
Complex Method,automark.Generate.Export,AsMarkdown,C:\repos\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,Cyclomatic complexity of the method is 17
Complex Method,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,Main,Cyclomatic complexity of the method is 20
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,Cyclomatic complexity of the method is 12
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticLossless,Cyclomatic complexity of the method is 9
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,Cyclomatic complexity of the method is 13
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,Cyclomatic complexity of the method is 11
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,Cyclomatic complexity of the method is 8
Long Parameter List,automark.Git,UnifiedDiffToMyersDifference,C:\repos\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,EmitNew,The method has 7 parameters. Parameters: leftStart' leftEnd' rightStart' rightEnd' rightDiffStart' rightDiffEnd' hunk
Long Parameter List,automark.Git,UnifiedDiffToMyersDifference,C:\repos\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,EmitChange,The method has 9 parameters. Parameters: leftStart' leftEnd' rightStart' rightEnd' leftDiffStart' leftDiffEnd' rightDiffStart' rightDiffEnd' hunk
Long Parameter List,automark.Git,UnifiedDiffToMyersDifference,C:\repos\chrisparnin_automark\Source\automark\automark\Git\UnifiedDiffToMyersDifference.cs,EmitRemove,The method has 5 parameters. Parameters: leftStart' leftEnd' rightStart' rightEnd' hunk
Long Parameter List,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisectSplit,The method has 5 parameters. Parameters: text1' text2' x' y' deadline
Long Statement,automark.Connections.Browser,FirefoxConnector,C:\repos\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,FindDbPath,The length of the statement  "                string ffPath = System.IO.Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' @"Mozilla\Firefox\Profiles\"); " is 139.
Long Statement,automark.Generate.Export,AsMarkdown,C:\repos\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "                w.WriteLine("Please make sure that *autogit* is properly saving changes in your solution directory in the hidden folder `.HistoryData/LocalHistory`"); " is 150.
Long Statement,automark.Generate.Export,AsMarkdown,C:\repos\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "                    w.WriteLine(string.Format("<div class='section'>{0}<div></div><div class='summary'></div></div>"' EmitTime(commit.CommitTimeStamp))); " is 133.
Long Statement,automark.Generate.Export,AsMarkdown,C:\repos\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The length of the statement  "                                    w.WriteLine(string.Join("'"' innerDiffs.Where(d => d.operation != DiffMatchPatch.Operation.EQUAL).Select(d => d.text))); " is 120.
Long Statement,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,CodeWebHistory,The length of the statement  "            string dbPath = System.IO.Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)' @"Google\Chrome\User Data\Default\History"); " is 158.
Long Statement,automark.Util,GitCommands,C:\repos\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ListSha,The length of the statement  "            var output = RunProcess(string.Format(" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" log --name-only"' path.Replace("\\"' "/")' path.Replace("\\"' "/"))); " is 152.
Long Statement,automark.Util,GitCommands,C:\repos\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ListShaWithFiles,The length of the statement  "            var output = RunProcess(string.Format(" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" log --name-status"' path.Replace("\\"' "/")' path.Replace("\\"' "/"))); " is 154.
Long Statement,automark.Util,GitCommands,C:\repos\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowDiffRange,The length of the statement  "            var output = RunProcess(string.Format(" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" diff {2} {3} --ignore-all-space"' path.Replace("\\"' "/")' path.Replace("\\"' "/")' shaBefore' shaAfter)); " is 189.
Long Statement,automark.Util,GitCommands,C:\repos\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowSha,The length of the statement  "            var output = RunProcess(string.Format(" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" show {2} --ignore-all-space"' path.Replace("\\"' "/")' path.Replace("\\"' "/")' sha)); " is 169.
Long Statement,automark.Util,GitCommands,C:\repos\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowFileAfterCommit,The length of the statement  "            var output = RunProcess(string.Format(" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" show {2}:\"{3}\""' path.Replace("\\"' "/")' path.Replace("\\"' "/")' sha' file)); " is 164.
Long Statement,automark.Util,GitCommands,C:\repos\chrisparnin_automark\Source\automark\automark\Util\GitCommands.cs,ShowFileBeforeCommit,The length of the statement  "            var output = RunProcess(string.Format(" --git-dir=\"{0}/.git\" --work-tree=\"{1}\" show {2}~1:\"{3}\""' path.Replace("\\"' "/")' path.Replace("\\"' "/")' sha' file)); " is 166.
Complex Conditional,automark.Generate.Export,AsMarkdown,C:\repos\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The conditional expression  "isFirstCommit || (span != TimeSpan.MaxValue && span.TotalHours > 2) || !IsCommitOnSameDay(commit' previousCommit)"  is complex.
Complex Conditional,automark.Git,ParseGitLog,C:\repos\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The conditional expression  "line.Length > 0 && line[0] == '\t' ||                          (line.Length > 4 && line.Substring(0'4).All( ch => ch == ' ') )"  is complex.
Complex Conditional,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The conditional expression  "accumalatedDifference.TotalMinutes <= 3 &&                           prevCommit.Files.All(f => commit.Files.Select(c => c.File).Contains(f.File)) &&                           prevCommit.Files.Any( f => f.Status != "A" || f.Status != "D" )"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The conditional expression  "(lastequality.Length != 0)                && ((pre_ins && pre_del && post_ins && post_del)                || ((lastequality.Length < this.Diff_EditCost / 2)                && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                + (post_del ? 1 : 0)) == 3))"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The conditional expression  "diff_type == Operation.DELETE && patch.diffs.Count == 1                  && patch.diffs.First().operation == Operation.EQUAL                  && diff_text.Length > 2 * patch_size"  is complex.
Magic Number,automark.Connections.Browser,ChromeHistory,C:\repos\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var connection = new System.Data.SQLite.SQLiteConnection("Data Source=" + dbPath + ";Version=3;Read Only=True"))              {                  connection.Open();                                    var command =                      @"SELECT urls.url' visits.visit_time' urls.title                    FROM visits' urls                    WHERE visits.url = urls.id AND urls.url LIKE '%stackoverflow%'                  ";                    using (var c = connection.CreateCommand())                  {                      c.CommandText = command;                      var reader = c.ExecuteReader();                      var urls = new HashSet<string>();                      while (reader.Read())                      {                          var url = reader.GetString(0);                          var timeEpoch = reader.GetInt64(1) / 1000;                          var visitTime = FromGoogleTime(timeEpoch);                          var title = reader.GetString(2);                          if (!urls.Contains(url))                          {                              list.Add(new WebVisit() { Url = url' Timestamp = visitTime' Title = title });                          }                          urls.Add(url);                      }                  }                  connection.Close();              }
Magic Number,automark.Connections.Browser,ChromeHistory,C:\repos\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var connection = new System.Data.SQLite.SQLiteConnection("Data Source=" + dbPath + ";Version=3;Read Only=True"))              {                  connection.Open();                                    var command =                      @"SELECT urls.url' visits.visit_time' urls.title                    FROM visits' urls                    WHERE visits.url = urls.id AND urls.url LIKE '%stackoverflow%'                  ";                    using (var c = connection.CreateCommand())                  {                      c.CommandText = command;                      var reader = c.ExecuteReader();                      var urls = new HashSet<string>();                      while (reader.Read())                      {                          var url = reader.GetString(0);                          var timeEpoch = reader.GetInt64(1) / 1000;                          var visitTime = FromGoogleTime(timeEpoch);                          var title = reader.GetString(2);                          if (!urls.Contains(url))                          {                              list.Add(new WebVisit() { Url = url' Timestamp = visitTime' Title = title });                          }                          urls.Add(url);                      }                  }                  connection.Close();              }
Magic Number,automark.Connections.Browser,ChromeHistory,C:\repos\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,FromUnixTime,The following statement contains a magic number: var epoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,automark.Connections.Browser,ChromeHistory,C:\repos\chrisparnin_automark\Source\automark\automark\Connections\Browser\ChromeConnector.cs,FromGoogleTime,The following statement contains a magic number: var epoch = new DateTime(1601' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,automark.Connections.Browser,FirefoxConnector,C:\repos\chrisparnin_automark\Source\automark\automark\Connections\Browser\FirefoxConnector.cs,RecentStackoverflow,The following statement contains a magic number: using (var connection = new System.Data.SQLite.SQLiteConnection("Data Source=" + dbPath + ";Version=3;Read Only=True"))              {                  connection.Open();                    var command =        @"SELECT moz_places.url' datetime(moz_historyvisits.visit_date/1000000''unixepoch') as visit_time' moz_places.title  	FROM moz_places' moz_historyvisits   	WHERE moz_places.id = moz_historyvisits.place_id AND moz_places.url LIKE '%stackoverflow%'                  ";                    using (var c = connection.CreateCommand())                  {                      c.CommandText = command;                      var reader = c.ExecuteReader();                      var urls = new HashSet<string>();                      while (reader.Read())                      {                          var url = reader.GetString(0);                          var visitTime = reader.GetDateTime(1);                          //var visitTime = FromGoogleTime(timeEpoch);                          var title = reader.GetString(2);                          if (!urls.Contains(url))                          {                              list.Add(new WebVisit() { Url = url' Timestamp = visitTime' Title = title });                          }                          urls.Add(url);                      }                  }                  connection.Close();              }
Magic Number,automark.Generate.Export,AsMarkdown,C:\repos\chrisparnin_automark\Source\automark\automark\Generate\Export\AsMarkdown.cs,Export,The following statement contains a magic number: foreach (var commit in commits)              {                  var span = TimeSinceLastCommit(commit' previousCommit);                    if (span != TimeSpan.MaxValue && !IsCommitOnSameDay(commit' previousCommit))                  {                      w.WriteLine(EmitDate(commit.CommitTimeStamp));                  }                    if (isFirstCommit || (span != TimeSpan.MaxValue && span.TotalHours > 2) || !IsCommitOnSameDay(commit' previousCommit))                  {                      w.WriteLine("");                      w.WriteLine(string.Format("<div class='section'>{0}<div></div><div class='summary'></div></div>"' EmitTime(commit.CommitTimeStamp)));                      isFirstCommit = false;                  }                  // Sunday' October 6 2013                  // 10:44 AM                  //if (span != TimeSpan.MaxValue && span.TotalHours > 2)                  //{                  //    w.WriteLine("<div class='divider'></div>");                  //    w.WriteLine(EmitTime(commit.CommitTimeStamp));                                      //}                    if( commit.Visits.Any() )                  {                      //w.WriteLine("#### Visited ");                      w.WriteLine("   ");                      foreach (var visit in commit.Visits)                      {                          w.WriteLine("* [{0}]({1})"'                              string.IsNullOrEmpty(visit.Title) ? visit.Url : visit.Title'                              visit.Url);                      }                      w.WriteLine("   ");                      if (commit.Visits.Count == 1)                      {                          w.WriteLine("<div></div>");                      }                  }                    foreach (var fileDiff in commit.Difflets)                  {                      //w.WriteLine("> {0} to {1}"' file.Status' file.File);                      w.WriteLine("#### {0}"' fileDiff.FileName);                      w.WriteLine();                      foreach (var hunk in fileDiff.Hunks)                      {                          foreach (var line in hunk.DiffLines)                          {                              // http://stackoverflow.com/questions/8301207/microsoft-ides-source-file-encodings-boms-and-the-unicode-character-ufeff                              // default filter: skip context of adding using.                              if (line.Trim().StartsWith("using ") )                                  continue;                                w.WriteLine("    {0}"' line.TrimEnd() );                          }                     }                      // test space                      if (debug)                       {                          w.WriteLine("##### Myers Version");                          var diffs = fileDiff.MyerDiffs;                          foreach (var diff in diffs)                          {                              w.WriteLine("Type {0} Left {1}:{2} Right {3}:{4}"' diff.DifferenceType'                                  diff.Left.Start' diff.Left.End' diff.Right.Start' diff.Right.End);                                if (diff.DifferenceType == Models.Diff.DifferenceType.Change &&                                  diff.Left.Length == diff.Right.Length)                              {                                  w.WriteLine();                                  for (var i = 0; i < diff.Left.Length; i++)                                  {                                      var left = diff.Left.TextLines[i];                                      var right = diff.Right.TextLines[i];                                        var innerDiffs = diffEngine.diff_main(left' right' false);                                      diffEngine.Diff_Timeout = 0;                                      diffEngine.diff_cleanupSemantic(innerDiffs);                                        w.WriteLine(string.Join("'"' innerDiffs.Where(d => d.operation != DiffMatchPatch.Operation.EQUAL).Select(d => d.text)));                                  }                              }                          }                      }                  }                    previousCommit = commit;                }
Magic Number,automark.Git,GitDiffParser,C:\repos\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: var fileA = fileInfo.FirstOrDefault().Remove(0' 4);
Magic Number,automark.Git,GitDiffParser,C:\repos\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: var fileB = fileInfo.Skip(1).FirstOrDefault().Remove(0' 4);
Magic Number,automark.Git,GitDiffParser,C:\repos\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: if (fileA.StartsWith("a/"))                  return fileA.Remove(0' 2).Trim();
Magic Number,automark.Git,GitDiffParser,C:\repos\chrisparnin_automark\Source\automark\automark\Git\GitDiffParser.cs,GetFileName,The following statement contains a magic number: if (fileB.StartsWith("b/"))                  return fileB.Remove(0' 2).Trim();
Magic Number,automark.Git,ParseGitLog,C:\repos\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: using (var strReader = new StringReader(output))              {                  do                  {                      var line = strReader.ReadLine();                      if (line == null)                          break;                        if( line.StartsWith("commit ") )                      {                          if (commit != null)                              commits.Add(commit);                          commit = new GitCommit();                          commit.Sha = line.Split(' ')[1];                      }                        if ( StartsWithHeader(line) )                      {                          var header = line.Split(':')[0];                          var val = string.Join(":"'line.Split(':').Skip(1)).Trim();                            // headers                          commit.Headers.Add(header' val);                      }                        if (string.IsNullOrEmpty(line) )                      {                          // commit message divider                          processingMessage = !processingMessage;                      }                        if (line.Length > 0 && line[0] == '\t' ||                          (line.Length > 4 && line.Substring(0'4).All( ch => ch == ' ') ) )                      {                           // commit message.                          commit.Message += line;                      }                        if (line.Length > 1 && Char.IsLetter(line[0]) && line[1] == '\t')                      {                          var status = line.Split('\t')[0];                          var file = line.Split('\t')[1];                          commit.Files.Add(new GitFileStatus() { Status = status' File = file } );                      }                  }                  while (strReader.Peek() != -1);              }
Magic Number,automark.Git,ParseGitLog,C:\repos\chrisparnin_automark\Source\automark\automark\Git\ParseGitLog.cs,Parse,The following statement contains a magic number: using (var strReader = new StringReader(output))              {                  do                  {                      var line = strReader.ReadLine();                      if (line == null)                          break;                        if( line.StartsWith("commit ") )                      {                          if (commit != null)                              commits.Add(commit);                          commit = new GitCommit();                          commit.Sha = line.Split(' ')[1];                      }                        if ( StartsWithHeader(line) )                      {                          var header = line.Split(':')[0];                          var val = string.Join(":"'line.Split(':').Skip(1)).Trim();                            // headers                          commit.Headers.Add(header' val);                      }                        if (string.IsNullOrEmpty(line) )                      {                          // commit message divider                          processingMessage = !processingMessage;                      }                        if (line.Length > 0 && line[0] == '\t' ||                          (line.Length > 4 && line.Substring(0'4).All( ch => ch == ' ') ) )                      {                           // commit message.                          commit.Message += line;                      }                        if (line.Length > 1 && Char.IsLetter(line[0]) && line[1] == '\t')                      {                          var status = line.Split('\t')[0];                          var file = line.Split('\t')[1];                          commit.Files.Add(new GitFileStatus() { Status = status' File = file } );                      }                  }                  while (strReader.Peek() != -1);              }
Magic Number,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: foreach (var commit in commits)              {                  commit.UnifiedDiff = GitCommands.ShowSha(path' commit.Sha);                    // skip big files for arbiturary definition of big.                  if (commit.UnifiedDiff.Length > 500000)                      continue;                    ParseUnifiedDiff(path' diffParser' commit);                    //commit.Print();              }
Magic Number,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: if( fuzz )              {                  var commitsToPrune = new List<GitCommit>();                  // Do processing of commits in order' just easier on the brain...                  var inOrderCommits = commits.ToList();                  inOrderCommits.Reverse();                    var prevCommit = inOrderCommits.FirstOrDefault();                  var accumalatedDifference = new TimeSpan();                  var startOfFuzz = prevCommit;                  var endOfFuzz = prevCommit;                  foreach (var commit in inOrderCommits.Skip(1))                  {                      var lastTime = ParseGitLog.GetDateFromGitFormat(prevCommit.Headers["Date"]);                      var commitTime = ParseGitLog.GetDateFromGitFormat(commit.Headers["Date"]);                      var span = (lastTime - commitTime).Duration();                      accumalatedDifference += span;                      if (accumalatedDifference.TotalMinutes <= 3 &&                           prevCommit.Files.All(f => commit.Files.Select(c => c.File).Contains(f.File)) &&                           prevCommit.Files.Any( f => f.Status != "A" || f.Status != "D" ) )                      {                          commitsToPrune.Add(prevCommit);                          endOfFuzz = commit;                      }                      else                      {                          // endOfFuzz will be only surviving commit in range' others will be pruned.                            // Get a new unified diff' and then reparse.                          if (startOfFuzz != endOfFuzz)                          {                              try                              {                                  endOfFuzz.UnifiedDiff = GitCommands.ShowDiffRange(path' startOfFuzz.Sha + "~1"' endOfFuzz.Sha);                                  ParseUnifiedDiff(path' diffParser' endOfFuzz);                              }                              catch (Exception ex)                              {                                  Trace.WriteLine(ex.Message);                              }                          }                          accumalatedDifference = new TimeSpan();                          startOfFuzz = commit;                          endOfFuzz = commit;                      }                        prevCommit = commit;                  }                    if (startOfFuzz != endOfFuzz)                  {                      try                      {                          endOfFuzz.UnifiedDiff = GitCommands.ShowDiffRange(path' startOfFuzz.Sha + "~1"' endOfFuzz.Sha);                          ParseUnifiedDiff(path' diffParser' endOfFuzz);                      }                      catch (Exception ex)                      {                          Trace.WriteLine(ex.Message);                      }                  }                    foreach (var commitToRemove in commitsToPrune)                  {                      commits.Remove(commitToRemove);                  }              }
Magic Number,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,Main,The following statement contains a magic number: if (args.Length == 0)              {                  Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture("sv-SE");                  Thread.CurrentThread.CurrentUICulture = new CultureInfo("sv-SE");                    Console.WriteLine(string.Format("## {0:dddd' MMMM dd' yyyy}\u00e5"' DateTime.Now.AddDays(-2)));                    Console.ReadKey();              }
Magic Number,automark,Program,C:\repos\chrisparnin_automark\Source\automark\automark\Program.cs,GetWebVisits,The following statement contains a magic number: if (System.IO.File.Exists(dbPath))              {                  try                  {                      // Chrome keeps an exclusive lock on database while open; copy-local                      var tempPath = tempName;                      System.IO.File.Copy(dbPath' tempPath' true);                        visits = connector.RecentStackoverflow(tempPath);                        // Clean up                      GC.Collect();                      connector = null;                      new System.Threading.Thread((db) =>                      {                          System.Threading.Thread.Sleep(1000);                          System.IO.File.Delete((string)db);                      }).Start(tempPath);                  }                  catch (Exception ex)                  {                      Trace.Write(ex.Message);                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0) {          deadline = DateTime.MaxValue;        } else {          deadline = DateTime.Now +              new TimeSpan(((long)(Diff_Timeout * 1000)) * 10000);        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0) {          deadline = DateTime.MaxValue;        } else {          deadline = DateTime.Now +              new TimeSpan(((long)(Diff_Timeout * 1000)) * 10000);        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {          // A half-match was found' sort out the return data.          string text1_a = hm[0];          string text1_b = hm[1];          string text2_a = hm[2];          string text2_b = hm[3];          string mid_common = hm[4];          // Send both pairs off for separate processing.          List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);          List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);          // Merge the results.          diffs = diffs_a;          diffs.Add(new Diff(Operation.EQUAL' mid_common));          diffs.AddRange(diffs_b);          return diffs;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {          // A half-match was found' sort out the return data.          string text1_a = hm[0];          string text1_b = hm[1];          string text2_a = hm[2];          string text2_b = hm[3];          string mid_common = hm[4];          // Send both pairs off for separate processing.          List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);          List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);          // Merge the results.          diffs = diffs_a;          diffs.Add(new Diff(Operation.EQUAL' mid_common));          diffs.AddRange(diffs_b);          return diffs;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {          // A half-match was found' sort out the return data.          string text1_a = hm[0];          string text1_b = hm[1];          string text2_a = hm[2];          string text2_b = hm[3];          string mid_common = hm[4];          // Send both pairs off for separate processing.          List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);          List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);          // Merge the results.          diffs = diffs_a;          diffs.Add(new Diff(Operation.EQUAL' mid_common));          diffs.AddRange(diffs_b);          return diffs;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100) {          return diff_lineMode(text1' text2' deadline);        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100) {          return diff_lineMode(text1' text2' deadline);        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_lineMode,The following statement contains a magic number: List<string> linearray = (List<string>)b[2];
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int max_d = (text1_length + text2_length + 1) / 2;
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int v_length = 2 * max_d;
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: bool front = (delta % 2 != 0);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {          // Bail out if deadline is reached.          if (DateTime.Now > deadline) {            break;          }            // Walk the front path one step.          for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {            int k1_offset = v_offset + k1;            int x1;            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {              x1 = v1[k1_offset + 1];            } else {              x1 = v1[k1_offset - 1] + 1;            }            int y1 = x1 - k1;            while (x1 < text1_length && y1 < text2_length                  && text1[x1] == text2[y1]) {              x1++;              y1++;            }            v1[k1_offset] = x1;            if (x1 > text1_length) {              // Ran off the right of the graph.              k1end += 2;            } else if (y1 > text2_length) {              // Ran off the bottom of the graph.              k1start += 2;            } else if (front) {              int k2_offset = v_offset + delta - k1;              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                // Mirror x2 onto top-left coordinate system.                int x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }            // Walk the reverse path one step.          for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {            int k2_offset = v_offset + k2;            int x2;            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {              x2 = v2[k2_offset + 1];            } else {              x2 = v2[k2_offset - 1] + 1;            }            int y2 = x2 - k2;            while (x2 < text1_length && y2 < text2_length                && text1[text1_length - x2 - 1]                == text2[text2_length - y2 - 1]) {              x2++;              y2++;            }            v2[k2_offset] = x2;            if (x2 > text1_length) {              // Ran off the left of the graph.              k2end += 2;            } else if (y2 > text2_length) {              // Ran off the top of the graph.              k2start += 2;            } else if (!front) {              int k1_offset = v_offset + delta - k2;              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                int x1 = v1[k1_offset];                int y1 = v_offset + x1 - k1_offset;                // Mirror x2 onto top-left coordinate system.                x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {          // Bail out if deadline is reached.          if (DateTime.Now > deadline) {            break;          }            // Walk the front path one step.          for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {            int k1_offset = v_offset + k1;            int x1;            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {              x1 = v1[k1_offset + 1];            } else {              x1 = v1[k1_offset - 1] + 1;            }            int y1 = x1 - k1;            while (x1 < text1_length && y1 < text2_length                  && text1[x1] == text2[y1]) {              x1++;              y1++;            }            v1[k1_offset] = x1;            if (x1 > text1_length) {              // Ran off the right of the graph.              k1end += 2;            } else if (y1 > text2_length) {              // Ran off the bottom of the graph.              k1start += 2;            } else if (front) {              int k2_offset = v_offset + delta - k1;              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                // Mirror x2 onto top-left coordinate system.                int x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }            // Walk the reverse path one step.          for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {            int k2_offset = v_offset + k2;            int x2;            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {              x2 = v2[k2_offset + 1];            } else {              x2 = v2[k2_offset - 1] + 1;            }            int y2 = x2 - k2;            while (x2 < text1_length && y2 < text2_length                && text1[text1_length - x2 - 1]                == text2[text2_length - y2 - 1]) {              x2++;              y2++;            }            v2[k2_offset] = x2;            if (x2 > text1_length) {              // Ran off the left of the graph.              k2end += 2;            } else if (y2 > text2_length) {              // Ran off the top of the graph.              k2start += 2;            } else if (!front) {              int k1_offset = v_offset + delta - k2;              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                int x1 = v1[k1_offset];                int y1 = v_offset + x1 - k1_offset;                // Mirror x2 onto top-left coordinate system.                x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {          // Bail out if deadline is reached.          if (DateTime.Now > deadline) {            break;          }            // Walk the front path one step.          for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {            int k1_offset = v_offset + k1;            int x1;            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {              x1 = v1[k1_offset + 1];            } else {              x1 = v1[k1_offset - 1] + 1;            }            int y1 = x1 - k1;            while (x1 < text1_length && y1 < text2_length                  && text1[x1] == text2[y1]) {              x1++;              y1++;            }            v1[k1_offset] = x1;            if (x1 > text1_length) {              // Ran off the right of the graph.              k1end += 2;            } else if (y1 > text2_length) {              // Ran off the bottom of the graph.              k1start += 2;            } else if (front) {              int k2_offset = v_offset + delta - k1;              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                // Mirror x2 onto top-left coordinate system.                int x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }            // Walk the reverse path one step.          for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {            int k2_offset = v_offset + k2;            int x2;            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {              x2 = v2[k2_offset + 1];            } else {              x2 = v2[k2_offset - 1] + 1;            }            int y2 = x2 - k2;            while (x2 < text1_length && y2 < text2_length                && text1[text1_length - x2 - 1]                == text2[text2_length - y2 - 1]) {              x2++;              y2++;            }            v2[k2_offset] = x2;            if (x2 > text1_length) {              // Ran off the left of the graph.              k2end += 2;            } else if (y2 > text2_length) {              // Ran off the top of the graph.              k2start += 2;            } else if (!front) {              int k1_offset = v_offset + delta - k2;              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                int x1 = v1[k1_offset];                int y1 = v_offset + x1 - k1_offset;                // Mirror x2 onto top-left coordinate system.                x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {          // Bail out if deadline is reached.          if (DateTime.Now > deadline) {            break;          }            // Walk the front path one step.          for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {            int k1_offset = v_offset + k1;            int x1;            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {              x1 = v1[k1_offset + 1];            } else {              x1 = v1[k1_offset - 1] + 1;            }            int y1 = x1 - k1;            while (x1 < text1_length && y1 < text2_length                  && text1[x1] == text2[y1]) {              x1++;              y1++;            }            v1[k1_offset] = x1;            if (x1 > text1_length) {              // Ran off the right of the graph.              k1end += 2;            } else if (y1 > text2_length) {              // Ran off the bottom of the graph.              k1start += 2;            } else if (front) {              int k2_offset = v_offset + delta - k1;              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                // Mirror x2 onto top-left coordinate system.                int x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }            // Walk the reverse path one step.          for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {            int k2_offset = v_offset + k2;            int x2;            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {              x2 = v2[k2_offset + 1];            } else {              x2 = v2[k2_offset - 1] + 1;            }            int y2 = x2 - k2;            while (x2 < text1_length && y2 < text2_length                && text1[text1_length - x2 - 1]                == text2[text2_length - y2 - 1]) {              x2++;              y2++;            }            v2[k2_offset] = x2;            if (x2 > text1_length) {              // Ran off the left of the graph.              k2end += 2;            } else if (y2 > text2_length) {              // Ran off the top of the graph.              k2start += 2;            } else if (!front) {              int k1_offset = v_offset + delta - k2;              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                int x1 = v1[k1_offset];                int y1 = v_offset + x1 - k1_offset;                // Mirror x2 onto top-left coordinate system.                x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {          // Bail out if deadline is reached.          if (DateTime.Now > deadline) {            break;          }            // Walk the front path one step.          for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {            int k1_offset = v_offset + k1;            int x1;            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {              x1 = v1[k1_offset + 1];            } else {              x1 = v1[k1_offset - 1] + 1;            }            int y1 = x1 - k1;            while (x1 < text1_length && y1 < text2_length                  && text1[x1] == text2[y1]) {              x1++;              y1++;            }            v1[k1_offset] = x1;            if (x1 > text1_length) {              // Ran off the right of the graph.              k1end += 2;            } else if (y1 > text2_length) {              // Ran off the bottom of the graph.              k1start += 2;            } else if (front) {              int k2_offset = v_offset + delta - k1;              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                // Mirror x2 onto top-left coordinate system.                int x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }            // Walk the reverse path one step.          for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {            int k2_offset = v_offset + k2;            int x2;            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {              x2 = v2[k2_offset + 1];            } else {              x2 = v2[k2_offset - 1] + 1;            }            int y2 = x2 - k2;            while (x2 < text1_length && y2 < text2_length                && text1[text1_length - x2 - 1]                == text2[text2_length - y2 - 1]) {              x2++;              y2++;            }            v2[k2_offset] = x2;            if (x2 > text1_length) {              // Ran off the left of the graph.              k2end += 2;            } else if (y2 > text2_length) {              // Ran off the top of the graph.              k2start += 2;            } else if (!front) {              int k1_offset = v_offset + delta - k2;              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                int x1 = v1[k1_offset];                int y1 = v_offset + x1 - k1_offset;                // Mirror x2 onto top-left coordinate system.                x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {          // Bail out if deadline is reached.          if (DateTime.Now > deadline) {            break;          }            // Walk the front path one step.          for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {            int k1_offset = v_offset + k1;            int x1;            if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {              x1 = v1[k1_offset + 1];            } else {              x1 = v1[k1_offset - 1] + 1;            }            int y1 = x1 - k1;            while (x1 < text1_length && y1 < text2_length                  && text1[x1] == text2[y1]) {              x1++;              y1++;            }            v1[k1_offset] = x1;            if (x1 > text1_length) {              // Ran off the right of the graph.              k1end += 2;            } else if (y1 > text2_length) {              // Ran off the bottom of the graph.              k1start += 2;            } else if (front) {              int k2_offset = v_offset + delta - k1;              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                // Mirror x2 onto top-left coordinate system.                int x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }            // Walk the reverse path one step.          for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {            int k2_offset = v_offset + k2;            int x2;            if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {              x2 = v2[k2_offset + 1];            } else {              x2 = v2[k2_offset - 1] + 1;            }            int y2 = x2 - k2;            while (x2 < text1_length && y2 < text2_length                && text1[text1_length - x2 - 1]                == text2[text2_length - y2 - 1]) {              x2++;              y2++;            }            v2[k2_offset] = x2;            if (x2 > text1_length) {              // Ran off the left of the graph.              k2end += 2;            } else if (y2 > text2_length) {              // Ran off the top of the graph.              k2start += 2;            } else if (!front) {              int k1_offset = v_offset + delta - k2;              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                int x1 = v1[k1_offset];                int y1 = v_offset + x1 - k1_offset;                // Mirror x2 onto top-left coordinate system.                x2 = text1_length - v2[k2_offset];                if (x1 >= x2) {                  // Overlap detected.                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                }              }            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length) {          return null;  // Pointless.        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length) {          return null;  // Pointless.        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext'                                       (longtext.Length + 3) / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext'                                       (longtext.Length + 3) / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm2 = diff_halfMatchI(longtext' shorttext'                                       (longtext.Length + 1) / 2);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null) {          return null;        } else if (hm2 == null) {          hm = hm1;        } else if (hm1 == null) {          hm = hm2;        } else {          // Both matched.  Select the longest.          hm = hm1[4].Length > hm2[4].Length ? hm1 : hm2;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null) {          return null;        } else if (hm2 == null) {          hm = hm1;        } else if (hm1 == null) {          hm = hm2;        } else {          // Both matched.  Select the longest.          hm = hm1[4].Length > hm2[4].Length ? hm1 : hm2;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {          return hm;          //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};        } else {          return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {          return hm;          //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};        } else {          return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {          return hm;          //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};        } else {          return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: string seed = longtext.Substring(i' longtext.Length / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: if (best_common.Length * 2 >= longtext.Length) {          return new string[]{best_longtext_a' best_longtext_b'              best_shorttext_a' best_shorttext_b' best_common};        } else {          return null;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {          if (diffs[pointer - 1].operation == Operation.DELETE &&              diffs[pointer].operation == Operation.INSERT) {            string deletion = diffs[pointer - 1].text;            string insertion = diffs[pointer].text;            int overlap_length1 = diff_commonOverlap(deletion' insertion);            int overlap_length2 = diff_commonOverlap(insertion' deletion);            if (overlap_length1 >= overlap_length2) {              if (overlap_length1 >= deletion.Length / 2.0 ||                  overlap_length1 >= insertion.Length / 2.0) {                // Overlap found.                // Insert an equality and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    insertion.Substring(0' overlap_length1)));                diffs[pointer - 1].text =                    deletion.Substring(0' deletion.Length - overlap_length1);                diffs[pointer + 1].text = insertion.Substring(overlap_length1);                pointer++;              }            } else {              if (overlap_length2 >= deletion.Length / 2.0 ||                  overlap_length2 >= insertion.Length / 2.0) {                // Reverse overlap found.                // Insert an equality and swap and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    deletion.Substring(0' overlap_length2)));                diffs[pointer - 1].operation = Operation.INSERT;                diffs[pointer - 1].text =                    insertion.Substring(0' insertion.Length - overlap_length2);                diffs[pointer + 1].operation = Operation.DELETE;                diffs[pointer + 1].text = deletion.Substring(overlap_length2);                pointer++;              }            }            pointer++;          }          pointer++;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {          if (diffs[pointer - 1].operation == Operation.DELETE &&              diffs[pointer].operation == Operation.INSERT) {            string deletion = diffs[pointer - 1].text;            string insertion = diffs[pointer].text;            int overlap_length1 = diff_commonOverlap(deletion' insertion);            int overlap_length2 = diff_commonOverlap(insertion' deletion);            if (overlap_length1 >= overlap_length2) {              if (overlap_length1 >= deletion.Length / 2.0 ||                  overlap_length1 >= insertion.Length / 2.0) {                // Overlap found.                // Insert an equality and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    insertion.Substring(0' overlap_length1)));                diffs[pointer - 1].text =                    deletion.Substring(0' deletion.Length - overlap_length1);                diffs[pointer + 1].text = insertion.Substring(overlap_length1);                pointer++;              }            } else {              if (overlap_length2 >= deletion.Length / 2.0 ||                  overlap_length2 >= insertion.Length / 2.0) {                // Reverse overlap found.                // Insert an equality and swap and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    deletion.Substring(0' overlap_length2)));                diffs[pointer - 1].operation = Operation.INSERT;                diffs[pointer - 1].text =                    insertion.Substring(0' insertion.Length - overlap_length2);                diffs[pointer + 1].operation = Operation.DELETE;                diffs[pointer + 1].text = deletion.Substring(overlap_length2);                pointer++;              }            }            pointer++;          }          pointer++;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {          if (diffs[pointer - 1].operation == Operation.DELETE &&              diffs[pointer].operation == Operation.INSERT) {            string deletion = diffs[pointer - 1].text;            string insertion = diffs[pointer].text;            int overlap_length1 = diff_commonOverlap(deletion' insertion);            int overlap_length2 = diff_commonOverlap(insertion' deletion);            if (overlap_length1 >= overlap_length2) {              if (overlap_length1 >= deletion.Length / 2.0 ||                  overlap_length1 >= insertion.Length / 2.0) {                // Overlap found.                // Insert an equality and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    insertion.Substring(0' overlap_length1)));                diffs[pointer - 1].text =                    deletion.Substring(0' deletion.Length - overlap_length1);                diffs[pointer + 1].text = insertion.Substring(overlap_length1);                pointer++;              }            } else {              if (overlap_length2 >= deletion.Length / 2.0 ||                  overlap_length2 >= insertion.Length / 2.0) {                // Reverse overlap found.                // Insert an equality and swap and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    deletion.Substring(0' overlap_length2)));                diffs[pointer - 1].operation = Operation.INSERT;                diffs[pointer - 1].text =                    insertion.Substring(0' insertion.Length - overlap_length2);                diffs[pointer + 1].operation = Operation.DELETE;                diffs[pointer + 1].text = deletion.Substring(overlap_length2);                pointer++;              }            }            pointer++;          }          pointer++;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {          if (diffs[pointer - 1].operation == Operation.DELETE &&              diffs[pointer].operation == Operation.INSERT) {            string deletion = diffs[pointer - 1].text;            string insertion = diffs[pointer].text;            int overlap_length1 = diff_commonOverlap(deletion' insertion);            int overlap_length2 = diff_commonOverlap(insertion' deletion);            if (overlap_length1 >= overlap_length2) {              if (overlap_length1 >= deletion.Length / 2.0 ||                  overlap_length1 >= insertion.Length / 2.0) {                // Overlap found.                // Insert an equality and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    insertion.Substring(0' overlap_length1)));                diffs[pointer - 1].text =                    deletion.Substring(0' deletion.Length - overlap_length1);                diffs[pointer + 1].text = insertion.Substring(overlap_length1);                pointer++;              }            } else {              if (overlap_length2 >= deletion.Length / 2.0 ||                  overlap_length2 >= insertion.Length / 2.0) {                // Reverse overlap found.                // Insert an equality and swap and trim the surrounding edits.                diffs.Insert(pointer' new Diff(Operation.EQUAL'                    deletion.Substring(0' overlap_length2)));                diffs[pointer - 1].operation = Operation.INSERT;                diffs[pointer - 1].text =                    insertion.Substring(0' insertion.Length - overlap_length2);                diffs[pointer + 1].operation = Operation.DELETE;                diffs[pointer + 1].text = deletion.Substring(overlap_length2);                pointer++;              }            }            pointer++;          }          pointer++;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (one.Length == 0 || two.Length == 0) {          // Edges are the best.          return 6;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {          // Five points for blank lines.          return 5;        } else if (lineBreak1 || lineBreak2) {          // Four points for line breaks.          return 4;        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {          // Three points for end of sentences.          return 3;        } else if (whitespace1 || whitespace2) {          // Two points for whitespace.          return 2;        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {          // One point for non-alphanumeric.          return 1;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {          // Five points for blank lines.          return 5;        } else if (lineBreak1 || lineBreak2) {          // Four points for line breaks.          return 4;        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {          // Three points for end of sentences.          return 3;        } else if (whitespace1 || whitespace2) {          // Two points for whitespace.          return 2;        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {          // One point for non-alphanumeric.          return 1;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {          // Five points for blank lines.          return 5;        } else if (lineBreak1 || lineBreak2) {          // Four points for line breaks.          return 4;        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {          // Three points for end of sentences.          return 3;        } else if (whitespace1 || whitespace2) {          // Two points for whitespace.          return 2;        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {          // One point for non-alphanumeric.          return 1;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {          // Five points for blank lines.          return 5;        } else if (lineBreak1 || lineBreak2) {          // Four points for line breaks.          return 4;        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {          // Three points for end of sentences.          return 3;        } else if (whitespace1 || whitespace2) {          // Two points for whitespace.          return 2;        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {          // One point for non-alphanumeric.          return 1;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count) {          if (diffs[pointer].operation == Operation.EQUAL) {  // Equality found.            if (diffs[pointer].text.Length < this.Diff_EditCost                && (post_ins || post_del)) {              // Candidate found.              equalities.Push(pointer);              pre_ins = post_ins;              pre_del = post_del;              lastequality = diffs[pointer].text;            } else {              // Not a candidate' and can never become one.              equalities.Clear();              lastequality = string.Empty;            }            post_ins = post_del = false;          } else {  // An insertion or deletion.            if (diffs[pointer].operation == Operation.DELETE) {              post_del = true;            } else {              post_ins = true;            }            /*             * Five types to be split:             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>             * <ins>A</ins>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<ins>C</ins>             * <ins>A</del>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<del>C</del>             */            if ((lastequality.Length != 0)                && ((pre_ins && pre_del && post_ins && post_del)                || ((lastequality.Length < this.Diff_EditCost / 2)                && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                + (post_del ? 1 : 0)) == 3))) {              // Duplicate record.              diffs.Insert(equalities.Peek()'                           new Diff(Operation.DELETE' lastequality));              // Change second copy to insert.              diffs[equalities.Peek() + 1].operation = Operation.INSERT;              equalities.Pop();  // Throw away the equality we just deleted.              lastequality = string.Empty;              if (pre_ins && pre_del) {                // No changes made which could affect previous entry' keep going.                post_ins = post_del = true;                equalities.Clear();              } else {                if (equalities.Count > 0) {                  equalities.Pop();                }                  pointer = equalities.Count > 0 ? equalities.Peek() : -1;                post_ins = post_del = false;              }              changes = true;            }          }          pointer++;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count) {          if (diffs[pointer].operation == Operation.EQUAL) {  // Equality found.            if (diffs[pointer].text.Length < this.Diff_EditCost                && (post_ins || post_del)) {              // Candidate found.              equalities.Push(pointer);              pre_ins = post_ins;              pre_del = post_del;              lastequality = diffs[pointer].text;            } else {              // Not a candidate' and can never become one.              equalities.Clear();              lastequality = string.Empty;            }            post_ins = post_del = false;          } else {  // An insertion or deletion.            if (diffs[pointer].operation == Operation.DELETE) {              post_del = true;            } else {              post_ins = true;            }            /*             * Five types to be split:             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>             * <ins>A</ins>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<ins>C</ins>             * <ins>A</del>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<del>C</del>             */            if ((lastequality.Length != 0)                && ((pre_ins && pre_del && post_ins && post_del)                || ((lastequality.Length < this.Diff_EditCost / 2)                && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                + (post_del ? 1 : 0)) == 3))) {              // Duplicate record.              diffs.Insert(equalities.Peek()'                           new Diff(Operation.DELETE' lastequality));              // Change second copy to insert.              diffs[equalities.Peek() + 1].operation = Operation.INSERT;              equalities.Pop();  // Throw away the equality we just deleted.              lastequality = string.Empty;              if (pre_ins && pre_del) {                // No changes made which could affect previous entry' keep going.                post_ins = post_del = true;                equalities.Clear();              } else {                if (equalities.Count > 0) {                  equalities.Pop();                }                  pointer = equalities.Count > 0 ? equalities.Peek() : -1;                post_ins = post_del = false;              }              changes = true;            }          }          pointer++;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {          // Scan for the best match; each iteration allows for one more error.          // Run a binary search to determine how far from 'loc' we can stray at          // this error level.          bin_min = 0;          bin_mid = bin_max;          while (bin_min < bin_mid) {            if (match_bitapScore(d' loc + bin_mid' loc' pattern)                <= score_threshold) {              bin_min = bin_mid;            } else {              bin_max = bin_mid;            }            bin_mid = (bin_max - bin_min) / 2 + bin_min;          }          // Use the result from this iteration as the maximum for the next.          bin_max = bin_mid;          int start = Math.Max(1' loc - bin_mid + 1);          int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;            int[] rd = new int[finish + 2];          rd[finish + 1] = (1 << d) - 1;          for (int j = finish; j >= start; j--) {            int charMatch;            if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1])) {              // Out of range.              charMatch = 0;            } else {              charMatch = s[text[j - 1]];            }            if (d == 0) {              // First pass: exact match.              rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;            } else {              // Subsequent passes: fuzzy match.              rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                  | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];            }            if ((rd[j] & matchmask) != 0) {              double score = match_bitapScore(d' j - 1' loc' pattern);              // This match will almost certainly be better than any existing              // match.  But check anyway.              if (score <= score_threshold) {                // Told you so.                score_threshold = score;                best_loc = j - 1;                if (best_loc > loc) {                  // When passing loc' don't exceed our current distance from loc.                  start = Math.Max(1' 2 * loc - best_loc);                } else {                  // Already passed loc' downhill from here on in.                  break;                }              }            }          }          if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold) {            // No hope for a (better) match at greater error levels.            break;          }          last_rd = rd;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {          // Scan for the best match; each iteration allows for one more error.          // Run a binary search to determine how far from 'loc' we can stray at          // this error level.          bin_min = 0;          bin_mid = bin_max;          while (bin_min < bin_mid) {            if (match_bitapScore(d' loc + bin_mid' loc' pattern)                <= score_threshold) {              bin_min = bin_mid;            } else {              bin_max = bin_mid;            }            bin_mid = (bin_max - bin_min) / 2 + bin_min;          }          // Use the result from this iteration as the maximum for the next.          bin_max = bin_mid;          int start = Math.Max(1' loc - bin_mid + 1);          int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;            int[] rd = new int[finish + 2];          rd[finish + 1] = (1 << d) - 1;          for (int j = finish; j >= start; j--) {            int charMatch;            if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1])) {              // Out of range.              charMatch = 0;            } else {              charMatch = s[text[j - 1]];            }            if (d == 0) {              // First pass: exact match.              rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;            } else {              // Subsequent passes: fuzzy match.              rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                  | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];            }            if ((rd[j] & matchmask) != 0) {              double score = match_bitapScore(d' j - 1' loc' pattern);              // This match will almost certainly be better than any existing              // match.  But check anyway.              if (score <= score_threshold) {                // Told you so.                score_threshold = score;                best_loc = j - 1;                if (best_loc > loc) {                  // When passing loc' don't exceed our current distance from loc.                  start = Math.Max(1' 2 * loc - best_loc);                } else {                  // Already passed loc' downhill from here on in.                  break;                }              }            }          }          if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold) {            // No hope for a (better) match at greater error levels.            break;          }          last_rd = rd;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {          // Scan for the best match; each iteration allows for one more error.          // Run a binary search to determine how far from 'loc' we can stray at          // this error level.          bin_min = 0;          bin_mid = bin_max;          while (bin_min < bin_mid) {            if (match_bitapScore(d' loc + bin_mid' loc' pattern)                <= score_threshold) {              bin_min = bin_mid;            } else {              bin_max = bin_mid;            }            bin_mid = (bin_max - bin_min) / 2 + bin_min;          }          // Use the result from this iteration as the maximum for the next.          bin_max = bin_mid;          int start = Math.Max(1' loc - bin_mid + 1);          int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;            int[] rd = new int[finish + 2];          rd[finish + 1] = (1 << d) - 1;          for (int j = finish; j >= start; j--) {            int charMatch;            if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1])) {              // Out of range.              charMatch = 0;            } else {              charMatch = s[text[j - 1]];            }            if (d == 0) {              // First pass: exact match.              rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;            } else {              // Subsequent passes: fuzzy match.              rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                  | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];            }            if ((rd[j] & matchmask) != 0) {              double score = match_bitapScore(d' j - 1' loc' pattern);              // This match will almost certainly be better than any existing              // match.  But check anyway.              if (score <= score_threshold) {                // Told you so.                score_threshold = score;                best_loc = j - 1;                if (best_loc > loc) {                  // When passing loc' don't exceed our current distance from loc.                  start = Math.Max(1' 2 * loc - best_loc);                } else {                  // Already passed loc' downhill from here on in.                  break;                }              }            }          }          if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold) {            // No hope for a (better) match at greater error levels.            break;          }          last_rd = rd;        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: if (diffs.Count > 2) {          diff_cleanupSemantic(diffs);          diff_cleanupEfficiency(diffs);        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs) {          if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL) {            // A new patch starts here.            patch.start1 = char_count1;            patch.start2 = char_count2;          }            switch (aDiff.operation) {            case Operation.INSERT:              patch.diffs.Add(aDiff);              patch.length2 += aDiff.text.Length;              postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);              break;            case Operation.DELETE:              patch.length1 += aDiff.text.Length;              patch.diffs.Add(aDiff);              postpatch_text = postpatch_text.Remove(char_count2'                  aDiff.text.Length);              break;            case Operation.EQUAL:              if (aDiff.text.Length <= 2 * Patch_Margin                  && patch.diffs.Count() != 0 && aDiff != diffs.Last()) {                // Small equality inside a patch.                patch.diffs.Add(aDiff);                patch.length1 += aDiff.text.Length;                patch.length2 += aDiff.text.Length;              }                if (aDiff.text.Length >= 2 * Patch_Margin) {                // Time for a new patch.                if (patch.diffs.Count != 0) {                  patch_addContext(patch' prepatch_text);                  patches.Add(patch);                  patch = new Patch();                  // Unlike Unidiff' our patch lists have a rolling context.                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                  // Update prepatch text & pos to reflect the application of the                  // just completed patch.                  prepatch_text = postpatch_text;                  char_count1 = char_count2;                }              }              break;          }            // Update the current character count.          if (aDiff.operation != Operation.INSERT) {            char_count1 += aDiff.text.Length;          }          if (aDiff.operation != Operation.DELETE) {            char_count2 += aDiff.text.Length;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs) {          if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL) {            // A new patch starts here.            patch.start1 = char_count1;            patch.start2 = char_count2;          }            switch (aDiff.operation) {            case Operation.INSERT:              patch.diffs.Add(aDiff);              patch.length2 += aDiff.text.Length;              postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);              break;            case Operation.DELETE:              patch.length1 += aDiff.text.Length;              patch.diffs.Add(aDiff);              postpatch_text = postpatch_text.Remove(char_count2'                  aDiff.text.Length);              break;            case Operation.EQUAL:              if (aDiff.text.Length <= 2 * Patch_Margin                  && patch.diffs.Count() != 0 && aDiff != diffs.Last()) {                // Small equality inside a patch.                patch.diffs.Add(aDiff);                patch.length1 += aDiff.text.Length;                patch.length2 += aDiff.text.Length;              }                if (aDiff.text.Length >= 2 * Patch_Margin) {                // Time for a new patch.                if (patch.diffs.Count != 0) {                  patch_addContext(patch' prepatch_text);                  patches.Add(patch);                  patch = new Patch();                  // Unlike Unidiff' our patch lists have a rolling context.                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                  // Update prepatch text & pos to reflect the application of the                  // just completed patch.                  prepatch_text = postpatch_text;                  char_count1 = char_count2;                }              }              break;          }            // Update the current character count.          if (aDiff.operation != Operation.INSERT) {            char_count1 += aDiff.text.Length;          }          if (aDiff.operation != Operation.DELETE) {            char_count2 += aDiff.text.Length;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_apply,The following statement contains a magic number: text = text.Substring(nullPadding.Length' text.Length            - 2 * nullPadding.Length);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: for (int x = 0; x < patches.Count; x++) {          if (patches[x].length1 <= patch_size) {            continue;          }          Patch bigpatch = patches[x];          // Remove the big old patch.          patches.Splice(x--' 1);          int start1 = bigpatch.start1;          int start2 = bigpatch.start2;          string precontext = string.Empty;          while (bigpatch.diffs.Count != 0) {            // Create one of several smaller patches.            Patch patch = new Patch();            bool empty = true;            patch.start1 = start1 - precontext.Length;            patch.start2 = start2 - precontext.Length;            if (precontext.Length != 0) {              patch.length1 = patch.length2 = precontext.Length;              patch.diffs.Add(new Diff(Operation.EQUAL' precontext));            }            while (bigpatch.diffs.Count != 0                && patch.length1 < patch_size - this.Patch_Margin) {              Operation diff_type = bigpatch.diffs[0].operation;              string diff_text = bigpatch.diffs[0].text;              if (diff_type == Operation.INSERT) {                // Insertions are harmless.                patch.length2 += diff_text.Length;                start2 += diff_text.Length;                patch.diffs.Add(bigpatch.diffs.First());                bigpatch.diffs.RemoveAt(0);                empty = false;              } else if (diff_type == Operation.DELETE && patch.diffs.Count == 1                  && patch.diffs.First().operation == Operation.EQUAL                  && diff_text.Length > 2 * patch_size) {                // This is a large deletion.  Let it pass in one chunk.                patch.length1 += diff_text.Length;                start1 += diff_text.Length;                empty = false;                patch.diffs.Add(new Diff(diff_type' diff_text));                bigpatch.diffs.RemoveAt(0);              } else {                // Deletion or equality.  Only take as much as we can stomach.                diff_text = diff_text.Substring(0' Math.Min(diff_text.Length'                    patch_size - patch.length1 - Patch_Margin));                patch.length1 += diff_text.Length;                start1 += diff_text.Length;                if (diff_type == Operation.EQUAL) {                  patch.length2 += diff_text.Length;                  start2 += diff_text.Length;                } else {                  empty = false;                }                patch.diffs.Add(new Diff(diff_type' diff_text));                if (diff_text == bigpatch.diffs[0].text) {                  bigpatch.diffs.RemoveAt(0);                } else {                  bigpatch.diffs[0].text =                      bigpatch.diffs[0].text.Substring(diff_text.Length);                }              }            }            // Compute the head context for the next patch.            precontext = this.diff_text2(patch.diffs);            precontext = precontext.Substring(Math.Max(0'                precontext.Length - this.Patch_Margin));              string postcontext = null;            // Append the end context for this patch.            if (diff_text1(bigpatch.diffs).Length > Patch_Margin) {              postcontext = diff_text1(bigpatch.diffs)                  .Substring(0' Patch_Margin);            } else {              postcontext = diff_text1(bigpatch.diffs);            }              if (postcontext.Length != 0) {              patch.length1 += postcontext.Length;              patch.length2 += postcontext.Length;              if (patch.diffs.Count != 0                  && patch.diffs[patch.diffs.Count - 1].operation                  == Operation.EQUAL) {                patch.diffs[patch.diffs.Count - 1].text += postcontext;              } else {                patch.diffs.Add(new Diff(Operation.EQUAL' postcontext));              }            }            if (!empty) {              patches.Splice(++x' 0' patch);            }          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {          m = patchHeader.Match(text[textPointer]);          if (!m.Success) {            throw new ArgumentException("Invalid patch string: "                + text[textPointer]);          }          patch = new Patch();          patches.Add(patch);          patch.start1 = Convert.ToInt32(m.Groups[1].Value);          if (m.Groups[2].Length == 0) {            patch.start1--;            patch.length1 = 1;          } else if (m.Groups[2].Value == "0") {            patch.length1 = 0;          } else {            patch.start1--;            patch.length1 = Convert.ToInt32(m.Groups[2].Value);          }            patch.start2 = Convert.ToInt32(m.Groups[3].Value);          if (m.Groups[4].Length == 0) {            patch.start2--;            patch.length2 = 1;          } else if (m.Groups[4].Value == "0") {            patch.length2 = 0;          } else {            patch.start2--;            patch.length2 = Convert.ToInt32(m.Groups[4].Value);          }          textPointer++;            while (textPointer < text.Length) {            try {              sign = text[textPointer][0];            } catch (IndexOutOfRangeException) {              // Blank line?  Whatever.              textPointer++;              continue;            }            line = text[textPointer].Substring(1);            line = line.Replace("+"' "%2b");            line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));            if (sign == '-') {              // Deletion.              patch.diffs.Add(new Diff(Operation.DELETE' line));            } else if (sign == '+') {              // Insertion.              patch.diffs.Add(new Diff(Operation.INSERT' line));            } else if (sign == ' ') {              // Minor equality.              patch.diffs.Add(new Diff(Operation.EQUAL' line));            } else if (sign == '@') {              // Start of next patch.              break;            } else {              // WTF?              throw new ArgumentException(                  "Invalid patch mode '" + sign + "' in: " + line);            }            textPointer++;          }        }
Missing Default,DiffMatchPatch,Patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,ToString,The following switch statement is missing a default case: switch (aDiff.operation) {            case Operation.INSERT:              text.Append('+');              break;            case Operation.DELETE:              text.Append('-');              break;            case Operation.EQUAL:              text.Append(' ');              break;          }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_lineMode,The following switch statement is missing a default case: switch (diffs[pointer].operation) {            case Operation.INSERT:              count_insert++;              text_insert += diffs[pointer].text;              break;            case Operation.DELETE:              count_delete++;              text_delete += diffs[pointer].text;              break;            case Operation.EQUAL:              // Upon reaching an equality' check for prior redundancies.              if (count_delete >= 1 && count_insert >= 1) {                // Delete the offending records and add the merged ones.                diffs.RemoveRange(pointer - count_delete - count_insert'                    count_delete + count_insert);                pointer = pointer - count_delete - count_insert;                List<Diff> a =                    this.diff_main(text_delete' text_insert' false' deadline);                diffs.InsertRange(pointer' a);                pointer = pointer + a.Count;              }              count_insert = 0;              count_delete = 0;              text_delete = string.Empty;              text_insert = string.Empty;              break;          }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_cleanupMerge,The following switch statement is missing a default case: switch (diffs[pointer].operation) {            case Operation.INSERT:              count_insert++;              text_insert += diffs[pointer].text;              pointer++;              break;            case Operation.DELETE:              count_delete++;              text_delete += diffs[pointer].text;              pointer++;              break;            case Operation.EQUAL:              // Upon reaching an equality' check for prior redundancies.              if (count_delete + count_insert > 1) {                if (count_delete != 0 && count_insert != 0) {                  // Factor out any common prefixies.                  commonlength = this.diff_commonPrefix(text_insert' text_delete);                  if (commonlength != 0) {                    if ((pointer - count_delete - count_insert) > 0 &&                      diffs[pointer - count_delete - count_insert - 1].operation                          == Operation.EQUAL) {                      diffs[pointer - count_delete - count_insert - 1].text                          += text_insert.Substring(0' commonlength);                    } else {                      diffs.Insert(0' new Diff(Operation.EQUAL'                          text_insert.Substring(0' commonlength)));                      pointer++;                    }                    text_insert = text_insert.Substring(commonlength);                    text_delete = text_delete.Substring(commonlength);                  }                  // Factor out any common suffixies.                  commonlength = this.diff_commonSuffix(text_insert' text_delete);                  if (commonlength != 0) {                    diffs[pointer].text = text_insert.Substring(text_insert.Length                        - commonlength) + diffs[pointer].text;                    text_insert = text_insert.Substring(0' text_insert.Length                        - commonlength);                    text_delete = text_delete.Substring(0' text_delete.Length                        - commonlength);                  }                }                // Delete the offending records and add the merged ones.                if (count_delete == 0) {                  diffs.Splice(pointer - count_insert'                      count_delete + count_insert'                      new Diff(Operation.INSERT' text_insert));                } else if (count_insert == 0) {                  diffs.Splice(pointer - count_delete'                      count_delete + count_insert'                      new Diff(Operation.DELETE' text_delete));                } else {                  diffs.Splice(pointer - count_delete - count_insert'                      count_delete + count_insert'                      new Diff(Operation.DELETE' text_delete)'                      new Diff(Operation.INSERT' text_insert));                }                pointer = pointer - count_delete - count_insert +                    (count_delete != 0 ? 1 : 0) + (count_insert != 0 ? 1 : 0) + 1;              } else if (pointer != 0                  && diffs[pointer - 1].operation == Operation.EQUAL) {                // Merge this equality with the previous one.                diffs[pointer - 1].text += diffs[pointer].text;                diffs.RemoveAt(pointer);              } else {                pointer++;              }              count_insert = 0;              count_delete = 0;              text_delete = string.Empty;              text_insert = string.Empty;              break;          }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_prettyHtml,The following switch statement is missing a default case: switch (aDiff.operation) {            case Operation.INSERT:              html.Append("<ins style=\"background:#e6ffe6;\">").Append(text)                  .Append("</ins>");              break;            case Operation.DELETE:              html.Append("<del style=\"background:#ffe6e6;\">").Append(text)                  .Append("</del>");              break;            case Operation.EQUAL:              html.Append("<span>").Append(text).Append("</span>");              break;          }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_levenshtein,The following switch statement is missing a default case: switch (aDiff.operation) {            case Operation.INSERT:              insertions += aDiff.text.Length;              break;            case Operation.DELETE:              deletions += aDiff.text.Length;              break;            case Operation.EQUAL:              // A deletion and an insertion is one substitution.              levenshtein += Math.Max(insertions' deletions);              insertions = 0;              deletions = 0;              break;          }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,diff_toDelta,The following switch statement is missing a default case: switch (aDiff.operation) {            case Operation.INSERT:              text.Append("+").Append(HttpUtility.UrlEncode(aDiff.text'                  new UTF8Encoding()).Replace('+'' ' ')).Append("\t");              break;            case Operation.DELETE:              text.Append("-").Append(aDiff.text.Length).Append("\t");              break;            case Operation.EQUAL:              text.Append("=").Append(aDiff.text.Length).Append("\t");              break;          }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\chrisparnin_automark\Source\automark\automark\Util\DiffMatchPatch.cs,patch_make,The following switch statement is missing a default case: switch (aDiff.operation) {            case Operation.INSERT:              patch.diffs.Add(aDiff);              patch.length2 += aDiff.text.Length;              postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);              break;            case Operation.DELETE:              patch.length1 += aDiff.text.Length;              patch.diffs.Add(aDiff);              postpatch_text = postpatch_text.Remove(char_count2'                  aDiff.text.Length);              break;            case Operation.EQUAL:              if (aDiff.text.Length <= 2 * Patch_Margin                  && patch.diffs.Count() != 0 && aDiff != diffs.Last()) {                // Small equality inside a patch.                patch.diffs.Add(aDiff);                patch.length1 += aDiff.text.Length;                patch.length2 += aDiff.text.Length;              }                if (aDiff.text.Length >= 2 * Patch_Margin) {                // Time for a new patch.                if (patch.diffs.Count != 0) {                  patch_addContext(patch' prepatch_text);                  patches.Add(patch);                  patch = new Patch();                  // Unlike Unidiff' our patch lists have a rolling context.                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                  // Update prepatch text & pos to reflect the application of the                  // just completed patch.                  prepatch_text = postpatch_text;                  char_count1 = char_count2;                }              }              break;          }
