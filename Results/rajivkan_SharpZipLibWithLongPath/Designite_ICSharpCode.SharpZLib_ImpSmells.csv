Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The method has 183 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Finish,The method has 102 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The method has 167 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,RunUpdates,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The method has 130 lines of code.
Long Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The method has 130 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The method has 129 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The method has 270 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,QSort3,The method has 102 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The method has 160 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The method has 116 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The method has 100 lines of code.
Complex Method,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Core,NameFilter,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\NameFilter.cs,SplitQuoted,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Core,FileSystemScanner,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\FileSystemScanner.cs,ScanDir,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\StreamUtils.cs,Copy,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\WindowsNameTransform.cs,MakeValidName,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,CloseEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,InitialRead,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,BodyRead,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,Cyclomatic complexity of the method is 33
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,CloseEntry,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Finish,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetInputStream,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestArchive,Cyclomatic complexity of the method is 23
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,BeginUpdate,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLocalEntryHeader,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteCentralDirectoryHeader,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CopyBytes,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetOutputStream,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,AddEntry,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,RunUpdates,Cyclomatic complexity of the method is 31
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,DiskArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetTempFileName,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,CreateZip,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractZip,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractEntry,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntryFactory.cs,MakeFileEntry,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,ReadByte,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,Cyclomatic complexity of the method is 24
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,HbCreateDecodeTables,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,Cyclomatic complexity of the method is 33
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,Cyclomatic complexity of the method is 63
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SimpleSort,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,QSort3,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,Cyclomatic complexity of the method is 30
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,Cyclomatic complexity of the method is 30
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarOutputStream.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarInputStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,WriteEntryCore,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,Deflate,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,SetLevel,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 40
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Inflate,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 15
Long Parameter List,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\PathFilter.cs,ExtendedPathFilter,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\StreamUtils.cs,Copy,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\StreamUtils.cs,Copy,The method has 8 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CopyBytes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CopyEntryDataDirect,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,CreateZip,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,CreateZip,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractZip,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractZip,The method has 8 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,HbCreateDecodeTables,The method has 7 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbAssignCodes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetAsciiBytes,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,UpdateCommentOnly,The length of the parameter CentralHeaderCommentSizeOffset is 30.
Long Statement,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\PathFilter.cs,IsMatch,The length of the statement  "		result = (MinSize <= fileInfo.Length) && (MaxSize >= fileInfo.Length) && (MinDate <= fileInfo.LastWriteTime) && (MaxDate >= fileInfo.LastWriteTime); " is 148.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESStream.cs,Read,The length of the statement  "					throw new Exception ("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n" + "The file may be damaged."); " is 182.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,TransformBlock,The length of the statement  "			/* encrypt the nonce to form next xor buffer    */_encryptor.TransformBlock (_counterNonce' 0' _blockSize' _encryptBuffer' 0); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,HasDosAttributes,The length of the statement  "		if (((HostSystem == (int)HostSystemID.Msdos) || (HostSystem == (int)HostSystemID.WindowsNT)) && (ExternalFileAttributes & attributes) == attributes) { " is 150.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "		if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "			DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "	if (header == ZipConstants.CentralHeaderSignature || header == ZipConstants.EndOfCentralDirectorySignature || header == ZipConstants.CentralHeaderDigitalSignature || header == ZipConstants.ArchiveExtraDataSignature || header == ZipConstants.Zip64CentralFileHeaderSignature) { " is 275.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "	if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))) { " is 143.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) { " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) { " is 127.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) { " is 158.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) { " is 363.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "			if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) { " is 135.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "					throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 130.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size)); " is 125.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "				throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize)); " is 156.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,UpdateCommentOnly,The length of the statement  "		long locatedCentralDirOffset = updateFile.LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff); " is 174.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The length of the statement  "	long locatedEndOfCentralDir = LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseStream_.Length' ZipConstants.EndOfCentralRecordBaseSize' 0xffff); " is 170.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The length of the statement  "	if ((thisDiskNumber == 0xffff) || (startCentralDirDisk == 0xffff) || (entriesForThisDisk == 0xffff) || (entriesForWholeCentralDir == 0xffff) || (centralDirSize == 0xffffffff) || (offsetOfCentralDir == 0xffffffff)) { " is 215.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The length of the statement  "		long offset = LocateBlockWithSignature (ZipConstants.Zip64CentralDirLocatorSignature' locatedEndOfCentralDir' 0' 0x1000); " is 121.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The length of the statement  "	if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The length of the statement  "	if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The length of the statement  "		result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write); " is 132.
Long Statement,ICSharpCode.SharpZipLib.Zip,DiskArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetTemporaryOutput,The length of the statement  "		temporaryStream_ = Alphaleonis.Win32.Filesystem.File.Open (temporaryName_' FileMode.OpenOrCreate' FileAccess.Write' FileShare.None); " is 132.
Long Statement,ICSharpCode.SharpZipLib.Zip,DiskArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetTemporaryOutput,The length of the statement  "		temporaryStream_ = Alphaleonis.Win32.Filesystem.File.Open (temporaryName_' FileMode.OpenOrCreate' FileAccess.Write' FileShare.None); " is 132.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,CreateZip,The length of the statement  "	CreateZip (Alphaleonis.Win32.Filesystem.File.Create (zipFileName)' sourceDirectory' recurse' fileFilter' directoryFilter); " is 122.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractZip,The length of the statement  "	Stream inputStream = Alphaleonis.Win32.Filesystem.File.Open (zipFileName' FileMode.Open' FileAccess.Read' FileShare.Read); " is 122.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractZip,The length of the statement  "	ExtractZip (inputStream' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime' true); " is 122.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractZip,The length of the statement  "				if (directoryFilter_.IsMatch (Alphaleonis.Win32.Filesystem.Path.GetDirectoryName (entry.Name)) && fileFilter_.IsMatch (entry.Name)) { " is 133.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ProcessFile,The length of the statement  "			using (FileStream stream = Alphaleonis.Win32.Filesystem.File.Open (e.Name' FileMode.Open' FileAccess.Read' FileShare.Read)) { " is 125.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The length of the statement  "						StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size); " is 148.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractEntry,The length of the statement  "			dirName = Alphaleonis.Win32.Filesystem.Path.GetDirectoryName (Alphaleonis.Win32.Filesystem.Path.GetFullPath (targetName)); " is 122.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,NameIsValid,The length of the statement  "	return (name != null) && (name.Length > 0) && (name.IndexOfAny (Alphaleonis.Win32.Filesystem.Path.GetInvalidPathChars ()) < 0); " is 127.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The length of the statement  "				_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 120.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntryFactory.cs,MakeFileEntry,The length of the statement  "	ZipEntry result = new ZipEntry (nameTransform_.TransformFile (entryName != null && entryName.Length > 0 ? entryName : fileName)); " is 129.
Long Statement,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadFooter,The length of the statement  "	uint total = (uint)((uint)footer [4] & 0xff) | (uint)(((uint)footer [5] & 0xff) << 8) | (uint)(((uint)footer [6] & 0xff) << 16) | (uint)((uint)footer [7] << 24); " is 161.
Long Statement,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The length of the statement  "				while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) { " is 135.
Long Statement,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The length of the statement  "			weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff))); " is 212.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,GetFileTarHeader,The length of the statement  "	header.ModTime = Alphaleonis.Win32.Filesystem.File.GetLastWriteTime (file.Replace ('/'' Alphaleonis.Win32.Filesystem.Path.DirectorySeparatorChar)).ToUniversalTime (); " is 166.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,Equals,The length of the statement  "		result = (name == localHeader.name) && (mode == localHeader.mode) && (UserId == localHeader.UserId) && (GroupId == localHeader.GroupId) && (Size == localHeader.Size) && (ModTime == localHeader.ModTime) && (Checksum == localHeader.Checksum) && (TypeFlag == localHeader.TypeFlag) && (LinkName == localHeader.LinkName) && (Magic == localHeader.Magic) && (Version == localHeader.Version) && (UserName == localHeader.UserName) && (GroupName == localHeader.GroupName) && (DevMajor == localHeader.DevMajor) && (DevMinor == localHeader.DevMinor); " is 538.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseBinaryOrOctal,The length of the statement  "		// File sizes over 8GB are stored in 8 right-justified bytes of binary indicated by setting the high-order bit of the leftmost byte of a numeric field. " is 151.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "		string errorText = string.Format ("TarBuffer.WriteBlock - block to write has length '{0}' which is not the block size of '{1}'"' block.Length' BlockSize); " is 154.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "		string errorText = string.Format ("TarBuffer.WriteBlock - record has length '{0}' with offset '{1}' which is less than the record size of '{2}'"' buffer.Length' offset' recordSize); " is 181.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarOutputStream.cs,CloseEntry,The length of the statement  "		string errorText = string.Format ("Entry closed at '{0}' before the '{1}' bytes specified in the header were written"' currBytes' currSize); " is 140.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarOutputStream.cs,Write,The length of the statement  "		string errorText = string.Format ("request to write '{0}' bytes exceeds size in header of '{1}' bytes"' count' this.currSize); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarInputStream.cs,GetNextEntry,The length of the statement  "			else if (header.TypeFlag != TarHeader.LF_NORMAL && header.TypeFlag != TarHeader.LF_OLDNORM && header.TypeFlag != TarHeader.LF_DIR) { " is 132.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarInputStream.cs,GetNextEntry,The length of the statement  "			string errorText = string.Format ("Bad header in record {0} block {1} {2}"' tarBuffer.CurrentRecord' tarBuffer.CurrentBlock' ex.Message); " is 137.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The length of the statement  "	int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength () + literalTree.GetEncodedLength () + distTree.GetEncodedLength () + extra_bits; " is 142.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "		if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) { " is 180.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) { " is 339.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateFast,The length of the statement  "		if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 175.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "			if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "				if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) { " is 123.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "header == ZipConstants.CentralHeaderSignature || header == ZipConstants.EndOfCentralDirectorySignature || header == ZipConstants.CentralHeaderDigitalSignature || header == ZipConstants.ArchiveExtraDataSignature || header == ZipConstants.Zip64CentralFileHeaderSignature"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,BodyRead,The conditional expression  "(flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The conditional expression  "(thisDiskNumber == 0xffff) || (startCentralDirDisk == 0xffff) || (entriesForThisDisk == 0xffff) || (entriesForWholeCentralDir == 0xffff) || (centralDirSize == 0xffffffff) || (offsetOfCentralDir == 0xffffffff)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,Initialize,The conditional expression  "magic1 != 'B' || magic2 != 'Z' || magic3 != 'h' || magic4 < '1' || magic4 > '9'"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The conditional expression  "!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The conditional expression  "block == null || quadrant == null || zptr == null || ftab == null"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The conditional expression  "(b < 8) || ((b > 13) && (b < 32)) || (b == 255)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full  (blockStart < WSIZE && storedLength >= MAX_DIST) || // Block may move out of window  flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path != null) && (path.Length > 0)) {  	if ((path [0] == '\\') || (path [0] == '/')) {  		// UNC name ?  		if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  			int index = 2;  			int elements = 2;  			// Scan for two separate elements \\machine\share\restofpath  			while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  				index++;  			}  			index++;  			if (index < path.Length) {  				result = path.Substring (index);  			}  			else {  				result = "";  			}  		}  	}  	else if ((path.Length > 1) && (path [1] == ':')) {  		int dropCount = 2;  		if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  			dropCount = 3;  		}  		result = result.Remove (0' dropCount);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path [0] == '\\') || (path [0] == '/')) {  	// UNC name ?  	if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  		int index = 2;  		int elements = 2;  		// Scan for two separate elements \\machine\share\restofpath  		while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  			index++;  		}  		index++;  		if (index < path.Length) {  			result = path.Substring (index);  		}  		else {  			result = "";  		}  	}  }  else if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  	int index = 2;  	int elements = 2;  	// Scan for two separate elements \\machine\share\restofpath  	while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  		index++;  	}  	index++;  	if (index < path.Length) {  		result = path.Substring (index);  	}  	else {  		result = "";  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && ((path [1] == '\\') || (path [1] == '/'))) {  	int index = 2;  	int elements = 2;  	// Scan for two separate elements \\machine\share\restofpath  	while ((index <= path.Length) && (((path [index] != '\\') && (path [index] != '/')) || (--elements > 0))) {  		index++;  	}  	index++;  	if (index < path.Length) {  		result = path.Substring (index);  	}  	else {  		result = "";  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 1) && (path [1] == ':')) {  	int dropCount = 2;  	if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  		dropCount = 3;  	}  	result = result.Remove (0' dropCount);  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if ((path.Length > 2) && ((path [2] == '\\') || (path [2] == '/'))) {  	dropCount = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: dropCount = 3;  
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  	throw new ArgumentException ("Buffer is too small"' "buffer");  }  
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  	throw new ArgumentException ("Buffer is too small"' "buffer");  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESStream.cs,ZipAESStream,The following statement contains a magic number: _slideBuffer = new byte[1024];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32)  	// 24 valid for AES but not supported by Winzip  	throw new Exception ("Invalid blocksize " + blockSize + ". Must be 16 or 32.");  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32)  	// 24 valid for AES but not supported by Winzip  	throw new Exception ("Invalid blocksize " + blockSize + ". Must be 16 or 32.");  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  	throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  	throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [1] = newKeys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [1] = (byte)((newKeys [0] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [4] = (byte)(newKeys [1] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if (keyData.Length != 12) {  	throw new InvalidOperationException ("Key length is not valid");  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [1] = keys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys [2] = 0;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > count) {  		n = count;  	}  	count -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buffer [offset++] & 0xff);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Crc32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable [(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Crc32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ value) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Crc32.cs,Update,The following statement contains a magic number: while (--count >= 0) {  	crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\Crc32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\StrangeCrc.cs,Update,The following statement contains a magic number: if (temp < 0) {  	temp = 256 + temp;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\StrangeCrc.cs,Update,The following statement contains a magic number: temp = 256 + temp;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Checksums\StrangeCrc.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table [temp]));  
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 2] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\WindowsNameTransform.cs,WindowsNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 3] = ':';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10)) {  	throw new ArgumentOutOfRangeException ("versionRequiredToExtract");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x0001)) {  	// Version required to extract is ignored here as some archivers dont set it correctly  	// in theory it should be version 45 or higher  	// The recorded size will change but remember that this is zip64.  	forceZip64_ = true;  	if (extraData.ValueLength < 4) {  		throw new ZipException ("Extra data extended Zip64 information length is invalid");  	}  	if (localHeader || (size == uint.MaxValue)) {  		size = (ulong)extraData.ReadLong ();  	}  	if (localHeader || (compressedSize == uint.MaxValue)) {  		compressedSize = (ulong)extraData.ReadLong ();  	}  	if (!localHeader && (offset == uint.MaxValue)) {  		offset = extraData.ReadLong ();  	}  	// Disk number on which file starts is ignored  }  else {  	if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) {  		throw new ZipException ("Zip64 Extended information required but is missing.");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new ZipException ("Extra data extended Zip64 information length is invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new ZipException ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				long lastAccess = extraData.ReadLong ();  				long createTime = extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new ZipException ("NTFS Extra data invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			long lastAccess = extraData.ReadLong ();  			long createTime = extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			long lastAccess = extraData.ReadLong ();  			long createTime = extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModification = extraData.ReadLong ();  		long lastAccess = extraData.ReadLong ();  		long createTime = extraData.ReadLong ();  		DateTime = System.DateTime.FromFileTime (lastModification);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	extraData.Skip (ntfsLength);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModification = extraData.ReadLong ();  	long lastAccess = extraData.ReadLong ();  	long createTime = extraData.ReadLong ();  	DateTime = System.DateTime.FromFileTime (lastModification);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (extraData.Find (0x9901)) {  	// Set version and flag for Zipfile.CreateAndInitDecryptionStream  	versionToExtract = ZipConstants.VERSION_AES;  	// Ver 5.1 = AES see "Version" getter  	// Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream  	Flags = Flags | (int)GeneralBitFlags.StrongEncryption;  	//  	// Unpack AES extra data field see http://www.winzip.com/aes_info.htm  	int length = extraData.ValueLength;  	// Data size currently 7  	if (length < 7)  		throw new ZipException ("AES Extra Data Length " + length + " invalid.");  	int ver = extraData.ReadShort ();  	// Version number (1=AE-1 2=AE-2)  	int vendorId = extraData.ReadShort ();  	// 2-character vendor ID 0x4541 = "AE"  	int encrStrength = extraData.ReadByte ();  	// encryption strength 1 = 128 2 = 192 3 = 256  	int actualCompress = extraData.ReadShort ();  	// The actual compression method used to compress the file  	_aesVer = ver;  	_aesEncryptionStrength = encrStrength;  	method = (CompressionMethod)actualCompress;  }  else  	throw new ZipException ("AES Extra Data missing");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (length < 7)  	throw new ZipException ("AES Extra Data Length " + length + " invalid.");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  	entry.Crc = crc2 & 0xFFFFFFFFL;  	entry.Size = size & 0xFFFFFFFFL;  	entry.CompressedSize = csize & 0xFFFFFFFFL;  	entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  }  else {  	// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  	// says these values are zero under these circumstances.  	if (crc2 != 0) {  		entry.Crc = crc2 & 0xFFFFFFFFL;  	}  	if (size != 0) {  		entry.Size = size & 0xFFFFFFFFL;  	}  	if (csize != 0) {  		entry.CompressedSize = csize & 0xFFFFFFFFL;  	}  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,CompleteCloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	ReadDataDescriptor ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  	if ((flags & 8) != 0) {  		// We don't know how much we must skip' read until end.  		byte[] tmp = new byte[4096];  		// Read will close this entry  		while (Read (tmp' 0' tmp.Length) > 0) {  		}  		return;  	}  	csize -= inf.TotalIn;  	inputBuffer.Available += inf.RemainingInput;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  	if ((flags & 8) != 0) {  		// We don't know how much we must skip' read until end.  		byte[] tmp = new byte[4096];  		// Read will close this entry  		while (Read (tmp' 0' tmp.Length) > 0) {  		}  		return;  	}  	csize -= inf.TotalIn;  	inputBuffer.Available += inf.RemainingInput;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	// We don't know how much we must skip' read until end.  	byte[] tmp = new byte[4096];  	// Read will close this entry  	while (Read (tmp' 0' tmp.Length) > 0) {  	}  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  	// We don't know how much we must skip' read until end.  	byte[] tmp = new byte[4096];  	// Read will close this entry  	while (Read (tmp' 0' tmp.Length) > 0) {  	}  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: switch (method) {  case (int)CompressionMethod.Deflated:  	count = base.Read (buffer' offset' count);  	if (count <= 0) {  		if (!inf.IsFinished) {  			throw new ZipException ("Inflater not finished!");  		}  		inputBuffer.Available = inf.RemainingInput;  		// A csize of -1 is from an unpatched local header  		if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  			throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  		}  		inf.Reset ();  		finished = true;  	}  	break;  case (int)CompressionMethod.Stored:  	if ((count > csize) && (csize >= 0)) {  		count = (int)csize;  	}  	if (count > 0) {  		count = inputBuffer.ReadClearTextBuffer (buffer' offset' count);  		if (count > 0) {  			csize -= count;  			size -= count;  		}  	}  	if (csize == 0) {  		finished = true;  	}  	else {  		if (count < 0) {  			throw new ZipException ("EOF in stored block");  		}  	}  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: if (count <= 0) {  	if (!inf.IsFinished) {  		throw new ZipException ("Inflater not finished!");  	}  	inputBuffer.Available = inf.RemainingInput;  	// A csize of -1 is from an unpatched local header  	if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  		throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  	}  	inf.Reset ();  	finished = true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  	throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: unchecked {  	baseOutputStream_.WriteByte ((byte)(value & 0xff));  	baseOutputStream_.WriteByte ((byte)((value >> 8) & 0xff));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: baseOutputStream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: unchecked {  	WriteLeShort (value);  	WriteLeShort (value >> 16);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: WriteLeShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: unchecked {  	WriteLeInt ((int)value);  	WriteLeInt ((int)(value >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: WriteLeInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (headerInfoAvailable == false) {  	if (CanPatchEntries == false) {  		// Only way to record size and compressed size is to append a data descriptor  		// after compressed data.  		// Stored entries of this form have already been converted to deflating.  		entry.Flags |= 8;  	}  	else {  		patchEntryHeader = true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (CanPatchEntries == false) {  	// Only way to record size and compressed size is to append a data descriptor  	// after compressed data.  	// Stored entries of this form have already been converted to deflating.  	entry.Flags |= 8;  }  else {  	patchEntryHeader = true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: entry.Flags |= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (Password != null) {  	entry.IsCrypted = true;  	if (entry.Crc < 0) {  		// Need to append a data descriptor as the crc isnt available for use  		// with encryption' the date is used instead.  Setting the flag  		// indicates this to the decompressor.  		entry.Flags |= 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.Crc < 0) {  	// Need to append a data descriptor as the crc isnt available for use  	// with encryption' the date is used instead.  Setting the flag  	// indicates this to the decompressor.  	entry.Flags |= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: entry.Flags |= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.IsCrypted) {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.AESKeySize > 0) {  		WriteAESHeader (entry);  	}  	else  	#endif  	 {  		if (entry.Crc < 0) {  			// so testing Zip will says its ok  			WriteEncryptionHeader (entry.DosTime << 16);  		}  		else {  			WriteEncryptionHeader (entry.Crc);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.AESKeySize > 0) {  	WriteAESHeader (entry);  }  else  #endif   {  	if (entry.Crc < 0) {  		// so testing Zip will says its ok  		WriteEncryptionHeader (entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.Crc < 0) {  	// so testing Zip will says its ok  	WriteEncryptionHeader (entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: WriteEncryptionHeader (entry.DosTime << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if (curEntry.AESKeySize > 0) {  	baseOutputStream_.Write (AESAuthCode' 0' 10);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: baseOutputStream_.Write (AESAuthCode' 0' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if ((curEntry.Flags & 8) != 0) {  	WriteLeInt (ZipConstants.DataDescriptorSignature);  	WriteLeInt (unchecked((int)curEntry.Crc));  	if (curEntry.LocalHeaderRequiresZip64) {  		WriteLeLong (curEntry.CompressedSize);  		WriteLeLong (curEntry.Size);  		offset += ZipConstants.Zip64DataDescriptorSize;  	}  	else {  		WriteLeInt ((int)curEntry.CompressedSize);  		WriteLeInt ((int)curEntry.Size);  		offset += ZipConstants.DataDescriptorSize;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: foreach (ZipEntry entry in entries) {  	WriteLeInt (ZipConstants.CentralHeaderSignature);  	WriteLeShort (ZipConstants.VersionMadeBy);  	WriteLeShort (entry.Version);  	WriteLeShort (entry.Flags);  	WriteLeShort ((short)entry.CompressionMethodForHeader);  	WriteLeInt ((int)entry.DosTime);  	WriteLeInt ((int)entry.Crc);  	if (entry.IsZip64Forced () || (entry.CompressedSize >= uint.MaxValue)) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.CompressedSize);  	}  	if (entry.IsZip64Forced () || (entry.Size >= uint.MaxValue)) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.Size);  	}  	byte[] name = ZipConstants.ConvertToArray (entry.Flags' entry.Name);  	if (name.Length > 0xffff) {  		throw new ZipException ("Name too long.");  	}  	ZipExtraData ed = new ZipExtraData (entry.ExtraData);  	if (entry.CentralHeaderRequiresZip64) {  		ed.StartNewEntry ();  		if (entry.IsZip64Forced () || (entry.Size >= 0xffffffff)) {  			ed.AddLeLong (entry.Size);  		}  		if (entry.IsZip64Forced () || (entry.CompressedSize >= 0xffffffff)) {  			ed.AddLeLong (entry.CompressedSize);  		}  		if (entry.Offset >= 0xffffffff) {  			ed.AddLeLong (entry.Offset);  		}  		ed.AddNewEntry (1);  	}  	else {  		ed.Delete (1);  	}  	#if !NET_1_1 && !NETCF_2_0  	if (entry.AESKeySize > 0) {  		AddExtraDataAES (entry' ed);  	}  	#endif  	byte[] extra = ed.GetEntryData ();  	byte[] entryComment = (entry.Comment != null) ? ZipConstants.ConvertToArray (entry.Flags' entry.Comment) : new byte[0];  	if (entryComment.Length > 0xffff) {  		throw new ZipException ("Comment too long.");  	}  	WriteLeShort (name.Length);  	WriteLeShort (extra.Length);  	WriteLeShort (entryComment.Length);  	WriteLeShort (0);  	// disk number  	WriteLeShort (0);  	// internal file attributes  	// external file attributes  	if (entry.ExternalFileAttributes != -1) {  		WriteLeInt (entry.ExternalFileAttributes);  	}  	else {  		if (entry.IsDirectory) {  			// mark entry as directory (from nikolam.AT.perfectinfo.com)  			WriteLeInt (16);  		}  		else {  			WriteLeInt (0);  		}  	}  	if (entry.Offset >= uint.MaxValue) {  		WriteLeInt (-1);  	}  	else {  		WriteLeInt ((int)entry.Offset);  	}  	if (name.Length > 0) {  		baseOutputStream_.Write (name' 0' name.Length);  	}  	if (extra.Length > 0) {  		baseOutputStream_.Write (extra' 0' extra.Length);  	}  	if (entryComment.Length > 0) {  		baseOutputStream_.Write (entryComment' 0' entryComment.Length);  	}  	sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  	WriteLeInt (entry.ExternalFileAttributes);  }  else {  	if (entry.IsDirectory) {  		// mark entry as directory (from nikolam.AT.perfectinfo.com)  		WriteLeInt (16);  	}  	else {  		WriteLeInt (0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: if (entry.IsDirectory) {  	// mark entry as directory (from nikolam.AT.perfectinfo.com)  	WriteLeInt (16);  }  else {  	WriteLeInt (0);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: WriteLeInt (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: try {  	int entryIndex = 0;  	while (testing && (entryIndex < Count)) {  		if (resultHandler != null) {  			status.SetEntry (this [entryIndex]);  			status.SetOperation (TestOperation.EntryHeader);  			resultHandler (status' null);  		}  		try {  			TestLocalHeader (this [entryIndex]' test);  		}  		catch (ZipException ex) {  			status.AddError ();  			if (resultHandler != null) {  				resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  			}  			if (strategy == TestStrategy.FindFirstError) {  				testing = false;  			}  		}  		if (testing && testData && this [entryIndex].IsFile) {  			if (resultHandler != null) {  				status.SetOperation (TestOperation.EntryData);  				resultHandler (status' null);  			}  			Crc32 crc = new Crc32 ();  			using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  				byte[] buffer = new byte[4096];  				long totalBytes = 0;  				int bytesRead;  				while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  					crc.Update (buffer' 0' bytesRead);  					if (resultHandler != null) {  						totalBytes += bytesRead;  						status.SetBytesTested (totalBytes);  						resultHandler (status' null);  					}  				}  			}  			if (this [entryIndex].Crc != crc.Value) {  				status.AddError ();  				if (resultHandler != null) {  					resultHandler (status' "CRC mismatch");  				}  				if (strategy == TestStrategy.FindFirstError) {  					testing = false;  				}  			}  			if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				ZipHelperStream helper = new ZipHelperStream (baseStream_);  				DescriptorData data = new DescriptorData ();  				helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  				if (this [entryIndex].Crc != data.Crc) {  					status.AddError ();  				}  				if (this [entryIndex].CompressedSize != data.CompressedSize) {  					status.AddError ();  				}  				if (this [entryIndex].Size != data.Size) {  					status.AddError ();  				}  			}  		}  		if (resultHandler != null) {  			status.SetOperation (TestOperation.EntryComplete);  			resultHandler (status' null);  		}  		entryIndex += 1;  	}  	if (resultHandler != null) {  		status.SetOperation (TestOperation.MiscellaneousTests);  		resultHandler (status' null);  	}  	// TODO: the 'Corrina Johns' test where local headers are missing from  	// the central directory.  They are therefore invisible to many archivers.  }  catch (Exception ex) {  	status.AddError ();  	if (resultHandler != null) {  		resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: while (testing && (entryIndex < Count)) {  	if (resultHandler != null) {  		status.SetEntry (this [entryIndex]);  		status.SetOperation (TestOperation.EntryHeader);  		resultHandler (status' null);  	}  	try {  		TestLocalHeader (this [entryIndex]' test);  	}  	catch (ZipException ex) {  		status.AddError ();  		if (resultHandler != null) {  			resultHandler (status' string.Format ("Exception during test - '{0}'"' ex.Message));  		}  		if (strategy == TestStrategy.FindFirstError) {  			testing = false;  		}  	}  	if (testing && testData && this [entryIndex].IsFile) {  		if (resultHandler != null) {  			status.SetOperation (TestOperation.EntryData);  			resultHandler (status' null);  		}  		Crc32 crc = new Crc32 ();  		using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  			byte[] buffer = new byte[4096];  			long totalBytes = 0;  			int bytesRead;  			while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  				crc.Update (buffer' 0' bytesRead);  				if (resultHandler != null) {  					totalBytes += bytesRead;  					status.SetBytesTested (totalBytes);  					resultHandler (status' null);  				}  			}  		}  		if (this [entryIndex].Crc != crc.Value) {  			status.AddError ();  			if (resultHandler != null) {  				resultHandler (status' "CRC mismatch");  			}  			if (strategy == TestStrategy.FindFirstError) {  				testing = false;  			}  		}  		if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  			ZipHelperStream helper = new ZipHelperStream (baseStream_);  			DescriptorData data = new DescriptorData ();  			helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  			if (this [entryIndex].Crc != data.Crc) {  				status.AddError ();  			}  			if (this [entryIndex].CompressedSize != data.CompressedSize) {  				status.AddError ();  			}  			if (this [entryIndex].Size != data.Size) {  				status.AddError ();  			}  		}  	}  	if (resultHandler != null) {  		status.SetOperation (TestOperation.EntryComplete);  		resultHandler (status' null);  	}  	entryIndex += 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: if (testing && testData && this [entryIndex].IsFile) {  	if (resultHandler != null) {  		status.SetOperation (TestOperation.EntryData);  		resultHandler (status' null);  	}  	Crc32 crc = new Crc32 ();  	using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  		byte[] buffer = new byte[4096];  		long totalBytes = 0;  		int bytesRead;  		while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  			crc.Update (buffer' 0' bytesRead);  			if (resultHandler != null) {  				totalBytes += bytesRead;  				status.SetBytesTested (totalBytes);  				resultHandler (status' null);  			}  		}  	}  	if (this [entryIndex].Crc != crc.Value) {  		status.AddError ();  		if (resultHandler != null) {  			resultHandler (status' "CRC mismatch");  		}  		if (strategy == TestStrategy.FindFirstError) {  			testing = false;  		}  	}  	if ((this [entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  		ZipHelperStream helper = new ZipHelperStream (baseStream_);  		DescriptorData data = new DescriptorData ();  		helper.ReadDataDescriptor (this [entryIndex].LocalHeaderRequiresZip64' data);  		if (this [entryIndex].Crc != data.Crc) {  			status.AddError ();  		}  		if (this [entryIndex].CompressedSize != data.CompressedSize) {  			status.AddError ();  		}  		if (this [entryIndex].Size != data.Size) {  			status.AddError ();  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: using (Stream entryStream = this.GetInputStream (this [entryIndex])) {  	byte[] buffer = new byte[4096];  	long totalBytes = 0;  	int bytesRead;  	while ((bytesRead = entryStream.Read (buffer' 0' buffer.Length)) > 0) {  		crc.Update (buffer' 0' bytesRead);  		if (resultHandler != null) {  			totalBytes += bytesRead;  			status.SetBytesTested (totalBytes);  			resultHandler (status' null);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  	bool testHeader = (tests & HeaderTest.Header) != 0;  	bool testData = (tests & HeaderTest.Extract) != 0;  	baseStream_.Seek (offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  	if ((int)ReadLEUint () != ZipConstants.LocalHeaderSignature) {  		throw new ZipException (string.Format ("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  	}  	short extractVersion = (short)(ReadLEUshort () & 0x00ff);  	short localFlags = (short)ReadLEUshort ();  	short compressionMethod = (short)ReadLEUshort ();  	short fileTime = (short)ReadLEUshort ();  	short fileDate = (short)ReadLEUshort ();  	uint crcValue = ReadLEUint ();  	long compressedSize = ReadLEUint ();  	long size = ReadLEUint ();  	int storedNameLength = ReadLEUshort ();  	int extraDataLength = ReadLEUshort ();  	byte[] nameData = new byte[storedNameLength];  	StreamUtils.ReadFully (baseStream_' nameData);  	byte[] extraData = new byte[extraDataLength];  	StreamUtils.ReadFully (baseStream_' extraData);  	ZipExtraData localExtraData = new ZipExtraData (extraData);  	// Extra data / zip64 checks  	if (localExtraData.Find (1)) {  		// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  		// and size or compressedSize = MaxValue' due to rogue creators.  		size = localExtraData.ReadLong ();  		compressedSize = localExtraData.ReadLong ();  		if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  			// These may be valid if patched later  			if ((size != -1) && (size != entry.Size)) {  				throw new ZipException ("Size invalid for descriptor");  			}  			if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  				throw new ZipException ("Compressed size invalid for descriptor");  			}  		}  	}  	else {  		// No zip64 extra data but entry requires it.  		if ((extractVersion >= ZipConstants.VersionZip64) && (((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  			throw new ZipException ("Required Zip64 extended information missing");  		}  	}  	if (testData) {  		if (entry.IsFile) {  			if (!entry.IsCompressionMethodSupported ()) {  				throw new ZipException ("Compression method not supported");  			}  			if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  				throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  			}  			if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  				throw new ZipException ("The library does not support the zip version required to extract this entry");  			}  		}  	}  	if (testHeader) {  		if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  		(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  			throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  		}  		// Local entry flags dont have reserved bit set on.  		if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  			throw new ZipException ("Reserved bit flags cannot be set.");  		}  		// Encryption requires extract version >= 20  		if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  		// Strong encryption requires encryption flag to be set and extract version >= 50.  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  				throw new ZipException ("Strong encryption flag set but encryption flag is not set");  			}  			if (extractVersion < 50) {  				throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  			}  		}  		// Patched entries require extract version >= 27  		if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  			throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  		}  		// Central header flags match local entry flags.  		if (localFlags != entry.Flags) {  			throw new ZipException ("Central header/local header flags mismatch");  		}  		// Central header compression method matches local entry  		if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  			throw new ZipException ("Central header/local header compression method mismatch");  		}  		if (entry.Version != extractVersion) {  			throw new ZipException ("Extract version mismatch");  		}  		// Strong encryption and extract version match  		if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  			if (extractVersion < 62) {  				throw new ZipException ("Strong encryption flag set but version not high enough");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  			if ((fileTime != 0) || (fileDate != 0)) {  				throw new ZipException ("Header masked set but date/time values non-zero");  			}  		}  		if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  			if (crcValue != (uint)entry.Crc) {  				throw new ZipException ("Central header/local header crc mismatch");  			}  		}  		// Crc valid for empty entry.  		// This will also apply to streamed entries where size isnt known and the header cant be patched  		if ((size == 0) && (compressedSize == 0)) {  			if (crcValue != 0) {  				throw new ZipException ("Invalid CRC for empty entry");  			}  		}  		// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  		// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  		if (entry.Name.Length > storedNameLength) {  			throw new ZipException ("File name length mismatch");  		}  		// Name data has already been read convert it and compare.  		string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  		// Central directory and local entry name match  		if (localName != entry.Name) {  			throw new ZipException ("Central header and local header file name mismatch");  		}  		// Directories have zero actual size but can have compressed size  		if (entry.IsDirectory) {  			if (size > 0) {  				throw new ZipException ("Directory cannot have size");  			}  			// There may be other cases where the compressed size can be greater than this?  			// If so until details are known we will be strict.  			if (entry.IsCrypted) {  				if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  					throw new ZipException ("Directory compressed size invalid");  				}  			}  			else if (compressedSize > 2) {  				// When not compressed the directory size can validly be 2 bytes  				// if the true size wasnt known when data was originally being written.  				// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		if (!ZipNameTransform.IsValidName (localName' true)) {  			throw new ZipException ("Name is invalid");  		}  	}  	// Tests that apply to both data and header.  	// Size can be verified only if it is known in the local header.  	// it will always be known in the central header.  	if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) || ((size > 0) || (compressedSize > 0))) {  		if (size != entry.Size) {  			throw new ZipException (string.Format ("Size mismatch between central header({0}) and local header({1})"' entry.Size' size));  		}  		if (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1) {  			throw new ZipException (string.Format ("Compressed size mismatch between central header({0}) and local header({1})"' entry.CompressedSize' compressedSize));  		}  	}  	int extraLength = storedNameLength + extraDataLength;  	return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testData) {  	if (entry.IsFile) {  		if (!entry.IsCompressionMethodSupported ()) {  			throw new ZipException ("Compression method not supported");  		}  		if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  			throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  		}  		if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  			throw new ZipException ("The library does not support the zip version required to extract this entry");  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsFile) {  	if (!entry.IsCompressionMethodSupported ()) {  		throw new ZipException ("Compression method not supported");  	}  	if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  		throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  	}  	if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  		throw new ZipException ("The library does not support the zip version required to extract this entry");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion > ZipConstants.VersionMadeBy) || ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  	throw new ZipException (string.Format ("Version required to extract this entry not supported ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (testHeader) {  	if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  	(extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  		throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  	}  	// Local entry flags dont have reserved bit set on.  	if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  		throw new ZipException ("Reserved bit flags cannot be set.");  	}  	// Encryption requires extract version >= 20  	if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  	// Strong encryption requires encryption flag to be set and extract version >= 50.  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  			throw new ZipException ("Strong encryption flag set but encryption flag is not set");  		}  		if (extractVersion < 50) {  			throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  		}  	}  	// Patched entries require extract version >= 27  	if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  		throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  	}  	// Central header flags match local entry flags.  	if (localFlags != entry.Flags) {  		throw new ZipException ("Central header/local header flags mismatch");  	}  	// Central header compression method matches local entry  	if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  		throw new ZipException ("Central header/local header compression method mismatch");  	}  	if (entry.Version != extractVersion) {  		throw new ZipException ("Extract version mismatch");  	}  	// Strong encryption and extract version match  	if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  		if (extractVersion < 62) {  			throw new ZipException ("Strong encryption flag set but version not high enough");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  		if ((fileTime != 0) || (fileDate != 0)) {  			throw new ZipException ("Header masked set but date/time values non-zero");  		}  	}  	if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  		if (crcValue != (uint)entry.Crc) {  			throw new ZipException ("Central header/local header crc mismatch");  		}  	}  	// Crc valid for empty entry.  	// This will also apply to streamed entries where size isnt known and the header cant be patched  	if ((size == 0) && (compressedSize == 0)) {  		if (crcValue != 0) {  			throw new ZipException ("Invalid CRC for empty entry");  		}  	}  	// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  	// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  	if (entry.Name.Length > storedNameLength) {  		throw new ZipException ("File name length mismatch");  	}  	// Name data has already been read convert it and compare.  	string localName = ZipConstants.ConvertToStringExt (localFlags' nameData);  	// Central directory and local entry name match  	if (localName != entry.Name) {  		throw new ZipException ("Central header and local header file name mismatch");  	}  	// Directories have zero actual size but can have compressed size  	if (entry.IsDirectory) {  		if (size > 0) {  			throw new ZipException ("Directory cannot have size");  		}  		// There may be other cases where the compressed size can be greater than this?  		// If so until details are known we will be strict.  		if (entry.IsCrypted) {  			if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  				throw new ZipException ("Directory compressed size invalid");  			}  		}  		else if (compressedSize > 2) {  			// When not compressed the directory size can validly be 2 bytes  			// if the true size wasnt known when data was originally being written.  			// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	if (!ZipNameTransform.IsValidName (localName' true)) {  		throw new ZipException ("Name is invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((extractVersion <= 63) && // Ignore later versions as we dont know about them..  (extractVersion != 10) && (extractVersion != 11) && (extractVersion != 20) && (extractVersion != 21) && (extractVersion != 25) && (extractVersion != 27) && (extractVersion != 45) && (extractVersion != 46) && (extractVersion != 50) && (extractVersion != 51) && (extractVersion != 52) && (extractVersion != 61) && (extractVersion != 62) && (extractVersion != 63)) {  	throw new ZipException (string.Format ("Version required to extract this entry is invalid ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  	throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  	if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  		throw new ZipException ("Strong encryption flag set but encryption flag is not set");  	}  	if (extractVersion < 50) {  		throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (extractVersion < 50) {  	throw new ZipException (string.Format ("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  	throw new ZipException (string.Format ("Patched data requires higher version than ({0})"' extractVersion));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  	if (extractVersion < 62) {  		throw new ZipException ("Strong encryption flag set but version not high enough");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (extractVersion < 62) {  	throw new ZipException ("Strong encryption flag set but version not high enough");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	if (size > 0) {  		throw new ZipException ("Directory cannot have size");  	}  	// There may be other cases where the compressed size can be greater than this?  	// If so until details are known we will be strict.  	if (entry.IsCrypted) {  		if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	else if (compressedSize > 2) {  		// When not compressed the directory size can validly be 2 bytes  		// if the true size wasnt known when data was originally being written.  		// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  		throw new ZipException ("Directory compressed size invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	if (size > 0) {  		throw new ZipException ("Directory cannot have size");  	}  	// There may be other cases where the compressed size can be greater than this?  	// If so until details are known we will be strict.  	if (entry.IsCrypted) {  		if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  			throw new ZipException ("Directory compressed size invalid");  		}  	}  	else if (compressedSize > 2) {  		// When not compressed the directory size can validly be 2 bytes  		// if the true size wasnt known when data was originally being written.  		// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  		throw new ZipException ("Directory compressed size invalid");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsCrypted) {  	if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  		throw new ZipException ("Directory compressed size invalid");  	}  }  else if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (entry.IsCrypted) {  	if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  		throw new ZipException ("Directory compressed size invalid");  	}  }  else if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: if (compressedSize > 2) {  	// When not compressed the directory size can validly be 2 bytes  	// if the true size wasnt known when data was originally being written.  	// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  	throw new ZipException ("Directory compressed size invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLEShort,The following statement contains a magic number: baseStream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLEUshort,The following statement contains a magic number: baseStream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLeLong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  	WriteLEInt (entry.ExternalFileAttributes);  }  else {  	if (entry.IsDirectory) {  		WriteLEUint (16);  	}  	else {  		WriteLEUint (0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.IsDirectory) {  	WriteLEUint (16);  }  else {  	WriteLEUint (0);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: WriteLEUint (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	result = ZipConstants.DataDescriptorSize - 4;  	if (update.Entry.LocalHeaderRequiresZip64) {  		result = ZipConstants.Zip64DataDescriptorSize - 4;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	result = ZipConstants.DataDescriptorSize - 4;  	if (update.Entry.LocalHeaderRequiresZip64) {  		result = ZipConstants.Zip64DataDescriptorSize - 4;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: result = ZipConstants.DataDescriptorSize - 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if (update.Entry.LocalHeaderRequiresZip64) {  	result = ZipConstants.Zip64DataDescriptorSize - 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: result = ZipConstants.Zip64DataDescriptorSize - 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,GetOutputStream,The following statement contains a magic number: switch (entry.CompressionMethod) {  case CompressionMethod.Stored:  	result = new UncompressedStream (result);  	break;  case CompressionMethod.Deflated:  	DeflaterOutputStream dos = new DeflaterOutputStream (result' new Deflater (9' true));  	dos.IsStreamOwner = false;  	result = dos;  	break;  default:  	throw new ZipException ("Unknown compression method " + entry.CompressionMethod);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CopyEntry,The following statement contains a magic number: if (update.Entry.CompressedSize > 0) {  	const int NameLengthOffset = 26;  	long entryDataOffset = update.Entry.Offset + NameLengthOffset;  	// TODO: This wont work for SFX files!  	baseStream_.Seek (entryDataOffset' SeekOrigin.Begin);  	uint nameLength = ReadLEUshort ();  	uint extraLength = ReadLEUshort ();  	baseStream_.Seek (nameLength + extraLength' SeekOrigin.Current);  	CopyBytes (update' workFile.baseStream_' baseStream_' update.Entry.CompressedSize' false);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,UpdateCommentOnly,The following statement contains a magic number: using (updateFile) {  	long locatedCentralDirOffset = updateFile.LocateBlockWithSignature (ZipConstants.EndOfCentralDirectorySignature' baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff);  	if (locatedCentralDirOffset < 0) {  		throw new ZipException ("Cannot find central directory");  	}  	const int CentralHeaderCommentSizeOffset = 16;  	updateFile.Position += CentralHeaderCommentSizeOffset;  	byte[] rawComment = newComment_.RawComment;  	updateFile.WriteLEShort (rawComment.Length);  	updateFile.Write (rawComment' 0' rawComment.Length);  	updateFile.SetLength (updateFile.Position);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadLEUshort,The following statement contains a magic number: return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadLEUint,The following statement contains a magic number: return (uint)(ReadLEUshort () | (ReadLEUshort () << 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadLEUlong,The following statement contains a magic number: return ReadLEUint () | ((ulong)ReadLEUint () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  	offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  	if (offsetOfFirstEntry <= 0) {  		throw new ZipException ("Invalid embedded zip archive");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  	offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  	if (offsetOfFirstEntry <= 0) {  		throw new ZipException ("Invalid embedded zip archive");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  	if (ReadLEUint () != ZipConstants.CentralHeaderSignature) {  		throw new ZipException ("Wrong Central Directory signature");  	}  	int versionMadeBy = ReadLEUshort ();  	int versionToExtract = ReadLEUshort ();  	int bitFlags = ReadLEUshort ();  	int method = ReadLEUshort ();  	uint dostime = ReadLEUint ();  	uint crc = ReadLEUint ();  	long csize = (long)ReadLEUint ();  	long size = (long)ReadLEUint ();  	int nameLen = ReadLEUshort ();  	int extraLen = ReadLEUshort ();  	int commentLen = ReadLEUshort ();  	int diskStartNo = ReadLEUshort ();  	// Not currently used  	int internalAttributes = ReadLEUshort ();  	// Not currently used  	uint externalAttributes = ReadLEUint ();  	long offset = ReadLEUint ();  	byte[] buffer = new byte[Math.Max (nameLen' commentLen)];  	StreamUtils.ReadFully (baseStream_' buffer' 0' nameLen);  	string name = ZipConstants.ConvertToStringExt (bitFlags' buffer' nameLen);  	ZipEntry entry = new ZipEntry (name' versionToExtract' versionMadeBy' (CompressionMethod)method);  	entry.Crc = crc & 0xffffffffL;  	entry.Size = size & 0xffffffffL;  	entry.CompressedSize = csize & 0xffffffffL;  	entry.Flags = bitFlags;  	entry.DosTime = (uint)dostime;  	entry.ZipFileIndex = (long)i;  	entry.Offset = offset;  	entry.ExternalFileAttributes = (int)externalAttributes;  	if ((bitFlags & 8) == 0) {  		entry.CryptoCheckValue = (byte)(crc >> 24);  	}  	else {  		entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  	}  	if (extraLen > 0) {  		byte[] extra = new byte[extraLen];  		StreamUtils.ReadFully (baseStream_' extra);  		entry.ExtraData = extra;  	}  	entry.ProcessExtraData (false);  	if (commentLen > 0) {  		StreamUtils.ReadFully (baseStream_' buffer' 0' commentLen);  		entry.Comment = ZipConstants.ConvertToStringExt (bitFlags' buffer' commentLen);  	}  	entries_ [i] = entry;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ((bitFlags & 8) == 0) {  	entry.CryptoCheckValue = (byte)(crc >> 24);  }  else {  	entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: entry.CryptoCheckValue = (byte)(crc >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	result = new CryptoStream (baseStream' classicManaged.CreateDecryptor (key' null)' CryptoStreamMode.Read);  	CheckClassicPassword (result' entry);  }  else {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.Version == ZipConstants.VERSION_AES) {  		//  		OnKeysRequired (entry.Name);  		if (HaveKeys == false) {  			throw new ZipException ("No password available for AES encrypted stream");  		}  		int saltLen = entry.AESSaltLen;  		byte[] saltBytes = new byte[saltLen];  		int saltIn = baseStream.Read (saltBytes' 0' saltLen);  		if (saltIn != saltLen)  			throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  		//  		byte[] pwdVerifyRead = new byte[2];  		baseStream.Read (pwdVerifyRead' 0' 2);  		int blockSize = entry.AESKeySize / 8;  		// bits to bytes  		ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  		byte[] pwdVerifyCalc = decryptor.PwdVerifier;  		if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  			throw new Exception ("Invalid password for AES");  		result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  	}  	else  	#endif  	 {  		throw new ZipException ("Decryption method not supported");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	result = new CryptoStream (baseStream' classicManaged.CreateDecryptor (key' null)' CryptoStreamMode.Read);  	CheckClassicPassword (result' entry);  }  else {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.Version == ZipConstants.VERSION_AES) {  		//  		OnKeysRequired (entry.Name);  		if (HaveKeys == false) {  			throw new ZipException ("No password available for AES encrypted stream");  		}  		int saltLen = entry.AESSaltLen;  		byte[] saltBytes = new byte[saltLen];  		int saltIn = baseStream.Read (saltBytes' 0' saltLen);  		if (saltIn != saltLen)  			throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  		//  		byte[] pwdVerifyRead = new byte[2];  		baseStream.Read (pwdVerifyRead' 0' 2);  		int blockSize = entry.AESKeySize / 8;  		// bits to bytes  		ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  		byte[] pwdVerifyCalc = decryptor.PwdVerifier;  		if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  			throw new Exception ("Invalid password for AES");  		result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  	}  	else  	#endif  	 {  		throw new ZipException ("Decryption method not supported");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	result = new CryptoStream (baseStream' classicManaged.CreateDecryptor (key' null)' CryptoStreamMode.Read);  	CheckClassicPassword (result' entry);  }  else {  	#if !NET_1_1 && !NETCF_2_0  	if (entry.Version == ZipConstants.VERSION_AES) {  		//  		OnKeysRequired (entry.Name);  		if (HaveKeys == false) {  			throw new ZipException ("No password available for AES encrypted stream");  		}  		int saltLen = entry.AESSaltLen;  		byte[] saltBytes = new byte[saltLen];  		int saltIn = baseStream.Read (saltBytes' 0' saltLen);  		if (saltIn != saltLen)  			throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  		//  		byte[] pwdVerifyRead = new byte[2];  		baseStream.Read (pwdVerifyRead' 0' 2);  		int blockSize = entry.AESKeySize / 8;  		// bits to bytes  		ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  		byte[] pwdVerifyCalc = decryptor.PwdVerifier;  		if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  			throw new Exception ("Invalid password for AES");  		result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  	}  	else  	#endif  	 {  		throw new ZipException ("Decryption method not supported");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if (entry.Version == ZipConstants.VERSION_AES) {  	//  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for AES encrypted stream");  	}  	int saltLen = entry.AESSaltLen;  	byte[] saltBytes = new byte[saltLen];  	int saltIn = baseStream.Read (saltBytes' 0' saltLen);  	if (saltIn != saltLen)  		throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  	//  	byte[] pwdVerifyRead = new byte[2];  	baseStream.Read (pwdVerifyRead' 0' 2);  	int blockSize = entry.AESKeySize / 8;  	// bits to bytes  	ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  	byte[] pwdVerifyCalc = decryptor.PwdVerifier;  	if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  		throw new Exception ("Invalid password for AES");  	result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  }  else  #endif   {  	throw new ZipException ("Decryption method not supported");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if (entry.Version == ZipConstants.VERSION_AES) {  	//  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for AES encrypted stream");  	}  	int saltLen = entry.AESSaltLen;  	byte[] saltBytes = new byte[saltLen];  	int saltIn = baseStream.Read (saltBytes' 0' saltLen);  	if (saltIn != saltLen)  		throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  	//  	byte[] pwdVerifyRead = new byte[2];  	baseStream.Read (pwdVerifyRead' 0' 2);  	int blockSize = entry.AESKeySize / 8;  	// bits to bytes  	ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  	byte[] pwdVerifyCalc = decryptor.PwdVerifier;  	if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  		throw new Exception ("Invalid password for AES");  	result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  }  else  #endif   {  	throw new ZipException ("Decryption method not supported");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if (entry.Version == ZipConstants.VERSION_AES) {  	//  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for AES encrypted stream");  	}  	int saltLen = entry.AESSaltLen;  	byte[] saltBytes = new byte[saltLen];  	int saltIn = baseStream.Read (saltBytes' 0' saltLen);  	if (saltIn != saltLen)  		throw new ZipException ("AES Salt expected " + saltLen + " got " + saltIn);  	//  	byte[] pwdVerifyRead = new byte[2];  	baseStream.Read (pwdVerifyRead' 0' 2);  	int blockSize = entry.AESKeySize / 8;  	// bits to bytes  	ZipAESTransform decryptor = new ZipAESTransform (rawPassword_' saltBytes' blockSize' false);  	byte[] pwdVerifyCalc = decryptor.PwdVerifier;  	if (pwdVerifyCalc [0] != pwdVerifyRead [0] || pwdVerifyCalc [1] != pwdVerifyRead [1])  		throw new Exception ("Invalid password for AES");  	result = new ZipAESStream (baseStream' decryptor' CryptoStreamMode.Read);  }  else  #endif   {  	throw new ZipException ("Decryption method not supported");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: baseStream.Read (pwdVerifyRead' 0' 2);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  	// which doesnt do this.  	result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write);  	if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  		WriteEncryptionHeader (result' entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (result' entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption) || (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  	PkzipClassicManaged classicManaged = new PkzipClassicManaged ();  	OnKeysRequired (entry.Name);  	if (HaveKeys == false) {  		throw new ZipException ("No password available for encrypted stream");  	}  	// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  	// which doesnt do this.  	result = new CryptoStream (new UncompressedStream (baseStream)' classicManaged.CreateEncryptor (key' null)' CryptoStreamMode.Write);  	if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  		WriteEncryptionHeader (result' entry.DosTime << 16);  	}  	else {  		WriteEncryptionHeader (result' entry.Crc);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  	WriteEncryptionHeader (result' entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (result' entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  	WriteEncryptionHeader (result' entry.DosTime << 16);  }  else {  	WriteEncryptionHeader (result' entry.Crc);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: WriteEncryptionHeader (result' entry.DosTime << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer [11] = (byte)(crcValue >> 24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,MakeTemporaryCopy,The following statement contains a magic number: StreamUtils.Copy (stream' temporaryStream_' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if ((stream == null) || !stream.CanWrite) {  	result = new MemoryStream ();  	if (stream != null) {  		stream.Position = 0;  		StreamUtils.Copy (stream' result' new byte[4096]);  		stream.Close ();  	}  }  else {  	result = stream;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if (stream != null) {  	stream.Position = 0;  	StreamUtils.Copy (stream' result' new byte[4096]);  	stream.Close ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: StreamUtils.Copy (stream' result' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: if (buffer_ == null) {  	buffer_ = new byte[4096];  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: buffer_ = new byte[4096];  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (proceed) {  	if (events_ != null) {  		continueRunning_ = events_.OnProcessFile (entry.Name);  	}  	if (continueRunning_) {  		try {  			using (FileStream outputStream = Alphaleonis.Win32.Filesystem.File.Create (targetName)) {  				if (buffer_ == null) {  					buffer_ = new byte[4096];  				}  				if ((events_ != null) && (events_.Progress != null)) {  					StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  				}  				else {  					StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  				}  				if (events_ != null) {  					continueRunning_ = events_.OnCompletedFile (entry.Name);  				}  			}  			#if !NETCF_1_0 && !NETCF_2_0  			if (restoreDateTimeOnExtract_) {  				Alphaleonis.Win32.Filesystem.File.SetLastWriteTime (targetName' entry.DateTime);  			}  			if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  				FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  				// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  				fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  				Alphaleonis.Win32.Filesystem.File.SetAttributes (targetName' fileAttributes);  			}  			#endif  		}  		catch (Exception ex) {  			if (events_ != null) {  				continueRunning_ = events_.OnFileFailure (targetName' ex);  			}  			else {  				continueRunning_ = false;  				throw;  			}  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (continueRunning_) {  	try {  		using (FileStream outputStream = Alphaleonis.Win32.Filesystem.File.Create (targetName)) {  			if (buffer_ == null) {  				buffer_ = new byte[4096];  			}  			if ((events_ != null) && (events_.Progress != null)) {  				StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  			}  			else {  				StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  			}  			if (events_ != null) {  				continueRunning_ = events_.OnCompletedFile (entry.Name);  			}  		}  		#if !NETCF_1_0 && !NETCF_2_0  		if (restoreDateTimeOnExtract_) {  			Alphaleonis.Win32.Filesystem.File.SetLastWriteTime (targetName' entry.DateTime);  		}  		if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  			FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  			// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  			fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  			Alphaleonis.Win32.Filesystem.File.SetAttributes (targetName' fileAttributes);  		}  		#endif  	}  	catch (Exception ex) {  		if (events_ != null) {  			continueRunning_ = events_.OnFileFailure (targetName' ex);  		}  		else {  			continueRunning_ = false;  			throw;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: try {  	using (FileStream outputStream = Alphaleonis.Win32.Filesystem.File.Create (targetName)) {  		if (buffer_ == null) {  			buffer_ = new byte[4096];  		}  		if ((events_ != null) && (events_.Progress != null)) {  			StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  		}  		else {  			StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  		}  		if (events_ != null) {  			continueRunning_ = events_.OnCompletedFile (entry.Name);  		}  	}  	#if !NETCF_1_0 && !NETCF_2_0  	if (restoreDateTimeOnExtract_) {  		Alphaleonis.Win32.Filesystem.File.SetLastWriteTime (targetName' entry.DateTime);  	}  	if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  		FileAttributes fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  		// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  		fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  		Alphaleonis.Win32.Filesystem.File.SetAttributes (targetName' fileAttributes);  	}  	#endif  }  catch (Exception ex) {  	if (events_ != null) {  		continueRunning_ = events_.OnFileFailure (targetName' ex);  	}  	else {  		continueRunning_ = false;  		throw;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: using (FileStream outputStream = Alphaleonis.Win32.Filesystem.File.Create (targetName)) {  	if (buffer_ == null) {  		buffer_ = new byte[4096];  	}  	if ((events_ != null) && (events_.Progress != null)) {  		StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_' events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  	}  	else {  		StreamUtils.Copy (zipFile_.GetInputStream (entry)' outputStream' buffer_);  	}  	if (events_ != null) {  		continueRunning_ = events_.OnCompletedFile (entry.Name);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (buffer_ == null) {  	buffer_ = new byte[4096];  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: buffer_ = new byte[4096];  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryCharsRelaxed [howMany - 2] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: howMany = invalidPathChars.Length + 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 2] = '\\';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 3] = '*';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars [howMany - 4] = '?';  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong (44);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort () | (ReadLEShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint)ReadLEInt () | ((long)ReadLEInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: _createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.ModificationTime) != 0) {  	TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.ReadLEInt ();  		// Reserved  		while (helperStream.Position < helperStream.Length) {  			int ntfsTag = helperStream.ReadLEShort ();  			int ntfsLength = helperStream.ReadLEShort ();  			if (ntfsTag == 1) {  				if (ntfsLength >= 24) {  					long lastModificationTicks = helperStream.ReadLELong ();  					_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  					long lastAccessTicks = helperStream.ReadLELong ();  					_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  					long createTimeTicks = helperStream.ReadLELong ();  					_createTime = DateTime.FromFileTime (createTimeTicks);  				}  				break;  			}  			else {  				// An unknown NTFS tag so simply skip it.  				helperStream.Seek (ntfsLength' SeekOrigin.Current);  			}  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.ReadLEInt ();  	// Reserved  	while (helperStream.Position < helperStream.Length) {  		int ntfsTag = helperStream.ReadLEShort ();  		int ntfsLength = helperStream.ReadLEShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModificationTicks = helperStream.ReadLELong ();  				_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  				long lastAccessTicks = helperStream.ReadLELong ();  				_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  				long createTimeTicks = helperStream.ReadLELong ();  				_createTime = DateTime.FromFileTime (createTimeTicks);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			helperStream.Seek (ntfsLength' SeekOrigin.Current);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: while (helperStream.Position < helperStream.Length) {  	int ntfsTag = helperStream.ReadLEShort ();  	int ntfsLength = helperStream.ReadLEShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModificationTicks = helperStream.ReadLELong ();  			_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  			long lastAccessTicks = helperStream.ReadLELong ();  			_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  			long createTimeTicks = helperStream.ReadLELong ();  			_createTime = DateTime.FromFileTime (createTimeTicks);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		helperStream.Seek (ntfsLength' SeekOrigin.Current);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModificationTicks = helperStream.ReadLELong ();  		_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  		long lastAccessTicks = helperStream.ReadLELong ();  		_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  		long createTimeTicks = helperStream.ReadLELong ();  		_createTime = DateTime.FromFileTime (createTimeTicks);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	helperStream.Seek (ntfsLength' SeekOrigin.Current);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModificationTicks = helperStream.ReadLELong ();  	_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  	long lastAccessTicks = helperStream.ReadLELong ();  	_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  	long createTimeTicks = helperStream.ReadLELong ();  	_createTime = DateTime.FromFileTime (createTimeTicks);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteLEInt (0);  		// Reserved  		helperStream.WriteLEShort (1);  		// Tag  		helperStream.WriteLEShort (24);  		// Length = 3 x 8.  		helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  		helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  		helperStream.WriteLELong (_createTime.ToFileTime ());  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteLEInt (0);  	// Reserved  	helperStream.WriteLEShort (1);  	// Tag  	helperStream.WriteLEShort (24);  	// Length = 3 x 8.  	helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  	helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  	helperStream.WriteLELong (_createTime.ToFileTime ());  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: helperStream.WriteLEShort (24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,Find,The following statement contains a magic number: while ((localTag != headerID) && (_index < _data.Length - 3)) {  	localTag = ReadShortInternal ();  	localLength = ReadShortInternal ();  	if (localTag != headerID) {  		_index += localLength;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if (Find (headerID)) {  	newLength -= (ValueLength + 4);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: newLength -= (ValueLength + 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked {  	_newEntry.WriteByte ((byte)toAdd);  	_newEntry.WriteByte ((byte)(toAdd >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: _newEntry.WriteByte ((byte)(toAdd >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked {  	AddLeShort ((short)toAdd);  	AddLeShort ((short)(toAdd >> 16));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: AddLeShort ((short)(toAdd >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked {  	AddLeInt ((int)(toAdd & 0xffffffff));  	AddLeInt ((int)(toAdd >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: AddLeInt ((int)(toAdd >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt () & 0xffffffff) | (((long)ReadInt ()) << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: _index += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck (2);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((_readValueStart > _data.Length) || (_readValueStart < 4)) {  	throw new ZipException ("Find must be called before calling a Read method");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if (_index + length < 4) {  	throw new ZipException ("Cannot read before start of tag");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if (_index > _data.Length - 2) {  	throw new ZipException ("End of extra data");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: _data [index + 1] = (byte)(source >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,The following statement contains a magic number: externalAttributes |= (setAttributes_ | 16);  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  	state_ = OutputState.Finished;  	base.Finish ();  	uint totalin = (uint)(deflater_.TotalIn & 0xffffffff);  	uint crcval = (uint)(crc.Value & 0xffffffff);  	byte[] gzipFooter;  	unchecked {  		gzipFooter = new byte[] {  			(byte)crcval'  			(byte)(crcval >> 8)'  			(byte)(crcval >> 16)'  			(byte)(crcval >> 24)'  			(byte)totalin'  			(byte)(totalin >> 8)'  			(byte)(totalin >> 16)'  			(byte)(totalin >> 24)  		};  	}  	baseOutputStream_.Write (gzipFooter' 0' gzipFooter.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: unchecked {  	gzipFooter = new byte[] {  		(byte)crcval'  		(byte)(crcval >> 8)'  		(byte)(crcval >> 16)'  		(byte)(crcval >> 24)'  		(byte)totalin'  		(byte)(totalin >> 8)'  		(byte)(totalin >> 16)'  		(byte)(totalin >> 24)  	};  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: gzipFooter = new byte[] {  	(byte)crcval'  	(byte)(crcval >> 8)'  	(byte)(crcval >> 16)'  	(byte)(crcval >> 24)'  	(byte)totalin'  	(byte)(totalin >> 8)'  	(byte)(totalin >> 16)'  	(byte)(totalin >> 24)  };  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = (int)((DateTime.Now.Ticks - new DateTime (1970' 1' 1).Ticks) / 10000000L);  	// Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = (int)((DateTime.Now.Ticks - new DateTime (1970' 1' 1).Ticks) / 10000000L);  	// Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = (int)((DateTime.Now.Ticks - new DateTime (1970' 1' 1).Ticks) / 10000000L);  	// Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = (int)((DateTime.Now.Ticks - new DateTime (1970' 1' 1).Ticks) / 10000000L);  	// Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = (int)((DateTime.Now.Ticks - new DateTime (1970' 1' 1).Ticks) / 10000000L);  	// Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  	state_ = OutputState.Footer;  	int mod_time = (int)((DateTime.Now.Ticks - new DateTime (1970' 1' 1).Ticks) / 10000000L);  	// Ticks give back 100ns intervals  	byte[] gzipHeader =  {  		// The two magic bytes  		(byte)(GZipConstants.GZIP_MAGIC >> 8)'  		(byte)(GZipConstants.GZIP_MAGIC & 0xff)'  		// The compression type  		(byte)Deflater.DEFLATED'  		// The flags (not set)  		0'  		// The modification time  		(byte)mod_time'  		(byte)(mod_time >> 8)'  		(byte)(mod_time >> 16)'  		(byte)(mod_time >> 24)'  		// The extra flags  		0'  		// The OS type (unknown)  		(byte)255  	};  	baseOutputStream_.Write (gzipHeader' 0' gzipHeader.Length);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (magic != (GZipConstants.GZIP_MAGIC >> 8)) {  	throw new GZipException ("Error GZIP header' first magic byte doesn't match");  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (compressionType != 8) {  	throw new GZipException ("Error GZIP header' data not in deflate format");  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  	int readByte = inputBuffer.ReadLeByte ();  	if (readByte < 0) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	headCRC.Update (readByte);  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FEXTRA) != 0) {  	// XLEN is total length of extra subfields' we will skip them all  	int len1' len2;  	len1 = inputBuffer.ReadLeByte ();  	len2 = inputBuffer.ReadLeByte ();  	if ((len1 < 0) || (len2 < 0)) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	headCRC.Update (len1);  	headCRC.Update (len2);  	int extraLen = (len2 << 8) | len1;  	// gzip is LSB first  	for (int i = 0; i < extraLen; i++) {  		int readByte = inputBuffer.ReadLeByte ();  		if (readByte < 0) {  			throw new EndOfStreamException ("EOS reading GZIP header");  		}  		headCRC.Update (readByte);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FHCRC) != 0) {  	int tempByte;  	int crcval = inputBuffer.ReadLeByte ();  	if (crcval < 0) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	tempByte = inputBuffer.ReadLeByte ();  	if (tempByte < 0) {  		throw new EndOfStreamException ("EOS reading GZIP header");  	}  	crcval = (crcval << 8) | tempByte;  	if (crcval != ((int)headCRC.Value & 0xffff)) {  		throw new GZipException ("Header CRC value mismatch");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: crcval = (crcval << 8) | tempByte;  
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: while (needed > 0) {  	int count = inputBuffer.ReadClearTextBuffer (footer' 8 - needed' needed);  	if (count <= 0) {  		throw new EndOfStreamException ("EOS reading GZIP footer");  	}  	needed -= count;  	// Jewel Jan 16  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  	if (inUse [i]) {  		seqToUnseq [nInUse] = (byte)i;  		unseqToSeq [i] = (byte)nInUse;  		nInUse++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,EndBlock,The following statement contains a magic number: computedCombinedCRC = ((computedCombinedCRC << 1) & 0xFFFFFFFF) | (computedCombinedCRC >> 31);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,FillBuffer,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (thech & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,FillBuffer,The following statement contains a magic number: bsLive += 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetUChar,The following statement contains a magic number: return (char)BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR (8);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	inUse16 [i] = (BsR (1) == 1);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = (BsR (1) == 1);  		}  	}  	else {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = false;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = (BsR (1) == 1);  		}  	}  	else {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = false;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = (BsR (1) == 1);  		}  	}  	else {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = false;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = (BsR (1) == 1);  		}  	}  	else {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = false;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = (BsR (1) == 1);  		}  	}  	else {  		for (int j = 0; j < 16; j++) {  			inUse [i * 16 + j] = false;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: if (inUse16 [i]) {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = (BsR (1) == 1);  	}  }  else {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = false;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: if (inUse16 [i]) {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = (BsR (1) == 1);  	}  }  else {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = false;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: if (inUse16 [i]) {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = (BsR (1) == 1);  	}  }  else {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = false;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: if (inUse16 [i]) {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = (BsR (1) == 1);  	}  }  else {  	for (int j = 0; j < 16; j++) {  		inUse [i * 16 + j] = false;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int j = 0; j < 16; j++) {  	inUse [i * 16 + j] = (BsR (1) == 1);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int j = 0; j < 16; j++) {  	inUse [i * 16 + j] = (BsR (1) == 1);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: inUse [i * 16 + j] = (BsR (1) == 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int j = 0; j < 16; j++) {  	inUse [i * 16 + j] = false;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int j = 0; j < 16; j++) {  	inUse [i * 16 + j] = false;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: inUse [i * 16 + j] = false;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  	int curr = BsR (5);  	for (int i = 0; i < alphaSize; i++) {  		while (BsR (1) == 1) {  			if (BsR (1) == 0) {  				curr++;  			}  			else {  				curr--;  			}  		}  		len [t] [i] = (char)curr;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  	int minLen = 32;  	int maxLen = 0;  	for (int i = 0; i < alphaSize; i++) {  		maxLen = Math.Max (maxLen' len [t] [i]);  		minLen = Math.Min (minLen' len [t] [i]);  	}  	HbCreateDecodeTables (limit [t]' baseArray [t]' perm [t]' len [t]' minLen' maxLen' alphaSize);  	minLens [t] = minLen;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: origPtr = BsGetIntVS (24);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++) {  	unzftab [i] = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++) {  	yy [i] = (byte)i;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: while (zvec > limit [zt] [zn]) {  	if (zn > 20) {  		// the longest code  		throw new BZip2Exception ("Bzip data error");  	}  	zn++;  	while (bsLive < 1) {  		FillBuffer ();  	}  	zj = (bsBuff >> (bsLive - 1)) & 1;  	bsLive--;  	zvec = (zvec << 1) | zj;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: if (zn > 20) {  	// the longest code  	throw new BZip2Exception ("Bzip data error");  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: Array.Copy (unzftab' 0' cftab' 1' 256);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (int i = 1; i <= 256; i++) {  	cftab [i] += cftab [i - 1];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: ch2 = 256;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: if (i2 <= last) {  	chPrev = ch2;  	ch2 = ll8 [tPos];  	tPos = tt [tPos];  	if (rNToGo == 0) {  		rNToGo = BZip2Constants.RandomNumbers [rTPos];  		rTPos++;  		if (rTPos == 512) {  			rTPos = 0;  		}  	}  	rNToGo--;  	ch2 ^= (int)((rNToGo == 1) ? 1 : 0);  	i2++;  	currentChar = ch2;  	currentState = RAND_PART_B_STATE;  	mCrc.Update (ch2);  }  else {  	EndBlock ();  	InitBlock ();  	SetupBlock ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: if (rNToGo == 0) {  	rNToGo = BZip2Constants.RandomNumbers [rTPos];  	rTPos++;  	if (rTPos == 512) {  		rTPos = 0;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: if (rTPos == 512) {  	rTPos = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  	currentState = RAND_PART_A_STATE;  	count = 1;  	SetupRandPartA ();  }  else {  	count++;  	if (count >= 4) {  		z = ll8 [tPos];  		tPos = tt [tPos];  		if (rNToGo == 0) {  			rNToGo = BZip2Constants.RandomNumbers [rTPos];  			rTPos++;  			if (rTPos == 512) {  				rTPos = 0;  			}  		}  		rNToGo--;  		z ^= (byte)((rNToGo == 1) ? 1 : 0);  		j2 = 0;  		currentState = RAND_PART_C_STATE;  		SetupRandPartC ();  	}  	else {  		currentState = RAND_PART_A_STATE;  		SetupRandPartA ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  	currentState = RAND_PART_A_STATE;  	count = 1;  	SetupRandPartA ();  }  else {  	count++;  	if (count >= 4) {  		z = ll8 [tPos];  		tPos = tt [tPos];  		if (rNToGo == 0) {  			rNToGo = BZip2Constants.RandomNumbers [rTPos];  			rTPos++;  			if (rTPos == 512) {  				rTPos = 0;  			}  		}  		rNToGo--;  		z ^= (byte)((rNToGo == 1) ? 1 : 0);  		j2 = 0;  		currentState = RAND_PART_C_STATE;  		SetupRandPartC ();  	}  	else {  		currentState = RAND_PART_A_STATE;  		SetupRandPartA ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (count >= 4) {  	z = ll8 [tPos];  	tPos = tt [tPos];  	if (rNToGo == 0) {  		rNToGo = BZip2Constants.RandomNumbers [rTPos];  		rTPos++;  		if (rTPos == 512) {  			rTPos = 0;  		}  	}  	rNToGo--;  	z ^= (byte)((rNToGo == 1) ? 1 : 0);  	j2 = 0;  	currentState = RAND_PART_C_STATE;  	SetupRandPartC ();  }  else {  	currentState = RAND_PART_A_STATE;  	SetupRandPartA ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (count >= 4) {  	z = ll8 [tPos];  	tPos = tt [tPos];  	if (rNToGo == 0) {  		rNToGo = BZip2Constants.RandomNumbers [rTPos];  		rTPos++;  		if (rTPos == 512) {  			rTPos = 0;  		}  	}  	rNToGo--;  	z ^= (byte)((rNToGo == 1) ? 1 : 0);  	j2 = 0;  	currentState = RAND_PART_C_STATE;  	SetupRandPartC ();  }  else {  	currentState = RAND_PART_A_STATE;  	SetupRandPartA ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (rNToGo == 0) {  	rNToGo = BZip2Constants.RandomNumbers [rTPos];  	rTPos++;  	if (rTPos == 512) {  		rTPos = 0;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (rTPos == 512) {  	rTPos = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupNoRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  	currentState = NO_RAND_PART_A_STATE;  	count = 1;  	SetupNoRandPartA ();  }  else {  	count++;  	if (count >= 4) {  		z = ll8 [tPos];  		tPos = tt [tPos];  		currentState = NO_RAND_PART_C_STATE;  		j2 = 0;  		SetupNoRandPartC ();  	}  	else {  		currentState = NO_RAND_PART_A_STATE;  		SetupNoRandPartA ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetupNoRandPartB,The following statement contains a magic number: if (count >= 4) {  	z = ll8 [tPos];  	tPos = tt [tPos];  	currentState = NO_RAND_PART_C_STATE;  	j2 = 0;  	SetupNoRandPartC ();  }  else {  	currentState = NO_RAND_PART_A_STATE;  	SetupNoRandPartA ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {  	throw new BZip2Exception ("Invalid block size");  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {  	throw new BZip2Exception ("Invalid block size");  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: workFactor = 50;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9) {  	blockSize = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9) {  	blockSize = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: blockSize = 9;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: if (currentChar != -1) {  	if (currentChar == b) {  		runLength++;  		if (runLength > 254) {  			WriteRun ();  			currentChar = -1;  			runLength = 0;  		}  	}  	else {  		WriteRun ();  		runLength = 1;  		currentChar = b;  	}  }  else {  	currentChar = b;  	runLength++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: if (currentChar == b) {  	runLength++;  	if (runLength > 254) {  		WriteRun ();  		currentChar = -1;  		runLength = 0;  	}  }  else {  	WriteRun ();  	runLength = 1;  	currentChar = b;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: if (runLength > 254) {  	WriteRun ();  	currentChar = -1;  	runLength = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	if (inUse [i]) {  		seqToUnseq [nInUse] = (char)i;  		unseqToSeq [i] = (char)nInUse;  		nInUse++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  	inUse [currentChar] = true;  	for (int i = 0; i < runLength; i++) {  		mCrc.Update (currentChar);  	}  	switch (runLength) {  	case 1:  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 2:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 3:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	default:  		inUse [runLength - 4] = true;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)(runLength - 4);  		break;  	}  }  else {  	EndBlock ();  	InitBlock ();  	WriteRun ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  	inUse [currentChar] = true;  	for (int i = 0; i < runLength; i++) {  		mCrc.Update (currentChar);  	}  	switch (runLength) {  	case 1:  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 2:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 3:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	default:  		inUse [runLength - 4] = true;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)(runLength - 4);  		break;  	}  }  else {  	EndBlock ();  	InitBlock ();  	WriteRun ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  	inUse [currentChar] = true;  	for (int i = 0; i < runLength; i++) {  		mCrc.Update (currentChar);  	}  	switch (runLength) {  	case 1:  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 2:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 3:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	default:  		inUse [runLength - 4] = true;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)(runLength - 4);  		break;  	}  }  else {  	EndBlock ();  	InitBlock ();  	WriteRun ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  	inUse [currentChar] = true;  	for (int i = 0; i < runLength; i++) {  		mCrc.Update (currentChar);  	}  	switch (runLength) {  	case 1:  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 2:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	case 3:  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		break;  	default:  		inUse [runLength - 4] = true;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)currentChar;  		last++;  		block [last + 1] = (byte)(runLength - 4);  		break;  	}  }  else {  	EndBlock ();  	InitBlock ();  	WriteRun ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength) {  case 1:  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 2:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 3:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  default:  	inUse [runLength - 4] = true;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)(runLength - 4);  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength) {  case 1:  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 2:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 3:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  default:  	inUse [runLength - 4] = true;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)(runLength - 4);  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength) {  case 1:  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 2:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 3:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  default:  	inUse [runLength - 4] = true;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)(runLength - 4);  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: switch (runLength) {  case 1:  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 2:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  case 3:  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	break;  default:  	inUse [runLength - 4] = true;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)currentChar;  	last++;  	block [last + 1] = (byte)(runLength - 4);  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: inUse [runLength - 4] = true;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: block [last + 1] = (byte)(runLength - 4);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,InitBlock,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	inUse [i] = false;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,InitBlock,The following statement contains a magic number: allowableBlockSize = BZip2Constants.BaseBlockSize * blockSize100k - 20;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,EndBlock,The following statement contains a magic number: combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0) {  	int ch = (bsBuff >> 24);  	baseStream.WriteByte ((byte)ch);  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	bytesOut++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0) {  	int ch = (bsBuff >> 24);  	baseStream.WriteByte ((byte)ch);  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	bytesOut++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0) {  	int ch = (bsBuff >> 24);  	baseStream.WriteByte ((byte)ch);  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	bytesOut++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: bsBuff <<= 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: bsLive -= 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  	int ch = (bsBuff >> 24);  	unchecked {  		baseStream.WriteByte ((byte)ch);  	}  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	++bytesOut;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  	int ch = (bsBuff >> 24);  	unchecked {  		baseStream.WriteByte ((byte)ch);  	}  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	++bytesOut;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  	int ch = (bsBuff >> 24);  	unchecked {  		baseStream.WriteByte ((byte)ch);  	}  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	++bytesOut;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  	int ch = (bsBuff >> 24);  	unchecked {  		baseStream.WriteByte ((byte)ch);  	}  	// write 8-bit  	bsBuff <<= 8;  	bsLive -= 8;  	++bytesOut;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: bsBuff <<= 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: bsLive -= 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: bsBuff |= (v << (32 - bsLive - n));  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutUChar,The following statement contains a magic number: BsW (8' c);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' (u >> 24) & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' (u >> 24) & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' (u >> 16) & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' (u >> 16) & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' (u >> 8) & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' (u >> 8) & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW (8' u & 0xFF);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: alphaSize = nInUse + 2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  	nGroups = 2;  }  else if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups = 2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 600) {  	nGroups = 3;  }  else if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups = 3;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 1200) {  	nGroups = 4;  }  else if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups = 4;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 2400) {  	nGroups = 5;  }  else {  	nGroups = 6;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups = 5;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: nGroups = 6;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (nPart > 0) {  	int tFreq = remF / nPart;  	int aFreq = 0;  	ge = gs - 1;  	while (aFreq < tFreq && ge < alphaSize - 1) {  		ge++;  		aFreq += mtfFreq [ge];  	}  	if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  		aFreq -= mtfFreq [ge];  		ge--;  	}  	for (int v = 0; v < alphaSize; v++) {  		if (v >= gs && v <= ge) {  			len [nPart - 1] [v] = (char)LESSER_ICOST;  		}  		else {  			len [nPart - 1] [v] = (char)GREATER_ICOST;  		}  	}  	nPart--;  	gs = ge + 1;  	remF -= aFreq;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  	aFreq -= mtfFreq [ge];  	ge--;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  	for (int t = 0; t < nGroups; ++t) {  		fave [t] = 0;  	}  	for (int t = 0; t < nGroups; ++t) {  		for (int v = 0; v < alphaSize; ++v) {  			rfreq [t] [v] = 0;  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= nMTF) {  			break;  		}  		ge = gs + BZip2Constants.GroupSize - 1;  		if (ge >= nMTF) {  			ge = nMTF - 1;  		}  		/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  			cost [t] = 0;  		}  		if (nGroups == 6) {  			short cost0' cost1' cost2' cost3' cost4' cost5;  			cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				cost0 += (short)len [0] [icv];  				cost1 += (short)len [1] [icv];  				cost2 += (short)len [2] [icv];  				cost3 += (short)len [3] [icv];  				cost4 += (short)len [4] [icv];  				cost5 += (short)len [5] [icv];  			}  			cost [0] = cost0;  			cost [1] = cost1;  			cost [2] = cost2;  			cost [3] = cost3;  			cost [4] = cost4;  			cost [5] = cost5;  		}  		else {  			for (int i = gs; i <= ge; ++i) {  				short icv = szptr [i];  				for (int t = 0; t < nGroups; t++) {  					cost [t] += (short)len [t] [icv];  				}  			}  		}  		/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (int t = 0; t < nGroups; ++t) {  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		}  		totc += bc;  		fave [bt]++;  		selector [nSelectors] = (char)bt;  		nSelectors++;  		/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  			++rfreq [bt] [szptr [i]];  		}  		gs = ge + 1;  	}  	/*-- 				Recompute the tables based on the accumulated frequencies. 				--*/for (int t = 0; t < nGroups; ++t) {  		HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= nMTF) {  		break;  	}  	ge = gs + BZip2Constants.GroupSize - 1;  	if (ge >= nMTF) {  		ge = nMTF - 1;  	}  	/*-- 					Calculate the cost of this group as coded 					by each of the coding tables. 					--*/for (int t = 0; t < nGroups; t++) {  		cost [t] = 0;  	}  	if (nGroups == 6) {  		short cost0' cost1' cost2' cost3' cost4' cost5;  		cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			cost0 += (short)len [0] [icv];  			cost1 += (short)len [1] [icv];  			cost2 += (short)len [2] [icv];  			cost3 += (short)len [3] [icv];  			cost4 += (short)len [4] [icv];  			cost5 += (short)len [5] [icv];  		}  		cost [0] = cost0;  		cost [1] = cost1;  		cost [2] = cost2;  		cost [3] = cost3;  		cost [4] = cost4;  		cost [5] = cost5;  	}  	else {  		for (int i = gs; i <= ge; ++i) {  			short icv = szptr [i];  			for (int t = 0; t < nGroups; t++) {  				cost [t] += (short)len [t] [icv];  			}  		}  	}  	/*-- 					Find the coding table which is best for this group' 					and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (int t = 0; t < nGroups; ++t) {  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	}  	totc += bc;  	fave [bt]++;  	selector [nSelectors] = (char)bt;  	nSelectors++;  	/*-- 					Increment the symbol frequencies for the selected table. 					--*/for (int i = gs; i <= ge; ++i) {  		++rfreq [bt] [szptr [i]];  	}  	gs = ge + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	short cost0' cost1' cost2' cost3' cost4' cost5;  	cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		cost0 += (short)len [0] [icv];  		cost1 += (short)len [1] [icv];  		cost2 += (short)len [2] [icv];  		cost3 += (short)len [3] [icv];  		cost4 += (short)len [4] [icv];  		cost5 += (short)len [5] [icv];  	}  	cost [0] = cost0;  	cost [1] = cost1;  	cost [2] = cost2;  	cost [3] = cost3;  	cost [4] = cost4;  	cost [5] = cost5;  }  else {  	for (int i = gs; i <= ge; ++i) {  		short icv = szptr [i];  		for (int t = 0; t < nGroups; t++) {  			cost [t] += (short)len [t] [icv];  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = gs; i <= ge; ++i) {  	short icv = szptr [i];  	cost0 += (short)len [0] [icv];  	cost1 += (short)len [1] [icv];  	cost2 += (short)len [2] [icv];  	cost3 += (short)len [3] [icv];  	cost4 += (short)len [4] [icv];  	cost5 += (short)len [5] [icv];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = gs; i <= ge; ++i) {  	short icv = szptr [i];  	cost0 += (short)len [0] [icv];  	cost1 += (short)len [1] [icv];  	cost2 += (short)len [2] [icv];  	cost3 += (short)len [3] [icv];  	cost4 += (short)len [4] [icv];  	cost5 += (short)len [5] [icv];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = gs; i <= ge; ++i) {  	short icv = szptr [i];  	cost0 += (short)len [0] [icv];  	cost1 += (short)len [1] [icv];  	cost2 += (short)len [2] [icv];  	cost3 += (short)len [3] [icv];  	cost4 += (short)len [4] [icv];  	cost5 += (short)len [5] [icv];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = gs; i <= ge; ++i) {  	short icv = szptr [i];  	cost0 += (short)len [0] [icv];  	cost1 += (short)len [1] [icv];  	cost2 += (short)len [2] [icv];  	cost3 += (short)len [3] [icv];  	cost4 += (short)len [4] [icv];  	cost5 += (short)len [5] [icv];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost2 += (short)len [2] [icv];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost3 += (short)len [3] [icv];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost4 += (short)len [4] [icv];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost5 += (short)len [5] [icv];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost [2] = cost2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost [3] = cost3;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost [4] = cost4;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: cost [5] = cost5;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: bc = 999999999;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  	HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: HbMakeCodeLengths (len [t]' rfreq [t]' alphaSize' 20);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nGroups < 8)) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (int i = 0; i < alphaSize; i++) {  		if (len [t] [i] > maxLen) {  			maxLen = len [t] [i];  		}  		if (len [t] [i] < minLen) {  			minLen = len [t] [i];  		}  	}  	if (maxLen > 20) {  		Panic ();  	}  	if (minLen < 1) {  		Panic ();  	}  	HbAssignCodes (code [t]' len [t]' minLen' maxLen' alphaSize);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (int i = 0; i < alphaSize; i++) {  		if (len [t] [i] > maxLen) {  			maxLen = len [t] [i];  		}  		if (len [t] [i] < minLen) {  			minLen = len [t] [i];  		}  	}  	if (maxLen > 20) {  		Panic ();  	}  	if (minLen < 1) {  		Panic ();  	}  	HbAssignCodes (code [t]' len [t]' minLen' maxLen' alphaSize);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: minLen = 32;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (maxLen > 20) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	inUse16 [i] = false;  	for (int j = 0; j < 16; ++j) {  		if (inUse [i * 16 + j]) {  			inUse16 [i] = true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	inUse16 [i] = false;  	for (int j = 0; j < 16; ++j) {  		if (inUse [i * 16 + j]) {  			inUse16 [i] = true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	inUse16 [i] = false;  	for (int j = 0; j < 16; ++j) {  		if (inUse [i * 16 + j]) {  			inUse16 [i] = true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	if (inUse [i * 16 + j]) {  		inUse16 [i] = true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	if (inUse [i * 16 + j]) {  		inUse16 [i] = true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (inUse [i * 16 + j]) {  	inUse16 [i] = true;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	if (inUse16 [i]) {  		BsW (1' 1);  	}  	else {  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; ++j) {  			if (inUse [i * 16 + j]) {  				BsW (1' 1);  			}  			else {  				BsW (1' 0);  			}  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; ++j) {  			if (inUse [i * 16 + j]) {  				BsW (1' 1);  			}  			else {  				BsW (1' 0);  			}  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  	if (inUse16 [i]) {  		for (int j = 0; j < 16; ++j) {  			if (inUse [i * 16 + j]) {  				BsW (1' 1);  			}  			else {  				BsW (1' 0);  			}  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (inUse16 [i]) {  	for (int j = 0; j < 16; ++j) {  		if (inUse [i * 16 + j]) {  			BsW (1' 1);  		}  		else {  			BsW (1' 0);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (inUse16 [i]) {  	for (int j = 0; j < 16; ++j) {  		if (inUse [i * 16 + j]) {  			BsW (1' 1);  		}  		else {  			BsW (1' 0);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	if (inUse [i * 16 + j]) {  		BsW (1' 1);  	}  	else {  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	if (inUse [i * 16 + j]) {  		BsW (1' 1);  	}  	else {  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (inUse [i * 16 + j]) {  	BsW (1' 1);  }  else {  	BsW (1' 0);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (3' nGroups);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (15' nSelectors);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  	int curr = len [t] [0];  	BsW (5' curr);  	for (int i = 0; i < alphaSize; ++i) {  		while (curr < len [t] [i]) {  			BsW (2' 2);  			curr++;  			/* 10 */}  		while (curr > len [t] [i]) {  			BsW (2' 3);  			curr--;  			/* 11 */}  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  	int curr = len [t] [0];  	BsW (5' curr);  	for (int i = 0; i < alphaSize; ++i) {  		while (curr < len [t] [i]) {  			BsW (2' 2);  			curr++;  			/* 10 */}  		while (curr > len [t] [i]) {  			BsW (2' 3);  			curr--;  			/* 11 */}  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  	int curr = len [t] [0];  	BsW (5' curr);  	for (int i = 0; i < alphaSize; ++i) {  		while (curr < len [t] [i]) {  			BsW (2' 2);  			curr++;  			/* 10 */}  		while (curr > len [t] [i]) {  			BsW (2' 3);  			curr--;  			/* 11 */}  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  	int curr = len [t] [0];  	BsW (5' curr);  	for (int i = 0; i < alphaSize; ++i) {  		while (curr < len [t] [i]) {  			BsW (2' 2);  			curr++;  			/* 10 */}  		while (curr > len [t] [i]) {  			BsW (2' 3);  			curr--;  			/* 11 */}  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  	int curr = len [t] [0];  	BsW (5' curr);  	for (int i = 0; i < alphaSize; ++i) {  		while (curr < len [t] [i]) {  			BsW (2' 2);  			curr++;  			/* 10 */}  		while (curr > len [t] [i]) {  			BsW (2' 3);  			curr--;  			/* 11 */}  		BsW (1' 0);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (5' curr);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i) {  	while (curr < len [t] [i]) {  		BsW (2' 2);  		curr++;  		/* 10 */}  	while (curr > len [t] [i]) {  		BsW (2' 3);  		curr--;  		/* 11 */}  	BsW (1' 0);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i) {  	while (curr < len [t] [i]) {  		BsW (2' 2);  		curr++;  		/* 10 */}  	while (curr > len [t] [i]) {  		BsW (2' 3);  		curr--;  		/* 11 */}  	BsW (1' 0);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i) {  	while (curr < len [t] [i]) {  		BsW (2' 2);  		curr++;  		/* 10 */}  	while (curr > len [t] [i]) {  		BsW (2' 3);  		curr--;  		/* 11 */}  	BsW (1' 0);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i) {  	while (curr < len [t] [i]) {  		BsW (2' 2);  		curr++;  		/* 10 */}  	while (curr > len [t] [i]) {  		BsW (2' 3);  		curr--;  		/* 11 */}  	BsW (1' 0);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (curr < len [t] [i]) {  	BsW (2' 2);  	curr++;  	/* 10 */}  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (curr < len [t] [i]) {  	BsW (2' 2);  	curr++;  	/* 10 */}  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (2' 2);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (2' 2);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (curr > len [t] [i]) {  	BsW (2' 3);  	curr--;  	/* 11 */}  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (curr > len [t] [i]) {  	BsW (2' 3);  	curr--;  	/* 11 */}  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (2' 3);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW (2' 3);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MoveToFrontCodeAndSend,The following statement contains a magic number: BsPutIntVS (24' origPtr);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,SimpleSort,The following statement contains a magic number: if (bigN < 2) {  	return;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i < BZip2Constants.OvershootBytes; i++) {  	block [last + i + 2] = block [(i % (last + 1)) + 1];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: block [last + i + 2] = block [(i % (last + 1)) + 1];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  	/*-- 				Use simpleSort()' since the full sorting mechanism 				has quite a large constant overhead. 				--*/for (i = 0; i <= last; i++) {  		zptr [i] = i;  	}  	firstAttempt = false;  	workDone = workLimit = 0;  	SimpleSort (0' last' 0);  }  else {  	numQSorted = 0;  	for (i = 0; i <= 255; i++) {  		bigDone [i] = false;  	}  	for (i = 0; i <= 65536; i++) {  		ftab [i] = 0;  	}  	c1 = block [0];  	for (i = 0; i <= last; i++) {  		c2 = block [i + 1];  		ftab [(c1 << 8) + c2]++;  		c1 = c2;  	}  	for (i = 1; i <= 65536; i++) {  		ftab [i] += ftab [i - 1];  	}  	c1 = block [1];  	for (i = 0; i < last; i++) {  		c2 = block [i + 2];  		j = (c1 << 8) + c2;  		c1 = c2;  		ftab [j]--;  		zptr [ftab [j]] = i;  	}  	j = ((block [last + 1]) << 8) + (block [1]);  	ftab [j]--;  	zptr [ftab [j]] = last;  	/*-- 				Now ftab contains the first loc of every small bucket. 				Calculate the running order' from smallest to largest 				big bucket. 				--*/for (i = 0; i <= 255; i++) {  		runningOrder [i] = i;  	}  	int vv;  	int h = 1;  	do {  		h = 3 * h + 1;  	}  	while (h <= 256);  	do {  		h = h / 3;  		for (i = h; i <= 255; i++) {  			vv = runningOrder [i];  			j = i;  			while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  				runningOrder [j] = runningOrder [j - h];  				j = j - h;  				if (j <= (h - 1)) {  					break;  				}  			}  			runningOrder [j] = vv;  		}  	}  	while (h != 1);  	/*-- 				The main sorting loop. 				--*/for (i = 0; i <= 255; i++) {  		/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  		/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  			sb = (ss << 8) + j;  			if (!((ftab [sb] & SETMASK) == SETMASK)) {  				int lo = ftab [sb] & CLEARMASK;  				int hi = (ftab [sb + 1] & CLEARMASK) - 1;  				if (hi > lo) {  					QSort3 (lo' hi' 2);  					numQSorted += (hi - lo + 1);  					if (workDone > workLimit && firstAttempt) {  						return;  					}  				}  				ftab [sb] |= SETMASK;  			}  		}  		/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  		if (i < 255) {  			int bbStart = ftab [ss << 8] & CLEARMASK;  			int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  			int shifts = 0;  			while ((bbSize >> shifts) > 65534) {  				shifts++;  			}  			for (j = 0; j < bbSize; j++) {  				int a2update = zptr [bbStart + j];  				int qVal = (j >> shifts);  				quadrant [a2update] = qVal;  				if (a2update < BZip2Constants.OvershootBytes) {  					quadrant [a2update + last + 1] = qVal;  				}  			}  			if (!(((bbSize - 1) >> shifts) <= 65535)) {  				Panic ();  			}  		}  		/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  			copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  		}  		for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  			c1 = block [zptr [j]];  			if (!bigDone [c1]) {  				zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  				copy [c1]++;  			}  		}  		for (j = 0; j <= 255; j++) {  			ftab [(j << 8) + ss] |= SETMASK;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	bigDone [i] = false;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 65536; i++) {  	ftab [i] = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= last; i++) {  	c2 = block [i + 1];  	ftab [(c1 << 8) + c2]++;  	c1 = c2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: ftab [(c1 << 8) + c2]++;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 1; i <= 65536; i++) {  	ftab [i] += ftab [i - 1];  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i < last; i++) {  	c2 = block [i + 2];  	j = (c1 << 8) + c2;  	c1 = c2;  	ftab [j]--;  	zptr [ftab [j]] = i;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i < last; i++) {  	c2 = block [i + 2];  	j = (c1 << 8) + c2;  	c1 = c2;  	ftab [j]--;  	zptr [ftab [j]] = i;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: c2 = block [i + 2];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: j = (c1 << 8) + c2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: j = ((block [last + 1]) << 8) + (block [1]);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	runningOrder [i] = i;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = 3 * h + 1;  }  while (h <= 256);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = 3 * h + 1;  }  while (h <= 256);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: h = 3 * h + 1;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1)) {  				break;  			}  		}  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1)) {  				break;  			}  		}  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1)) {  				break;  			}  		}  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1)) {  				break;  			}  		}  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1)) {  				break;  			}  		}  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1)) {  				break;  			}  		}  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: h = h / 3;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = h; i <= 255; i++) {  	vv = runningOrder [i];  	j = i;  	while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  		runningOrder [j] = runningOrder [j - h];  		j = j - h;  		if (j <= (h - 1)) {  			break;  		}  	}  	runningOrder [j] = vv;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = h; i <= 255; i++) {  	vv = runningOrder [i];  	j = i;  	while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  		runningOrder [j] = runningOrder [j - h];  		j = j - h;  		if (j <= (h - 1)) {  			break;  		}  	}  	runningOrder [j] = vv;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = h; i <= 255; i++) {  	vv = runningOrder [i];  	j = i;  	while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  		runningOrder [j] = runningOrder [j - h];  		j = j - h;  		if (j <= (h - 1)) {  			break;  		}  	}  	runningOrder [j] = vv;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = h; i <= 255; i++) {  	vv = runningOrder [i];  	j = i;  	while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  		runningOrder [j] = runningOrder [j - h];  		j = j - h;  		if (j <= (h - 1)) {  			break;  		}  	}  	runningOrder [j] = vv;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = h; i <= 255; i++) {  	vv = runningOrder [i];  	j = i;  	while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  		runningOrder [j] = runningOrder [j - h];  		j = j - h;  		if (j <= (h - 1)) {  			break;  		}  	}  	runningOrder [j] = vv;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  	runningOrder [j] = runningOrder [j - h];  	j = j - h;  	if (j <= (h - 1)) {  		break;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  	runningOrder [j] = runningOrder [j - h];  	j = j - h;  	if (j <= (h - 1)) {  		break;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  	runningOrder [j] = runningOrder [j - h];  	j = j - h;  	if (j <= (h - 1)) {  		break;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: while ((ftab [((runningOrder [j - h]) + 1) << 8] - ftab [(runningOrder [j - h]) << 8]) > (ftab [((vv) + 1) << 8] - ftab [(vv) << 8])) {  	runningOrder [j] = runningOrder [j - h];  	j = j - h;  	if (j <= (h - 1)) {  		break;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 					Process big buckets' starting with the least full. 					--*/ss = runningOrder [i];  	/*-- 					Complete the big bucket [ss] by quicksorting 					any unsorted small buckets [ss' j].  Hopefully 					previous pointer-scanning phases have already 					completed many of the small buckets [ss' j]' so 					we don't have to sort them at all. 					--*/for (j = 0; j <= 255; j++) {  		sb = (ss << 8) + j;  		if (!((ftab [sb] & SETMASK) == SETMASK)) {  			int lo = ftab [sb] & CLEARMASK;  			int hi = (ftab [sb + 1] & CLEARMASK) - 1;  			if (hi > lo) {  				QSort3 (lo' hi' 2);  				numQSorted += (hi - lo + 1);  				if (workDone > workLimit && firstAttempt) {  					return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	/*-- 					The ss big bucket is now done.  Record this fact' 					and update the quadrant descriptors.  Remember to 					update quadrants in the overshoot area too' if 					necessary.  The "if (i < 255)" test merely skips 					this updating for the last bucket processed' since 					updating for the last bucket is pointless. 					--*/bigDone [ss] = true;  	if (i < 255) {  		int bbStart = ftab [ss << 8] & CLEARMASK;  		int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		int shifts = 0;  		while ((bbSize >> shifts) > 65534) {  			shifts++;  		}  		for (j = 0; j < bbSize; j++) {  			int a2update = zptr [bbStart + j];  			int qVal = (j >> shifts);  			quadrant [a2update] = qVal;  			if (a2update < BZip2Constants.OvershootBytes) {  				quadrant [a2update + last + 1] = qVal;  			}  		}  		if (!(((bbSize - 1) >> shifts) <= 65535)) {  			Panic ();  		}  	}  	/*-- 					Now scan this big bucket so as to synthesise the 					sorted order for small buckets [t' ss] for all t != ss. 					--*/for (j = 0; j <= 255; j++) {  		copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  	}  	for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  		c1 = block [zptr [j]];  		if (!bigDone [c1]) {  			zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  			copy [c1]++;  		}  	}  	for (j = 0; j <= 255; j++) {  		ftab [(j << 8) + ss] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	sb = (ss << 8) + j;  	if (!((ftab [sb] & SETMASK) == SETMASK)) {  		int lo = ftab [sb] & CLEARMASK;  		int hi = (ftab [sb + 1] & CLEARMASK) - 1;  		if (hi > lo) {  			QSort3 (lo' hi' 2);  			numQSorted += (hi - lo + 1);  			if (workDone > workLimit && firstAttempt) {  				return;  			}  		}  		ftab [sb] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	sb = (ss << 8) + j;  	if (!((ftab [sb] & SETMASK) == SETMASK)) {  		int lo = ftab [sb] & CLEARMASK;  		int hi = (ftab [sb + 1] & CLEARMASK) - 1;  		if (hi > lo) {  			QSort3 (lo' hi' 2);  			numQSorted += (hi - lo + 1);  			if (workDone > workLimit && firstAttempt) {  				return;  			}  		}  		ftab [sb] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	sb = (ss << 8) + j;  	if (!((ftab [sb] & SETMASK) == SETMASK)) {  		int lo = ftab [sb] & CLEARMASK;  		int hi = (ftab [sb + 1] & CLEARMASK) - 1;  		if (hi > lo) {  			QSort3 (lo' hi' 2);  			numQSorted += (hi - lo + 1);  			if (workDone > workLimit && firstAttempt) {  				return;  			}  		}  		ftab [sb] |= SETMASK;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: sb = (ss << 8) + j;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (!((ftab [sb] & SETMASK) == SETMASK)) {  	int lo = ftab [sb] & CLEARMASK;  	int hi = (ftab [sb + 1] & CLEARMASK) - 1;  	if (hi > lo) {  		QSort3 (lo' hi' 2);  		numQSorted += (hi - lo + 1);  		if (workDone > workLimit && firstAttempt) {  			return;  		}  	}  	ftab [sb] |= SETMASK;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (hi > lo) {  	QSort3 (lo' hi' 2);  	numQSorted += (hi - lo + 1);  	if (workDone > workLimit && firstAttempt) {  		return;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: QSort3 (lo' hi' 2);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (i < 255) {  	int bbStart = ftab [ss << 8] & CLEARMASK;  	int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	int shifts = 0;  	while ((bbSize >> shifts) > 65534) {  		shifts++;  	}  	for (j = 0; j < bbSize; j++) {  		int a2update = zptr [bbStart + j];  		int qVal = (j >> shifts);  		quadrant [a2update] = qVal;  		if (a2update < BZip2Constants.OvershootBytes) {  			quadrant [a2update + last + 1] = qVal;  		}  	}  	if (!(((bbSize - 1) >> shifts) <= 65535)) {  		Panic ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (i < 255) {  	int bbStart = ftab [ss << 8] & CLEARMASK;  	int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	int shifts = 0;  	while ((bbSize >> shifts) > 65534) {  		shifts++;  	}  	for (j = 0; j < bbSize; j++) {  		int a2update = zptr [bbStart + j];  		int qVal = (j >> shifts);  		quadrant [a2update] = qVal;  		if (a2update < BZip2Constants.OvershootBytes) {  			quadrant [a2update + last + 1] = qVal;  		}  	}  	if (!(((bbSize - 1) >> shifts) <= 65535)) {  		Panic ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (i < 255) {  	int bbStart = ftab [ss << 8] & CLEARMASK;  	int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	int shifts = 0;  	while ((bbSize >> shifts) > 65534) {  		shifts++;  	}  	for (j = 0; j < bbSize; j++) {  		int a2update = zptr [bbStart + j];  		int qVal = (j >> shifts);  		quadrant [a2update] = qVal;  		if (a2update < BZip2Constants.OvershootBytes) {  			quadrant [a2update + last + 1] = qVal;  		}  	}  	if (!(((bbSize - 1) >> shifts) <= 65535)) {  		Panic ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (i < 255) {  	int bbStart = ftab [ss << 8] & CLEARMASK;  	int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	int shifts = 0;  	while ((bbSize >> shifts) > 65534) {  		shifts++;  	}  	for (j = 0; j < bbSize; j++) {  		int a2update = zptr [bbStart + j];  		int qVal = (j >> shifts);  		quadrant [a2update] = qVal;  		if (a2update < BZip2Constants.OvershootBytes) {  			quadrant [a2update + last + 1] = qVal;  		}  	}  	if (!(((bbSize - 1) >> shifts) <= 65535)) {  		Panic ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (i < 255) {  	int bbStart = ftab [ss << 8] & CLEARMASK;  	int bbSize = (ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	int shifts = 0;  	while ((bbSize >> shifts) > 65534) {  		shifts++;  	}  	for (j = 0; j < bbSize; j++) {  		int a2update = zptr [bbStart + j];  		int qVal = (j >> shifts);  		quadrant [a2update] = qVal;  		if (a2update < BZip2Constants.OvershootBytes) {  			quadrant [a2update + last + 1] = qVal;  		}  	}  	if (!(((bbSize - 1) >> shifts) <= 65535)) {  		Panic ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: while ((bbSize >> shifts) > 65534) {  	shifts++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (!(((bbSize - 1) >> shifts) <= 65535)) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: copy [j] = ftab [(j << 8) + ss] & CLEARMASK;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  	c1 = block [zptr [j]];  	if (!bigDone [c1]) {  		zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  		copy [c1]++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = ftab [ss << 8] & CLEARMASK; j < (ftab [(ss + 1) << 8] & CLEARMASK); j++) {  	c1 = block [zptr [j]];  	if (!bigDone [c1]) {  		zptr [copy [c1]] = zptr [j] == 0 ? last : zptr [j] - 1;  		copy [c1]++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: j = ftab [ss << 8] & CLEARMASK
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	ftab [(j << 8) + ss] |= SETMASK;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	ftab [(j << 8) + ss] |= SETMASK;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: ftab [(j << 8) + ss] |= SETMASK;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	inUse [i] = false;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i <= last; i++) {  	if (rNToGo == 0) {  		rNToGo = (int)BZip2Constants.RandomNumbers [rTPos];  		rTPos++;  		if (rTPos == 512) {  			rTPos = 0;  		}  	}  	rNToGo--;  	block [i + 1] ^= (byte)((rNToGo == 1) ? 1 : 0);  	// handle 16 bit signed numbers  	block [i + 1] &= 0xFF;  	inUse [block [i + 1]] = true;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: if (rNToGo == 0) {  	rNToGo = (int)BZip2Constants.RandomNumbers [rTPos];  	rTPos++;  	if (rTPos == 512) {  		rTPos = 0;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: if (rTPos == 512) {  	rTPos = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The following statement contains a magic number: do {  	c1 = block [i1 + 1];  	c2 = block [i2 + 1];  	if (c1 != c2) {  		return c1 > c2;  	}  	s1 = quadrant [i1];  	s2 = quadrant [i2];  	if (s1 != s2) {  		return s1 > s2;  	}  	i1++;  	i2++;  	c1 = block [i1 + 1];  	c2 = block [i2 + 1];  	if (c1 != c2) {  		return c1 > c2;  	}  	s1 = quadrant [i1];  	s2 = quadrant [i2];  	if (s1 != s2) {  		return s1 > s2;  	}  	i1++;  	i2++;  	c1 = block [i1 + 1];  	c2 = block [i2 + 1];  	if (c1 != c2) {  		return c1 > c2;  	}  	s1 = quadrant [i1];  	s2 = quadrant [i2];  	if (s1 != s2) {  		return s1 > s2;  	}  	i1++;  	i2++;  	c1 = block [i1 + 1];  	c2 = block [i2 + 1];  	if (c1 != c2) {  		return c1 > c2;  	}  	s1 = quadrant [i1];  	s2 = quadrant [i2];  	if (s1 != s2) {  		return s1 > s2;  	}  	i1++;  	i2++;  	if (i1 > last) {  		i1 -= last;  		i1--;  	}  	if (i2 > last) {  		i2 -= last;  		i2--;  	}  	k -= 4;  	++workDone;  }  while (k >= 0);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The following statement contains a magic number: k -= 4;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: ftab = new int[65537];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: szptr = new short[2 * n];  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  	char ll_i;  	ll_i = unseqToSeq [block [zptr [i]]];  	j = 0;  	tmp = yy [j];  	while (ll_i != tmp) {  		j++;  		tmp2 = tmp;  		tmp = yy [j];  		yy [j] = tmp2;  	}  	yy [0] = tmp;  	if (j == 0) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				switch (zPend % 2) {  				case 0:  					szptr [wr] = (short)BZip2Constants.RunA;  					wr++;  					mtfFreq [BZip2Constants.RunA]++;  					break;  				case 1:  					szptr [wr] = (short)BZip2Constants.RunB;  					wr++;  					mtfFreq [BZip2Constants.RunB]++;  					break;  				}  				if (zPend < 2) {  					break;  				}  				zPend = (zPend - 2) / 2;  			}  			zPend = 0;  		}  		szptr [wr] = (short)(j + 1);  		wr++;  		mtfFreq [j + 1]++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  	char ll_i;  	ll_i = unseqToSeq [block [zptr [i]]];  	j = 0;  	tmp = yy [j];  	while (ll_i != tmp) {  		j++;  		tmp2 = tmp;  		tmp = yy [j];  		yy [j] = tmp2;  	}  	yy [0] = tmp;  	if (j == 0) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				switch (zPend % 2) {  				case 0:  					szptr [wr] = (short)BZip2Constants.RunA;  					wr++;  					mtfFreq [BZip2Constants.RunA]++;  					break;  				case 1:  					szptr [wr] = (short)BZip2Constants.RunB;  					wr++;  					mtfFreq [BZip2Constants.RunB]++;  					break;  				}  				if (zPend < 2) {  					break;  				}  				zPend = (zPend - 2) / 2;  			}  			zPend = 0;  		}  		szptr [wr] = (short)(j + 1);  		wr++;  		mtfFreq [j + 1]++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  	char ll_i;  	ll_i = unseqToSeq [block [zptr [i]]];  	j = 0;  	tmp = yy [j];  	while (ll_i != tmp) {  		j++;  		tmp2 = tmp;  		tmp = yy [j];  		yy [j] = tmp2;  	}  	yy [0] = tmp;  	if (j == 0) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				switch (zPend % 2) {  				case 0:  					szptr [wr] = (short)BZip2Constants.RunA;  					wr++;  					mtfFreq [BZip2Constants.RunA]++;  					break;  				case 1:  					szptr [wr] = (short)BZip2Constants.RunB;  					wr++;  					mtfFreq [BZip2Constants.RunB]++;  					break;  				}  				if (zPend < 2) {  					break;  				}  				zPend = (zPend - 2) / 2;  			}  			zPend = 0;  		}  		szptr [wr] = (short)(j + 1);  		wr++;  		mtfFreq [j + 1]++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  	char ll_i;  	ll_i = unseqToSeq [block [zptr [i]]];  	j = 0;  	tmp = yy [j];  	while (ll_i != tmp) {  		j++;  		tmp2 = tmp;  		tmp = yy [j];  		yy [j] = tmp2;  	}  	yy [0] = tmp;  	if (j == 0) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				switch (zPend % 2) {  				case 0:  					szptr [wr] = (short)BZip2Constants.RunA;  					wr++;  					mtfFreq [BZip2Constants.RunA]++;  					break;  				case 1:  					szptr [wr] = (short)BZip2Constants.RunB;  					wr++;  					mtfFreq [BZip2Constants.RunB]++;  					break;  				}  				if (zPend < 2) {  					break;  				}  				zPend = (zPend - 2) / 2;  			}  			zPend = 0;  		}  		szptr [wr] = (short)(j + 1);  		wr++;  		mtfFreq [j + 1]++;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (j == 0) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			switch (zPend % 2) {  			case 0:  				szptr [wr] = (short)BZip2Constants.RunA;  				wr++;  				mtfFreq [BZip2Constants.RunA]++;  				break;  			case 1:  				szptr [wr] = (short)BZip2Constants.RunB;  				wr++;  				mtfFreq [BZip2Constants.RunB]++;  				break;  			}  			if (zPend < 2) {  				break;  			}  			zPend = (zPend - 2) / 2;  		}  		zPend = 0;  	}  	szptr [wr] = (short)(j + 1);  	wr++;  	mtfFreq [j + 1]++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (j == 0) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			switch (zPend % 2) {  			case 0:  				szptr [wr] = (short)BZip2Constants.RunA;  				wr++;  				mtfFreq [BZip2Constants.RunA]++;  				break;  			case 1:  				szptr [wr] = (short)BZip2Constants.RunB;  				wr++;  				mtfFreq [BZip2Constants.RunB]++;  				break;  			}  			if (zPend < 2) {  				break;  			}  			zPend = (zPend - 2) / 2;  		}  		zPend = 0;  	}  	szptr [wr] = (short)(j + 1);  	wr++;  	mtfFreq [j + 1]++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (j == 0) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			switch (zPend % 2) {  			case 0:  				szptr [wr] = (short)BZip2Constants.RunA;  				wr++;  				mtfFreq [BZip2Constants.RunA]++;  				break;  			case 1:  				szptr [wr] = (short)BZip2Constants.RunB;  				wr++;  				mtfFreq [BZip2Constants.RunB]++;  				break;  			}  			if (zPend < 2) {  				break;  			}  			zPend = (zPend - 2) / 2;  		}  		zPend = 0;  	}  	szptr [wr] = (short)(j + 1);  	wr++;  	mtfFreq [j + 1]++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (j == 0) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			switch (zPend % 2) {  			case 0:  				szptr [wr] = (short)BZip2Constants.RunA;  				wr++;  				mtfFreq [BZip2Constants.RunA]++;  				break;  			case 1:  				szptr [wr] = (short)BZip2Constants.RunB;  				wr++;  				mtfFreq [BZip2Constants.RunB]++;  				break;  			}  			if (zPend < 2) {  				break;  			}  			zPend = (zPend - 2) / 2;  		}  		zPend = 0;  	}  	szptr [wr] = (short)(j + 1);  	wr++;  	mtfFreq [j + 1]++;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  	zPend = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  	zPend = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  	zPend = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  	zPend = 0;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: switch (zPend % 2) {  case 0:  	szptr [wr] = (short)BZip2Constants.RunA;  	wr++;  	mtfFreq [BZip2Constants.RunA]++;  	break;  case 1:  	szptr [wr] = (short)BZip2Constants.RunB;  	wr++;  	mtfFreq [BZip2Constants.RunB]++;  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend < 2) {  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		switch (zPend % 2) {  		case 0:  			szptr [wr] = (short)BZip2Constants.RunA;  			wr++;  			mtfFreq [BZip2Constants.RunA]++;  			break;  		case 1:  			szptr [wr] = (short)BZip2Constants.RunB;  			wr++;  			mtfFreq [BZip2Constants.RunB]++;  			break;  		}  		if (zPend < 2) {  			break;  		}  		zPend = (zPend - 2) / 2;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: while (true) {  	switch (zPend % 2) {  	case 0:  		szptr [wr] = (short)BZip2Constants.RunA;  		wr++;  		mtfFreq [BZip2Constants.RunA]++;  		break;  	case 1:  		szptr [wr] = (short)BZip2Constants.RunB;  		wr++;  		mtfFreq [BZip2Constants.RunB]++;  		break;  	}  	if (zPend < 2) {  		break;  	}  	zPend = (zPend - 2) / 2;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: switch (zPend % 2) {  case 0:  	szptr [wr] = (short)BZip2Constants.RunA;  	wr++;  	mtfFreq [BZip2Constants.RunA]++;  	break;  case 1:  	szptr [wr] = (short)BZip2Constants.RunB;  	wr++;  	mtfFreq [BZip2Constants.RunB]++;  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend < 2) {  	break;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i) {  	weight [i + 1] = (freq [i] == 0 ? 1 : freq [i]) << 8;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: weight [i + 1] = (freq [i] == 0 ? 1 : freq [i]) << 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (int i = 1; i <= alphaSize; ++i) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		int zz = nHeap;  		int tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  		Panic ();  	}  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		int zz = 1;  		int yy = 0;  		int tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		zz = 1;  		yy = 0;  		tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff)));  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		zz = nHeap;  		tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  		Panic ();  	}  	tooLong = false;  	for (int i = 1; i <= alphaSize; ++i) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [i - 1] = (char)j;  		if (j > maxLen) {  			tooLong = true;  		}  	}  	if (!tooLong) {  		break;  	}  	for (int i = 1; i < alphaSize; ++i) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (int i = 1; i <= alphaSize; ++i) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		int zz = nHeap;  		int tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  		Panic ();  	}  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		int zz = 1;  		int yy = 0;  		int tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		zz = 1;  		yy = 0;  		tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff)));  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		zz = nHeap;  		tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  		Panic ();  	}  	tooLong = false;  	for (int i = 1; i <= alphaSize; ++i) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [i - 1] = (char)j;  		if (j > maxLen) {  			tooLong = true;  		}  	}  	if (!tooLong) {  		break;  	}  	for (int i = 1; i < alphaSize; ++i) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (int i = 1; i <= alphaSize; ++i) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		int zz = nHeap;  		int tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  		Panic ();  	}  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		int zz = 1;  		int yy = 0;  		int tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		zz = 1;  		yy = 0;  		tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff)));  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		zz = nHeap;  		tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  		Panic ();  	}  	tooLong = false;  	for (int i = 1; i <= alphaSize; ++i) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [i - 1] = (char)j;  		if (j > maxLen) {  			tooLong = true;  		}  	}  	if (!tooLong) {  		break;  	}  	for (int i = 1; i < alphaSize; ++i) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (int i = 1; i <= alphaSize; ++i) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		int zz = nHeap;  		int tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  		Panic ();  	}  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		int zz = 1;  		int yy = 0;  		int tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		zz = 1;  		yy = 0;  		tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff)));  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		zz = nHeap;  		tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  		Panic ();  	}  	tooLong = false;  	for (int i = 1; i <= alphaSize; ++i) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [i - 1] = (char)j;  		if (j > maxLen) {  			tooLong = true;  		}  	}  	if (!tooLong) {  		break;  	}  	for (int i = 1; i < alphaSize; ++i) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (int i = 1; i <= alphaSize; ++i) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		int zz = nHeap;  		int tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  		Panic ();  	}  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		int zz = 1;  		int yy = 0;  		int tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		zz = 1;  		yy = 0;  		tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff)));  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		zz = nHeap;  		tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  		Panic ();  	}  	tooLong = false;  	for (int i = 1; i <= alphaSize; ++i) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [i - 1] = (char)j;  		if (j > maxLen) {  			tooLong = true;  		}  	}  	if (!tooLong) {  		break;  	}  	for (int i = 1; i < alphaSize; ++i) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (int i = 1; i <= alphaSize; ++i) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		int zz = nHeap;  		int tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  		Panic ();  	}  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		int zz = 1;  		int yy = 0;  		int tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		zz = 1;  		yy = 0;  		tmp = heap [zz];  		while (true) {  			yy = zz << 1;  			if (yy > nHeap) {  				break;  			}  			if (yy < nHeap && weight [heap [yy + 1]] < weight [heap [yy]]) {  				yy++;  			}  			if (weight [tmp] < weight [heap [yy]]) {  				break;  			}  			heap [zz] = heap [yy];  			zz = yy;  		}  		heap [zz] = tmp;  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = (int)((weight [n1] & 0xffffff00) + (weight [n2] & 0xffffff00)) | (int)(1 + (((weight [n1] & 0x000000ff) > (weight [n2] & 0x000000ff)) ? (weight [n1] & 0x000000ff) : (weight [n2] & 0x000000ff)));  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		zz = nHeap;  		tmp = heap [zz];  		while (weight [tmp] < weight [heap [zz >> 1]]) {  			heap [zz] = heap [zz >> 1];  			zz >>= 1;  		}  		heap [zz] = tmp;  	}  	if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  		Panic ();  	}  	tooLong = false;  	for (int i = 1; i <= alphaSize; ++i) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [i - 1] = (char)j;  		if (j > maxLen) {  			tooLong = true;  		}  	}  	if (!tooLong) {  		break;  	}  	for (int i = 1; i < alphaSize; ++i) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: parent [0] = -2;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  	Panic ();  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 1; i < alphaSize; ++i) {  	j = weight [i] >> 8;  	j = 1 + (j / 2);  	weight [i] = j << 8;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 1; i < alphaSize; ++i) {  	j = weight [i] >> 8;  	j = 1 + (j / 2);  	weight [i] = j << 8;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 1; i < alphaSize; ++i) {  	j = weight [i] >> 8;  	j = 1 + (j / 2);  	weight [i] = j << 8;  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: j = weight [i] >> 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: j = 1 + (j / 2);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: weight [i] = j << 8;  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2.cs,Decompress,The following statement contains a magic number: try {  	using (BZip2InputStream bzipInput = new BZip2InputStream (inStream)) {  		bzipInput.IsStreamOwner = isStreamOwner;  		Core.StreamUtils.Copy (bzipInput' outStream' new byte[4096]);  	}  }  finally {  	if (isStreamOwner) {  		// inStream is closed by the BZip2InputStream if stream owner  		outStream.Close ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2.cs,Decompress,The following statement contains a magic number: using (BZip2InputStream bzipInput = new BZip2InputStream (inStream)) {  	bzipInput.IsStreamOwner = isStreamOwner;  	Core.StreamUtils.Copy (bzipInput' outStream' new byte[4096]);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2.cs,Decompress,The following statement contains a magic number: Core.StreamUtils.Copy (bzipInput' outStream' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2.cs,Compress,The following statement contains a magic number: try {  	using (BZip2OutputStream bzipOutput = new BZip2OutputStream (outStream' level)) {  		bzipOutput.IsStreamOwner = isStreamOwner;  		Core.StreamUtils.Copy (inStream' bzipOutput' new byte[4096]);  	}  }  finally {  	if (isStreamOwner) {  		// outStream is closed by the BZip2OutputStream if stream owner  		inStream.Close ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2.cs,Compress,The following statement contains a magic number: using (BZip2OutputStream bzipOutput = new BZip2OutputStream (outStream' level)) {  	bzipOutput.IsStreamOwner = isStreamOwner;  	Core.StreamUtils.Copy (inStream' bzipOutput' new byte[4096]);  }  
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2.cs,Compress,The following statement contains a magic number: Core.StreamUtils.Copy (inStream' bzipOutput' new byte[4096]);  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Alphaleonis.Win32.Filesystem.Directory.Exists (file)) {  	header.Mode = 1003;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_DIR;  	if ((header.Name.Length == 0) || header.Name [header.Name.Length - 1] != '/') {  		header.Name = header.Name + "/";  	}  	header.Size = 0;  }  else {  	header.Mode = 33216;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_NORMAL;  	header.Size = new FileInfo (file.Replace ('/'' Alphaleonis.Win32.Filesystem.Path.DirectorySeparatorChar)).Length;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Alphaleonis.Win32.Filesystem.Directory.Exists (file)) {  	header.Mode = 1003;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_DIR;  	if ((header.Name.Length == 0) || header.Name [header.Name.Length - 1] != '/') {  		header.Name = header.Name + "/";  	}  	header.Size = 0;  }  else {  	header.Mode = 33216;  	// Magic number for security access for a UNIX filesystem  	header.TypeFlag = TarHeader.LF_NORMAL;  	header.Size = new FileInfo (file.Replace ('/'' Alphaleonis.Win32.Filesystem.Path.DirectorySeparatorChar)).Length;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: header.Mode = 1003;  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: header.Mode = 33216;  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: if (header [offset] >= 0x80) {  	// File sizes over 8GB are stored in 8 right-justified bytes of binary indicated by setting the high-order bit of the leftmost byte of a numeric field.  	long result = 0;  	for (int pos = length - 8; pos < length; pos++) {  		result = result << 8 | header [offset + pos];  	}  	return result;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: if (header [offset] >= 0x80) {  	// File sizes over 8GB are stored in 8 right-justified bytes of binary indicated by setting the high-order bit of the leftmost byte of a numeric field.  	long result = 0;  	for (int pos = length - 8; pos < length; pos++) {  		result = result << 8 | header [offset + pos];  	}  	return result;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: for (int pos = length - 8; pos < length; pos++) {  	result = result << 8 | header [offset + pos];  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: for (int pos = length - 8; pos < length; pos++) {  	result = result << 8 | header [offset + pos];  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: result = result << 8 | header [offset + pos];  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseOctal,The following statement contains a magic number: for (int i = offset; i < end; ++i) {  	if (header [i] == 0) {  		break;  	}  	if (header [i] == (byte)' ' || header [i] == '0') {  		if (stillPadding) {  			continue;  		}  		if (header [i] == (byte)' ') {  			break;  		}  	}  	stillPadding = false;  	result = (result << 3) + (header [i] - '0');  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,ParseOctal,The following statement contains a magic number: result = (result << 3) + (header [i] - '0');  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  	for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  		buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  		v >>= 3;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  	for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  		buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  		v >>= 3;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  	buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  	v >>= 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  	buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  	v >>= 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: buffer [offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: v >>= 3;  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetBinaryOrOctalBytes,The following statement contains a magic number: if (value > 0x1FFFFFFFF) {  	// Octal 77777777777 (11 digits)  	// Put value as binary' right-justified into the buffer. Set high order bit of left-most byte.  	for (int pos = length - 1; pos > 0; pos--) {  		buffer [offset + pos] = (byte)value;  		value = value >> 8;  	}  	buffer [offset] = 0x80;  	return offset + length;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetBinaryOrOctalBytes,The following statement contains a magic number: for (int pos = length - 1; pos > 0; pos--) {  	buffer [offset + pos] = (byte)value;  	value = value >> 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarHeader.cs,GetBinaryOrOctalBytes,The following statement contains a magic number: value = value >> 8;  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  	EnsureDirectoryExists (destFile);  }  else {  	string parentDirectory = Alphaleonis.Win32.Filesystem.Path.GetDirectoryName (destFile);  	EnsureDirectoryExists (parentDirectory);  	bool process = true;  	FileInfo fileInfo = new FileInfo (destFile);  	if (fileInfo.Exists) {  		if (keepOldFiles) {  			OnProgressMessageEvent (entry' "Destination file already exists");  			process = false;  		}  		else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  			OnProgressMessageEvent (entry' "Destination file already exists' and is read-only");  			process = false;  		}  	}  	if (process) {  		bool asciiTrans = false;  		Stream outputStream = Alphaleonis.Win32.Filesystem.File.Create (destFile);  		if (this.asciiTranslate) {  			asciiTrans = !IsBinary (destFile);  		}  		StreamWriter outw = null;  		if (asciiTrans) {  			outw = new StreamWriter (outputStream);  		}  		byte[] rdbuf = new byte[32 * 1024];  		while (true) {  			int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  			if (numRead <= 0) {  				break;  			}  			if (asciiTrans) {  				for (int off = 0' b = 0; b < numRead; ++b) {  					if (rdbuf [b] == 10) {  						string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  						outw.WriteLine (s);  						off = b + 1;  					}  				}  			}  			else {  				outputStream.Write (rdbuf' 0' numRead);  			}  		}  		if (asciiTrans) {  			outw.Close ();  		}  		else {  			outputStream.Close ();  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  	EnsureDirectoryExists (destFile);  }  else {  	string parentDirectory = Alphaleonis.Win32.Filesystem.Path.GetDirectoryName (destFile);  	EnsureDirectoryExists (parentDirectory);  	bool process = true;  	FileInfo fileInfo = new FileInfo (destFile);  	if (fileInfo.Exists) {  		if (keepOldFiles) {  			OnProgressMessageEvent (entry' "Destination file already exists");  			process = false;  		}  		else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  			OnProgressMessageEvent (entry' "Destination file already exists' and is read-only");  			process = false;  		}  	}  	if (process) {  		bool asciiTrans = false;  		Stream outputStream = Alphaleonis.Win32.Filesystem.File.Create (destFile);  		if (this.asciiTranslate) {  			asciiTrans = !IsBinary (destFile);  		}  		StreamWriter outw = null;  		if (asciiTrans) {  			outw = new StreamWriter (outputStream);  		}  		byte[] rdbuf = new byte[32 * 1024];  		while (true) {  			int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  			if (numRead <= 0) {  				break;  			}  			if (asciiTrans) {  				for (int off = 0' b = 0; b < numRead; ++b) {  					if (rdbuf [b] == 10) {  						string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  						outw.WriteLine (s);  						off = b + 1;  					}  				}  			}  			else {  				outputStream.Write (rdbuf' 0' numRead);  			}  		}  		if (asciiTrans) {  			outw.Close ();  		}  		else {  			outputStream.Close ();  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  	EnsureDirectoryExists (destFile);  }  else {  	string parentDirectory = Alphaleonis.Win32.Filesystem.Path.GetDirectoryName (destFile);  	EnsureDirectoryExists (parentDirectory);  	bool process = true;  	FileInfo fileInfo = new FileInfo (destFile);  	if (fileInfo.Exists) {  		if (keepOldFiles) {  			OnProgressMessageEvent (entry' "Destination file already exists");  			process = false;  		}  		else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  			OnProgressMessageEvent (entry' "Destination file already exists' and is read-only");  			process = false;  		}  	}  	if (process) {  		bool asciiTrans = false;  		Stream outputStream = Alphaleonis.Win32.Filesystem.File.Create (destFile);  		if (this.asciiTranslate) {  			asciiTrans = !IsBinary (destFile);  		}  		StreamWriter outw = null;  		if (asciiTrans) {  			outw = new StreamWriter (outputStream);  		}  		byte[] rdbuf = new byte[32 * 1024];  		while (true) {  			int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  			if (numRead <= 0) {  				break;  			}  			if (asciiTrans) {  				for (int off = 0' b = 0; b < numRead; ++b) {  					if (rdbuf [b] == 10) {  						string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  						outw.WriteLine (s);  						off = b + 1;  					}  				}  			}  			else {  				outputStream.Write (rdbuf' 0' numRead);  			}  		}  		if (asciiTrans) {  			outw.Close ();  		}  		else {  			outputStream.Close ();  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (process) {  	bool asciiTrans = false;  	Stream outputStream = Alphaleonis.Win32.Filesystem.File.Create (destFile);  	if (this.asciiTranslate) {  		asciiTrans = !IsBinary (destFile);  	}  	StreamWriter outw = null;  	if (asciiTrans) {  		outw = new StreamWriter (outputStream);  	}  	byte[] rdbuf = new byte[32 * 1024];  	while (true) {  		int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  		if (numRead <= 0) {  			break;  		}  		if (asciiTrans) {  			for (int off = 0' b = 0; b < numRead; ++b) {  				if (rdbuf [b] == 10) {  					string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  					outw.WriteLine (s);  					off = b + 1;  				}  			}  		}  		else {  			outputStream.Write (rdbuf' 0' numRead);  		}  	}  	if (asciiTrans) {  		outw.Close ();  	}  	else {  		outputStream.Close ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (process) {  	bool asciiTrans = false;  	Stream outputStream = Alphaleonis.Win32.Filesystem.File.Create (destFile);  	if (this.asciiTranslate) {  		asciiTrans = !IsBinary (destFile);  	}  	StreamWriter outw = null;  	if (asciiTrans) {  		outw = new StreamWriter (outputStream);  	}  	byte[] rdbuf = new byte[32 * 1024];  	while (true) {  		int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  		if (numRead <= 0) {  			break;  		}  		if (asciiTrans) {  			for (int off = 0' b = 0; b < numRead; ++b) {  				if (rdbuf [b] == 10) {  					string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  					outw.WriteLine (s);  					off = b + 1;  				}  			}  		}  		else {  			outputStream.Write (rdbuf' 0' numRead);  		}  	}  	if (asciiTrans) {  		outw.Close ();  	}  	else {  		outputStream.Close ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (process) {  	bool asciiTrans = false;  	Stream outputStream = Alphaleonis.Win32.Filesystem.File.Create (destFile);  	if (this.asciiTranslate) {  		asciiTrans = !IsBinary (destFile);  	}  	StreamWriter outw = null;  	if (asciiTrans) {  		outw = new StreamWriter (outputStream);  	}  	byte[] rdbuf = new byte[32 * 1024];  	while (true) {  		int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  		if (numRead <= 0) {  			break;  		}  		if (asciiTrans) {  			for (int off = 0' b = 0; b < numRead; ++b) {  				if (rdbuf [b] == 10) {  					string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  					outw.WriteLine (s);  					off = b + 1;  				}  			}  		}  		else {  			outputStream.Write (rdbuf' 0' numRead);  		}  	}  	if (asciiTrans) {  		outw.Close ();  	}  	else {  		outputStream.Close ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: while (true) {  	int numRead = tarIn.Read (rdbuf' 0' rdbuf.Length);  	if (numRead <= 0) {  		break;  	}  	if (asciiTrans) {  		for (int off = 0' b = 0; b < numRead; ++b) {  			if (rdbuf [b] == 10) {  				string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  				outw.WriteLine (s);  				off = b + 1;  			}  		}  	}  	else {  		outputStream.Write (rdbuf' 0' numRead);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (asciiTrans) {  	for (int off = 0' b = 0; b < numRead; ++b) {  		if (rdbuf [b] == 10) {  			string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  			outw.WriteLine (s);  			off = b + 1;  		}  	}  }  else {  	outputStream.Write (rdbuf' 0' numRead);  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: for (int off = 0' b = 0; b < numRead; ++b) {  	if (rdbuf [b] == 10) {  		string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  		outw.WriteLine (s);  		off = b + 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (rdbuf [b] == 10) {  	string s = Encoding.ASCII.GetString (rdbuf' off' (b - off));  	outw.WriteLine (s);  	off = b + 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: if (entry.IsDirectory) {  	if (recurse) {  		TarEntry[] list = entry.GetDirectoryEntries ();  		for (int i = 0; i < list.Length; ++i) {  			WriteEntryCore (list [i]' recurse);  		}  	}  }  else {  	using (Stream inputStream = Alphaleonis.Win32.Filesystem.File.OpenRead (entryFilename)) {  		byte[] localBuffer = new byte[32 * 1024];  		while (true) {  			int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  			if (numRead <= 0) {  				break;  			}  			tarOut.Write (localBuffer' 0' numRead);  		}  	}  	if ((tempFileName != null) && (tempFileName.Length > 0)) {  		Alphaleonis.Win32.Filesystem.File.Delete (tempFileName);  	}  	tarOut.CloseEntry ();  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: if (entry.IsDirectory) {  	if (recurse) {  		TarEntry[] list = entry.GetDirectoryEntries ();  		for (int i = 0; i < list.Length; ++i) {  			WriteEntryCore (list [i]' recurse);  		}  	}  }  else {  	using (Stream inputStream = Alphaleonis.Win32.Filesystem.File.OpenRead (entryFilename)) {  		byte[] localBuffer = new byte[32 * 1024];  		while (true) {  			int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  			if (numRead <= 0) {  				break;  			}  			tarOut.Write (localBuffer' 0' numRead);  		}  	}  	if ((tempFileName != null) && (tempFileName.Length > 0)) {  		Alphaleonis.Win32.Filesystem.File.Delete (tempFileName);  	}  	tarOut.CloseEntry ();  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: using (Stream inputStream = Alphaleonis.Win32.Filesystem.File.OpenRead (entryFilename)) {  	byte[] localBuffer = new byte[32 * 1024];  	while (true) {  		int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  		if (numRead <= 0) {  			break;  		}  		tarOut.Write (localBuffer' 0' numRead);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: using (Stream inputStream = Alphaleonis.Win32.Filesystem.File.OpenRead (entryFilename)) {  	byte[] localBuffer = new byte[32 * 1024];  	while (true) {  		int numRead = inputStream.Read (localBuffer' 0' localBuffer.Length);  		if (numRead <= 0) {  			break;  		}  		tarOut.Write (localBuffer' 0' numRead);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = Alphaleonis.Win32.Filesystem.File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = Alphaleonis.Win32.Filesystem.File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = Alphaleonis.Win32.Filesystem.File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = Alphaleonis.Win32.Filesystem.File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = Alphaleonis.Win32.Filesystem.File.OpenRead (filename)) {  	int sampleSize = Math.Min (4096' (int)fs.Length);  	byte[] content = new byte[sampleSize];  	int bytesRead = fs.Read (content' 0' sampleSize);  	for (int i = 0; i < bytesRead; ++i) {  		byte b = content [i];  		if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  			return true;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: for (int i = 0; i < bytesRead; ++i) {  	byte b = content [i];  	if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bits >>= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(s >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bits >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bitCount -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  }  else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x030 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes [i] = BitReverse (i << 11);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength [i] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree (this' DIST_NUM' 1' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (distTree.numCodes - 1' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  	pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (bits > 0 && bits <= 5) {  	pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  	if (blTree.length [BL_ORDER [i]] > 0) {  		blTreeCodes = i + 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf [last_lit++] = (byte)(length - 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: return 285;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: code += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: code += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9)) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  	int more = 2 * WSIZE - lookahead - strstart;  	if (more > inputEnd - inputOff) {  		more = inputEnd - inputOff;  	}  	System.Array.Copy (inputBuf' inputOff' window' strstart + lookahead' more);  	adler.Update (inputBuf' inputOff' more);  	inputOff += more;  	totalIn += more;  	lookahead += more;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  	chainLength >>= 2;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		// We are flushing everything  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int hashHead;  	if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 						for (int i = 0 ; i < matchLen; i++) { 							if (window[strstart + i] != window[matchStart + i]) { 								throw new SharpZipBaseException("Match failure"); 							} 						} 					} #endif  		bool full = huffman.TallyDist (strstart - matchStart' matchLen);  		lookahead -= matchLen;  		if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  			while (--matchLen > 0) {  				++strstart;  				InsertString ();  			}  			++strstart;  		}  		else {  			strstart += matchLen;  			if (lookahead >= MIN_MATCH - 1) {  				UpdateHash ();  			}  		}  		matchLen = MIN_MATCH - 1;  		if (!full) {  			continue;  		}  	}  	else {  		// No match found  		huffman.TallyLit (window [strstart] & 0xff);  		++strstart;  		--lookahead;  	}  	if (huffman.IsFull ()) {  		bool lastBlock = finish && (lookahead == 0);  		huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  		blockStart = strstart;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (lookahead >= MIN_MATCH) {  	int hashHead = InsertString ();  	if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		// Discard match if too small and too far away  		if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  			matchLen = MIN_MATCH - 1;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  	// longestMatch sets matchStart and matchLen  	// Discard match if too small and too far away  	if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  		matchLen = MIN_MATCH - 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  	matchLen = MIN_MATCH - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  	#if DebugDeflation  						if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  	huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  	prevLen -= 2;  	do {  		strstart++;  		lookahead--;  		if (lookahead >= MIN_MATCH) {  			InsertString ();  		}  	}  	while (--prevLen > 0);  	strstart++;  	lookahead--;  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  }  else {  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	prevAvailable = true;  	strstart++;  	lookahead--;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  }  else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	}  	else {  		// symbol == 256: end of block  		distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	}  	else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  }  else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if ((state & IS_SETDICT) != 0) {  	int chksum = engine.Adler;  	engine.ResetAdler ();  	pending.WriteShortMSB (chksum >> 16);  	pending.WriteShortMSB (chksum & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (chksum >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: neededbits -= 10;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!noZlibHeaderOrFooter) {  	int adler = engine.Adler;  	pending.WriteShortMSB (adler >> 16);  	pending.WriteShortMSB (adler & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (adler >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\DeflaterOutputStream.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512) {  	throw new ArgumentOutOfRangeException ("bufferSize");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: bufferSize = 1024;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte () | (ReadLeByte () << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort () | (ReadLeShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt () | ((long)ReadLeInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek) {  	baseInputStream.Seek (count' SeekOrigin.Current);  	return count;  }  else {  	int length = 2048;  	if (count < length) {  		length = (int)count;  	}  	byte[] tmp = new byte[length];  	int readCount = 1;  	long toSkip = count;  	while ((toSkip > 0) && (readCount > 0)) {  		if (toSkip < length) {  			length = (int)toSkip;  		}  		readCount = baseInputStream.Read (tmp' 0' length);  		toSkip -= readCount;  	}  	return count - toSkip;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bitsInBuffer_ += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  	// bits_in_buffer may only be 0 or a multiple of 8  	throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer_ >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  	// We always want an even number of bytes in input' see peekBits  	buffer_ = (uint)(window_ [windowStart_++] & 0xff);  	bitsInBuffer_ = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  	// We always want an even number of bytes in input' see PeekBits  	buffer_ |= (uint)((buffer [offset++] & 0xff) << bitsInBuffer_);  	bitsInBuffer_ += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bitsInBuffer_ += 8;  
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (12' 31)' (19' 38)' (26' 45))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 37)' (12' 44))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (19' 38)' (26' 45))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((49' 79)' (61' 91))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((49' 68)' (73' 92))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((35' 54)' (62' 81))
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipInputStream.cs,BodyRead,The following switch statement is missing a default case: switch (method) {  case (int)CompressionMethod.Deflated:  	count = base.Read (buffer' offset' count);  	if (count <= 0) {  		if (!inf.IsFinished) {  			throw new ZipException ("Inflater not finished!");  		}  		inputBuffer.Available = inf.RemainingInput;  		// A csize of -1 is from an unpatched local header  		if ((flags & 8) == 0 && (inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  			throw new ZipException ("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  		}  		inf.Reset ();  		finished = true;  	}  	break;  case (int)CompressionMethod.Stored:  	if ((count > csize) && (csize >= 0)) {  		count = (int)csize;  	}  	if (count > 0) {  		count = inputBuffer.ReadClearTextBuffer (buffer' offset' count);  		if (count > 0) {  			csize -= count;  			size -= count;  		}  	}  	if (csize == 0) {  		finished = true;  	}  	else {  		if (count < 0) {  			throw new ZipException ("EOF in stored block");  		}  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipOutputStream.cs,Write,The following switch statement is missing a default case: switch (curMethod) {  case CompressionMethod.Deflated:  	base.Write (buffer' offset' count);  	break;  case CompressionMethod.Stored:  	if (Password != null) {  		CopyAndEncrypt (buffer' offset' count);  	}  	else {  		baseOutputStream_.Write (buffer' offset' count);  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,WriteLocalEntryHeader,The following switch statement is missing a default case: switch (useZip64_) {  case UseZip64.Dynamic:  	if (entry.Size < 0) {  		entry.ForceZip64 ();  	}  	break;  case UseZip64.On:  	entry.ForceZip64 ();  	break;  case UseZip64.Off:  	// Do nothing.  The entry itself may be using Zip64 independantly.  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\ZipFile.cs,RunUpdates,The following switch statement is missing a default case: switch (update.Command) {  case UpdateCommand.Copy:  	if (directUpdate) {  		CopyEntryDirect (workFile' update' ref destinationPosition);  	}  	else {  		CopyEntry (workFile' update);  	}  	break;  case UpdateCommand.Modify:  	// TODO: Direct modifying of an entry will take some legwork.  	ModifyEntry (workFile' update);  	break;  case UpdateCommand.Add:  	if (!IsNewArchive && directUpdate) {  		workFile.baseStream_.Position = destinationPosition;  	}  	AddEntry (workFile' update);  	if (directUpdate) {  		destinationPosition = workFile.baseStream_.Position;  	}  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2) {  case 0:  	szptr [wr] = (short)BZip2Constants.RunA;  	wr++;  	mtfFreq [BZip2Constants.RunA]++;  	break;  case 1:  	szptr [wr] = (short)BZip2Constants.RunB;  	wr++;  	mtfFreq [BZip2Constants.RunB]++;  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2) {  case 0:  	szptr [wr] = (short)BZip2Constants.RunA;  	wr++;  	mtfFreq [BZip2Constants.RunA]++;  	break;  case 1:  	szptr [wr] = (short)BZip2Constants.RunB;  	wr++;  	mtfFreq [BZip2Constants.RunB]++;  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\rajivkan_SharpZipLibWithLongPath\SharpZipLib\src\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction) {  case DEFLATE_STORED:  	if (strstart > blockStart) {  		huffman.FlushStoredBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	UpdateHash ();  	break;  case DEFLATE_FAST:  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	break;  case DEFLATE_SLOW:  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  	break;  }  
