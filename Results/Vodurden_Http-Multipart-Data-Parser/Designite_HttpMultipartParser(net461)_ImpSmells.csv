Implementation smell,Namespace,Class,File,Method,Description
Long Method,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePart,The method has 113 lines of code.
Long Method,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePartAsync,The method has 113 lines of code.
Complex Method,HttpMultipartParser,BinaryStreamStack,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\BinaryStreamStack.cs,ReadByteLine,Cyclomatic complexity of the method is 10
Long Parameter List,HttpMultipartParser,FilePart,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\FilePart.cs,FilePart,The method has 5 parameters. Parameters: name' fileName' data' contentType' contentDisposition
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,DetectBoundary,The following statement contains a magic number: string boundary = string.Concat(reader.ReadLine().Skip(2));
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,DetectBoundaryAsync,The following statement contains a magic number: var boundary = string.Concat(line.Skip(2));
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePart,The following statement contains a magic number: var fullBuffer = Utilities.ArrayPool.Rent(BinaryBufferSize * 2);
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePart,The following statement contains a magic number: int maxNewlineBytes = Encoding.GetMaxByteCount(2);
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePartAsync,The following statement contains a magic number: var fullBuffer = Utilities.ArrayPool.Rent(BinaryBufferSize * 2);
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePartAsync,The following statement contains a magic number: int maxNewlineBytes = Encoding.GetMaxByteCount(2);
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseSection,The following statement contains a magic number: Dictionary<string' string> values = SplitBySemicolonIgnoringSemicolonsInQuotes(line)                      .Select(x => x.Split(new[] { ':'' '=' }' 2))                        // select where the length of the array is equal to two' that way if it is only one it will                      // be ignored as it is invalid key-pair                      .Where(x => x.Length == 2)                        // Limit split to 2 splits so we don't accidently split characters in file paths.                      .ToDictionary(                          x => x[0].Trim().Replace("\""' string.Empty).ToLower()'                          x => x[1].Trim().Replace("\""' string.Empty));
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseSection,The following statement contains a magic number: Dictionary<string' string> values = SplitBySemicolonIgnoringSemicolonsInQuotes(line)                      .Select(x => x.Split(new[] { ':'' '=' }' 2))                        // select where the length of the array is equal to two' that way if it is only one it will                      // be ignored as it is invalid key-pair                      .Where(x => x.Length == 2)                        // Limit split to 2 splits so we don't accidently split characters in file paths.                      .ToDictionary(                          x => x[0].Trim().Replace("\""' string.Empty).ToLower()'                          x => x[1].Trim().Replace("\""' string.Empty));
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseSectionAsync,The following statement contains a magic number: Dictionary<string' string> values = SplitBySemicolonIgnoringSemicolonsInQuotes(line)                      .Select(x => x.Split(new[] { ':'' '=' }' 2))                        // select where the length of the array is equal to two' that way if it is only one it will                      // be ignored as it is invalid key-pair                      .Where(x => x.Length == 2)                        // Limit split to 2 splits so we don't accidently split characters in file paths.                      .ToDictionary(                          x => x[0].Trim().Replace("\""' string.Empty).ToLower()'                          x => x[1].Trim().Replace("\""' string.Empty));
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,D:\research\architectureSmells\repos\Vodurden_Http-Multipart-Data-Parser\Source\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseSectionAsync,The following statement contains a magic number: Dictionary<string' string> values = SplitBySemicolonIgnoringSemicolonsInQuotes(line)                      .Select(x => x.Split(new[] { ':'' '=' }' 2))                        // select where the length of the array is equal to two' that way if it is only one it will                      // be ignored as it is invalid key-pair                      .Where(x => x.Length == 2)                        // Limit split to 2 splits so we don't accidently split characters in file paths.                      .ToDictionary(                          x => x[0].Trim().Replace("\""' string.Empty).ToLower()'                          x => x[1].Trim().Replace("\""' string.Empty));
