Implementation smell,Namespace,Class,File,Method,Description
Long Method,HttpMultipartParser,StreamingMultipartFormDataParser,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePart,The method has 115 lines of code.
Complex Method,HttpMultipartParser,BinaryStreamStack,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\BinaryStreamStack.cs,ReadByteLine,Cyclomatic complexity of the method is 9
Long Parameter List,HttpMultipartParser,FilePart,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\FilePart.cs,FilePart,The method has 5 parameters. Parameters: name' fileName' data' contentType' contentDisposition
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\StreamingMultipartFormDataParser.cs,DetectBoundary,The following statement contains a magic number: string boundary = string.Concat(reader.ReadLine().Skip(2));
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePart,The following statement contains a magic number: var fullBuffer = new byte[BinaryBufferSize*2];
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseFilePart,The following statement contains a magic number: do              {                  curLength = reader.Read(curBuffer' 0' curBuffer.Length);                    // Combine both buffers into the fullBuffer                  // See: http://stackoverflow.com/questions/415291/best-way-to-combine-two-or-more-byte-arrays-in-c-sharp                  Buffer.BlockCopy(prevBuffer' 0' fullBuffer' 0' prevLength);                  Buffer.BlockCopy(curBuffer' 0' fullBuffer' prevLength' curLength);                  fullLength = prevLength + curLength;                    // Now we want to check for a substring within the current buffer.                  // We need to find the closest substring greedily. That is find the                  // closest boundary and don't miss the end --'s if it's an end boundary.                  int endBoundaryPos = SubsequenceFinder.Search(fullBuffer' endBoundaryBinary' fullLength);                  int endBoundaryLength = endBoundaryBinary.Length;                    int boundaryPos = SubsequenceFinder.Search(fullBuffer' boundaryBinary' fullLength);                  int boundaryLength = boundaryBinary.Length;                    // If the boundaryPos is exactly at the end of our full buffer then ignore it as it could                  // actually be a endBoundary that's had one or both of the '--' chopped off by the buffer.                  if(boundaryPos + boundaryLength == fullLength ||                     boundaryPos + boundaryLength + 1 == fullLength)                  {                      boundaryPos = -1;                  }                    // We need to select the appropriate position and length                  // based on the smallest non-negative position.                  int endPos = -1;                  int endPosLength = 0;                    if (endBoundaryPos >= 0 && boundaryPos >= 0)                  {                      if (boundaryPos < endBoundaryPos)                      {                          // Select boundary                          endPos = boundaryPos;                          endPosLength = boundaryLength;                      }                      else                      {                          // Select end boundary                          endPos = endBoundaryPos;                          endPosLength = endBoundaryLength;                          readEndBoundary = true;                      }                  }                  else if (boundaryPos >= 0 && endBoundaryPos < 0)                  {                      // Select boundary                          endPos = boundaryPos;                      endPosLength = boundaryLength;                  }                  else if (boundaryPos < 0 && endBoundaryPos >= 0)                  {                      // Select end boundary                      endPos = endBoundaryPos;                      endPosLength = endBoundaryLength;                      readEndBoundary = true;                  }                    if (endPos != -1)                  {                      // Now we need to check if the endPos is followed by \r\n or just \n. HTTP                      // specifies \r\n but some clients might encode with \n. Or we might get 0 if                      // we are at the end of the file.                      int boundaryNewlineOffset = CalculateNewlineLength(ref fullBuffer'                                                                         Math.Min(fullLength - 1'                                                                                  endPos + endPosLength));                        // We also need to check if the last n characters of the buffer to write                      // are a newline and if they are ignore them.                      int maxNewlineBytes = Encoding.GetMaxByteCount(2);                      int bufferNewlineOffset = FindNextNewline(                          ref fullBuffer' Math.Max(0' endPos - maxNewlineBytes)' maxNewlineBytes);                      int bufferNewlineLength = CalculateNewlineLength(ref fullBuffer' bufferNewlineOffset);                        // We've found an end. We need to consume all the binary up to it                       // and then write the remainder back to the original stream. Then we                      // need to modify the original streams position to take into account                      // the new data.                      // We also want to chop off the newline that is inserted by the protocl.                      // We can do this by reducing endPos by the length of newline in this environment                      // and encoding                      FileHandler(name' filename' contentType' contentDisposition' fullBuffer'                                  endPos - bufferNewlineLength);                        int writeBackOffset = endPos + endPosLength + boundaryNewlineOffset;                      int writeBackAmount = (prevLength + curLength) - writeBackOffset;                      var writeBackBuffer = new byte[writeBackAmount];                      Buffer.BlockCopy(fullBuffer' writeBackOffset' writeBackBuffer' 0' writeBackAmount);                      reader.Buffer(writeBackBuffer);                        break;                  }                    // No end' consume the entire previous buffer                      FileHandler(name' filename' contentType' contentDisposition' prevBuffer' prevLength);                    // Now we want to swap the two buffers' we don't care                  // what happens to the data from prevBuffer so we set                  // curBuffer to it so it gets overwrited.                  byte[] tempBuffer = curBuffer;                  curBuffer = prevBuffer;                  prevBuffer = tempBuffer;                    // We don't need to swap the lengths because                  // curLength will be overwritten in the next                  // iteration of the loop.                  prevLength = curLength;              } while (prevLength != 0);
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseSection,The following statement contains a magic number: while (line != string.Empty)              {                  if (line == null)                  {                      throw new MultipartParseException("Unexpected end of stream");                  }                    if (line == boundary || line == endBoundary)                  {                      throw new MultipartParseException("Unexpected end of section");                  }                      // This line parses the header values into a set of key/value pairs. For example:                  // Content-Disposition: form-data; name="textdata"                   // ["content-disposition"] = "form-data"                  // ["name"] = "textdata"                  // Content-Disposition: form-data; name="file"; filename="data.txt"                  // ["content-disposition"] = "form-data"                  // ["name"] = "file"                  // ["filename"] = "data.txt"                  // Content-Type: text/plain                   // ["content-type"] = "text/plain"                  Dictionary<string' string> values = SplitBySemicolonIgnoringSemicolonsInQuotes(line)                      .Select(x => x.Split(new[] {':'' '='}' 2))                      // select where the length of the array is equal to two' that way if it is only one it will                      // be ignored as it is invalid key-pair                      .Where(x=> x.Length == 2)                      // Limit split to 2 splits so we don't accidently split characters in file paths.                      .ToDictionary(                          x => x[0].Trim().Replace("\""' string.Empty).ToLower()'                          x => x[1].Trim().Replace("\""' string.Empty));                      // Here we just want to push all the values that we just retrieved into the                   // parameters dictionary.                  try                  {                      foreach (var pair in values)                      {                          parameters.Add(pair.Key' pair.Value);                      }                  }                  catch (ArgumentException)                  {                      throw new MultipartParseException("Duplicate field in section");                  }                    line = reader.ReadLine();              }
Magic Number,HttpMultipartParser,StreamingMultipartFormDataParser,C:\repos\Vodurden_Http-Multipart-Data-Parser\HttpMultipartParser\StreamingMultipartFormDataParser.cs,ParseSection,The following statement contains a magic number: while (line != string.Empty)              {                  if (line == null)                  {                      throw new MultipartParseException("Unexpected end of stream");                  }                    if (line == boundary || line == endBoundary)                  {                      throw new MultipartParseException("Unexpected end of section");                  }                      // This line parses the header values into a set of key/value pairs. For example:                  // Content-Disposition: form-data; name="textdata"                   // ["content-disposition"] = "form-data"                  // ["name"] = "textdata"                  // Content-Disposition: form-data; name="file"; filename="data.txt"                  // ["content-disposition"] = "form-data"                  // ["name"] = "file"                  // ["filename"] = "data.txt"                  // Content-Type: text/plain                   // ["content-type"] = "text/plain"                  Dictionary<string' string> values = SplitBySemicolonIgnoringSemicolonsInQuotes(line)                      .Select(x => x.Split(new[] {':'' '='}' 2))                      // select where the length of the array is equal to two' that way if it is only one it will                      // be ignored as it is invalid key-pair                      .Where(x=> x.Length == 2)                      // Limit split to 2 splits so we don't accidently split characters in file paths.                      .ToDictionary(                          x => x[0].Trim().Replace("\""' string.Empty).ToLower()'                          x => x[1].Trim().Replace("\""' string.Empty));                      // Here we just want to push all the values that we just retrieved into the                   // parameters dictionary.                  try                  {                      foreach (var pair in values)                      {                          parameters.Add(pair.Key' pair.Value);                      }                  }                  catch (ArgumentException)                  {                      throw new MultipartParseException("Duplicate field in section");                  }                    line = reader.ReadLine();              }
