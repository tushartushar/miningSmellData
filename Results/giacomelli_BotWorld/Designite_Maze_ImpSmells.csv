Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DG.BotWorld.Environments.Games.Maze,MazeEnvironment,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironment.cs,GenerateMaze,Cyclomatic complexity of the method is 14
Complex Method,DG.BotWorld.Environments.Games.Maze,MazeEnvironment,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironment.cs,Update,Cyclomatic complexity of the method is 18
Complex Method,DG.BotWorld.Environments.Games.Maze,MazeEnvironmentContext,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironmentContext.cs,CanWalkTo,Cyclomatic complexity of the method is 8
Magic Number,DG.BotWorld.Environments.Games.Maze,MazeEnvironment,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironment.cs,MazeEnvironment,The following statement contains a magic number: MaxUpdateCycles = 10000;  
Magic Number,DG.BotWorld.Environments.Games.Maze,MazeEnvironment,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironment.cs,MazeEnvironment,The following statement contains a magic number: UpdateTimeout = 1000000;  
Magic Number,DG.BotWorld.Environments.Games.Maze,MazeEnvironment,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironment.cs,MazeEnvironment,The following statement contains a magic number: HorizontalCells = 40;  
Magic Number,DG.BotWorld.Environments.Games.Maze,MazeEnvironment,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironment.cs,MazeEnvironment,The following statement contains a magic number: VerticalCells = 40;  
Missing Default,DG.BotWorld.Environments.Games.Maze,MazeEnvironmentContext,C:\repos\giacomelli_BotWorld\src\DG.BotWorld.Environments.Games.Maze\MazeEnvironmentContext.cs,CanWalkTo,The following switch statement is missing a default case: switch (direction) {  case WalkDirection.Up:  	return cell.TopSide == CellSideType.Free;  case WalkDirection.Left:  	return cell.LeftSide == CellSideType.Free;  case WalkDirection.Right:  	if (cell.X == m_map.GetUpperBound (1)) {  		return false;  	}  	return GetMyNextCellFrom (direction).LeftSide == CellSideType.Free;  case WalkDirection.Down:  	if (cell.Y == m_map.GetUpperBound (0)) {  		return false;  	}  	return GetMyNextCellFrom (direction).TopSide == CellSideType.Free;  }  
