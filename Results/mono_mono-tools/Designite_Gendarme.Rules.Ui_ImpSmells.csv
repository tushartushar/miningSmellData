Implementation smell,Namespace,Class,File,Method,Description
Long Statement,Gendarme.Rules.UI,UseSTAThreadAttributeOnSWFEntryPointsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\UseSTAThreadAttributeOnSWFEntryPointsRule.cs,CheckAssembly,The length of the statement  "				text = "In order for Windows Forms to work properly' replace [System.MTAThread] attribute with [System.STAThread] on the entry point."; " is 135.
Long Statement,Gendarme.Rules.UI,UseSTAThreadAttributeOnSWFEntryPointsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\UseSTAThreadAttributeOnSWFEntryPointsRule.cs,CheckAssembly,The length of the statement  "				text = "In order for Windows Forms to work properly' remove [System.MTAThread] attribute from the entry point' leaving [System.STAThread] there."; " is 146.
Complex Conditional,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The conditional expression  "(token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7])"  is complex.
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
Magic Number,Gendarme.Rules.UI,ExecutableTargetRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Ui\ExecutableTargetRule.cs,CheckReferences,The following statement contains a magic number: foreach (AssemblyNameReference a in assembly.MainModule.AssemblyReferences) {  				// check name and public key token (but not version or culture)  				if (a.Name == AssemblyName) {  					byte[] token = a.PublicKeyToken;  					if (token != null) {  						if ((token[0] == publicKeyToken[0]) && (token[1] == publicKeyToken[1]) &&  						    (token[2] == publicKeyToken[2]) && (token[3] == publicKeyToken[3]) &&  						    (token[4] == publicKeyToken[4]) && (token[5] == publicKeyToken[5]) &&  						    (token[6] == publicKeyToken[6]) && (token[7] == publicKeyToken[7]))  							return true;  					}  				}  			}
