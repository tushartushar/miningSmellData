Implementation smell,Namespace,Class,File,Method,Description
Long Method,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,CheckMethodBody,The method has 144 lines of code.
Complex Method,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,CheckMethod,Cyclomatic complexity of the method is 13
Complex Method,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,CheckMethodBody,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Concurrency,ThreadRocks,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ThreadRocks.cs,ThreadingModel,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Concurrency,DoNotUseLockedRegionOutsideMethodRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DontUseLockedRegionOutsideMethodRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Concurrency,ReviewLockUsedOnlyForOperationsOnVariablesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ReviewLockUsedOnlyForOperationsOnVariablesRule.cs,CheckMethod,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Concurrency,ProtectCallToEventDelegatesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ProtectCallToEventDelegatesRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Long Identifier,Gendarme.Rules.Concurrency,ReviewLockUsedOnlyForOperationsOnVariablesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ReviewLockUsedOnlyForOperationsOnVariablesRule.cs,,The length of the parameter interlockedFriendlyOpCodeBitmask is 32.
Long Statement,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,IsValidCall,The length of the statement  "			else if (caller.Is (ThreadModel.SingleThread) && (target.Is (ThreadModel.SingleThread) || target.Is (ThreadModel.Serializable) || target.Is (ThreadModel.Concurrent))) " is 166.
Long Statement,Gendarme.Rules.Concurrency,ThreadRocks,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ThreadRocks.cs,TryGetThreadingModel,The length of the statement  "				throw new ArgumentException ("There should be a single ThreadModelAttribute ctor taking an (Int32) ThreadModel enum argument."); " is 128.
Long Statement,Gendarme.Rules.Concurrency,ProtectCallToEventDelegatesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ProtectCallToEventDelegatesRule.cs,CheckMethod,The length of the statement  "					string msg = String.Format (CultureInfo.InvariantCulture' "Possible race condition since field '{0}' is accessed directly."' field.Name); " is 137.
Long Statement,Gendarme.Rules.Concurrency,ProtectCallToEventDelegatesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ProtectCallToEventDelegatesRule.cs,CheckMethod,The length of the statement  "						string msg = String.Format (CultureInfo.InvariantCulture' "Variable '{0}' does not seems to be checked against null."' load.Name); " is 130.
Complex Conditional,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,CheckMethodBody,The conditional expression  "name == "ThreadStart" ||  									name == "ParameterizedThreadStart" ||  									name == "WaitCallback" ||  									name == "WaitOrTimerCallback" ||  									name == "TimerCallback""  is complex.
Complex Conditional,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,IsValidCall,The conditional expression  "caller.Is (ThreadModel.SingleThread) && (target.Is (ThreadModel.SingleThread) || target.Is (ThreadModel.Serializable) || target.Is (ThreadModel.Concurrent))"  is complex.
Complex Conditional,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,IsValidCall,The conditional expression  "(caller.Is (ThreadModel.Serializable) || caller.Is (ThreadModel.Concurrent)) &&  				(target.Is (ThreadModel.Serializable) || target.Is (ThreadModel.Concurrent))"  is complex.
Complex Conditional,Gendarme.Rules.Concurrency,NonConstantStaticFieldsShouldNotBeVisibleRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\NonConstantStaticFieldsShouldNotBeVisibleRule.cs,CheckType,The conditional expression  "type.IsInterface || type.IsEnum || !type.HasFields || type.IsDelegate ()"  is complex.
Complex Conditional,Gendarme.Rules.Concurrency,NonConstantStaticFieldsShouldNotBeVisibleRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\NonConstantStaticFieldsShouldNotBeVisibleRule.cs,CheckType,The conditional expression  "field.IsStatic && field.IsVisible () && !field.IsInitOnly && !field.IsLiteral"  is complex.
Magic Number,Gendarme.Rules.Concurrency,ReviewLockUsedOnlyForOperationsOnVariablesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\ReviewLockUsedOnlyForOperationsOnVariablesRule.cs,CheckMethod,The following statement contains a magic number: foreach (ExceptionHandler eh in body.ExceptionHandlers) {  				Instruction ins = eh.TryStart;  				// xMCS and earlier (pre-4.0) CSC used Monitor.Enter(object) just outside of the Try block  				bool monitor_enter = IsMonitorEnter (ins.Previous' 1);  				// check every try block  				int end = eh.TryEnd.Offset;  				for (; ins.Offset < end; ins = ins.Next) {  					// CSC10 use Monitor.Enter(object' ref bool) and put it inside the Try block  					if (!monitor_enter) {  						if (ins.OpCode.FlowControl == FlowControl.Call)  							monitor_enter = (IsMonitorEnter (ins' 2));  						// we do not start checking instruction until we have found our Enter call  						continue;  					}    					// check for operations that requires a lock (and not a simpler interlock)  					bool lock_required = false;  					while (ins.Offset < end) {  						if (!interlockedFriendlyOpCodeBitmask.Get (ins.OpCode.Code)) {  							lock_required = true;  							break;  						}  						ins = ins.Next;  					}    					if (!lock_required && monitor_enter)  						Runner.Report (method' ins' Severity.Medium' Confidence.Normal);  					break;  				}  			}
Missing Default,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,TearDown,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  					case Code.Call:  					case Code.Callvirt:  						MethodDefinition target = ((MethodReference) ins.Operand).Resolve ();  						if (target != null) {  							ThreadModel targetModel = target.ThreadingModel ();  							if (targetModel == ThreadModel.MainThread) {  								string mesg = String.Format (CultureInfo.InvariantCulture'   									"An anonymous thread entry point cannot call MainThread {0}."'   									target.Name);  								  								++DefectCount;  								Log.WriteLine (this' "Defect: {0}"' mesg);  								Defect defect = new Defect (this' caller' caller' ins' Severity.High' Confidence.High' mesg);  								Runner.Report (defect);  							}  						}  						break;  					}
Missing Default,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,CheckMethodBody,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Newobj:  					if (ins.Previous != null && ins.Previous.OpCode.Code == Code.Ldftn) {  						MethodReference ctor = (MethodReference) ins.Operand;  						TypeReference type = ctor.DeclaringType;  						if (type.IsDelegate ()) {  							string nspace = type.Namespace;  							// ldftn entry-point  							// newobj System.Void System.Threading.XXX::.ctor (System.Object'System.IntPtr)  							// i.e. creation of a System.Threading delegate  							if (nspace == "System.Threading") {  								string name = type.Name;  								if (name == "ThreadStart" ||  									name == "ParameterizedThreadStart" ||  									name == "WaitCallback" ||  									name == "WaitOrTimerCallback" ||  									name == "TimerCallback") {  										candidate = (MethodReference) ins.Previous.Operand;  								}  							  							// ldftn entry-point  							// newobj System.Void System.AsyncCallback::.ctor (System.Object'System.IntPtr)  							// i.e. creation of a async delegate  							} else if (nspace == "System") {  								if (type.Name == "AsyncCallback") {  									candidate = (MethodReference) ins.Previous.Operand;  								}  							  							// ldftn entry-point  							// newobj System.Void ThreadedDelegate::.ctor (System.Object'System.IntPtr)  							// i.e. creation of a delegate which is decorated with a threading attribute  							} else if (!ThreadRocks.ThreadedNamespace (nspace)) {  								// Delegates must be able to call the methods they are bound to.  								MethodDefinition target = ((MethodReference) ins.Previous.Operand).Resolve ();  								if (target != null) {  									ThreadModel callerModel = type.ThreadingModel ();  									if (!target.IsGeneratedCode () || target.IsProperty ()) {  										ThreadModel targetModel = target.ThreadingModel ();  										if (!IsValidCall (callerModel' targetModel)) {  											string mesg = String.Format (CultureInfo.InvariantCulture'  												"{0} delegate cannot be bound to {1} {2} method."'   												callerModel' targetModel' target.Name);  											++DefectCount;  											Log.WriteLine (this' "Defect: {0}"' mesg);  											Defect defect = new Defect (this' method' method' ins' Severity.High' Confidence.High' mesg);  											Runner.Report (defect);  										}  										  									} else if (!callerModel.Is (ThreadModel.MainThread)) {  										anonymous_entry_points.Add (target);  									}  								}  							}  						}  					}  					break;  				  				case Code.Call:  				case Code.Callvirt:  					if (!method.IsGeneratedCode () || method.IsProperty ())  						CheckForLegalCall (method' ins);  					  					// ldftn entry-point  					// newobj XXX  					// callvirt System.Void SynchronizedType::add_Name (XXX)	  					// i.e. adding a delegate to an event in a type which uses SynchronizingObject  					MethodReference call = (MethodReference) ins.Operand;  					TypeReference call_type = call.DeclaringType;  					if (ins.Previous.Is (Code.Newobj) && ins.Previous.Previous.Is (Code.Ldftn)) {  						// A few events are blacklisted because they do not use SynchronizingObject and  						// are therefore always threaded.  						if (IsNonSynchronizedSetter (call)) {  							candidate = (MethodReference) ins.Previous.Previous.Operand;  						  						// But most events do use SynchronizingObject and therefore their threading  						// depends on whether and how SynchronizingObject is initialized.  						} else if (HasSynchronizingObject (call_type)) {  							List<MethodReference> methods;  							if (!synchronizedEvents.TryGetValue (call' out methods)) {  								methods = new List<MethodReference> ();  								synchronizedEvents.Add (call' methods);  							}  							  							methods.AddIfNew ((MethodReference) ins.Previous.Previous.Operand);  						  						// Misc threaded events.  						} else if (call_type.IsNamed ("System.ComponentModel"' "BackgroundWorker")) {  							if (call.Name == "add_DoWork") {  								candidate = (MethodReference) ins.Previous.Previous.Operand;  							}  						}  					  					// callvirt System.Void System.Diagnostics.Process::set_SynchronizingObject (System.ComponentModel.ISynchronizeInvoke)  					} else if (SetSynchronizingObject.Matches (call)) {  						if (ins.Previous.OpCode.Code == Code.Ldarg_0) {  							thisSynchronized.Add (call_type);  						}  					}  					break;  				}
Missing Default,Gendarme.Rules.Concurrency,DecorateThreadsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DecorateThreadsRule.cs,IsNonSynchronizedSetter,The following switch statement is missing a default case: switch (method.Name) {  			case "add_Disposed":  				return true;  			// MSDN is ambiguous about whether these are supposed to work with SynchronizingObject  			// but mono doesn't.  			case "add_ErrorDataReceived":  			case "add_OutputDataReceived":  				if (method.DeclaringType.IsNamed ("System.Diagnostics"' "Process"))  					return true;  				break;  			}
Missing Default,Gendarme.Rules.Concurrency,DoubleCheckLockingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Concurrency\DoubleCheckLockingRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.FlowControl) {  				case FlowControl.Cond_Branch:  					if ((ins.Previous == null) || (ins.Previous.Previous == null))  						continue;  					if (monitorOffsetList.Count > 0) {  						/* If there's a comparison in the list matching this  						* one' we have double-check locking. */  						foreach (Instruction insn in comparisons) {  							if (!EffectivelyEqual (insn' ins))  								continue;  							if (!EffectivelyEqual (insn.Previous' ins.Previous))  								continue;  							if (!EffectivelyEqual (insn.Previous.Previous' ins.Previous.Previous))  								continue;  							if (insn.Offset >= monitorOffsetList.Peek ())  								continue;    							Runner.Report (method' insn' Severity.Medium' Confidence.High);  							return RuleResult.Failure;  						}  					}  					comparisons.Add (ins);  					break;  				case FlowControl.Call:  					MethodReference m = (ins.Operand as MethodReference);  					if (IsMonitorMethod (m' "Enter"))  						monitorOffsetList.Push (ins.Offset);  					else if (IsMonitorMethod (m' "Exit")) {  						if (monitorOffsetList.Count > 0)  							monitorOffsetList.Pop ();  					}  					break;  				}
