Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.Correctness,AvoidCodeWithSideEffectsInConditionalCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidCodeWithSideEffectsInConditionalCodeRule.cs,Mutates,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,AvoidConstructorsInStaticTypesRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidConstructorsInStaticTypesRule.cs,IsAllStatic,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Correctness,AvoidMethodsWithSideEffectsInConditionalCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidMethodsWithSideEffectsInConditionalCodeRule.cs,IsPure,Cyclomatic complexity of the method is 14
Complex Method,Gendarme.Rules.Correctness,BadRecursiveInvocationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\BadRecursiveInvocationRule.cs,CompareMethods,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,DoNotRecurseInEqualityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DoNotRecurseInEqualityRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,DoNotRoundIntegersRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DoNotRoundIntegersRule.cs,GetArgumentType,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,DoNotRoundIntegersRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DoNotRoundIntegersRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Correctness,DoNotCompareWithNaNRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DontCompareWithNaNRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,EnsureLocalDisposalRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\EnsureLocalDisposalRule.cs,CheckMethod,Cyclomatic complexity of the method is 16
Complex Method,Gendarme.Rules.Correctness,MethodCanBeMadeStaticRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\MethodCanBeMadeStaticRule.cs,CheckMethod,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Correctness,ProvideCorrectArgumentsToFormattingMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectArgumentsToFormattingMethodsRule.cs,TryComputeArraySize,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,ProvideCorrectArgumentsToFormattingMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectArgumentsToFormattingMethodsRule.cs,CheckCallToFormatter,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,ProvideCorrectRegexPatternRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectRegexPatternRule.cs,CheckCall,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,ProvideValidXPathExpressionRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideValidXPathExpressionRule.cs,CheckCall,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,ReviewDoubleAssignmentRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewDoubleAssignmentRule.cs,CheckDoubleAssignement,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,ReviewDoubleAssignmentRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewDoubleAssignmentRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,ReviewInconsistentIdentityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewInconsistentIdentityRule.cs,ProcessMethod,Cyclomatic complexity of the method is 19
Complex Method,Gendarme.Rules.Correctness,ReviewSelfAssignmentRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewSelfAssignmentRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,ReviewUselessControlFlowRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewUselessControlFlowRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,TypesShouldBeDisposableBaseRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\TypesShouldBeDisposableBaseRule.cs,CheckType,Cyclomatic complexity of the method is 12
Complex Method,Gendarme.Rules.Correctness,TypesWithDisposableFieldsShouldBeDisposableRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\TypesWithDisposableFieldsShouldBeDisposableRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,TypesWithNativeFieldsShouldBeDisposableRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\TypesWithNativeFieldsShouldBeDisposableRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Correctness,UseValueInPropertySetterRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\UseValueInPropertySetterRule.cs,CheckMethod,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Correctness,AvoidFloatingPointEqualityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidFloatingPointEqualityRule.cs,CheckCeqInstruction,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,CheckParametersNullityInVisibleMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\CheckParametersNullityInVisibleMethodsRule.cs,CheckParameter,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,CheckParametersNullityInVisibleMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\CheckParametersNullityInVisibleMethodsRule.cs,CheckArgument,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,CheckParametersNullityInVisibleMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\CheckParametersNullityInVisibleMethodsRule.cs,CheckCall,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,CheckParametersNullityInVisibleMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\CheckParametersNullityInVisibleMethodsRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,DisposableFieldsShouldBeDisposedRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DisposableFieldsShouldBeDisposedRule.cs,CheckType,Cyclomatic complexity of the method is 16
Complex Method,Gendarme.Rules.Correctness,DisposableFieldsShouldBeDisposedRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DisposableFieldsShouldBeDisposedRule.cs,CheckIfBaseDisposeIsCalled,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Correctness,DisposableFieldsShouldBeDisposedRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DisposableFieldsShouldBeDisposedRule.cs,CheckIfAllFieldsAreDisposed,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Correctness,DisposableFieldsShouldBeDisposedRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DisposableFieldsShouldBeDisposedRule.cs,ProcessMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Correctness,AttributeStringLiteralsShouldParseCorrectlyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AttributeStringLiteralsShouldParseCorrectlyRule.cs,CheckParametersAndValues,Cyclomatic complexity of the method is 9
Long Statement,Gendarme.Rules.Correctness,AvoidMethodsWithSideEffectsInConditionalCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidMethodsWithSideEffectsInConditionalCodeRule.cs,IsPure,The length of the statement  "				if (method_name.StartsWith ("op_"' StringComparison.Ordinal) && method_name != "op_Implicit" && method_name != "op_Explicit") " is 125.
Long Statement,Gendarme.Rules.Correctness,ProvideCorrectArgumentsToFormattingMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectArgumentsToFormattingMethodsRule.cs,CheckCallToFormatter,The length of the statement  "				Runner.Report (method' call' Severity.Low' Confidence.Normal' "You are calling String.Format without arguments' you can remove the call to String.Format"); " is 155.
Long Statement,Gendarme.Rules.Correctness,ProvideCorrectRegexPatternRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectRegexPatternRule.cs,Initialize,The length of the statement  "				bool usingValidatorClass = (e.CurrentModule.Runtime >= TargetRuntime.Net_2_0) && (assembly_name == "System.Configuration"); " is 123.
Long Statement,Gendarme.Rules.Correctness,ProvideCorrectRegexPatternRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectRegexPatternRule.cs,CheckCall,The length of the statement  "			if (!type.IsNamed ("System.Text.RegularExpressions"' "Regex") && !type.IsNamed ("System.Configuration"' "RegexStringValidator")) " is 128.
Long Statement,Gendarme.Rules.Correctness,AttributeStringLiteralsShouldParseCorrectlyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AttributeStringLiteralsShouldParseCorrectlyRule.cs,CheckParametersAndValues,The length of the statement  "							string msg = String.Format (CultureInfo.InvariantCulture' "The value passed: {0} can't be parsed to a valid Version."' value); " is 126.
Long Statement,Gendarme.Rules.Correctness,AttributeStringLiteralsShouldParseCorrectlyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AttributeStringLiteralsShouldParseCorrectlyRule.cs,CheckParametersAndValues,The length of the statement  "							string msg = String.Format (CultureInfo.InvariantCulture' "The valued passed {0} can't be parsed to a valid Uri."' value); " is 122.
Long Statement,Gendarme.Rules.Correctness,AttributeStringLiteralsShouldParseCorrectlyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AttributeStringLiteralsShouldParseCorrectlyRule.cs,CheckParametersAndValues,The length of the statement  "							string msg = String.Format (CultureInfo.InvariantCulture' "The valued passed {0} can't be parsed to a valid Guid."' value); " is 123.
Complex Conditional,Gendarme.Rules.Correctness,AvoidConstructorsInStaticTypesRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidConstructorsInStaticTypesRule.cs,CheckType,The conditional expression  "type.IsEnum || type.IsInterface || type.IsValueType || type.IsDelegate () || type.IsGeneratedCode ()"  is complex.
Complex Conditional,Gendarme.Rules.Correctness,ReviewInconsistentIdentityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewInconsistentIdentityRule.cs,CheckCloneMethod,The conditional expression  "clone.Method != null && !clone.Delegates && (clone.HasFields || clone.HasGetters)"  is complex.
Magic Number,Gendarme.Rules.Correctness,EnsureLocalDisposalRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\EnsureLocalDisposalRule.cs,ReportNonDisposedLocals,The following statement contains a magic number: i < 64
Magic Number,Gendarme.Rules.Correctness,ReviewUselessControlFlowRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewUselessControlFlowRule.cs,CheckMethod,The following statement contains a magic number: switch (ins.OpCode.Code) {  				case Code.Brfalse:  				case Code.Brfalse_S:  				case Code.Brtrue:  				case Code.Brtrue_S:  				// BNE is used by [G]MCS  				case Code.Bne_Un:  				case Code.Bne_Un_S:  				case Code.Beq:  				case Code.Beq_S:  					Instruction br = (ins.Operand as Instruction);  					int delta = br.Offset - ins.Next.Offset;  					if (delta == 0) {  						// Medium: since compiler already warned about this  						Runner.Report (method' ins' Severity.Medium' Confidence.Normal);  					}  else if (delta <= 2) {  						// is the block (between the jumps) small and empty ?  						// CSC does this' probably to help the debugger.  						// [G]MCS does not  						while (delta > 0) {  							br = br.Previous;  							if (br.OpCode.Code != Code.Nop)  								break;  							delta--;  						}  						if (delta == 0)  							Runner.Report (method' ins' Severity.Low' Confidence.Normal);  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,AvoidCodeWithSideEffectsInConditionalCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidCodeWithSideEffectsInConditionalCodeRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference target = ins.Operand as MethodReference;  					string define = AvoidMethodsWithSideEffectsInConditionalCodeRule.ConditionalOn (target);  					if (define != null) {  						Log.WriteLine (this' "call to {0} method at {1:X4}"' define' ins.Offset);  						  						string name = Mutates (method' ins);  						if (name != null) {  							string mesg = String.Format (CultureInfo.InvariantCulture'   								"{0}::{1} is conditionally compiled on {2} but mutates {3}"'  								target.DeclaringType.Name' target.Name' define' name);  							Log.WriteLine (this' mesg);  							  							Confidence confidence = AvoidMethodsWithSideEffectsInConditionalCodeRule.GetConfidence (define);  							Runner.Report (method' ins' Severity.High' confidence' mesg);  						}  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,AvoidMethodsWithSideEffectsInConditionalCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidMethodsWithSideEffectsInConditionalCodeRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference target = ins.Operand as MethodReference;  					string define = ConditionalOn (target);  					if (define != null) {  						Log.WriteLine (this' "call to {0} method at {1:X4}"' define' ins.Offset);  						  						MethodReference impure = FindImpurity (method' ins);  						if (impure != null) {  							string mesg = String.Format (CultureInfo.InvariantCulture'   								"{0}::{1} is conditionally compiled on {2} but uses the impure {3}::{4}"'  								target.DeclaringType.Name' target.Name' define' impure.DeclaringType.Name' impure.Name);  							Log.WriteLine (this' mesg);  							  							Confidence confidence = GetConfidence (define);  							Runner.Report (method' ins' Severity.High' confidence' mesg);  						}  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,BadRecursiveInvocationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\BadRecursiveInvocationRule.cs,CheckParams,The following switch statement is missing a default case: switch (insn.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  					ParameterDefinition param = (ParameterDefinition) insn.Operand;  					if (method.IsStatic)  						paramNum++;  					return (param.Index == paramNum - 1);  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					return (paramNum == (int) (insn.OpCode.Code - Code.Ldarg_0));  				case Code.Ldloc:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  				case Code.Ldloc_S:  				case Code.Ldloca:  				case Code.Ldloca_S:  				case Code.Ldfld:  				case Code.Ldflda:  				case Code.Call:  				case Code.Calli:  				case Code.Callvirt:  				case Code.Newarr:  				case Code.Newobj:  					return false;  				}
Missing Default,Gendarme.Rules.Correctness,BadRecursiveInvocationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\BadRecursiveInvocationRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.FlowControl) {  				case FlowControl.Call:  					MethodReference callee = (ins.Operand as MethodReference);  					// check type name only if the call isn't virtual  					bool virtual_call = (ins.OpCode.Code == Code.Callvirt);  					// continue scanning unless we're calling ourself  					if (!CompareMethods (method' callee' virtual_call))  						break;    					// recursion detected! check if there a way out of it  					if (CheckForEndlessRecursion (method' i)) {  						Runner.Report (method' ins' Severity.Critical' Confidence.High);  						return RuleResult.Failure;  					}  					break;  				case FlowControl.Cond_Branch:  				case FlowControl.Return:  				case FlowControl.Throw:  					// if there's a way to break free before a recursive call then we let it go  					return RuleResult.Success;  				}
Missing Default,Gendarme.Rules.Correctness,CallingEqualsWithNullArgRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\CallingEqualsWithNullArgRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					// if we're calling bool type.Equals({anytype})  					if (!Equals.Matches (ins.Operand as MethodReference))  						continue;    					// and that the previous' real' instruction is loading a null value  					// note: check the first parameter (not the instance)  					Instruction source = ins.TraceBack (method' -1);  					if ((source != null) && (source.OpCode.Code == Code.Ldnull))  						Runner.Report (method' ins' Severity.Low' Confidence.High);    					break;  				}
Missing Default,Gendarme.Rules.Correctness,DoNotRecurseInEqualityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DoNotRecurseInEqualityRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference callee = (ins.Operand as MethodReference).Resolve();	// need the resolve for generics  					if (callee != null) {  						if (callee.MetadataToken == method.MetadataToken) {  							// MethodReference.ToString is very costly but' in this case' won't be called often  							if (callee.ToString () == method.ToString ()) {  								Log.WriteLine (this' "recursive call at {0:X4}"' ins.Offset);  								Runner.Report (method' ins' Severity.Critical' Confidence.Normal);  							}  						}  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,DoNotRoundIntegersRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DoNotRoundIntegersRule.cs,CheckMethod,The following switch statement is missing a default case: switch (name) {  				case "Ceiling":  				case "Floor":  				case "Truncate":  					value = ins.Previous;  					break;  				case "Round":  					// variable number of arguments for different overloads  					int n = ins.GetPopCount (method);  					value = ins.Previous;  					while (value != null) {  						// stop before first parameter  						if (n == 1)  							break;  						n += value.GetPopCount (method) - value.GetPushCount ();  						value = value.Previous;  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,DoNotCompareWithNaNRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DontCompareWithNaNRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				// handle == and !=  				case Code.Ceq:  					if (!CheckPrevious (il' i - 1)) {  						Runner.Report (method' ins' Severity.Critical' Confidence.Total' EqualityMessage);  					}  					break;  				// handle calls to [Single|Double].Equals  				case Code.Call:  				case Code.Callvirt:  					MemberReference callee = ins.Operand as MemberReference;  					if ((callee != null) && (callee.Name == "Equals") && callee.DeclaringType.IsFloatingPoint ()) {  						if (!CheckPrevious (il' i - 1)) {  							Runner.Report (method' ins' Severity.Critical' Confidence.Total' EqualsMessage);  						}  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,ProvideCorrectRegexPatternRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideCorrectRegexPatternRule.cs,CheckLoadInstruction,The following switch statement is missing a default case: switch (ld.OpCode.Code) {  			case Code.Ldstr:  				return CheckPattern (method' ins' (string) ld.Operand' confidence);  			case Code.Ldsfld:  				FieldReference f = (FieldReference) ld.Operand;  				if (f.Name != "Empty" || !f.DeclaringType.IsNamed ("System"' "String"))  					return false;  				return CheckPattern (method' ins' null' confidence);  			case Code.Ldnull:  				return CheckPattern (method' ins' null' confidence);  			}
Missing Default,Gendarme.Rules.Correctness,ProvideValidXmlStringRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideValidXmlStringRule.cs,CheckString,The following switch statement is missing a default case: switch (ld.OpCode.Code) {  			case Code.Ldstr:  				CheckString (method' ins' (string) ld.Operand);  				break;  			case Code.Ldsfld:  				FieldReference f = (FieldReference) ld.Operand;  				if (f.Name == "Empty" && f.DeclaringType.IsNamed ("System"' "String"))  					CheckString (method' ins' null);  				break;  			case Code.Ldnull:  				CheckString (method' ins' null);  				break;  			}
Missing Default,Gendarme.Rules.Correctness,ProvideValidXmlStringRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideValidXmlStringRule.cs,CheckCall,The following switch statement is missing a default case: switch (mref.Name) {  			case "LoadXml":  				if (mref.DeclaringType.IsNamed ("System.Xml"' "XmlDocument"))  					CheckString (method' ins' -1);  				break;  			case "set_InnerXml":  			case "set_OuterXml":  				TypeReference tr = mref.DeclaringType;  				if (tr.Inherits ("System.Xml"' "XmlNode") || tr.Inherits ("System.Xml.XPath"' "XPathNavigator"))  					CheckString (method' ins' -1);  				break;  			case "AppendChild":  			case "PrependChild":  			case "InsertAfter":  			case "InsertBefore":  				IList<ParameterDefinition> pdc = mref.Parameters;  				if (pdc.Count == 1  					&& pdc [0].ParameterType.IsNamed ("System"' "String")  					&& mref.DeclaringType.Inherits ("System.Xml.XPath"' "XPathNavigator"))  					CheckString (method' ins' -1);  				break;  			}
Missing Default,Gendarme.Rules.Correctness,ProvideValidXPathExpressionRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideValidXPathExpressionRule.cs,CheckString,The following switch statement is missing a default case: switch (ld.OpCode.Code) {  			case Code.Ldstr:  				CheckString (method' ins' (string) ld.Operand);  				break;  			case Code.Ldsfld:  				FieldReference f = (FieldReference) ld.Operand;  				if (f.Name == "Empty" && f.DeclaringType.IsNamed ("System"' "String"))  					CheckString (method' ins' null);  				break;  			case Code.Ldnull:  				CheckString (method' ins' null);  				break;  			}
Missing Default,Gendarme.Rules.Correctness,ProvideValidXPathExpressionRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ProvideValidXPathExpressionRule.cs,CheckCall,The following switch statement is missing a default case: switch (mref.Name) {  			case "Compile":  				TypeReference tr = mref.DeclaringType;  				if (tr.IsNamed ("System.Xml.XPath"' "XPathExpression") || tr.Inherits ("System.Xml.XPath"' "XPathNavigator"))  					CheckString (method' ins' GetFirstArgumentOffset (mref));  				break;  			case "SelectNodes":  				if (mref.DeclaringType.IsNamed ("System.Xml"' "XmlNode"))  					CheckString (method' ins' -1);  				break;  			case "Evaluate":  			case "Select":  				CheckXPathNavigatorString (method' ins' mref);  				break;  			case "SelectSingleNode":  				CheckXPathNavigatorString (method' ins' mref);  				if (mref.DeclaringType.IsNamed ("System.Xml"' "XmlNode"))  					CheckString (method' ins' -1);  				break;  			}
Missing Default,Gendarme.Rules.Correctness,ReviewUseOfInt64BitsToDoubleRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewUseOfInt64BitsToDoubleRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.Previous.OpCode.Code) {  				case Code.Conv_I8:  				case Code.Conv_U8:  				case Code.Conv_Ovf_I8:  				case Code.Conv_Ovf_I8_Un:  				case Code.Conv_Ovf_U8:  				case Code.Conv_Ovf_U8_Un:  					Runner.Report (method' ins' Severity.High' Confidence.High);  					break;  				}
Missing Default,Gendarme.Rules.Correctness,ReviewUselessControlFlowRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewUselessControlFlowRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Brfalse:  				case Code.Brfalse_S:  				case Code.Brtrue:  				case Code.Brtrue_S:  				// BNE is used by [G]MCS  				case Code.Bne_Un:  				case Code.Bne_Un_S:  				case Code.Beq:  				case Code.Beq_S:  					Instruction br = (ins.Operand as Instruction);  					int delta = br.Offset - ins.Next.Offset;  					if (delta == 0) {  						// Medium: since compiler already warned about this  						Runner.Report (method' ins' Severity.Medium' Confidence.Normal);  					}  else if (delta <= 2) {  						// is the block (between the jumps) small and empty ?  						// CSC does this' probably to help the debugger.  						// [G]MCS does not  						while (delta > 0) {  							br = br.Previous;  							if (br.OpCode.Code != Code.Nop)  								break;  							delta--;  						}  						if (delta == 0)  							Runner.Report (method' ins' Severity.Low' Confidence.Normal);  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,ReviewUseOfModuloOneOnIntegersRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewUseOfModuloOneOnIntegersRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Rem:  				case Code.Rem_Un:  					if (CheckModuloOne (ins.Previous))  						Runner.Report (method' ins' Severity.High' Confidence.Total);  					break;  				}
Missing Default,Gendarme.Rules.Correctness,AvoidFloatingPointEqualityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidFloatingPointEqualityRule.cs,CheckCeqInstruction,The following switch statement is missing a default case: switch (instruction.OpCode.Code) {  			case Code.Conv_R_Un:  			case Code.Conv_R4:  			case Code.Conv_R8:  				return true;  			case Code.Ldc_R4:  				return !CheckFloatConstants ((float) instruction.Operand);  			case Code.Ldc_R8:  				return !CheckDoubleConstants ((double) instruction.Operand);  			case Code.Ldelem_R4:  			case Code.Ldelem_R8:  				return true;  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  			case Code.Ldloc_S:  			case Code.Ldloc:  			case Code.Ldloca:  			case Code.Ldloca_S:  				return instruction.GetVariable (method).VariableType.IsFloatingPoint ();  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarga:  			case Code.Ldarga_S:  				ParameterDefinition parameter = instruction.GetParameter (method);  				// handle 'this'  				if (parameter == null)  					return method.DeclaringType.IsFloatingPoint ();  				return parameter.ParameterType.IsFloatingPoint ();  			case Code.Call:  			case Code.Callvirt:  				MethodReference call = instruction.Operand as MethodReference;  				return call.ReturnType.IsFloatingPoint ();  			case Code.Ldfld:  			case Code.Ldflda:  			case Code.Ldsfld:  			case Code.Ldsflda:  				FieldReference field = instruction.Operand as FieldReference;  				return field.FieldType.IsFloatingPoint ();  			}
Missing Default,Gendarme.Rules.Correctness,AvoidFloatingPointEqualityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\AvoidFloatingPointEqualityRule.cs,CheckMethod,The following switch statement is missing a default case: switch (instruction.OpCode.Code) {  				case Code.Ceq:  					if (CheckCeqInstruction (SkipArithmeticOperations (instruction)' method)) {  						Runner.Report (method' instruction' Severity.High' Confidence.Total' EqualityMessage);  					}  					break;  				case Code.Call:  				case Code.Callvirt:  					MemberReference member = instruction.Operand as MemberReference;  					if ((member != null) && (member.Name == "Equals") && member.DeclaringType.IsFloatingPoint ()) {  						Runner.Report (method' instruction' Severity.High' Confidence.Total' EqualsMessage);  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,CheckParametersNullityInVisibleMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\CheckParametersNullityInVisibleMethodsRule.cs,CheckArgument,The following switch statement is missing a default case: switch (nc) {  			case Code.Box:		// generics  			case Code.Ldind_Ref:	// load indirect reference  				next = next.Next;  				nc = next.OpCode.Code;  				break;  			case Code.Isinst:  				has_null_check.Set (parameter.Index);  				return;  			}
Missing Default,Gendarme.Rules.Correctness,DisposableFieldsShouldBeDisposedRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\DisposableFieldsShouldBeDisposedRule.cs,CheckIfAllFieldsAreDisposed,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  						case Code.Call:  						case Code.Callvirt:  							MethodDefinition md = (ins.Operand as MethodDefinition);  							if ((md != null) && DisposeBool.Matches (md))  								ProcessMethod (md' fields);  							break;  						}
Missing Default,Gendarme.Rules.Correctness,FinalizersShouldCallBaseClassFinalizerRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\FinalizersShouldCallBaseClassFinalizerRule.cs,IsBaseFinalizeCalled,The following switch statement is missing a default case: switch (current.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference mr = (current.Operand as MethodReference);  					if ((mr != null) && mr.IsFinalizer ())  						return true;  					break;  				}
Missing Default,Gendarme.Rules.Correctness,ReviewCastOnIntegerDivisionRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewCastOnIntegerDivisionRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Div:  				case Code.Div_Un:  					// if the next step is a conversion to a FP value it means  					// that the result' on the stack' is not in it's final form  					switch (ins.Next.OpCode.Code) {  					case Code.Conv_R_Un:  						// no doubt since the result is unsigned it's not a FP  						Runner.Report (method' ins' Severity.High' Confidence.High);  						break;  					case Code.Conv_R4:  					case Code.Conv_R8:  						// it could be a R4 converted into a R8 (or vice versa)  						// Note: we don't have to check both divided and divisor since they will  						// be converted to the same type on the stack before the call to DIV  						if (!IsFloatingPointArguments (ins.TraceBack (method)' method))  							Runner.Report (method' ins' Severity.High' Confidence.High);  						break;  					}  					break;  				}
Missing Default,Gendarme.Rules.Correctness,ReviewCastOnIntegerDivisionRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewCastOnIntegerDivisionRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.Next.OpCode.Code) {  					case Code.Conv_R_Un:  						// no doubt since the result is unsigned it's not a FP  						Runner.Report (method' ins' Severity.High' Confidence.High);  						break;  					case Code.Conv_R4:  					case Code.Conv_R8:  						// it could be a R4 converted into a R8 (or vice versa)  						// Note: we don't have to check both divided and divisor since they will  						// be converted to the same type on the stack before the call to DIV  						if (!IsFloatingPointArguments (ins.TraceBack (method)' method))  							Runner.Report (method' ins' Severity.High' Confidence.High);  						break;  					}
Missing Default,Gendarme.Rules.Correctness,ReviewCastOnIntegerMultiplicationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Correctness\ReviewCastOnIntegerMultiplicationRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.Next.OpCode.Code) {  				case Code.Conv_I8:  				case Code.Conv_Ovf_I8:  				case Code.Conv_Ovf_I8_Un:  				case Code.Conv_U8:  				case Code.Conv_Ovf_U8:  				case Code.Conv_Ovf_U8_Un:  					Runner.Report (method' ins' s' Confidence.Normal);  					break;  				}
