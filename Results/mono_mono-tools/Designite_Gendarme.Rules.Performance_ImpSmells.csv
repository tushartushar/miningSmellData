Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.Performance,AvoidConcatenatingCharsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidConcatenatingCharsRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,AvoidRepetitiveCallsToPropertiesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidRepetitiveCallsToPropertiesRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Performance,AvoidTypeGetTypeForConstantStringsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidTypeGetTypeForConstantStringsRule.cs,CheckMethod,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Performance,AvoidUnnecessaryOverridesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnnecessaryOverridesRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Performance,AvoidLargeStructureRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidLargeStructureRule.cs,SizeOfStruct,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Performance,AvoidUncalledPrivateCodeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUncalledPrivateCodeRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Performance,AvoidUncalledPrivateCodeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUncalledPrivateCodeRule.cs,CheckPublicMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Performance,AvoidUninstantiatedInternalClassesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUninstantiatedInternalClassesRule.cs,ProcessType,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,AvoidUninstantiatedInternalClassesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUninstantiatedInternalClassesRule.cs,ProcessMethod,Cyclomatic complexity of the method is 12
Complex Method,Gendarme.Rules.Performance,AvoidUnusedParametersRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnusedParametersRule.cs,CheckMethod,Cyclomatic complexity of the method is 12
Complex Method,Gendarme.Rules.Performance,AvoidUnusedPrivateFieldsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnusedPrivateFieldsRule.cs,CheckType,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,MathMinMaxCandidateRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\MathMinMaxCandidateRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,RemoveUnusedLocalVariablesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\RemoveUnusedLocalVariablesRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Performance,ReviewLinqMethodRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\ReviewLinqMethodRule.cs,CheckForAny,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Performance,ReviewLinqMethodRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\ReviewLinqMethodRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,UseTypeEmptyTypesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\UseTypeEmptyTypesRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,AvoidUnneededFieldInitializationRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnneededFieldInitializationRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Performance,PreferLiteralOverInitOnlyFieldsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\PreferLiteralOverInitOnlyFieldsRule.cs,CheckType,Cyclomatic complexity of the method is 10
Long Parameter List,Gendarme.Rules.Performance,PreferCharOverloadRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\PreferCharOverloadRule.cs,Report,The method has 5 parameters. Parameters: method' ins' confidence' call' parameter
Long Statement,Gendarme.Rules.Performance,AvoidUncalledPrivateCodeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUncalledPrivateCodeRule.cs,CheckMethod,The length of the statement  "			Runner.Report (method' Severity.High' Confidence.Normal' "The method is not visible outside its declaring assembly' nor used within."); " is 135.
Long Statement,Gendarme.Rules.Performance,AvoidUncalledPrivateCodeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUncalledPrivateCodeRule.cs,GetToken,The length of the statement  "			return (ulong) method.DeclaringType.Module.Assembly.GetHashCode () << 32 | method.GetElementMethod ().MetadataToken.ToUInt32 (); " is 128.
Long Statement,Gendarme.Rules.Performance,DoNotIgnoreMethodResultRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\DontIgnoreMethodResultRule.cs,IsNewException,The length of the statement  "			case "System.Void System.Threading.Timer::.ctor(System.Threading.TimerCallback'System.Object'System.Int32'System.Int32)": " is 121.
Complex Conditional,Gendarme.Rules.Performance,AvoidUncalledPrivateCodeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUncalledPrivateCodeRule.cs,HasAnySpecialAttribute,The conditional expression  "(cat.IsNamed ("System.Diagnostics"' name)) || (cat.Namespace == "System.Runtime.InteropServices" &&   					(name == "ComRegisterFunctionAttribute" || name == "ComUnregisterFunctionAttribute"))"  is complex.
Complex Conditional,Gendarme.Rules.Performance,AvoidUnsealedUninheritedInternalTypeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnsealedUninheritedInternalClassesRule.cs,CheckType,The conditional expression  "type.IsAbstract || type.IsSealed || type.IsVisible () || type.IsGeneratedCode ()"  is complex.
Complex Conditional,Gendarme.Rules.Performance,AvoidUnusedPrivateFieldsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnusedPrivateFieldsRule.cs,CheckType,The conditional expression  "type.IsEnum || type.IsInterface || !type.HasFields || type.IsDelegate () || type.IsGeneratedCode ()"  is complex.
Complex Conditional,Gendarme.Rules.Performance,ConsiderCustomAccessorsForNonVisibleEventsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\ConsiderCustomAccessorsForNonVisibleEventsRule.cs,CheckType,The conditional expression  "type.IsEnum || type.IsInterface || type.IsValueType || !type.HasEvents"  is complex.
Complex Conditional,Gendarme.Rules.Performance,MathMinMaxCandidateRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\MathMinMaxCandidateRule.cs,CheckMethod,The conditional expression  "((op1 == next) && (op2 == branch)) || ((op2 == next) && (op1 == branch))"  is complex.
Magic Number,Gendarme.Rules.Performance,AvoidRepetitiveCallsToPropertiesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidRepetitiveCallsToPropertiesRule.cs,GetSeverity,The following statement contains a magic number: if (count < 3)  				return Severity.Low;  			else if (count < 6)  				return Severity.Medium;  			else if (count < 10)  				return Severity.High;
Magic Number,Gendarme.Rules.Performance,AvoidRepetitiveCallsToPropertiesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidRepetitiveCallsToPropertiesRule.cs,GetSeverity,The following statement contains a magic number: if (count < 3)  				return Severity.Low;  			else if (count < 6)  				return Severity.Medium;  			else if (count < 10)  				return Severity.High;
Magic Number,Gendarme.Rules.Performance,AvoidRepetitiveCallsToPropertiesRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidRepetitiveCallsToPropertiesRule.cs,GetSeverity,The following statement contains a magic number: if (count < 3)  				return Severity.Low;  			else if (count < 6)  				return Severity.Medium;  			else if (count < 10)  				return Severity.High;
Magic Number,Gendarme.Rules.Performance,AvoidUnneededUnboxingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnneededUnboxingRule.cs,GetSeverityFromCount,The following statement contains a magic number: if (count < 4)  				return Severity.Low;
Magic Number,Gendarme.Rules.Performance,AvoidUnneededUnboxingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnneededUnboxingRule.cs,GetSeverityFromCount,The following statement contains a magic number: if (count < 8)  				return Severity.Medium;
Magic Number,Gendarme.Rules.Performance,AvoidUnneededUnboxingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnneededUnboxingRule.cs,CheckMethod,The following statement contains a magic number: foreach (KeyValuePair<string'int> kvp in unboxed) {  				// we can't (always) avoid unboxing one time  				if (kvp.Value < 2)  					continue;  				string s = String.Format (CultureInfo.InvariantCulture' kvp.Key' kvp.Value);  				Runner.Report (method' GetSeverityFromCount (kvp.Value)' Confidence.Normal' s);  			}
Magic Number,Gendarme.Rules.Performance,AvoidLargeStructureRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidLargeStructureRule.cs,Initialize,The following statement contains a magic number: medium_severity_limit = max_size * 2;
Magic Number,Gendarme.Rules.Performance,AvoidLargeStructureRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidLargeStructureRule.cs,Initialize,The following statement contains a magic number: high_severity_limit = max_size * 4;
Magic Number,Gendarme.Rules.Performance,AvoidLargeStructureRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidLargeStructureRule.cs,Initialize,The following statement contains a magic number: critical_severity_limit = max_size * 16;
Magic Number,Gendarme.Rules.Performance,AvoidLargeStructureRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidLargeStructureRule.cs,SizeOfEnum,The following statement contains a magic number: return 4;
Magic Number,Gendarme.Rules.Performance,AvoidUncalledPrivateCodeRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUncalledPrivateCodeRule.cs,GetToken,The following statement contains a magic number: return (ulong) method.DeclaringType.Module.Assembly.GetHashCode () << 32 | method.GetElementMethod ().MetadataToken.ToUInt32 ();
Magic Number,Gendarme.Rules.Performance,AvoidUnusedParametersRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnusedParametersRule.cs,CheckMethod,The following statement contains a magic number: if (pcount > 64)  				pcount = 64;
Magic Number,Gendarme.Rules.Performance,AvoidUnusedParametersRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnusedParametersRule.cs,CheckMethod,The following statement contains a magic number: if (pcount > 64)  				pcount = 64;
Magic Number,Gendarme.Rules.Performance,AvoidUnusedParametersRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnusedParametersRule.cs,CheckMethod,The following statement contains a magic number: int shift = 64 - pcount;
Magic Number,Gendarme.Rules.Performance,UseSuppressFinalizeOnIDisposableTypeWithFinalizerRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\IDisposableWithDestructorWithoutSuppressFinalizeRule.cs,Recurse,The following statement contains a magic number: foreach (Instruction ins in method.Body.Instructions) {  				switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					// are we calling GC.SuppressFinalize ?  					MethodReference callee = (ins.Operand as MethodReference);  					if (callee.IsNamed ("System"' "GC"' "SuppressFinalize")) {  						return true;  					} else if (level < 3) {  						if (Recurse (callee.Resolve ()' level + 1))  							return true;  					}  					break;  				}  			}
Magic Number,Gendarme.Rules.Performance,PreferCharOverloadRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\PreferCharOverloadRule.cs,CheckReplace,The following statement contains a magic number: string p2 = GetString (ins.TraceBack (method' -2));
Magic Number,Gendarme.Rules.Performance,ReviewLinqMethodRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\ReviewLinqMethodRule.cs,CheckMethod,The following statement contains a magic number: foreach (Instruction ins in method.Body.Instructions) {  				// if we're calling a method'  				if (!calls.Get (ins.OpCode.Code))  					continue;  				  				// and the method is a System.Linq.Enumerable method then'  				var target = ins.Operand as MethodReference;  				if (!target.DeclaringType.IsNamed ("System.Linq"' "Enumerable"))  					continue;    				string tname = target.Name;  				int tcount = target.HasParameters ? target.Parameters.Count : 0;  				// see if we can use a more efficient method.  				if (tname == "Count" && tcount == 1) {  					TypeReference tr = ins.Previous.GetOperandType (method);  					if (tr != null) {  						CheckForCountProperty (tr' method' ins);  						CheckForAny (method' ins);  					}  				} else if ((tname == "ElementAt" || tname == "ElementAtOrDefault") && tcount == 2) {  					Instruction arg = ins.TraceBack (method);  					TypeReference tr = arg.GetOperandType (method);  					if (tr != null)  						CheckForSubscript (tr' method' ins' tname);  				} else if ((tname == "Last" || tname == "LastOrDefault") && tcount == 1) {  					TypeReference tr = ins.Previous.GetOperandType (method);  					if (tr != null)  						CheckForSubscript (tr' method' ins' tname);  				} else if (tname == "OrderBy" || tname == "OrderByDescending") {  					Instruction arg = ins.TraceBack (method);  					TypeReference tr = arg.GetOperandType (method);  					if (tr != null)  						CheckForSort (tr' method' ins' tname);  				}  			}
Magic Number,Gendarme.Rules.Performance,UseIsOperatorRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\UseIsOperatorRule.cs,CheckMethod,The following statement contains a magic number: int n = instructions.Count - 2;
Magic Number,Gendarme.Rules.Performance,UseIsOperatorRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\UseIsOperatorRule.cs,CheckMethod,The following statement contains a magic number: for (int i = 0; i < n; i++) {  				Code code0 = instructions [i].OpCode.Code;  				if (code0 != Code.Isinst)  					continue;  				Code code1 = instructions [i + 1].OpCode.Code;  				if (code1 != Code.Ldnull)  					continue;  				Code code2 = instructions [i + 2].OpCode.Code;  				if (code2 != Code.Ceq)  					continue;    				Runner.Report (method' instructions[i]' Severity.High' Confidence.High);  			}
Missing Default,Gendarme.Rules.Performance,AvoidConcatenatingCharsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidConcatenatingCharsRule.cs,HasReferenceToStringConcatObject,The following switch statement is missing a default case: switch (ptype.Name) {  					case "Object":  					case "Object[]":  						return (ptype.Namespace == "System");  					}
Missing Default,Gendarme.Rules.Performance,AvoidConcatenatingCharsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidConcatenatingCharsRule.cs,ScanArray,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Newarr:  					return;  				case Code.Box:  					ReportBoxing (method' ins' Confidence.Normal);  					break;  				}
Missing Default,Gendarme.Rules.Performance,AvoidConcatenatingCharsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidConcatenatingCharsRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ptype.Name) {  				case "Object":  					CheckParameters (mr' method' ins);  					break;  				case "Object[]":  					if ((ins.Previous.OpCode.Code == Code.Stelem_Ref) || ins.Previous.IsLoadLocal ())  						ScanArray (method' ins.Previous);  					break;  				}
Missing Default,Gendarme.Rules.Performance,AvoidRepetitiveCastsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidRepetitiveCastsRule.cs,IndexesMatch,The following switch statement is missing a default case: switch (lhs.OpCode.Code) {  				case Code.Ldc_I4_M1:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4:  					object operand1 = lhs.GetOperand (method);  					object operand2 = rhs.GetOperand (method);  					match = operand1.Equals (operand2);  					break;  				}
Missing Default,Gendarme.Rules.Performance,AvoidUnneededUnboxingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\AvoidUnneededUnboxingRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Unbox:  				case Code.Unbox_Any:  					string previous = Previous (method' ins);  					if (previous.Length == 0)  						continue;    					int num;  					if (!unboxed.TryGetValue (previous' out num)) {  						unboxed.Add (previous' 1);  					} else {  						unboxed [previous] = ++num;  					}  					break;  				}
Missing Default,Gendarme.Rules.Performance,UseSuppressFinalizeOnIDisposableTypeWithFinalizerRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\IDisposableWithDestructorWithoutSuppressFinalizeRule.cs,Recurse,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					// are we calling GC.SuppressFinalize ?  					MethodReference callee = (ins.Operand as MethodReference);  					if (callee.IsNamed ("System"' "GC"' "SuppressFinalize")) {  						return true;  					} else if (level < 3) {  						if (Recurse (callee.Resolve ()' level + 1))  							return true;  					}  					break;  				}
Missing Default,Gendarme.Rules.Performance,MathMinMaxCandidateRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\MathMinMaxCandidateRule.cs,GetPrevious,The following switch statement is missing a default case: switch (code) {  			case Code.Ldarg_0:  				if (method.HasThis) {  					ins = ins.Previous;  					return GetPrevious (method' ref ins);  				}  				if (IsSupported (method.Parameters [0].ParameterType))  					return ins.OpCode.Name;  				break;  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  				int index = code - (method.HasThis ? Code.Ldarg_1 : Code.Ldarg_0);  				if (IsSupported (method.Parameters [index].ParameterType))  					return ins.OpCode.Name;  				break;  			case Code.Ldfld:  				FieldReference field = (ins.Operand as FieldReference);  				if (IsSupported (field.FieldType))  					return field.Name;  				break;  			}
Missing Default,Gendarme.Rules.Performance,MathMinMaxCandidateRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\MathMinMaxCandidateRule.cs,GetNext,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  			case Code.Ldarg_0:  				if (method.HasThis) {  					return GetNext (method' ins.Next);  				}  				if (IsOk (ins.Next))  					return ins.OpCode.Name;  				break;  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  				if (IsOk (ins.Next))  					return ins.OpCode.Name;  				break;  			case Code.Ldfld:  				FieldReference field = (ins.Operand as FieldReference);  				if (IsOk (ins.Next))  					return field.Name;  				break;  			}
Missing Default,Gendarme.Rules.Performance,PreferCharOverloadRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\PreferCharOverloadRule.cs,CheckIndexOf,The following switch statement is missing a default case: switch (sc.OpCode.Code) {  			case Code.Ldc_I4_4:  				// if it's StringComparison.Ordinal (4) then it's identical to what a Char would do  				Report (method' ins' Confidence.High' call' p1);  				break;  			case Code.Ldc_I4_5:  				// if it's StringComparison.OrdinalIgnoreCase (5) then it's identical as long as the Char is not case sensitive  				if (p1 == p1.ToLowerInvariant () && p1 == p1.ToUpperInvariant ()) {  					Report (method' ins' Confidence.High' call' p1);  				}  				break;  			}
Missing Default,Gendarme.Rules.Performance,PreferCharOverloadRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\PreferCharOverloadRule.cs,CheckMethod,The following switch statement is missing a default case: switch (call.Name) {  				case "IndexOf":  				case "LastIndexOf":  					// 3 overloads each - parameters are identical (between them)  					// and the String (or Char) is always the first one  					if (CheckFirstParameterIsString (call))  						CheckIndexOf (method' call' ins);  					break;  				case "Replace":  					// both parameters needs to be length == 1  					if (CheckFirstParameterIsString (call))  						CheckReplace (method' ins);  					break;  				}
Missing Default,Gendarme.Rules.Performance,UseStringEmptyRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Performance\UseStringEmptyRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.OperandType) {  				case OperandType.InlineString:  					string s = (ins.Operand as string);  					if (s.Length == 0)  						Runner.Report (method' ins' Severity.Medium' Confidence.High);  					break;  				}
