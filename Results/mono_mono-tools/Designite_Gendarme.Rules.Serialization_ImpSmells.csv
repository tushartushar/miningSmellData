Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.Serialization,DeserializeOptionalFieldRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Serialization\DeserializeOptionalFieldRule.cs,CheckType,Cyclomatic complexity of the method is 12
Magic Number,Gendarme.Rules.Serialization,ImplementISerializableCorrectlyRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Serialization\ImplementISerializableCorrectlyRule.cs,CheckSerializedFields,The following statement contains a magic number: foreach (Instruction ins in method.Body.Instructions) {  				switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference mr = ins.Operand as MethodReference;  					if (!mr.HasParameters || (mr.Name != "AddValue") || (mr.Parameters.Count < 2))  						continue;  					// type is sealed so this check is ok  					if (!mr.DeclaringType.IsNamed ("System.Runtime.Serialization"' "SerializationInfo"))  						continue;    					// look at the second parameter' which should be (or return) the field  					Instruction i = ins.TraceBack (method' -2);  					// if we're boxing then find what's in that box  					if (i.OpCode.Code == Code.Box)  						i = i.TraceBack (method);    					FieldDefinition f = (i.Operand as FieldDefinition);  					if (f != null) {  						fields.Remove (f);  						continue;  					}  					MethodDefinition md = (i.Operand as MethodDefinition);  					if ((md != null) && md.IsGetter && md.HasBody) {  						f = CheckProperty (md);  						if (f != null)  							fields.Remove (f);  					}  					break;  				}  			}
Magic Number,Gendarme.Rules.Serialization,ImplementISerializableCorrectlyRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Serialization\ImplementISerializableCorrectlyRule.cs,CheckSerializedFields,The following statement contains a magic number: foreach (Instruction ins in method.Body.Instructions) {  				switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference mr = ins.Operand as MethodReference;  					if (!mr.HasParameters || (mr.Name != "AddValue") || (mr.Parameters.Count < 2))  						continue;  					// type is sealed so this check is ok  					if (!mr.DeclaringType.IsNamed ("System.Runtime.Serialization"' "SerializationInfo"))  						continue;    					// look at the second parameter' which should be (or return) the field  					Instruction i = ins.TraceBack (method' -2);  					// if we're boxing then find what's in that box  					if (i.OpCode.Code == Code.Box)  						i = i.TraceBack (method);    					FieldDefinition f = (i.Operand as FieldDefinition);  					if (f != null) {  						fields.Remove (f);  						continue;  					}  					MethodDefinition md = (i.Operand as MethodDefinition);  					if ((md != null) && md.IsGetter && md.HasBody) {  						f = CheckProperty (md);  						if (f != null)  							fields.Remove (f);  					}  					break;  				}  			}
Missing Default,Gendarme.Rules.Serialization,ImplementISerializableCorrectlyRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Serialization\ImplementISerializableCorrectlyRule.cs,CheckSerializedFields,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference mr = ins.Operand as MethodReference;  					if (!mr.HasParameters || (mr.Name != "AddValue") || (mr.Parameters.Count < 2))  						continue;  					// type is sealed so this check is ok  					if (!mr.DeclaringType.IsNamed ("System.Runtime.Serialization"' "SerializationInfo"))  						continue;    					// look at the second parameter' which should be (or return) the field  					Instruction i = ins.TraceBack (method' -2);  					// if we're boxing then find what's in that box  					if (i.OpCode.Code == Code.Box)  						i = i.TraceBack (method);    					FieldDefinition f = (i.Operand as FieldDefinition);  					if (f != null) {  						fields.Remove (f);  						continue;  					}  					MethodDefinition md = (i.Operand as MethodDefinition);  					if ((md != null) && md.IsGetter && md.HasBody) {  						f = CheckProperty (md);  						if (f != null)  							fields.Remove (f);  					}  					break;  				}
