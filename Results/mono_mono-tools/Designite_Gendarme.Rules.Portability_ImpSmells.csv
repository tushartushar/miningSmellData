Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Long Identifier,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,,The length of the parameter SubmitResultsOperationCompleted is 31.
Long Identifier,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,,The length of the parameter GetLatestDefinitionsVersionOperationCompleted is 45.
Long Identifier,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,,The length of the parameter useDefaultCredentialsSetExplicitly is 34.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,SubmitResultsAsync,The length of the statement  "				this.SubmitResultsOperationCompleted = new System.Threading.SendOrPostCallback (this.OnSubmitResultsOperationCompleted); " is 120.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,OnSubmitResultsOperationCompleted,The length of the statement  "				System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs) (arg)); " is 133.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,OnSubmitResultsOperationCompleted,The length of the statement  "				this.SubmitResultsCompleted (this' new SubmitResultsCompletedEventArgs (invokeArgs.Results' invokeArgs.Error' invokeArgs.Cancelled' invokeArgs.UserState)); " is 155.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,GetLatestDefinitionsVersionAsync,The length of the statement  "				this.GetLatestDefinitionsVersionOperationCompleted = new System.Threading.SendOrPostCallback (this.OnGetLatestDefinitionsVersionOperationCompleted); " is 148.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,GetLatestDefinitionsVersionAsync,The length of the statement  "			this.InvokeAsync ("GetLatestDefinitionsVersion"' new object [0]' this.GetLatestDefinitionsVersionOperationCompleted' userState); " is 128.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,OnGetLatestDefinitionsVersionOperationCompleted,The length of the statement  "				System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs) (arg)); " is 133.
Long Statement,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,OnGetLatestDefinitionsVersionOperationCompleted,The length of the statement  "				this.GetLatestDefinitionsVersionCompleted (this' new GetLatestDefinitionsVersionCompletedEventArgs (invokeArgs.Results' invokeArgs.Error' invokeArgs.Cancelled' invokeArgs.UserState)); " is 183.
Complex Conditional,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessUnixProbablyAbsolutePath,The conditional expression  "path.StartsWith ("/bin/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/etc/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/sbin/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/dev/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/lib/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/usr/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/tmp/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/proc/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/sys/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/cdrom/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/home/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/media/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/mnt/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/opt/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/var/"' StringComparison.Ordinal)"  is complex.
Complex Conditional,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfMethodOrCtorIsCalled,The conditional expression  "nameSpace == "Microsoft.Win32" && typeName.StartsWith ("Registry"' StringComparison.Ordinal) // registry keys  				    || (nameSpace.StartsWith ("System.Xml"' StringComparison.Ordinal) // xpath expressions  					&& methodName.StartsWith ("Select"' StringComparison.Ordinal))"  is complex.
Empty Catch Block,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The method has an empty catch block.
Magic Number,Gendarme.Rules.Portability,ExitCodeIsLimitedOnUnixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\ExitCodeIsLimitedOnUnixRule.cs,CheckInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code) {  			case Code.Ldc_I4_M1: // -1 is pushed onto stack  				return InspectionResult.Bad;  			case Code.Ldc_I4_0: // small numbers are pushed onto stack -- all OK  			case Code.Ldc_I4_1:  			case Code.Ldc_I4_2:  			case Code.Ldc_I4_3:  			case Code.Ldc_I4_4:  			case Code.Ldc_I4_5:  			case Code.Ldc_I4_6:  			case Code.Ldc_I4_7:  			case Code.Ldc_I4_8:  				return InspectionResult.Good;  			case Code.Ldc_I4_S: // sbyte ([-128' 127]) - should check >= 0  				sbyte b = (sbyte) instruction.Operand;  				return (b >= 0) ? InspectionResult.Good : InspectionResult.Bad;  			case Code.Ldc_I4: // normal int - should check whether is within [0' 255]  				int a = (int) instruction.Operand;  				return (a >= 0 && a <= 255) ? InspectionResult.Good : InspectionResult.Bad;  			case Code.Call:  			case Code.Callvirt:  				if ((instruction.Operand as MethodReference).ReturnType.IsNamed ("System"' "Byte"))  					return InspectionResult.Good;  				else  					return InspectionResult.Unsure; // could be within 0-255 or not  			default:  				return InspectionResult.Unsure;  			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (CountOccurences (str' '.') > 2)  				return null;
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (CanBeWindowsAbsolutePath (str)) {  				// whoooaaa! most probably we have a windows absolute path here  				AddPoints (5); // add points (5 because '*:\*' is less common)  				backslashes--; // we should't count a backslash in drive letter    				// process a windows path  				ProcessWindowsPath ();    			} else if (CanBeWindowsUNCPath (str)) {  				AddPoints (4); // add points  				backslashes -= 2;    				// go!  				ProcessWindowsPath ();    			} else if (CanBeUnixAbsolutePath (str)) {  				// same for unix  				AddPoints (2); // add points (2 because '/*' is more common)  				slashes--; // we shouldn't count a slash in the beginning    				// process a unix path  				ProcessUnixProbablyAbsolutePath (str);    			} else {  				// since that's not an absolute path' we need to  				// switch between unix/windows path handlers  				// depending on what character is more common  				// ('/' for unix' '\' for windows)    				if (backslashes > slashes)  					ProcessWindowsPath (); // like directory\something\..  				else if (backslashes < slashes)  					ProcessUnixPath (); // like directory/something/..    			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (CanBeWindowsAbsolutePath (str)) {  				// whoooaaa! most probably we have a windows absolute path here  				AddPoints (5); // add points (5 because '*:\*' is less common)  				backslashes--; // we should't count a backslash in drive letter    				// process a windows path  				ProcessWindowsPath ();    			} else if (CanBeWindowsUNCPath (str)) {  				AddPoints (4); // add points  				backslashes -= 2;    				// go!  				ProcessWindowsPath ();    			} else if (CanBeUnixAbsolutePath (str)) {  				// same for unix  				AddPoints (2); // add points (2 because '/*' is more common)  				slashes--; // we shouldn't count a slash in the beginning    				// process a unix path  				ProcessUnixProbablyAbsolutePath (str);    			} else {  				// since that's not an absolute path' we need to  				// switch between unix/windows path handlers  				// depending on what character is more common  				// ('/' for unix' '\' for windows)    				if (backslashes > slashes)  					ProcessWindowsPath (); // like directory\something\..  				else if (backslashes < slashes)  					ProcessUnixPath (); // like directory/something/..    			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (CanBeWindowsAbsolutePath (str)) {  				// whoooaaa! most probably we have a windows absolute path here  				AddPoints (5); // add points (5 because '*:\*' is less common)  				backslashes--; // we should't count a backslash in drive letter    				// process a windows path  				ProcessWindowsPath ();    			} else if (CanBeWindowsUNCPath (str)) {  				AddPoints (4); // add points  				backslashes -= 2;    				// go!  				ProcessWindowsPath ();    			} else if (CanBeUnixAbsolutePath (str)) {  				// same for unix  				AddPoints (2); // add points (2 because '/*' is more common)  				slashes--; // we shouldn't count a slash in the beginning    				// process a unix path  				ProcessUnixProbablyAbsolutePath (str);    			} else {  				// since that's not an absolute path' we need to  				// switch between unix/windows path handlers  				// depending on what character is more common  				// ('/' for unix' '\' for windows)    				if (backslashes > slashes)  					ProcessWindowsPath (); // like directory\something\..  				else if (backslashes < slashes)  					ProcessUnixPath (); // like directory/something/..    			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (CanBeWindowsAbsolutePath (str)) {  				// whoooaaa! most probably we have a windows absolute path here  				AddPoints (5); // add points (5 because '*:\*' is less common)  				backslashes--; // we should't count a backslash in drive letter    				// process a windows path  				ProcessWindowsPath ();    			} else if (CanBeWindowsUNCPath (str)) {  				AddPoints (4); // add points  				backslashes -= 2;    				// go!  				ProcessWindowsPath ();    			} else if (CanBeUnixAbsolutePath (str)) {  				// same for unix  				AddPoints (2); // add points (2 because '/*' is more common)  				slashes--; // we shouldn't count a slash in the beginning    				// process a unix path  				ProcessUnixProbablyAbsolutePath (str);    			} else {  				// since that's not an absolute path' we need to  				// switch between unix/windows path handlers  				// depending on what character is more common  				// ('/' for unix' '\' for windows)    				if (backslashes > slashes)  					ProcessWindowsPath (); // like directory\something\..  				else if (backslashes < slashes)  					ProcessUnixPath (); // like directory/something/..    			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (current_score > 13)  				return Confidence.Total;    			else if (current_score > 9)  				return Confidence.High;    			else if (current_score > 7)  				return Confidence.Normal;    			else  				return null;
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (current_score > 13)  				return Confidence.Total;    			else if (current_score > 9)  				return Confidence.High;    			else if (current_score > 7)  				return Confidence.Normal;    			else  				return null;
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfStringIsHardcodedPath,The following statement contains a magic number: if (current_score > 13)  				return Confidence.Total;    			else if (current_score > 9)  				return Confidence.High;    			else if (current_score > 7)  				return Confidence.Normal;    			else  				return null;
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CanBeWindowsAbsolutePath,The following statement contains a magic number: return s [1] == ':' && s [2] == '\\';
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessWindowsPath,The following statement contains a magic number: if (slashes == 0 && backslashes > 1)  				AddPoints (2);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessWindowsPath,The following statement contains a magic number: if (backslashes > 3)  				AddPoints (4);    			else if (backslashes > 1)  				AddPoints (3);    			else if (backslashes == 1)  				AddPoints (2);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessWindowsPath,The following statement contains a magic number: if (backslashes > 3)  				AddPoints (4);    			else if (backslashes > 1)  				AddPoints (3);    			else if (backslashes == 1)  				AddPoints (2);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessWindowsPath,The following statement contains a magic number: if (backslashes > 3)  				AddPoints (4);    			else if (backslashes > 1)  				AddPoints (3);    			else if (backslashes == 1)  				AddPoints (2);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessWindowsPath,The following statement contains a magic number: if (backslashes > 3)  				AddPoints (4);    			else if (backslashes > 1)  				AddPoints (3);    			else if (backslashes == 1)  				AddPoints (2);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessUnixProbablyAbsolutePath,The following statement contains a magic number: if (path.StartsWith ("/bin/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/etc/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/sbin/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/dev/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/lib/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/usr/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/tmp/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/proc/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/sys/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/cdrom/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/home/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/media/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/mnt/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/opt/"' StringComparison.Ordinal) ||  			    path.StartsWith ("/var/"' StringComparison.Ordinal))    				AddPoints (4);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessUnixPath,The following statement contains a magic number: if (backslashes == 0)  				AddPoints (2);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessUnixPath,The following statement contains a magic number: if (slashes > 3)  				AddPoints (3);    			else if (slashes > 1)  				AddPoints (2);    			else if (slashes == 1)  				AddPoints (1);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessUnixPath,The following statement contains a magic number: if (slashes > 3)  				AddPoints (3);    			else if (slashes > 1)  				AddPoints (2);    			else if (slashes == 1)  				AddPoints (1);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessUnixPath,The following statement contains a magic number: if (slashes > 3)  				AddPoints (3);    			else if (slashes > 1)  				AddPoints (2);    			else if (slashes == 1)  				AddPoints (1);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessExtension,The following statement contains a magic number: if (length < 2 || length > 6)  				return;
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessExtension,The following statement contains a magic number: if (length < 2 || length > 6)  				return;
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessExtension,The following statement contains a magic number: if (length == 4) // this is very common for extensions => really good sign :-)  				AddPoints (4);    			else  				AddPoints (3);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessExtension,The following statement contains a magic number: if (length == 4) // this is very common for extensions => really good sign :-)  				AddPoints (4);    			else  				AddPoints (3);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,ProcessExtension,The following statement contains a magic number: if (length == 4) // this is very common for extensions => really good sign :-)  				AddPoints (4);    			else  				AddPoints (3);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfMethodOrCtorIsCalled,The following statement contains a magic number: switch (ins.OpCode.Code) {  			case Code.Call:  			case Code.Calli:  			case Code.Callvirt:  				// this is a call  				MethodReference target = ins.Operand as MethodReference;    				// this happens sometimes so it's worth checking  				if (target == null)  					return true;    				// we can avoid some false positives by doing additional checks here    				TypeReference tr = target.DeclaringType;  				string nameSpace = tr.Namespace;  				string typeName = tr.Name;  				string methodName = target.Name;    				if (nameSpace == "Microsoft.Win32" && typeName.StartsWith ("Registry"' StringComparison.Ordinal) // registry keys  				    || (nameSpace.StartsWith ("System.Xml"' StringComparison.Ordinal) // xpath expressions  					&& methodName.StartsWith ("Select"' StringComparison.Ordinal))) {  					AddPoints (-42);  					return true; // handled  				}    				// see what we can learn    				if (target.HasParameters && (target.Parameters.Count == 1) &&   					methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  					// to improve performance' don't Resolve () to call IsSpecialName  					// this is a setter (in 99% cases)  					CheckIdentifier (methodName);  				} else {  					// we can also check parameter name  					CheckMethodParameterName (target' currentOffset);  				}  				break;    			case Code.Newobj:  				// this is a constructor call  				MethodReference ctor = (MethodReference) ins.Operand;  				// avoid catching regular expressions  				if (ctor.DeclaringType.IsNamed ("System.Text.RegularExpressions"' "Regex"))  					AddPoints (-42);    				break;    			default:  				return false;  			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIfMethodOrCtorIsCalled,The following statement contains a magic number: switch (ins.OpCode.Code) {  			case Code.Call:  			case Code.Calli:  			case Code.Callvirt:  				// this is a call  				MethodReference target = ins.Operand as MethodReference;    				// this happens sometimes so it's worth checking  				if (target == null)  					return true;    				// we can avoid some false positives by doing additional checks here    				TypeReference tr = target.DeclaringType;  				string nameSpace = tr.Namespace;  				string typeName = tr.Name;  				string methodName = target.Name;    				if (nameSpace == "Microsoft.Win32" && typeName.StartsWith ("Registry"' StringComparison.Ordinal) // registry keys  				    || (nameSpace.StartsWith ("System.Xml"' StringComparison.Ordinal) // xpath expressions  					&& methodName.StartsWith ("Select"' StringComparison.Ordinal))) {  					AddPoints (-42);  					return true; // handled  				}    				// see what we can learn    				if (target.HasParameters && (target.Parameters.Count == 1) &&   					methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  					// to improve performance' don't Resolve () to call IsSpecialName  					// this is a setter (in 99% cases)  					CheckIdentifier (methodName);  				} else {  					// we can also check parameter name  					CheckMethodParameterName (target' currentOffset);  				}  				break;    			case Code.Newobj:  				// this is a constructor call  				MethodReference ctor = (MethodReference) ins.Operand;  				// avoid catching regular expressions  				if (ctor.DeclaringType.IsNamed ("System.Text.RegularExpressions"' "Regex"))  					AddPoints (-42);    				break;    			default:  				return false;  			}
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckIdentifier,The following statement contains a magic number: if (IdentifierLooksLikePath (name))  				AddPoints (4);
Magic Number,Gendarme.Rules.Portability,DoNotHardcodePathsRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\DoNotHardcodePathsRule.cs,CheckMethod,The following statement contains a magic number: foreach (Instruction ins in method_body.Instructions) {  				// Console.WriteLine ("{0} {1}"' ins.OpCode' ins.Operand);    				if (!ins.Is (Code.Ldstr))  					continue;    				slashes = backslashes = current_score = 0;    				// check if loaded string is a hardcoded path  				string candidate = (ins.Operand as string);    				// don't check too short strings (we do this very earlier to avoid caching the small values)  				if (candidate.Length < 4)  					continue;    				Confidence? conf = GetConfidence (ins' candidate);    				// if sure enough' report the problem with the candidate string  				// important as this allows a quick false positive check without checking the source code  				if (conf.HasValue) {  					string msg = String.Format (CultureInfo.InvariantCulture'  						"string \"{0}\" looks quite like a filename."' candidate);  					Runner.Report (method' ins' Severity.High' conf.Value' msg);  				}  			}
Magic Number,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,FindLastestLocalVersion,The following statement contains a magic number: try {  				string latest = def_files [def_files.Length - 1];  				int s = latest.LastIndexOf ("definitions-"' StringComparison.Ordinal) + 12;  				return new Version (latest.Substring (s' latest.Length - s - 4)); // remove .zip  			}  			catch (FormatException) {  				return new Version ();  			}
Magic Number,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,FindLastestLocalVersion,The following statement contains a magic number: try {  				string latest = def_files [def_files.Length - 1];  				int s = latest.LastIndexOf ("definitions-"' StringComparison.Ordinal) + 12;  				return new Version (latest.Substring (s' latest.Length - s - 4)); // remove .zip  			}  			catch (FormatException) {  				return new Version ();  			}
Magic Number,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,SelectDefinitionsFile,The following statement contains a magic number: if (def_version == null) {  				// then we'll use the latest local version available  				def_version = FindLastestLocalVersion ();  				// if Gendarme version is newer than the definitions then there's likely something new available  				if (typeof (IRule).Assembly.GetName ().Version > def_version) {  					// however we don't want to download a (potentially) unexisting file each time we execute   					// Gendarme (e.g. a development release' like 2.5.x.x) so we limit this to once per week  					FileInfo fi = new FileInfo (GetFileName (def_version));  					if (!fi.Exists || (fi.CreationTimeUtc < DateTime.UtcNow.AddDays (-7)))  						def_version = DownloadLatestDefinitions ();  				}  			}
Magic Number,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,ComparePublicKeyToken,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				if (pkt1 [i] != pkt2 [i])  					return false;  			}
Magic Number,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,Filter,The following statement contains a magic number: if ((pkt == null) || (pkt.Length != 8))  				return false;
Magic Number,Gendarme.Rules.Portability,MonoCompatibilityReviewRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MonoCompatibilityReviewRule.cs,DownloadLatestDefinitions,The following statement contains a magic number: try {  				string definitionsUri;  				using (MoMASubmit ws = new MoMASubmit ()) {  					string lastest_def = ws.GetLatestDefinitionsVersion ();  					int s = lastest_def.LastIndexOf ('/') + 1;  					int e = lastest_def.IndexOf ('-'' s);  					v = new Version (lastest_def.Substring (s' e - s));  					definitionsUri = lastest_def.Split ('|') [2];  				}    				using (WebClient wc = new WebClient ()) {  					string filename = GetFileName (v);  					wc.DownloadFile (new Uri (definitionsUri)' filename);  				}  			}  			catch (WebException e) {  				if (Runner.VerbosityLevel > 0)  					Console.Error.WriteLine (e);  			}
Magic Number,MoMA.Analyzer.MoMAWebService,MoMASubmit,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\MoMAWebService.cs,IsLocalFileSystemWebService,The following statement contains a magic number: if (((wsUri.Port >= 1024)  				    && (string.Compare (wsUri.Host' "localHost"' System.StringComparison.OrdinalIgnoreCase) == 0))) {  				return true;  			}
Missing Default,Gendarme.Rules.Portability,ExitCodeIsLimitedOnUnixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\ExitCodeIsLimitedOnUnixRule.cs,Report,The following switch statement is missing a default case: switch (result) {  			case InspectionResult.Good:  				// should never occur  				break;  			case InspectionResult.Bad:  				Runner.Report (method' ins' Severity.Medium' Confidence.High'   					"Return value is outside the range of valid values (0-255).");  				break;  			case InspectionResult.Unsure:  				Runner.Report (method' ins' Severity.Medium' Confidence.Low'   					"Make sure not to return values that are out of range (0-255).");  				break;  			}
Missing Default,Gendarme.Rules.Portability,ExitCodeIsLimitedOnUnixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Portability\ExitCodeIsLimitedOnUnixRule.cs,CheckMethod,The following switch statement is missing a default case: switch (current.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					MethodReference calledMethod = (MethodReference) current.Operand;  					string name = calledMethod.Name;  					if ((name != "set_ExitCode") && (name != "Exit"))  						break;  					if (!calledMethod.DeclaringType.IsNamed ("System"' "Environment"))  						break;    					InspectionResult result = CheckInstruction (previous);  					if (result == InspectionResult.Good)  						break;    					Report (method' current' result);  					break;  				}
