Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.BadPractice,AvoidAssemblyVersionMismatchRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\AvoidAssemblyVersionMismatchRule.cs,CheckAssembly,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.BadPractice,CheckNewExceptionWithoutThrowingRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\CheckNewExceptionWithoutThrowingRule.cs,CheckMethod,Cyclomatic complexity of the method is 13
Complex Method,Gendarme.Rules.BadPractice,CheckNewThreadWithoutStartRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\CheckNewThreadWithoutStartRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.BadPractice,DoNotForgetNotImplementedMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\DoNotForgetNotImplementedMethodsRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.BadPractice,ConstructorShouldNotCallVirtualMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ConstructorShouldNotCallVirtualMethodsRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.BadPractice,DisableDebuggingCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\DisableDebuggingCodeRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.BadPractice,DoNotUseGetInterfaceToCheckAssignabilityRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\DoNotUseGetInterfaceToCheckAssignabilityRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.BadPractice,EqualsShouldHandleNullArgRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\EqualShouldHandleNullArgRule.cs,CheckSequence,Cyclomatic complexity of the method is 15
Complex Method,Gendarme.Rules.BadPractice,ObsoleteMessagesShouldNotBeEmptyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ObsoleteMessagesShouldNotBeEmptyRule.cs,CheckType,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.BadPractice,ReplaceIncompleteOddnessCheckRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ReplaceIncompleteOddnessCheckRule.cs,IsLoadConstant,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.BadPractice,ReplaceIncompleteOddnessCheckRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ReplaceIncompleteOddnessCheckRule.cs,CheckMethod,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.BadPractice,UseFileOpenOnlyWithFileAccessRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\UseFileOpenOnlyWithFileAccessRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Long Statement,Gendarme.Rules.BadPractice,AvoidAssemblyVersionMismatchRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\AvoidAssemblyVersionMismatchRule.cs,CheckAssembly,The length of the statement  "				// http://msdn.microsoft.com/en-us/library/system.reflection.assemblyfileversionattribute.assemblyfileversionattribute.aspx " is 123.
Long Statement,Gendarme.Rules.BadPractice,CheckNewThreadWithoutStartRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\CheckNewThreadWithoutStartRule.cs,CheckMethod,The length of the statement  "				if (ins.Next != null && (ins.Next.OpCode.Code == Code.Call || ins.Next.OpCode.Code == Code.Callvirt)) { //quick check to safe resources " is 135.
Long Statement,Gendarme.Rules.BadPractice,UseFileOpenOnlyWithFileAccessRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\UseFileOpenOnlyWithFileAccessRule.cs,CheckMethod,The length of the statement  "					if (!foundFileAccess && (ptype.IsNamed ("System.IO"' "FileAccess") || ptype.IsNamed ("System.Security.AccessControl"' "FileSystemRights"))) " is 139.
Magic Number,Gendarme.Rules.BadPractice,DoNotForgetNotImplementedMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\DoNotForgetNotImplementedMethodsRule.cs,CheckMethod,The following statement contains a magic number: cond_branch && (++n > 10)
Magic Number,Gendarme.Rules.BadPractice,ReplaceIncompleteOddnessCheckRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ReplaceIncompleteOddnessCheckRule.cs,IsLoadConstant,The following statement contains a magic number: switch (ins.OpCode.Code) {  			case Code.Ldc_I4_1:  				return (constant == 1);  			case Code.Ldc_I4_2:  				return (constant == 2);  			case Code.Ldc_I4:  				return ((int) ins.Operand == constant);  			case Code.Ldc_I4_S:  				return ((int)(sbyte) ins.Operand == constant);  			case Code.Ldc_I8:  				return ((long) ins.Operand == constant);  			default:  				// recurse on integer convertion  				if (Conversion.Get (ins.OpCode.Code))  					return IsLoadConstant (ins.Previous' constant);  				return false;  			}
Magic Number,Gendarme.Rules.BadPractice,ReplaceIncompleteOddnessCheckRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ReplaceIncompleteOddnessCheckRule.cs,CheckMethod,The following statement contains a magic number: !IsLoadConstant (ins.Previous' 2)
Missing Default,Gendarme.Rules.BadPractice,CheckNewExceptionWithoutThrowingRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\CheckNewExceptionWithoutThrowingRule.cs,CheckMethod,The following switch statement is missing a default case: switch (usage.Instruction.OpCode.Code) {  					case Code.Throw: //throw  					case Code.Ret: //return  					case Code.Stind_I: //out / ref  					case Code.Stind_I1:  					case Code.Stind_I2:  					case Code.Stind_I4:  					case Code.Stind_I8:  					case Code.Stind_R4:  					case Code.Stind_R8:  					case Code.Stind_Ref:  						//case Code.Stfld:  						exceptionUsed = true;  						break;  					case Code.Call: //call (to the exception or as an argument)  					case Code.Calli:  					case Code.Callvirt:  					case Code.Newobj:  					case Code.Initobj:  						IMethodSignature calledMethod = (IMethodSignature) usage.Instruction.Operand;  						int pcount = calledMethod.HasParameters ? calledMethod.Parameters.Count : 0;  						if (pcount <= usage.StackOffset)  							break; //not used as a parameter  						exceptionUsed = true;  						break;  					}
Missing Default,Gendarme.Rules.BadPractice,CheckNewThreadWithoutStartRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\CheckNewThreadWithoutStartRule.cs,CheckUsage,The following switch statement is missing a default case: switch (usage.Instruction.OpCode.Code) {  				case Code.Ret: //return  				case Code.Stind_I: //out / ref  				case Code.Stind_I1:  				case Code.Stind_I2:  				case Code.Stind_I4:  				case Code.Stind_I8:  				case Code.Stind_R4:  				case Code.Stind_R8:  				case Code.Stind_Ref:  				case Code.Newobj: //passed as an argument  				case Code.Initobj:  				case Code.Stfld:  					return true;  				case Code.Call: //call (to the thread or as an argument)  				case Code.Callvirt:  					MethodReference calledMethod = (MethodReference) usage.Instruction.Operand;  					int pcount = calledMethod.HasParameters ? calledMethod.Parameters.Count : 0;  					if (pcount <= usage.StackOffset) {  						//thread.Method (not used as a parameter)  						if (calledMethod.Name != "Start")  							break;  					}  					return true;  				}
Missing Default,Gendarme.Rules.BadPractice,ConstructorShouldNotCallVirtualMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ConstructorShouldNotCallVirtualMethodsRule.cs,IsCallFromInstance,The following switch statement is missing a default case: switch (ins.OpCode.StackBehaviourPush) {  				case StackBehaviour.Push0:  				case StackBehaviour.Push1:  				case StackBehaviour.Push1_push1:  				case StackBehaviour.Pushi:  				case StackBehaviour.Pushi8:  				case StackBehaviour.Pushr4:  				case StackBehaviour.Pushr8:  				case StackBehaviour.Pushref:  					parameters--;  					break;  				case StackBehaviour.Varpush:  					// call[i|virt]  					MethodReference mr = (ins.Operand as MethodReference);  					if (mr != null) {  						if (mr.HasThis)  							parameters++;  						parameters += mr.Parameters.Count;  						if (!mr.ReturnType.IsNamed ("System"' "Void"))  							parameters--;  					}  					break;  				}
Missing Default,Gendarme.Rules.BadPractice,ConstructorShouldNotCallVirtualMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ConstructorShouldNotCallVirtualMethodsRule.cs,CheckMethod,The following switch statement is missing a default case: switch (current.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					// we recurse into normal calls since they might be calling virtual methods  					MethodDefinition md = (current.Operand as MethodDefinition);  					if (md == null || md.IsConstructor || !md.HasThis)  						continue;    					// check that the method is it this class or a subclass  					if (!IsSubsclass (md.DeclaringType' method.DeclaringType))  						continue;    					// check that we're not calling the method on another object  					int n = md.HasParameters ? md.Parameters.Count : 0;  					if (!IsCallFromInstance (current.Previous' n))  						continue;    					if (md.IsVirtual && !md.IsFinal) {  						string s = stack.Count == 0 ? method_name : stack.Aggregate ((a1' a2) => a1 + "' " + Environment.NewLine + a2);  						s = String.Format (CultureInfo.InvariantCulture'  							"Calling a virtual method' '{0}' from {1}."' md' s);  						Runner.Report (method' current' Severity.High' Confidence.High' s);  					} else {  						stack.Push (method_name);  						CheckMethod (md);  						stack.Pop ();  					}  					break;  				}
Missing Default,Gendarme.Rules.BadPractice,DisableDebuggingCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\DisableDebuggingCodeRule.cs,HasConditionalAttributeForDebugging,The following switch statement is missing a default case: switch (ca.ConstructorArguments [0].Value as string) {  					case "DEBUG":  					case "TRACE":  						return true;  					}
Missing Default,Gendarme.Rules.BadPractice,EqualsShouldHandleNullArgRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\EqualShouldHandleNullArgRule.cs,CheckSequence,The following switch statement is missing a default case: switch (ins.Next.OpCode.Code) {  					case Code.Brfalse:  					case Code.Brfalse_S:  						return CheckSequence (ins.Next.Operand as Instruction' type);  					}
Missing Default,Gendarme.Rules.BadPractice,GetEntryAssemblyMayReturnNullRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\GetEntryAssemblyMayReturnNullRule.cs,CheckMethod,The following switch statement is missing a default case: switch (current.OpCode.Code) {  				case Code.Call:  				case Code.Callvirt:  					if (IsGetEntryAssembly (current.Operand as MethodReference))  						Runner.Report (method' current' Severity.Medium' Confidence.Total);  					break;  				}
Missing Default,Gendarme.Rules.BadPractice,ReturnNullRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.BadPractice\ReturnNullRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Ret:  					// look if a null is returned  					CheckReturn (ins' method);  					break;  				case Code.Ldnull:  					// look for branching' e.g. immediate if  					CheckLdnull (ins' method);  					break;  				}
