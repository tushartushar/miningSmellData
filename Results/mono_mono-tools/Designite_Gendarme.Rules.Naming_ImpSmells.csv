Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.Naming,AvoidNonAlphanumericIdentifierRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\DetectNonAlphaNumericsInTypeNamesRule.cs,CheckType,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Naming,ParameterNamesShouldMatchOverriddenMethodRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\ParameterNamesShouldMatchOverridenMethodRule.cs,SignatureMatches,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Naming,ParameterNamesShouldMatchOverriddenMethodRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\ParameterNamesShouldMatchOverridenMethodRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Naming,UseCorrectCasingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectCasingRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Naming,UseCorrectSuffixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectSuffixRule.cs,CheckType,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,CheckMethod,Cyclomatic complexity of the method is 13
Complex Method,Gendarme.Rules.Naming,AvoidRedundancyInTypeNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInTypeNameRule.cs,CheckType,Cyclomatic complexity of the method is 14
Long Statement,Gendarme.Rules.Naming,UseCorrectCasingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectCasingRule.cs,CheckMethod,The length of the statement  "					"By existing naming conventions' all the method and property names should all be pascal-cased (e.g. MyOperation). Rename '{0}' to '{1}'."' " is 138.
Long Statement,Gendarme.Rules.Naming,UseCorrectCasingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectCasingRule.cs,CheckMethod,The length of the statement  "							"By existing naming conventions' the parameter names should all be camel-cased (e.g. myParameter). Rename '{0}' parameter to '{1}'."' " is 133.
Long Statement,Gendarme.Rules.Naming,UseCorrectPrefixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectPrefixRule.cs,CheckType,The length of the statement  "						"The '{0}' interface name doesn't have the required 'I' prefix. Acoording to existing naming conventions' all interface names should begin with the 'I' letter followed by another capital letter."'  " is 196.
Long Statement,Gendarme.Rules.Naming,UseCorrectPrefixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectPrefixRule.cs,CheckType,The length of the statement  "						"The '{0}' type name starts with '{1}' prefix but' according to existing naming conventions' type names should not have any specific prefix."'  " is 142.
Long Statement,Gendarme.Rules.Naming,UseCorrectSuffixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectSuffixRule.cs,CheckCollection,The length of the statement  "			return "'Collection' should only be used for implementing ICollection or IEnumerable or inheriting from Queue' Stack' DataSet and DataTable."; " is 142.
Long Statement,Gendarme.Rules.Naming,UseCorrectSuffixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectSuffixRule.cs,CheckDictionary,The length of the statement  "			if (type.Implements ("System.Collections"' "IDictionary") || type.Implements ("System.Collections.Generic"' "IDictionary`2")) " is 125.
Long Statement,Gendarme.Rules.Naming,UseCorrectSuffixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectSuffixRule.cs,HasSuffix,The length of the statement  "			return (String.Compare (suffix' 0' typeName' gpos - suffix.Length' suffix.Length' StringComparison.OrdinalIgnoreCase) == 0); " is 124.
Long Statement,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,CheckMethod,The length of the statement  "			if ((method_name.Length - name.Length) < 4 && IsVaguePrefix (method_name)) //suggestion would be too vague anyway (Get/Set/Is) " is 126.
Long Statement,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,CheckMethod,The length of the statement  "					"Consider renaming method to '{2}'' or extracting method to type '{0}' as {1} '{2}'' or making an extension method of that type."'  " is 130.
Long Statement,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,GetSuggestionMethodName,The length of the statement  "			string suggestion = string.Concat (method_name.Substring (0' posFound)' method_name.Substring (posFound + name.Length)); " is 120.
Complex Conditional,Gendarme.Rules.Naming,UseCorrectSuffixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectSuffixRule.cs,CheckCollection,The conditional expression  "type.Inherits ("System.Collections"' "Queue") || type.Inherits ("System.Collections"' "Stack") ||   				type.Inherits ("System.Data"' "DataSet") || type.Inherits ("System.Data"' "DataTable")"  is complex.
Magic Number,Gendarme.Rules.Naming,AvoidDeepNamespaceHierarchyRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidDeepNamespaceHierarchyRule.cs,CheckAssembly,The following statement contains a magic number: foreach (string ns in NamespaceEngine.NamespacesInside (assembly)) {  				// shortest invalid namespace would be "a.b.c.d.e"  				// so we can skip anything less than 2 * MaxDepth  				// note: overflow does not matter  				if (ns.Length < unchecked (MaxDepth + MaxDepth))  					continue;    				// count the levels (i.e. number of dots + 1)  				int levels = CountLevels (ns);  				if (levels <= MaxDepth)  					continue;    				// we have some exceptions for namespace specialization  				// i.e. stuff we often prefer to have in a sub-namespace  				// and for internal (non-visible) namespaces  				if (levels == MaxDepth + 1) {  					if (NamespaceDefinition.IsSpecialized (ns)) {  						continue;  					} else if (ns.EndsWith (".Internal"' StringComparison.Ordinal) || ns.EndsWith (".Impl"' StringComparison.Ordinal)) {  						continue;  					}  				}    				Severity severity = (levels < MaxDepth * 2) ? Severity.Medium : Severity.High;  				Runner.Report (NamespaceDefinition.GetDefinition (ns)' severity' Confidence.High);  			}
Magic Number,Gendarme.Rules.Naming,UseCorrectCasingRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectCasingRule.cs,CheckNamespace,The following statement contains a magic number: foreach (string ns in nspace.Split ('.')) {  				switch (ns.Length) {  				case 1:  					ReportCasingError (nd' String.Format (CultureInfo.InvariantCulture'  						"Use of single character namespace is discouraged. Rename namespace {0}"' ns));    					break;  				case 2:  					// if the subnamespace is made of 2 chars' each letter have to be uppercase  					if (ns.Any (c => Char.IsLetter (c) && Char.IsLower (c))) {  						string msg = String.Format (CultureInfo.InvariantCulture'  							"In namespaces made of two characters' both characters should uppercase. Rename namespace '{0}' to '{1}'"'  							ns' ns.ToUpperInvariant ());  						ReportCasingError (nd' msg);  					}  					break;  				default:  					// if the sub namespace is made of 3 or more chars' make sure they're not all uppercase  					if (ns.All (c => Char.IsLetter (c) && Char.IsUpper (c))) {  						string msg = String.Format (CultureInfo.InvariantCulture'  							"Namespaces longer than two characters should not be all uppercase. Rename namespace '{0}' to '{1}{2}'"'  							ns' ns [0].ToString (CultureInfo.InvariantCulture)' ns.Substring (1).ToLowerInvariant ());  						ReportCasingError (nd' msg);  					} else if (!IsPascalCase (ns)) {  						string msg = String.Format (CultureInfo.InvariantCulture'  							"Namespaces longer than two characters should be pascal cased. Rename namespace '{0}' to '{1}'"'  							ns' PascalCase (ns));  						ReportCasingError (nd' msg);  					}  					break;  				}  			}
Magic Number,Gendarme.Rules.Naming,UseCorrectPrefixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectPrefixRule.cs,IsCorrectTypeName,The following statement contains a magic number: if (name.Length < 3)  				return true;
Magic Number,Gendarme.Rules.Naming,UseCorrectPrefixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectPrefixRule.cs,IsCorrectTypeName,The following statement contains a magic number: switch (name [0]) {  			case 'C':	// MFC like CMyClass should fail - but works for CLSCompliant  			case 'I':	// interface-like - Classes beginning with In or Is etc should pass' e.g. InMemoryDoohicky  				return Char.IsLower (name [1]) ? true : Char.IsUpper (name [2]);  			default:  				return true;  			}
Magic Number,Gendarme.Rules.Naming,UseCorrectPrefixRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\UseCorrectPrefixRule.cs,IsCorrectInterfaceName,The following statement contains a magic number: if (name.Length < 3)  				return false;
Magic Number,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,CheckMethod,The following statement contains a magic number: if ((method_name.Length - name.Length) < 4 && IsVaguePrefix (method_name)) //suggestion would be too vague anyway (Get/Set/Is)  				return RuleResult.DoesNotApply;
Magic Number,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,GetSuggestionMethodName,The following statement contains a magic number: if (suggestion.EndsWith ("In"' StringComparison.Ordinal))  				return suggestion.Substring (0' suggestion.Length - 2);
Magic Number,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,GetSuggestionMethodName,The following statement contains a magic number: if (suggestion.EndsWith ("For"' StringComparison.Ordinal))  				return suggestion.Substring (0' suggestion.Length - 3);
Magic Number,Gendarme.Rules.Naming,AvoidRedundancyInMethodNameRule,C:\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Naming\AvoidRedundancyInMethodNameRule.cs,GetSuggestionMethodName,The following statement contains a magic number: if (suggestion.EndsWith ("From"' StringComparison.Ordinal) || suggestion.EndsWith ("With"' StringComparison.Ordinal))  				return suggestion.Substring (0' suggestion.Length - 4);
