Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The method has 822 lines of code.
Complex Method,Mono.Profiler,BaseHeapObject<HO;LC>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AllocateBackReferences,Cyclomatic complexity of the method is 9
Complex Method,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,Cyclomatic complexity of the method is 89
Complex Method,Mono.Profiler,NativeLibraryReader,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\NativeLibraryReader.cs,FillFunctionsUsingNm,Cyclomatic complexity of the method is 14
Complex Method,Mono.Profiler,Factory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,NewStackTrace,Cyclomatic complexity of the method is 8
Complex Method,Mono.Profiler,HeapItemSetFromComparison<HI;OHI>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,PerformComparison,Cyclomatic complexity of the method is 8
Long Parameter List,Mono.Profiler,LoadedAssembly,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,LoadedAssembly,The method has 10 parameters. Parameters: id' name' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable
Long Parameter List,Mono.Profiler,IHeapSnapshot,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewHeapObject,The method has 5 parameters. Parameters: id' c' size' referenceIds' referencesCount
Long Parameter List,Mono.Profiler,ILoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewAssembly,The method has 10 parameters. Parameters: id' name' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable
Long Parameter List,Mono.Profiler,ILoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewExecutableMemoryRegion,The method has 5 parameters. Parameters: id' fileName' fileOffset' startAddress' endAddress
Long Parameter List,Mono.Profiler,ILoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewHeapSnapshot,The method has 8 parameters. Parameters: collection' startCounter' startTime' endCounter' endTime' headerStartTime' initialAllocations' recordSnapshot
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Start,The method has 5 parameters. Parameters: version' runtimeFile' flags' startCounter' startTime
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ModuleLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ModuleUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AssemblyLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AssemblyUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ApplicationDomainLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ApplicationDomainUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Allocation,The method has 6 parameters. Parameters: c' size' caller' jitTime' objectId' counter
Long Parameter List,Mono.Profiler,IProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ClassAllocationSummary,The method has 5 parameters. Parameters: c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes
Long Parameter List,Mono.Profiler,BaseHeapSnapshot<HO;LC>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewHeapObject,The method has 5 parameters. Parameters: id' c' size' referenceIds' referencesCount
Long Parameter List,Mono.Profiler,BaseHeapSnapshot<HO;LC>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,BaseHeapSnapshot,The method has 8 parameters. Parameters: heapObjectFactory' collection' startCounter' startTime' endCounter' endTime' headerStartTime' recordSnapshot
Long Parameter List,Mono.Profiler,AllocationClassData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AllocationClassData,The method has 5 parameters. Parameters: c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes
Long Parameter List,Mono.Profiler,BaseAllocationSummary<LC>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,RecordData,The method has 5 parameters. Parameters: c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Start,The method has 5 parameters. Parameters: version' runtimeFile' flags' startCounter' startTime
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ModuleLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ModuleUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AssemblyLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AssemblyUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ApplicationDomainLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ApplicationDomainUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Allocation,The method has 6 parameters. Parameters: c' size' caller' jitTime' objectId' counter
Long Parameter List,Mono.Profiler,BaseProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ClassAllocationSummary,The method has 5 parameters. Parameters: c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Start,The method has 5 parameters. Parameters: version' runtimeFile' flags' startCounter' startTime
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ModuleLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ModuleUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AssemblyLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,AssemblyUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ApplicationDomainLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ApplicationDomainUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Allocation,The method has 6 parameters. Parameters: c' size' caller' jitTime' objectId' counter
Long Parameter List,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,ClassAllocationSummary,The method has 5 parameters. Parameters: c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes
Long Parameter List,Mono.Profiler,BaseExecutableMemoryRegion<UFR>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,BaseExecutableMemoryRegion,The method has 5 parameters. Parameters: id' name' fileOffset' startAddress' endAddress
Long Parameter List,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewAssembly,The method has 10 parameters. Parameters: id' name' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable
Long Parameter List,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewExecutableMemoryRegion,The method has 5 parameters. Parameters: id' fileName' fileOffset' startAddress' endAddress
Long Parameter List,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewHeapSnapshot,The method has 8 parameters. Parameters: collection' startCounter' startTime' endCounter' endTime' headerStartTime' initialAllocations' recordSnapshot
Long Parameter List,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,BlockData,The method has 5 parameters. Parameters: fileOffset' code' length' headerStartCounter' data
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,RecordAllocation,The method has 6 parameters. Parameters: c' objectId' size' caller' jitTime' trace
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,Start,The method has 5 parameters. Parameters: version' runtimeFile' flags' startCounter' startTime
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,ModuleLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,ModuleUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,AssemblyLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,AssemblyUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,ApplicationDomainLoaded,The method has 6 parameters. Parameters: threadId' id' startCounter' endCounter' name' success
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,ApplicationDomainUnloaded,The method has 5 parameters. Parameters: threadId' id' startCounter' endCounter' name
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,Allocation,The method has 6 parameters. Parameters: c' size' caller' jitTime' objectId' counter
Long Parameter List,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,ClassAllocationSummary,The method has 5 parameters. Parameters: c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes
Long Parameter List,Mono.Profiler,ExecutableMemoryRegion,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,ExecutableMemoryRegion,The method has 5 parameters. Parameters: id' name' fileOffset' startAddress' endAddress
Long Parameter List,Mono.Profiler,AllocatedObject,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,AllocatedObject,The method has 6 parameters. Parameters: id' c' size' caller' jitTime' trace
Long Parameter List,Mono.Profiler,HeapSnapshot,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,HeapSnapshot,The method has 8 parameters. Parameters: collection' startCounter' startTime' endCounter' endTime' headerStartTime' initialAllocations' recordSnapshot
Long Parameter List,Mono.Profiler,LoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,NewAssembly,The method has 10 parameters. Parameters: id' name' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable
Long Parameter List,Mono.Profiler,LoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,NewExecutableMemoryRegion,The method has 5 parameters. Parameters: id' fileName' fileOffset' startAddress' endAddress
Long Parameter List,Mono.Profiler,LoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,NewHeapSnapshot,The method has 8 parameters. Parameters: collection' startCounter' startTime' endCounter' endTime' headerStartTime' initialAllocations' recordSnapshots
Long Parameter List,Mono.Profiler,BaseMonitorStatisticsCollector,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,WriteComponentStatistics,The method has 5 parameters. Parameters: writer' owner' components' processor' depth
Long Parameter List,Mono.Profiler,BaseMonitorStatisticsCollector,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,WriteSimpleContainerFullStatistics,The method has 5 parameters. Parameters: writer' owner' container' processor' depth
Long Parameter List,Mono.Profiler,GlobalMonitorStatistics,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,HandleEvent,The method has 6 parameters. Parameters: threadId' eventCode' c' objectId' trace' counter
Long Parameter List,Mono.Profiler,MonitorStatisticsByClass,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,HandleEvent,The method has 5 parameters. Parameters: threadId' eventCode' objectId' trace' counter
Long Parameter List,Mono.Profiler,MonitorStatistics,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,HandleEvent,The method has 5 parameters. Parameters: threadId' eventCode' trace' counter' tracePerClassDestination
Long Identifier,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,,The length of the parameter unknownStatisticalHitsCollector is 31.
Long Identifier,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,,The length of the parameter compareGcStatisticsByAllocation is 31.
Long Identifier,Mono.Profiler,LoadedMethod,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,,The length of the parameter LoadedMethodForStackTraceUnavailable is 36.
Long Statement,Mono.Profiler,DebugProfilerEventHandler<LC;LM;UFR;UFI;MR;EH;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,Allocation,The length of the statement  "			output.WriteLine ("Allocation [classId {0}({1})' size {2}' callerId {3})' jitTime {4}' counter {5}]"' c.ID' c.Name' size' caller != null ? caller.ID : 0' jitTime' counter); " is 172.
Long Statement,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewAssembly,The length of the statement  "			LoadedAssembly result = factory.NewAssembly (id' name' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable); " is 135.
Long Statement,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewHeapSnapshot,The length of the statement  "			HS result = factory.NewHeapSnapshot (collection' startCounter' startTime' endCounter' endTime' headerStartTime' initialAllocations' recordSnapshot); " is 148.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,ReadString,The length of the statement  "				//LogLine ("Read string: putting data [offsetInBlock + i] ({0}' i = {1}) in builder [i]"' (char) data [offsetInBlock + i]' i); " is 126.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime); " is 170.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName); " is 168.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable); " is 130.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName); " is 170.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0); " is 123.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId); " is 125.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0); " is 172.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData)); " is 120.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind); " is 125.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind); " is 120.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind); " is 125.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind); " is 126.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind); " is 124.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId); " is 127.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0); " is 171.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size); " is 187.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name); " is 153.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots); " is 315.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime); " is 172.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime); " is 123.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The length of the statement  "					throw new DecodingException (this' offsetInBlock' String.Format ("Block ended at offset {0} but its declared length is {1}"' offsetInBlock' length)); " is 149.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,HandleDecodingException,The length of the statement  "				debugLog.WriteLine ("ERROR: DecodingException in block of code {0}' length {1}' file offset {2}' block offset {3}: {4}"' e.FailingData.Code' e.FailingData.Length' e.FailingData.FileOffset' e.OffsetInBlock' e.Message); " is 217.
Long Statement,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,HandleRegularException,The length of the statement  "				debugLog.WriteLine ("ERROR: Exception in block of code {0}' length {1}' file offset {2}' block offset {3}: {4}"' Code' Length' FileOffset' offsetInBlock' e.Message); " is 165.
Long Statement,Mono.Profiler,ProfilerEventHandler,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\EventProcessor.cs,End,The length of the statement  "				throw new Exception (String.Format ("Version {0} specified at start is inconsistent witn {1} specified at end"' this.version' version)); " is 136.
Long Statement,Mono.Profiler,LoadedElementFactory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,NewHeapSnapshot,The length of the statement  "			return new HeapSnapshot (collection' startCounter' startTime' endCounter' endTime' headerStartTime' initialAllocations' recordSnapshots); " is 137.
Long Statement,Mono.Profiler,MonitorStatisticsByClass,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,HandleEvent,The length of the statement  "			MonitorStatisticsByCallStack<MonitorStatisticsByCallerPerClass> tracePerClassDestination = callerPerClassTarget.HandleEvent (eventCode' trace); " is 143.
Long Statement,Mono.Profiler,SyncLogFileReader,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Reader.cs,ReadBlock,The length of the statement  "					throw new DecodingException (result' 0' String.Format ("Invalid header: length is {0} instead of {1}"' bytesRead' BlockData.BLOCK_HEADER_SIZE)); " is 144.
Long Statement,Mono.Profiler,SeekableLogFileReader,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Reader.cs,InitializeBlocks,The length of the statement  "				Block block = new Block (fileOffset' BlockData.DecodeHeaderBlockCode (header)' (uint) BlockData.DecodeHeaderBlockLength (header)' counter); " is 139.
Magic Number,Mono.Profiler,BaseExecutableMemoryRegion<UFR>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,GetFunction,The following statement contains a magic number: int middleIndex = lowIndex + ((highIndex - lowIndex) / 2);
Magic Number,Mono.Profiler,BaseExecutableMemoryRegion<UFR>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,GetFunction,The following statement contains a magic number: middleIndex = lowIndex + ((highIndex - lowIndex) / 2);
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,GetExecutableMemoryRegion,The following statement contains a magic number: int middleIndex = lowIndex + ((highIndex - lowIndex) / 2);
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,GetExecutableMemoryRegion,The following statement contains a magic number: middleIndex = lowIndex + ((highIndex - lowIndex) / 2);
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewAssembly,The following statement contains a magic number: LoadedAssembly[] newLoadedAssemblies = new LoadedAssembly [((int) id + 1) * 2];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewClass,The following statement contains a magic number: LC[] newLoadedClasses = new LC [((int) id + 1) * 2];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewMethod,The following statement contains a magic number: LM[] newLoadedMethods = new LM [((int) id + 1) * 2];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,NewUnmanagedFunction,The following statement contains a magic number: UFI[] newUnmanagedFunctionsByID = new UFI [((int) id + 1) * 2];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,LoadedElementHandler,The following statement contains a magic number: loadedAssemblies = new LoadedAssembly [10];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,LoadedElementHandler,The following statement contains a magic number: loadedClasses = new LC [1000];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,LoadedElementHandler,The following statement contains a magic number: loadedMethods = new LM [5000];
Magic Number,Mono.Profiler,LoadedElementHandler<LC;LM;UFR;UFI;MR;HO;HS>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\BaseTypes.cs,LoadedElementHandler,The following statement contains a magic number: unmanagedFunctionsByID = new UFI [1000];
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,microsecondsToTimeSpan,The following statement contains a magic number: return TimeSpan.FromTicks ((long) microseconds * 10);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCode,The following statement contains a magic number: return (BlockCode) (header [0] | (header [1] << 8));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockLength,The following statement contains a magic number: return header [2] | (header [3] << 8) | (header [4] << 16) | (header [5] << 24);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeHeaderBlockCounterDelta,The following statement contains a magic number: return (uint) (header [6] | (header [7] << 8) | (header [8] << 16) | (header [9] << 24));
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,ReadUint,The following statement contains a magic number: factor += 7;
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,ReadUlong,The following statement contains a magic number: factor += 7;
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,EventKindFromEventCode,The following statement contains a magic number: return ((eventCode & (1<<4)) != 0) ? EventKind.END : EventKind.START;
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DecodeGarbageCollectionEventValue,The following statement contains a magic number: collection = eventValue >> 8;
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: StackSectionElement<LC'LM>[] stackSection = new StackSectionElement<LC'LM> [32];
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following statement contains a magic number: switch (code) {  				case BlockCode.INTRO : {  					uint version;  					string runtimeFile;  					uint flags;  					ulong startCounter;  					ulong startTime;  					  					version = ReadUint (ref offsetInBlock);  					runtimeFile = ReadString (ref offsetInBlock);  					flags = ReadUint (ref offsetInBlock);  					startCounter = ReadUlong (ref offsetInBlock);  					startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK INTRO: version {0}' runtimeFile {1}' flags {2}' startCounter {3}' startTime {4}"' version' runtimeFile' (ProfilerFlags) flags' startCounter' startTime);  					  					handler.Start (version' runtimeFile' (ProfilerFlags) flags' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.END : {  					uint version;  					ulong endCounter;  					ulong endTime;  					  					version = ReadUint (ref offsetInBlock);  					endCounter = ReadUlong (ref offsetInBlock);  					endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK END: version {0}' endCounter {1}' endTime {2}"' version' endCounter' endTime);  					  					handler.End (version' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.LOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					bool success = ((kind & (byte)LoadedItemInfo.SUCCESS) != 0);  					kind &= (byte) (LoadedItemInfo.APPDOMAIN|LoadedItemInfo.ASSEMBLY|LoadedItemInfo.MODULE);  					//LogLine ("BLOCK LOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						string baseName;  						uint major;  						uint minor;  						uint build;  						uint revision;  						string culture;  						string publicKeyToken;  						bool retargetable;  						if (handler.Directives.ClassesCarryAssemblyId) {  							baseName = ReadString (ref offsetInBlock);  							major = ReadUint (ref offsetInBlock);  							minor = ReadUint (ref offsetInBlock);  							build = ReadUint (ref offsetInBlock);  							revision = ReadUint (ref offsetInBlock);  							culture = ReadString (ref offsetInBlock);  							publicKeyToken = ReadString (ref offsetInBlock);  							retargetable = (ReadUint (ref offsetInBlock) != 0);  						} else {  							int commaPosition = itemName.IndexOf (''');  							if (commaPosition > 0) {  								baseName = itemName.Substring (0' commaPosition);  							} else {  								baseName = "UNKNOWN";  							}  							major = 0;  							minor = 0;  							build = 0;  							revision = 0;  							culture = "neutral";  							publicKeyToken = "null";  							retargetable = false;  						}  						handler.LoadedElements.NewAssembly (id' itemName' baseName' major' minor' build' revision' culture' publicKeyToken' retargetable);  						handler.AssemblyLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleLoaded (threadId' id' startCounter' endCounter' itemName' success);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown load event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.UNLOADED : {  					byte kind = ReadByte (ref offsetInBlock);  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					uint id;  					if (handler.Directives.LoadedElementsCarryId) {  						id = ReadUint (ref offsetInBlock);  					} else {  						id = 0;  					}  					string itemName = ReadString (ref offsetInBlock);  					  					//LogLine ("BLOCK UNLOADED: kind {0}' startCounter {1}' endCounter {2}' threadId {3}' itemName {4}"' (LoadedItemInfo) kind' startCounter' endCounter' threadId' itemName);  					  					switch ((LoadedItemInfo) kind) {  					case LoadedItemInfo.APPDOMAIN: {  						handler.ApplicationDomainUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.ASSEMBLY: {  						handler.AssemblyUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					case LoadedItemInfo.MODULE: {  						handler.ModuleUnloaded (threadId' id' startCounter' endCounter' itemName);  						handler.DataProcessed (offsetInBlock);  						break;  					}  					default: {  						throw new DecodingException (this' offsetInBlock' String.Format ("unknown unload event kind {0}"' kind));  					}  					}  					break;  				}  				case BlockCode.MAPPING : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					uint itemId;  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint assemblyId;  						if (handler.Directives.ClassesCarryAssemblyId) {  							assemblyId = ReadUint (ref offsetInBlock);  						} else {  							assemblyId = 0;  						}  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (CLASS): itemId {0}' assemblyId = {1}' itemName {2}' size {3}"' itemId' assemblyId' itemName' 0);  						handler.LoadedElements.NewClass (itemId' handler.LoadedElements.GetAssembly (assemblyId)' itemName' 0);  					}  					  					for (itemId = ReadUint (ref offsetInBlock); itemId != 0; itemId = ReadUint (ref offsetInBlock)) {  						uint classId = ReadUint (ref offsetInBlock);  						uint wrapperValue;  						if (handler.Directives.MethodsCarryWrapperFlag) {  							wrapperValue = ReadUint (ref offsetInBlock);  						} else {  							wrapperValue = 0;  						}  						bool isWrapper = (wrapperValue != 0) ? true : false;  						string itemName = ReadString (ref offsetInBlock);  						//LogLine ("BLOCK MAPPING (METHOD): itemId {0}' classId {1}' itemName {2}' size {3}"' itemId' classId' itemName' 0);  						handler.LoadedElements.NewMethod (itemId' handler.LoadedElements.GetClass (classId)' isWrapper' itemName);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK MAPPING (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.EVENTS : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					ulong threadId = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK EVENTS (START): startCounter {0}' startTime {1}' threadId {2}"' startCounter' startTime' threadId);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' threadId);  					handler.SetCurrentThread (threadId);  					handler.DataProcessed (offsetInBlock);  					  					ulong baseCounter = ReadUlong (ref offsetInBlock);  					  					byte eventCode;  					for (eventCode = ReadByte (ref offsetInBlock); eventCode != 0; eventCode = ReadByte (ref offsetInBlock)) {  						PackedEventCode packedCode = (PackedEventCode) (eventCode & PACKED_EVENT_CODE_MASK);  						int packedData = ((eventCode >> PACKED_EVENT_CODE_BITS) & PACKED_EVENT_DATA_MASK);  						  						switch (packedCode) {  						case PackedEventCode.CLASS_ALLOCATION: {  							handler.AllocationDataProcessed ();  							  							uint classId = ReadUint (ref offsetInBlock);  							uint classSize = ReadUint (ref offsetInBlock);  							classId <<= PACKED_EVENT_DATA_BITS;  							classId |= (uint) packedData;  							uint callerId = 0;  							if (handler.Directives.AllocationsCarryCallerMethod) {  								callerId = ReadUint (ref offsetInBlock);  							}  							ulong objectId = 0;  							if (handler.Directives.AllocationsCarryId) {  								objectId = ReadUlong (ref offsetInBlock);  							}  							//LogLine ("BLOCK EVENTS (PACKED:CLASS_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  							handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' false' objectId' 0);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.CLASS_EVENT: {  							ClassEvent classEventCode = ClassEventFromEventCode (packedData);  							switch (classEventCode) {  							case ClassEvent.EXCEPTION: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (CLASS:EXCEPTION): classId {0}' counterDelta {1}"' classId' counterDelta);  								handler.Exception (handler.LoadedElements.GetClass (classId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case ClassEvent.LOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:LOAD): classId {0}' classSize {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartLoad (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndLoad (handler.LoadedElements.GetClass (classId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.UNLOAD: {  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (CLASS:UNLOAD): classId {0}' counterDelta {1}' kind {2}"' classId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ClassStartUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ClassEndUnload (handler.LoadedElements.GetClass (classId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case ClassEvent.LOCK: {  								handler.LockContentionDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								uint lockEvent = ReadUint (ref offsetInBlock);  								ulong objectId = ReadUlong (ref offsetInBlock);  								  								handler.MonitorEvent ((MonitorEvent) lockEvent' handler.LoadedElements.GetClass (classId)' objectId' baseCounter);  								  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown class event {0}"' classEventCode));  							}  							}  							break;  						}  						case PackedEventCode.METHOD_ENTER: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_ENTER): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodEnter (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_EXPLICIT: {  							handler.CallDataProcessed ();  							  							uint methodId = ReadUint (ref offsetInBlock);  							ulong counterDelta = ReadUlong (ref offsetInBlock);  							baseCounter += counterDelta;  							methodId <<= PACKED_EVENT_DATA_BITS;  							methodId |= (uint) packedData;  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_EXPLICIT): methodId {0}' counterDelta {1}"' methodId' counterDelta);  							handler.MethodExit (handler.LoadedElements.GetMethod (methodId)' baseCounter);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case PackedEventCode.METHOD_EXIT_IMPLICIT: {  							handler.CallDataProcessed ();  							  							//LogLine ("BLOCK EVENTS (PACKED:METHOD_EXIT_IMPLICIT): counterDelta {0}"' 0);  							throw new DecodingException (this' offsetInBlock' "PackedEventCode.METHOD_EXIT_IMPLICIT unsupported");  						}  						case PackedEventCode.METHOD_EVENT: {  							MethodEvent methodEventCode = MethodEventFromEventCode (packedData);  							switch (methodEventCode) {  							case MethodEvent.FREED: {  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								//LogLine ("BLOCK EVENTS (METHOD:FREED): methodId {0}' counterDelta {1}"' methodId' counterDelta);  								handler.MethodFreed (handler.LoadedElements.GetMethod (methodId)' baseCounter);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case MethodEvent.JIT: {  								handler.JitTimeDataProcessed ();  								  								uint methodId = ReadUint (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (METHOD:JIT): methodId {0}' counterDelta {1}' kind {2}"' methodId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.MethodJitStart (handler.LoadedElements.GetMethod (methodId)' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.MethodJitEnd (handler.LoadedElements.GetMethod (methodId)' baseCounter' EventSuccessFromEventCode (packedData));  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown method event {0}"' methodEventCode));  							}  							}  							break;  						}  						case PackedEventCode.OTHER_EVENT: {  							GenericEvent genericEventCode = GenericEventFromEventCode (packedData);  							switch (genericEventCode) {  							case GenericEvent.GC_COLLECTION: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_COLLECTION): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_MARK: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_MARK): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionMarkStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionMarkEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_SWEEP: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_SWEEP): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionSweepStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionSweepEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_RESIZE: {  								handler.GcTimeDataProcessed ();  								  								ulong newSize = ReadUlong (ref offsetInBlock);  								uint collection = ReadUint (ref offsetInBlock);  								//LogLine ("BLOCK EVENTS (OTHER:GC_RESIZE): newSize {0}' collection {1}"' newSize' collection);  								handler.GarbageCollectionResize (collection' newSize);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.GC_STOP_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_STOP_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStopWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStopWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.GC_START_WORLD: {  								handler.GcTimeDataProcessed ();  								  								uint collection;  								uint generation;  								DecodeGarbageCollectionEventValue (ReadUint (ref offsetInBlock)' out collection' out generation);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:GC_START_WORLD): generation {0}' counterDelta {1}' kind {2}"' generation' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.GarbageCollectionStartWorldStart (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.GarbageCollectionStartWorldEnd (collection' generation' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.THREAD: {  								ulong eventThreadId = ReadUlong (ref offsetInBlock);  								ulong counterDelta = ReadUlong (ref offsetInBlock);  								baseCounter += counterDelta;  								EventKind kind = EventKindFromEventCode (packedData);  								//LogLine ("BLOCK EVENTS (OTHER:THREAD): eventThreadId {0}' counterDelta {1}' kind {2}"' eventThreadId' counterDelta' kind);  								if (kind == EventKind.START) {  									handler.ThreadStart (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								} else {  									handler.ThreadEnd (eventThreadId' baseCounter);  									handler.DataProcessed (offsetInBlock);  								}  								break;  							}  							case GenericEvent.JIT_TIME_ALLOCATION: {  								handler.AllocationDataProcessed ();  								  								uint classId = ReadUint (ref offsetInBlock);  								uint classSize = ReadUint (ref offsetInBlock);  								uint callerId = 0;  								if (handler.Directives.AllocationsCarryCallerMethod) {  									callerId = ReadUint (ref offsetInBlock);  								}  								ulong objectId = 0;  								if (handler.Directives.AllocationsCarryId) {  									objectId = ReadUlong (ref offsetInBlock);  								}  								//LogLine ("BLOCK EVENTS (OTHER:JIT_TIME_ALLOCATION): classId {0}' classSize {1}' callerId {2}"' classId' classSize' callerId);  								handler.Allocation (handler.LoadedElements.GetClass (classId)' classSize' (callerId != 0) ? handler.LoadedElements.GetMethod (callerId) : default (LM)' true' objectId' 0);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							case GenericEvent.STACK_SECTION: {  								uint lastValidFrame = ReadUint (ref offsetInBlock);  								uint topSectionSize = ReadUint (ref offsetInBlock);  								  								if (stackSection.Length < topSectionSize) {  									stackSection = new StackSectionElement<LC'LM> [topSectionSize * 2];  								}  								  								for (int i = 0; i < topSectionSize; i++) {  									uint methodId = ReadUint (ref offsetInBlock);  									stackSection [i].IsBeingJitted = ((methodId & 1) != 0) ? true : false;  									methodId >>= 1;  									stackSection [i].Method = handler.LoadedElements.GetMethod (methodId);  								}  								  								handler.AdjustStack (lastValidFrame' topSectionSize' stackSection);  								handler.DataProcessed (offsetInBlock);  								break;  							}  							default: {  								throw new DecodingException (this' offsetInBlock' String.Format ("unknown generic event {0}"' genericEventCode));  							}  							}  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown packed event code {0}"' packedCode));  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK EVENTS (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' threadId);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.STATISTICAL : {  					handler.StatisticalDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					  					//LogLine ("BLOCK STATISTICAL (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != (uint) StatisticalCode.END; id = ReadUint (ref offsetInBlock)) {  						StatisticalCode statisticalCode = (StatisticalCode) (id & 7);  						switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK STATISTICAL (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					break;  				}  				case BlockCode.HEAP_DATA : {  					handler.HeapSnapshotDataProcessed ();  					  					ulong jobStartCounter = ReadUlong (ref offsetInBlock);  					ulong jobStartTime = ReadUlong (ref offsetInBlock);  					ulong jobEndCounter = ReadUlong (ref offsetInBlock);  					ulong jobEndTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					HS snapshot = handler.LoadedElements.NewHeapSnapshot (collection' jobStartCounter' microsecondsFromEpochToDateTime (jobStartTime)' jobEndCounter' microsecondsFromEpochToDateTime (jobEndTime)' handler.ClicksToTimeSpan (headerStartCounter)' handler.LoadedElements.Classes' handler.LoadedElements.RecordHeapSnapshots);  					handler.HeapReportStart (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (START): ({0}:{1}-{2}:{3}) startCounter {4}' startTime {5}"' jobStartCounter' jobStartTime' jobEndCounter' jobEndTime' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					ulong item;  					ulong[] references = new ulong [50];  					for (item = ReadUlong (ref offsetInBlock); item != 0; item = ReadUlong (ref offsetInBlock)) {  						HeapSnapshotCode itemCode = (HeapSnapshotCode) (((int) item) & ((int) HeapSnapshotCode.MASK));  						//LogLine ("Got raw value {0} (code {1})"' item' itemCode);  						switch (itemCode) {  						case HeapSnapshotCode.FREE_OBJECT_CLASS: {  							uint classId = (uint) (item >> 2);  							uint size = ReadUint (ref offsetInBlock);  							LC c = handler.LoadedElements.GetClass (classId);  							//LogLine ("  Class id {0}' size {1}"' classId' size);  							handler.HeapObjectUnreachable (c' size);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case HeapSnapshotCode.OBJECT: {  							uint classId = ReadUint (ref offsetInBlock);  							uint size = ReadUint (ref offsetInBlock);  							int referencesCount = (int) ReadUint (ref offsetInBlock);  							ulong objectId = item & (~ ((ulong) HeapSnapshotCode.MASK));  							//LogLine ("  Object id {0}' references {1}"' objectId' referencesCount);  							if (references.Length < referencesCount) {  								references = new ulong [referencesCount + 50];  							}  							for (int i = 0; i < referencesCount; i++) {  								references [i] = ReadUlong (ref offsetInBlock);  								//LogLine ("    reference[{0}] {1}"' i' references [i]);  							}  							LC c = handler.LoadedElements.GetClass (classId);  							HO o = snapshot.NewHeapObject (objectId' c' size' references' referencesCount);  							handler.HeapObjectReachable (o);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						default: {  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown item code {0}"' itemCode));  						}  						}  					}  					handler.HeapReportEnd (snapshot);  					handler.DataProcessed (offsetInBlock);  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					//LogLine ("BLOCK HEAP_DATA (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.HEAP_SUMMARY : {  					handler.HeapSummaryDataProcessed ();  					  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					uint collection = ReadUint (ref offsetInBlock);  					  					//LogLine ("BLOCK HEAP_SUMMARY (START): ([]{0}:{1}) startCounter {4}' startTime {5}"' collection' startCounter' startTime);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.AllocationSummaryStart (collection' startCounter' microsecondsFromEpochToDateTime (startTime));  					handler.DataProcessed (offsetInBlock);  					  					uint id;  					for (id = ReadUint (ref offsetInBlock); id != 0; id = ReadUint (ref offsetInBlock)) {  						uint reachableInstances = ReadUint (ref offsetInBlock);  						uint reachableBytes = ReadUint (ref offsetInBlock);  						uint unreachableInstances = ReadUint (ref offsetInBlock);  						uint unreachableBytes = ReadUint (ref offsetInBlock);  						LC c = handler.LoadedElements.GetClass (id);  						  						handler.ClassAllocationSummary (c' reachableInstances' reachableBytes' unreachableInstances' unreachableBytes);  						handler.DataProcessed (offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.AllocationSummaryEnd (collection' endCounter' microsecondsFromEpochToDateTime (endTime));  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK HEAP_SUMMARY (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					break;  				}  				case BlockCode.DIRECTIVES : {  					ulong startCounter = ReadUlong (ref offsetInBlock);  					ulong startTime = ReadUlong (ref offsetInBlock);  					handler.StartBlock (startCounter' microsecondsFromEpochToDateTime (startTime)' 0);  					handler.DataProcessed (offsetInBlock);  					  					//LogLine ("BLOCK DIRECTIVES (START): startCounter {0}' startTime {1}"' startCounter' startTime);  					DirectiveCodes directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					while (directive != DirectiveCodes.END) {  						switch (directive) {  						case DirectiveCodes.ALLOCATIONS_CARRY_CALLER:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_CALLER");  							handler.Directives.AllocationsCarryCallerMethodReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_HAVE_STACK:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_HAVE_STACK");  							handler.Directives.AllocationsHaveStackTraceReceived ();  							break;  						case DirectiveCodes.ALLOCATIONS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): ALLOCATIONS_CARRY_ID");  							handler.Directives.AllocationsCarryIdReceived ();  							break;  						case DirectiveCodes.LOADED_ELEMENTS_CARRY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): LOADED_ELEMENTS_CARRY_ID");  							handler.Directives.LoadedElementsCarryIdReceived ();  							break;  						case DirectiveCodes.CLASSES_CARRY_ASSEMBLY_ID:  							//LogLine ("BLOCK DIRECTIVES (START): CLASSES_CARRY_ASSEMBLY_ID");  							handler.Directives.ClassesCarryAssemblyIdReceived ();  							break;  						case DirectiveCodes.METHODS_CARRY_WRAPPER_FLAG:  							//LogLine ("BLOCK DIRECTIVES (START): METHODS_CARRY_WRAPPER_FLAG");  							handler.Directives.MethodsCarryWrapperFlagReceived ();  							break;  						default:  							throw new DecodingException (this' offsetInBlock' String.Format ("unknown directive {0}"' directive));  						}  						  						directive = (DirectiveCodes) ReadUint (ref offsetInBlock);  					}  					  					ulong endCounter = ReadUlong (ref offsetInBlock);  					ulong endTime = ReadUlong (ref offsetInBlock);  					handler.EndBlock (endCounter' microsecondsFromEpochToDateTime (endTime)' 0);  					handler.DataProcessed (offsetInBlock);  					//LogLine ("BLOCK DIRECTIVES (END): endCounter {0}' endTime {1}"' endCounter' endTime);  					break;  				}  				default: {  					throw new DecodingException (this' offsetInBlock' String.Format ("unknown block code {0}"' code));  				}  				}
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DumpData,The following statement contains a magic number: output.Write ("  [{0}-{1}]"' startOffset' startOffset + 7);
Magic Number,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,DumpData,The following statement contains a magic number: currentIndex % 8 == 0
Magic Number,Mono.Profiler,NativeLibraryReader,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\NativeLibraryReader.cs,FillFunctionsUsingNm,The following statement contains a magic number: String symbolType = m.Groups [2].Value;
Magic Number,Mono.Profiler,NativeLibraryReader,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\NativeLibraryReader.cs,FillFunctionsUsingNm,The following statement contains a magic number: String symbolName = m.Groups [3].Value;
Magic Number,Mono.Profiler,Factory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,Factory,The following statement contains a magic number: tracesByLevel = new Dictionary<uint'List<StackTrace>> [64];
Magic Number,Mono.Profiler,Factory,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,NewStackTrace,The following statement contains a magic number: Dictionary<uint'List<StackTrace>> [] newTracesByLevel = new Dictionary<uint'List<StackTrace>> [frame.Level * 2];
Magic Number,Mono.Profiler,StatisticalHitItemTreeNode,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,PrintTree,The following statement contains a magic number: writer.WriteLine ("{0'5:F2}% ({1}) {2}"' ((((double) HitCount) / fatherHits) * 100)' HitCount' Name);
Magic Number,Mono.Profiler,BaseMonitorStatisticsCollector,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,WriteIndividualStatistics,The following statement contains a magic number: writer.Write ("{0'5:F2}% ({1:F6} ticks) contention time ({2} contentions' {3} failures) in "'  			              //(secondsContended / ownerSecondsContended) * 100.0'  			              (((double) TicksContended) / owner.TicksContended) * 100.0'  			              //secondsContended'  			              TicksContended'  			              ContentionCount'  			              FailCount);
Magic Number,Mono.Profiler,MonitorStatisticsByCallStack<C>,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\ObjectModel.cs,WriteName,The following statement contains a magic number: trace.Write (writer' depth + 2' IndentationString);
Missing Default,Mono.Profiler,BlockData,C:\research\architectureSmells\repos\mono_mono-tools\Mono.Profiler\profiler-decoder-library\Decoder.cs,Decode,The following switch statement is missing a default case: switch (statisticalCode) {  						case StatisticalCode.METHOD: {  							uint methodId = id >> 3;  							//LogLine ("BLOCK STATISTICAL (METHOD): methodId {0}"' methodId);  							if (methodId != 0) {  								handler.MethodStatisticalHit (handler.LoadedElements.GetMethod (methodId));  								handler.DataProcessed (offsetInBlock);  							} else {  								handler.UnknownMethodStatisticalHit ();  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_ID: {  							uint functionId = id >> 3;  							UFI function = handler.LoadedElements.GetUnmanagedFunctionByID (functionId);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_NEW_ID: {  							uint regionId = id >> 3;  							uint functionId = ReadUint (ref offsetInBlock);  							string name = ReadString (ref offsetInBlock);  							MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  							UFI function = handler.LoadedElements.NewUnmanagedFunction (functionId' name' region);  							handler.UnmanagedFunctionStatisticalHit (function);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.UNMANAGED_FUNCTION_OFFSET_IN_REGION: {  							uint regionId = id >> 3;  							if (regionId != 0) {  								MR region = handler.LoadedElements.GetExecutableMemoryRegion (regionId);  								uint offset = ReadUint (ref offsetInBlock);  								UFR function = region.GetFunction (offset);  								if (function != null) {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' offset {1}"' regionId' offset);  									handler.UnmanagedFunctionStatisticalHit (function);  									handler.DataProcessed (offsetInBlock);  								} else {  									//LogLine ("BLOCK STATISTICAL (FUNCTION): regionId {0}' unknown offset {1}"' regionId' offset);  									handler.UnknownUnmanagedFunctionStatisticalHit (region' offset);  									handler.DataProcessed (offsetInBlock);  								}  							} else {  								ulong address = ReadUlong (ref offsetInBlock);  								//LogLine ("BLOCK STATISTICAL (FUNCTION): unknown address {0}"' address);  								handler.UnknownUnmanagedFunctionStatisticalHit (address);  								handler.DataProcessed (offsetInBlock);  							}  							break;  						}  						case StatisticalCode.CALL_CHAIN: {  							uint chainDepth = id >> 3;  							//LogLine ("BLOCK STATISTICAL (CHAIN): starting chain of depth {0}"' chainDepth);  							handler.StatisticalCallChainStart (chainDepth);  							handler.DataProcessed (offsetInBlock);  							break;  						}  						case StatisticalCode.REGIONS: {  							uint regionId;  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								//LogLine ("BLOCK STATISTICAL (REGION): invalidated regionId {0}"' regionId);  								handler.LoadedElements.InvalidateExecutableMemoryRegion (regionId);  							}  							for (regionId = ReadUint (ref offsetInBlock); regionId != 0; regionId = ReadUint (ref offsetInBlock)) {  								ulong start = ReadUlong (ref offsetInBlock);  								uint size = ReadUint (ref offsetInBlock);  								uint regionFileOffset = ReadUint (ref offsetInBlock);  								string fileName = ReadString (ref offsetInBlock);  								  								//LogLine ("BLOCK STATISTICAL (REGION): added regionId {0} (fileName {1}' fileOffset {2}' start {3}' end {4}' size {5})"' regionId' fileName' regionFileOffset' start' start + size' size);  								handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' regionFileOffset' start' start + size);  								//MR region = handler.LoadedElements.NewExecutableMemoryRegion (regionId' fileName' fileOffset' start' start + size);  								//UF[] functions = region.Functions;  								//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got {1} functions"' regionId' functions.Length);  								//foreach (UF function in functions) {  									//LogLine ("BLOCK STATISTICAL (REGION): in regionId {0}' got function [{1}-{2}] {3}"' regionId' function.StartOffset' function.EndOffset' function.Name);  								//}  							}  							handler.LoadedElements.SortExecutableMemoryRegions ();  							handler.DataProcessed (offsetInBlock);  							break;  						}  						}
