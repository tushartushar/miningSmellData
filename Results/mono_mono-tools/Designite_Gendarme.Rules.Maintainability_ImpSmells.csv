Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gendarme.Rules.Maintainability,AvoidAlwaysNullFieldRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidAlwaysNullFieldRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Maintainability,AvoidAlwaysNullFieldRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidAlwaysNullFieldRule.cs,CheckType,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Maintainability,AvoidComplexMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidComplexMethodsRule.cs,GetSwitchCyclomaticComplexity,Cyclomatic complexity of the method is 10
Complex Method,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,GetCohesivenessForType,Cyclomatic complexity of the method is 12
Complex Method,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,GetInterfaceImplementor,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,UpdateParameterLeastType,Cyclomatic complexity of the method is 12
Complex Method,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,CheckParameters,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Maintainability,ConsiderUsingStopwatchRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\ConsiderUsingStopwatchRule.cs,CheckParameters,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Maintainability,ConsiderUsingStopwatchRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\ConsiderUsingStopwatchRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Maintainability,PreferStringIsNullOrEmptyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\PreferStringIsNullOrEmptyRule.cs,GetName,Cyclomatic complexity of the method is 11
Complex Method,Gendarme.Rules.Maintainability,PreferStringIsNullOrEmptyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\PreferStringIsNullOrEmptyRule.cs,CheckMethod,Cyclomatic complexity of the method is 8
Complex Method,Gendarme.Rules.Maintainability,RemoveDependenceOnObsoleteCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\RemoveDependenceOnObsoleteCodeRule.cs,CheckMethod,Cyclomatic complexity of the method is 9
Complex Method,Gendarme.Rules.Maintainability,VariableNamesShouldNotMatchFieldNamesRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\VariableNamesShouldNotMatchFieldNamesRule.cs,CheckType,Cyclomatic complexity of the method is 11
Long Statement,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,CheckParameters,The length of the statement  "			Dictionary<ParameterDefinition' List<StackEntryUsageResult>> usages = new Dictionary<ParameterDefinition' List<StackEntryUsageResult>> (); " is 138.
Long Statement,Gendarme.Rules.Maintainability,RemoveDependenceOnObsoleteCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\RemoveDependenceOnObsoleteCodeRule.cs,CheckMethod,The length of the statement  "			if (method.HasAttribute ("System"' "ObsoleteAttribute") || method.DeclaringType.HasAttribute ("System"' "ObsoleteAttribute")) " is 125.
Complex Conditional,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,CheckType,The conditional expression  "type.IsEnum || type.IsInterface || type.IsAbstract || type.IsDelegate () || type.IsGeneratedCode ()"  is complex.
Complex Conditional,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,GetCohesivenessForType,The conditional expression  "null == fd || !fd.IsPrivate || fd.IsStatic || fd.IsGeneratedCode ()"  is complex.
Complex Conditional,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,GetCohesivenessForType,The conditional expression  "md == null || md.IsPrivate || md.IsStatic || !md.IsProperty () || !md.IsGeneratedCode ()"  is complex.
Complex Conditional,Gendarme.Rules.Maintainability,RemoveDependenceOnObsoleteCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\RemoveDependenceOnObsoleteCodeRule.cs,CheckMethod,The conditional expression  "method.IsProperty () || method.IsAddOn || method.IsRemoveOn || method.IsFire"  is complex.
Magic Number,Gendarme.Rules.Maintainability,AvoidComplexMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidComplexMethodsRule.cs,Initialize,The following statement contains a magic number: LowThreshold = SuccessThreshold * 2;
Magic Number,Gendarme.Rules.Maintainability,AvoidComplexMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidComplexMethodsRule.cs,Initialize,The following statement contains a magic number: MediumThreshold = SuccessThreshold * 3;
Magic Number,Gendarme.Rules.Maintainability,AvoidComplexMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidComplexMethodsRule.cs,Initialize,The following statement contains a magic number: HighThreshold = SuccessThreshold * 4;
Magic Number,Gendarme.Rules.Maintainability,AvoidDeepInheritanceTreeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidDeepInheritanceTreeRule.cs,GetSeverity,The following statement contains a magic number: depth < 2 * MaximumDepth
Magic Number,Gendarme.Rules.Maintainability,AvoidDeepInheritanceTreeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidDeepInheritanceTreeRule.cs,GetSeverity,The following statement contains a magic number: return (depth < 4 * MaximumDepth) ? Severity.High : Severity.Critical;
Magic Number,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,CheckType,The following statement contains a magic number: string msg = String.Format (CultureInfo.CurrentCulture' "Type cohesiveness : {0}%"' (int) (coh * 100));
Magic Number,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,GetCohesivenessForType,The following statement contains a magic number: double coh = Math.Round(1 - ((M - rm) / M)' 2);
Magic Number,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,IsSystemObjectMethod,The following statement contains a magic number: name.Length < 6 /*Equals*/ || name.Length > 16
Magic Number,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,IsSystemObjectMethod,The following statement contains a magic number: name.Length < 6 /*Equals*/ || name.Length > 16
Magic Number,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,IsSystemObjectMethod,The following statement contains a magic number: switch (name) {  			case "Finalize" :  			case "GetHashCode" :  			case "GetType" :  			case "MemberwiseClone" :  			case "ToString" :  				return !method.HasParameters;  			case "Equals" :  				IList<ParameterDefinition> pdc = method.Parameters;  				return (method.HasParameters && (pdc.Count == 1 || pdc.Count == 2));  			case "ReferenceEquals" :  				return (method.HasParameters && (method.Parameters.Count == 2));    			//HACK: BOO:  			case "EqualityOperator" :  				return (method.HasParameters && (method.Parameters.Count == 2) &&   					(method.DeclaringType.IsNamed ("Boo.Lang.Runtime"' "RuntimeServices")));  			}
Magic Number,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,IsSystemObjectMethod,The following statement contains a magic number: switch (name) {  			case "Finalize" :  			case "GetHashCode" :  			case "GetType" :  			case "MemberwiseClone" :  			case "ToString" :  				return !method.HasParameters;  			case "Equals" :  				IList<ParameterDefinition> pdc = method.Parameters;  				return (method.HasParameters && (pdc.Count == 1 || pdc.Count == 2));  			case "ReferenceEquals" :  				return (method.HasParameters && (method.Parameters.Count == 2));    			//HACK: BOO:  			case "EqualityOperator" :  				return (method.HasParameters && (method.Parameters.Count == 2) &&   					(method.DeclaringType.IsNamed ("Boo.Lang.Runtime"' "RuntimeServices")));  			}
Magic Number,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,IsSystemObjectMethod,The following statement contains a magic number: switch (name) {  			case "Finalize" :  			case "GetHashCode" :  			case "GetType" :  			case "MemberwiseClone" :  			case "ToString" :  				return !method.HasParameters;  			case "Equals" :  				IList<ParameterDefinition> pdc = method.Parameters;  				return (method.HasParameters && (pdc.Count == 1 || pdc.Count == 2));  			case "ReferenceEquals" :  				return (method.HasParameters && (method.Parameters.Count == 2));    			//HACK: BOO:  			case "EqualityOperator" :  				return (method.HasParameters && (method.Parameters.Count == 2) &&   					(method.DeclaringType.IsNamed ("Boo.Lang.Runtime"' "RuntimeServices")));  			}
Magic Number,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,CheckParametersSpecializationDelta,The following statement contains a magic number: Severity sev = (delta < 3) ? Severity.Medium : Severity.High;
Missing Default,Gendarme.Rules.Maintainability,AvoidAlwaysNullFieldRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidAlwaysNullFieldRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  					case Code.Stfld:  					case Code.Stsfld:  						field = ins.GetField ();  						// if non-resolved then it will not be a field of this type  						if (field == null)  							continue;  						// FIXME: we'd catch more cases (and avoid some false positives)   						// if we used a null value tracker.  						if (CheckForNullAssignment (ins)) {  							setFields.Add (field);  							Log.WriteLine (this' "{0} is set to null at {1:X4}"' field.Name' ins.Offset);  						} else {  							nullFields.Remove (field);	  							Log.WriteLine (this' "{0} is set at {1:X4}"' field.Name' ins.Offset);  						}  						break;    					case Code.Ldflda:	// if the field address is taken we have to assume the field has been set  					case Code.Ldsflda:  						field = ins.GetField ();  						// if non-resolved then it will not be a field of this type  						if (field == null)  							continue;  						nullFields.Remove (field);	  						Log.WriteLine (this' "{0} is set at {1:X4}"' field.Name' ins.Offset);  						break;    					case Code.Ldfld:  					case Code.Ldsfld:  						field = ins.GetField ();  						// if non-resolved then it will not be a field of this type  						if (field == null)  							continue;  						usedFields.Add (field);  						Log.WriteLine (this' "{0} is used at {1:X4}"' field.Name' ins.Offset);  						break;  					}
Missing Default,Gendarme.Rules.Maintainability,AvoidComplexMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidComplexMethodsRule.cs,GetFastCyclomaticComplexity,The following switch statement is missing a default case: switch (ins.OpCode.FlowControl) {  				case FlowControl.Branch:  					// detect ternary pattern  					Instruction previous = ins.Previous;  					if ((previous != null) && ld.Get (previous.OpCode.Code))  						cc++;  					break;  				case FlowControl.Cond_Branch:  					cc++;  					break;  				}
Missing Default,Gendarme.Rules.Maintainability,AvoidComplexMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidComplexMethodsRule.cs,GetSwitchCyclomaticComplexity,The following switch statement is missing a default case: switch (ins.OpCode.FlowControl) {  				case FlowControl.Branch:  					if (previous == null)  						continue;  					// detect ternary pattern  					previous = ins.Previous;  					if (ld.Get (previous.OpCode.Code))  						cc++;  					// or 'default' (xmcs)  					if (previous.OpCode.FlowControl == FlowControl.Cond_Branch) {  						branch = (previous.Operand as Instruction);  						// branch can be null (e.g. switch -> Instruction[])  						if ((branch != null) && targets.Contains (branch))  							targets.AddIfNew (ins);  					}  					break;  				case FlowControl.Cond_Branch:  					// note: a single switch (C#) with sparse values can be broken into several swicth (IL)  					// that will use the same 'targets' and must be counted only once  					if (ins.OpCode.Code == Code.Switch) {  						AccumulateSwitchTargets (ins);  					} else {  						// some conditional branch can be related to the sparse switch  						branch = (ins.Operand as Instruction);  						previous = branch.Previous;  						if ((previous != null) && !previous.Previous.Is (Code.Switch)) {  							if (!targets.Contains (branch))  								cc++;  						}  					}  					break;  				}
Missing Default,Gendarme.Rules.Maintainability,AvoidLackOfCohesionOfMethodsRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidLackOfCohesionOfMethodsRule.cs,GetCohesivenessForType,The following switch statement is missing a default case: switch (inst.OpCode.OperandType) {  					case OperandType.InlineField:  						FieldDefinition fd = inst.Operand as FieldDefinition;  						if (null == fd || !fd.IsPrivate || fd.IsStatic || fd.IsGeneratedCode ())  							continue; //does not make sense for LCOM calculation  						mr = fd;  						break;  					case OperandType.InlineMethod:  						// special case for automatic properties since the 'backing' fields won't be used  						MethodDefinition md = inst.Operand as MethodDefinition;  						if (md == null || md.IsPrivate || md.IsStatic || !md.IsProperty () || !md.IsGeneratedCode ())  							continue;  						mr = md.GetPropertyByAccessor ();  						break;  					}
Missing Default,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,IsSystemObjectMethod,The following switch statement is missing a default case: switch (name) {  			case "Finalize" :  			case "GetHashCode" :  			case "GetType" :  			case "MemberwiseClone" :  			case "ToString" :  				return !method.HasParameters;  			case "Equals" :  				IList<ParameterDefinition> pdc = method.Parameters;  				return (method.HasParameters && (pdc.Count == 1 || pdc.Count == 2));  			case "ReferenceEquals" :  				return (method.HasParameters && (method.Parameters.Count == 2));    			//HACK: BOO:  			case "EqualityOperator" :  				return (method.HasParameters && (method.Parameters.Count == 2) &&   					(method.DeclaringType.IsNamed ("Boo.Lang.Runtime"' "RuntimeServices")));  			}
Missing Default,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,GetSignatures,The following switch statement is missing a default case: switch (usage.Instruction.OpCode.Code) {  				case Code.Newobj:  				case Code.Call:  				case Code.Callvirt:  					MethodReference method = (MethodReference) usage.Instruction.Operand;  					if (IsSystemObjectMethod (method) || IsFromNonGenericCollectionNamespace (method.DeclaringType.Namespace))  						continue;  					signatures.Add (GetSignature (method));  					break;  				}
Missing Default,Gendarme.Rules.Maintainability,AvoidUnnecessarySpecializationRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\AvoidUnnecessarySpecializationRule.cs,UpdateParameterLeastType,The following switch statement is missing a default case: switch (usage.Instruction.OpCode.Code) {  				case Code.Newobj :  				case Code.Call :  				case Code.Callvirt :  					MethodReference method = (MethodReference) usage.Instruction.Operand;    					//potential generalization to object does not really make sense  					//from a readability/maintainability point of view  					if (IsSystemObjectMethod (method))  						continue;  					//we cannot really know if suggestion would work since the collection  					//is non-generic thus we ignore it  					TypeReference type = method.DeclaringType;  					if (IsFromNonGenericCollectionNamespace (type.Namespace))  						continue;    					int pcount = method.HasParameters ? method.Parameters.Count : 0;  					if (usage.StackOffset == pcount) {  						//argument is used as `this` in the call  						if (signatures == null)  							signatures = GetSignatures (usageResults);  						currentLeastType = GetBaseImplementor (GetActualType (type)' signatures);  					} else {  						//argument is also used as an argument in the call  						currentLeastType = method.Parameters [pcount - usage.StackOffset - 1].ParameterType;    						//if parameter type is a generic' find the 'real' constructed type  						GenericParameter gp = (currentLeastType as GenericParameter);  						if (gp != null)  							currentLeastType = GetConstructedGenericType (method' gp);  					}    					//if the best we could find is object or non-generic collection' ignore this round  					if (currentLeastType == null || IsIgnoredSuggestionType (currentLeastType))  						continue;    					needUpdate = true;  					break;    				case Code.Stfld :  				case Code.Stsfld :  					FieldReference field = (FieldReference) usage.Instruction.Operand;  					currentLeastType = field.FieldType;    					needUpdate = true;  					break;  				}
Missing Default,Gendarme.Rules.Maintainability,PreferStringIsNullOrEmptyRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\PreferStringIsNullOrEmptyRule.cs,PreLengthCheck,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  				case Code.Brfalse:  				case Code.Brfalse_S:  					if (name_length == GetName (method' ins.Previous))  						return (ins.Operand as Instruction);  					return null;  				}
Missing Default,Gendarme.Rules.Maintainability,RemoveDependenceOnObsoleteCodeRule,C:\research\architectureSmells\repos\mono_mono-tools\gendarme\rules\Gendarme.Rules.Maintainability\RemoveDependenceOnObsoleteCodeRule.cs,CheckMethod,The following switch statement is missing a default case: switch (ins.OpCode.Code) {  					case Code.Newarr:  					case Code.Newobj:  					case Code.Call:  					case Code.Callvirt:  						CheckMethodCall (method' ins' (ins.Operand as MethodReference));  						break;  					case Code.Initobj:  						CheckTypeCreation (method' ins' (ins.Operand as TypeReference));  						break;  					case Code.Ldfld:  					case Code.Ldflda:  					case Code.Ldsfld:  					case Code.Ldsflda:  					case Code.Stfld:  					case Code.Stsfld:  						CheckFieldAccess (method' ins' (ins.Operand as FieldReference));  						break;  					}
