Implementation smell,Namespace,Class,File,Method,Description
Long Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The method has 100 lines of code.
Long Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The method has 106 lines of code.
Long Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The method has 165 lines of code.
Complex Method,Pathfinding,AstarData,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphsPart,Cyclomatic complexity of the method is 13
Complex Method,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNodes,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeNodes,Cyclomatic complexity of the method is 15
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeSerializeNode,Cyclomatic complexity of the method is 12
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,Cyclomatic complexity of the method is 13
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,Cyclomatic complexity of the method is 16
Complex Method,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BaseInitialOpen,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BaseOpen,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,NodeColor,Cyclomatic complexity of the method is 15
Complex Method,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,OnDrawGizmos,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,Cyclomatic complexity of the method is 22
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,Scan,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,Cyclomatic complexity of the method is 12
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,Cyclomatic complexity of the method is 16
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnPostScan,Cyclomatic complexity of the method is 16
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,Cyclomatic complexity of the method is 17
Complex Method,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,RemoveGridGraph,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,ListGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\ListGenerator.cs,Scan,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,Cyclomatic complexity of the method is 22
Complex Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,Cyclomatic complexity of the method is 27
Complex Method,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,OnDrawGizmos,Cyclomatic complexity of the method is 9
Long Parameter List,Pathfinding,AstarSplines,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CatmullRom,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarSplines,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CatmullRomOLD,The method has 5 parameters.
Long Parameter List,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,DistancePointSegment,The method has 6 parameters.
Long Parameter List,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,DistancePointSegment2,The method has 6 parameters.
Long Parameter List,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The method has 5 parameters.
Long Parameter List,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,MapTo,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPointOptimized,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactor,The method has 6 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,InitialOpen,The method has 5 parameters.
Long Parameter List,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BaseInitialOpen,The method has 5 parameters.
Long Parameter List,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,BuildFunnelCorridor,The method has 5 parameters.
Long Parameter List,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,InitialOpen,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The method has 6 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The method has 5 parameters.
Long Parameter List,Pathfinding,MonoModifier,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Modifiers\Modifiers.cs,Apply,The method has 6 parameters.
Long Parameter List,System.Threading.Tasks,Parallel,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Utilities\Parallel.cs,For,The method has 5 parameters.
Long Parameter List,System.Threading.Tasks,Parallel,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Utilities\Parallel.cs,ForLoop,The method has 5 parameters.
Long Statement,Pathfinding,AstarData,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphs,The length of the statement  "	Debug.Log ("Deserialization complete - Process took " + ((endTime - startTime).Ticks * 0.0001F).ToString ("0.00") + " ms"); " is 123.
Long Statement,Pathfinding,AstarData,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphsPart,The length of the statement  "			//Search for existing graphs with the same GUID. If one is found' that means that we are loading another version of that graph " is 126.
Long Statement,Pathfinding,AstarData,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarData.cs,AddGraph,The length of the statement  "		Debug.LogError ("No NavGraph of type '" + type + "' could be found' " + graphTypes.Length + " graph types are avaliable"); " is 122.
Long Statement,Pathfinding,AstarData,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarData.cs,RemoveGraph,The length of the statement  "	//Safe OnDestroy is called since there is a risk that the pathfinding is searching through the graph right now' and if we don't wait until the search has completed we could end up with evil NullReferenceExceptions " is 213.
Long Statement,Pathfinding,AstarSplines,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CatmullRom,The length of the statement  "					tension*percentCompleteSquared);*/return previous * (-0.5F * percentCompleteCubed + percentCompleteSquared - 0.5F * percentComplete) + start * (1.5F * percentCompleteCubed + -2.5F * percentCompleteSquared + 1.0F) + end * (-1.5F * percentCompleteCubed + 2.0F * percentCompleteSquared + 0.5F * percentComplete) + next * (0.5F * percentCompleteCubed - 0.5F * percentCompleteSquared); " is 380.
Long Statement,Pathfinding,AstarSplines,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CatmullRomOLD,The length of the statement  "	return previous * (-0.5F * percentCompleteCubed + percentCompleteSquared - 0.5F * percentComplete) + start * (1.5F * percentCompleteCubed + -2.5F * percentCompleteSquared + 1.0F) + end * (-1.5F * percentCompleteCubed + 2.0F * percentCompleteSquared + 0.5F * percentComplete) + next * (0.5F * percentCompleteCubed - 0.5F * percentCompleteSquared); " is 346.
Long Statement,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The length of the statement  "	return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3; " is 120.
Long Statement,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "		if (((polyPoints [i].y <= p.y && p.y < polyPoints [j].y) || (polyPoints [j].y <= p.y && p.y < polyPoints [i].y)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.y - polyPoints [i].y) / (polyPoints [j].y - polyPoints [i].y) + polyPoints [i].x)) " is 248.
Long Statement,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The length of the statement  "	//Debug.Log ("U1 "+u.ToString ("0.00")+" U2 "+u2.ToString ("0.00")+"\nP1: "+(start1 + dir1*u)+"\nP2: "+(start2 + dir2*u2)+"\nStart1: "+start1+"  End1: "+end1); " is 159.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The length of the statement  "			Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version); " is 210.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The length of the statement  "			Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version); " is 188.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeNodes,The length of the statement  "					Debug.LogError ("Run Length Encoding is too long " + runLength + " " + endIndex + " " + graph.nodes.Length + " " + totalCount); " is 127.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeNodes,The length of the statement  "					Debug.LogError ("Run Length Encoding is too long " + runLength + " " + endIndex + " " + graph.nodes.Length + " " + totalCount); " is 127.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeSerializeSettings,The length of the statement  "		Debug.LogError ("The graph specified is not (de)serializable (how it could be serialized in the first place is a mystery) the graph was of type " + graph.GetType ()); " is 166.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The length of the statement  "	UnityReferenceHelper[] helpers = UnityEngine.Object.FindSceneObjectsOfType (typeof(UnityReferenceHelper)) as UnityReferenceHelper[]; " is 132.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The length of the statement  "		Debug.Log ("Couldn't find key '" + key + "' in the data' returning default (" + (defaultValue == null ? "null" : defaultValue.ToString ()) + ")"); " is 146.
Long Statement,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,LoadFromFile,The length of the statement  "	        	Debug.LogWarning ("Magic Numbers did not match - The file is probably corrupt\nThe magic numbers in the file were "+(char)b1+" and "+(char)b2+" ("+b1+"' "+b2+")");" is 163.
Long Statement,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The length of the statement  "		h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale); " is 146.
Long Statement,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BaseUpdateAllG,The length of the statement  "	//Loop through the connections of this node and call UpdateALlG on nodes which have this node set as #parent and has been searched by the pathfinder for this path */ " is 165.
Long Statement,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BaseOpen,The length of the statement  "			//(current.costs == null || current.costs.Length == 0 ? costs[current.neighboursKeys[i]] : current.costs[current.neighboursKeys[i]]); " is 133.
Long Statement,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BaseOpen,The length of the statement  "				//Make sure we don't travel along the wrong direction of a one way link now' make sure the Current node can be moved to from the other Node. " is 140.
Long Statement,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Add,The length of the statement  "		Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size (" + numberOfItems + " " + binaryHeap.Length + ")"); " is 159.
Long Statement,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Add,The length of the statement  "			//binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /** \todo Wouldn't it be more efficient with '<' instead of '<=' ? * / " is 130.
Long Statement,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Add,The length of the statement  "			/*if (binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /** \todo Wouldn't it be more efficient with '<' instead of '<=' ? *" is 132.
Long Statement,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BubbleDown,The length of the statement  "		/* Can be optimized to use 'node' instead of 'binaryHeap[bubbleIndex]' */if (binaryHeap [bubbleIndex].f <= binaryHeap [parentIndex].f) { " is 136.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,GetNearest,The length of the statement  "	//Debug.LogError ("This function (GetNearest) is not implemented in the navigation graph generator : Type "+this.GetType ().Name); " is 130.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,GetNearestForce,The length of the statement  "	Debug.LogError ("This should not be called if not GetNearest has been overriden' and if GetNearest has been overriden' you should override this function too' always return a node which returns true when passed to constraint.Suitable (node)"); " is 242.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "		c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.g / (float)AstarPath.active.debugRoof); " is 128.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "		c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.h / (float)AstarPath.active.debugRoof); " is 128.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "		c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.f / (float)AstarPath.active.debugRoof); " is 128.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "		c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.penalty / (float)AstarPath.active.debugRoof); " is 134.
Long Statement,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,OnDrawGizmos,The length of the statement  "			if (AstarPath.active.debugPath != null && AstarPath.active.showSearchTree && (node.pathID != AstarPath.active.debugPath.pathID || Node.activePath == null)) { " is 157.
Long Statement,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnDestroy,The length of the statement  "	//Clean up a reference in a static variable which otherwise should point to this graph forever and stop the GC from collecting it " is 129.
Long Statement,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GenerateMatrix,The length of the statement  "	matrix.SetTRS (boundsMatrix.MultiplyPoint3x4 (-new Vector3 (size.x' 0' size.y) * 0.5F)' Quaternion.Euler (rotation)' new Vector3 (nodeSize * aspectRatio' 1' nodeSize)); " is 168.
Long Statement,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The length of the statement  "				//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too " is 130.
Long Statement,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,SerializeNodes,The length of the statement  "	/** \todo Add check for mask == Save Node Positions. Can't use normal mask since it is changed by SerializeSettings */GenerateMatrix (); " is 136.
Long Statement,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,DeSerializeNodes,The length of the statement  "			//Needs to multiply with precision factor because the position will be scaled by Int3.Precision later (Vector3 --> Int3 conversion) " is 131.
Long Statement,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,Open,The length of the statement  "				//(current.costs == null || current.costs.Length == 0 ? costs[current.neighboursKeys[i]] : current.costs[current.neighboursKeys[i]]); " is 133.
Long Statement,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,Open,The length of the statement  "							//[Edit' no one-way links between nodes in a single grid] Make sure we don't travel along the wrong direction of a one way link now' make sure the Current node can be accesed from the Node." is 189.
Long Statement,Pathfinding,ListGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\ListGenerator.cs,IsValidConnection,The length of the statement  "	if ((!Mathf.Approximately (limits.x' 0) && Mathf.Abs (dir.x) > limits.x) || (!Mathf.Approximately (limits.y' 0) && Mathf.Abs (dir.y) > limits.y) || (!Mathf.Approximately (limits.z' 0) && Mathf.Abs (dir.z) > limits.z)) { " is 219.
Long Statement,Pathfinding,ListGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\ListGenerator.cs,IsValidConnection,The length of the statement  "				if (!Physics.SphereCast (ray' thickRaycastRadius' dist' mask) && !Physics.SphereCast (invertRay' thickRaycastRadius' dist' mask)) { " is 131.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RelocateNodes,The length of the statement  "	if (vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length) { " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The length of the statement  "		if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' pos) || !Polygon.IsClockwise (vertices [node.v2]' vertices [node.v3]' pos) || !Polygon.IsClockwise (vertices [node.v3]' vertices [node.v1]' pos)) { " is 213.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The length of the statement  "			//Polygon.TriangleArea2 (vertices[node.v1]'vertices[node.v2]'pos) >= 0 || Polygon.TriangleArea2 (vertices[node.v2]'vertices[node.v3]'pos) >= 0 || Polygon.TriangleArea2 (vertices[node.v3]'vertices[node.v1]'pos) >= 0) { " is 217.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The length of the statement  "					}*//*float dist2 = Mathfx.DistancePointSegment2 (pos.x'pos.z'vertices[node.v1].x'vertices[node.v1].z'vertices[node.v2].x'vertices[node.v2].z);" is 142.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The length of the statement  "					dist2 = Mathfx.Min (dist2'Mathfx.DistancePointSegment2 (pos.x'pos.z'vertices[node.v1].x'vertices[node.v1].z'vertices[node.v3].x'vertices[node.v3].z));" is 150.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The length of the statement  "					dist2 = Mathfx.Min (dist2'Mathfx.DistancePointSegment2 (pos.x'pos.z'vertices[node.v3].x'vertices[node.v3].z'vertices[node.v2].x'vertices[node.v2].z));*/float dist2 = (node.position - pos).sqrMagnitude; " is 201.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The length of the statement  "	NNInfo nninfo = new NNInfo (minNode == null ? minNode2 : minNode' minNode == null ? NearestNodePriority.Low : NearestNodePriority.High); " is 136.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The length of the statement  "		Debug.LogError ("Couldn't cast graph to the appropriate type (graph isn't a Navmesh type graph' it doesn't implement the INavmesh interface)"); " is 143.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (Polygon.IsClockwise ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos) && Polygon.IsClockwise ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v3]' pos) && Polygon.IsClockwise ((Vector3)vertices [node.v3]' (Vector3)vertices [node.v1]' pos)) { " is 264.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (Polygon.IsClockwiseMargin ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos) && Polygon.IsClockwiseMargin ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v3]' pos) && Polygon.IsClockwiseMargin ((Vector3)vertices [node.v3]' (Vector3)vertices [node.v1]' pos)) { " is 282.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "			}*///Debug.Log ("NavMesh - Old vertice count "+vertices.Length+"' new vertice count "+c+" "+maxX+" "+maxZ+" "+maxX*maxZ); " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "		node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F; " is 122.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "		Debug.LogError ("One or more triangles are identical to other triangles' this is not a good thing to have in a navmesh\nIncreasing the scale of the mesh might help\nNumber of triangles with error: " + identicalError + "\n"); " is 224.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "	//Debug.Log ("Graph Generation - NavMesh - Time to compute graph "+((Time.realtimeSinceStartup-startTime)*1000F).ToString ("0")+"ms"); " is 134.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RebuildBBTree,The length of the statement  "	//BBTrees is a A* Pathfinding Project Pro only feature - The Pro version can be bought on the Unity Asset Store or on arongranberg.com " is 134.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,Sort,The length of the statement  "			if (a [i].x > a [i + 1].x || (a [i].x == a [i + 1].x && (a [i].y > a [i + 1].y || (a [i].y == a [i + 1].y && a [i].z > a [i + 1].z)))) { " is 136.
Long Statement,Pathfinding,ModifierConverter,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Modifiers\Modifiers.cs,Convert,The length of the statement  "		return ModifierData.VectorPath | (AnyBits (input' ModifierData.StrictNodePath) ? ModifierData.StrictVectorPath : ModifierData.None); " is 132.
Long Statement,Pathfinding,ModifierConverter,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Modifiers\Modifiers.cs,Convert,The length of the statement  "	Debug.LogError ("This part should not be reached - Error in ModifierConverted\nInput: " + input + " (" + (int)input + ")\nOutput: " + output + " (" + (int)output + ")"); " is 169.
Long Statement,Pathfinding,ConstantPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\ConstantPath.cs,Initialize,The length of the statement  "			//Resets the binary heap' don't clear it because that takes an awful lot of time' instead we can just change the numberOfItems in it (which is just an int)" is 155.
Long Statement,Pathfinding,ConstantPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\ConstantPath.cs,Initialize,The length of the statement  "			//Binary heaps are just like a standard array but are always sorted so the node with the lowest F value can be retrieved faster" is 127.
Long Statement,Pathfinding,ConstantPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\ConstantPath.cs,Initialize,The length of the statement  "			//callback += ResetCosts; /* \todo Might interfere with other paths since other paths might be calculated before #callback is called *" is 134.
Long Statement,Pathfinding,ConstantPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\ConstantPath.cs,CalculateStep,The length of the statement  "			//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag " is 131.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Prepare,The length of the statement  "	//Tell the NNConstraint which node was found as the start node if it is a PathNNConstraint and not a normal NNConstraint " is 120.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Prepare,The length of the statement  "		LogError ("Couldn't find close nodes to either the start or the end (start = " + (startNode != null) + " end = " + (endNode != null) + ")"); " is 140.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Prepare,The length of the statement  "		LogError ("There is no valid path to the target (start area: " + startNode.area + "' target area: " + endNode.area + ")"); " is 122.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Initialize,The length of the statement  "	//Resets the binary heap' don't clear it because that takes an awful lot of time' instead we can just change the numberOfItems in it (which is just an int) " is 155.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Initialize,The length of the statement  "	//Binary heaps are just like a standard array but are always sorted so the node with the lowest F value can be retrieved faster " is 127.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,CalculateStep,The length of the statement  "			//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag " is 131.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,CalculateStep,The length of the statement  "	//Return instead of yielding' a separate function handles the yield (CalculatePaths or CalculatePathsThreaded in AstarPath.cs) " is 126.
Long Statement,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,DebugString,The length of the statement  "				+"\nStart Point = "+p.startPoint+"\n"+"Start Node graph: "+p.startNode.graphIndex+" End Node graph: "+p.endNode.graphIndex+" is 123.
Long Statement,Pathfinding,XPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\XPath.cs,CalculateStep,The length of the statement  "			//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag " is 131.
Complex Conditional,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The conditional expression  "((polyPoints [i].y <= p.y && p.y < polyPoints [j].y) || (polyPoints [j].y <= p.y && p.y < polyPoints [i].y)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.y - polyPoints [i].y) / (polyPoints [j].y - polyPoints [i].y) + polyPoints [i].x)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Intersects,The conditional expression  "u < 0F || u > 1F || u2 < 0F || u2 > 1F"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The conditional expression  "u < 0F || u > 1F || u2 < 0F || u2 > 1F"  is complex.
Complex Conditional,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,OnDrawGizmos,The conditional expression  "AstarPath.active.debugPath != null && AstarPath.active.showSearchTree && (node.pathID != AstarPath.active.debugPath.pathID || Node.activePath == null)"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The conditional expression  "x < 0 || z < 0 || x >= width || z >= depth"  is complex.
Complex Conditional,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateGridConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= graph.width || nz >= graph.depth"  is complex.
Complex Conditional,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,RemoveConnection,The conditional expression  "nx < 0 || nz < 0 || nx >= graph.width || nz >= graph.depth"  is complex.
Complex Conditional,Pathfinding,ListGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\ListGenerator.cs,IsValidConnection,The conditional expression  "(!Mathf.Approximately (limits.x' 0) && Mathf.Abs (dir.x) > limits.x) || (!Mathf.Approximately (limits.y' 0) && Mathf.Abs (dir.y) > limits.y) || (!Mathf.Approximately (limits.z' 0) && Mathf.Abs (dir.z) > limits.z)"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RelocateNodes,The conditional expression  "vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The conditional expression  "allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,Sort,The conditional expression  "a [i].x > a [i + 1].x || (a [i].x == a [i + 1].x && (a [i].y > a [i + 1].y || (a [i].y == a [i + 1].y && a [i].z > a [i + 1].z)))"  is complex.
Virtual Method Call from Constructor,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Path,The constructor "Path" calls a virtual method "Reset".
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,LoadIdentity,The following statement contains a magic number: m = new float[16];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,LoadIdentity,The following statement contains a magic number: for (int x = 0; x < 16; ++x) {  	m [x] = 0;  }  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,LoadIdentity,The following statement contains a magic number: m [5] = 1;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,LoadIdentity,The following statement contains a magic number: m [10] = 1;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,LoadIdentity,The following statement contains a magic number: m [15] = 1;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Translate,The following statement contains a magic number: wk.m [12] = _X;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Translate,The following statement contains a magic number: wk.m [13] = _Y;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Translate,The following statement contains a magic number: wk.m [14] = _Z;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,translate,The following statement contains a magic number: m [12] = _X;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,translate,The following statement contains a magic number: m [13] = _Y;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,translate,The following statement contains a magic number: m [14] = _Z;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateX,The following statement contains a magic number: wk.m [5] = C;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateX,The following statement contains a magic number: wk.m [6] = S;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateX,The following statement contains a magic number: wk.m [9] = -S;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateX,The following statement contains a magic number: wk.m [10] = C;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateY,The following statement contains a magic number: wk.m [2] = -S;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateY,The following statement contains a magic number: wk.m [8] = S;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateY,The following statement contains a magic number: wk.m [10] = C;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateZ,The following statement contains a magic number: wk.m [4] = -S;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,RotateZ,The following statement contains a magic number: wk.m [5] = C;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Scale,The following statement contains a magic number: wk.m [5] = _Y;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Scale,The following statement contains a magic number: wk.m [10] = _Z;  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.x = (_V.x * m [0]) + (_V.y * m [4]) + (_V.z * m [8]) + m [12];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.x = (_V.x * m [0]) + (_V.y * m [4]) + (_V.z * m [8]) + m [12];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.x = (_V.x * m [0]) + (_V.y * m [4]) + (_V.z * m [8]) + m [12];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.y = (_V.x * m [1]) + (_V.y * m [5]) + (_V.z * m [9]) + m [13];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.y = (_V.x * m [1]) + (_V.y * m [5]) + (_V.z * m [9]) + m [13];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.y = (_V.x * m [1]) + (_V.y * m [5]) + (_V.z * m [9]) + m [13];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.z = (_V.x * m [2]) + (_V.y * m [6]) + (_V.z * m [10]) + m [14];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.z = (_V.x * m [2]) + (_V.y * m [6]) + (_V.z * m [10]) + m [14];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.z = (_V.x * m [2]) + (_V.y * m [6]) + (_V.z * m [10]) + m [14];  
Magic Number,Pathfinding,Matrix,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,TransformVector,The following statement contains a magic number: vtx.z = (_V.x * m [2]) + (_V.y * m [6]) + (_V.z * m [10]) + m [14];  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ComputeVertexHash,The following statement contains a magic number: return (int)(n & ((1 << 30) - 1));  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3;  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3;  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3;  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3;  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3;  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return Mathf.Pow (t2' 3) * p0 + 3 * Mathf.Pow (t2' 2) * t * p1 + 3 * t2 * Mathf.Pow (t' 2) * p2 + Mathf.Pow (t' 3) * p3;  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Mathfx,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1000000000) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,Subdivide,The following statement contains a magic number: for (int p = 0; p < path.Length - 1; p++) {  	float step = 1.0F / Mathf.Pow (2' subdivisions);  	for (float i = 0; i < 1.0F; i += step) {  		path2 [c] = Vector3.Lerp (path [p]' path [p + 1]' Mathf.SmoothStep (0' 1' i));  		c++;  	}  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: return ClosesPointOnTriangle (triangle [0]' triangle [1]' triangle [2]' point);  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (s + t < det) {  	if (s < 0.0F) {  		if (t < 0.0F) {  			if (d < 0.0F) {  				s = Mathfx.Clamp01 (-d / a);  				t = 0.0F;  			}  			else {  				s = 0.0F;  				t = Mathfx.Clamp01 (-e / c);  			}  		}  		else {  			s = 0.0F;  			t = Mathfx.Clamp01 (-e / c);  		}  	}  	else if (t < 0.0F) {  		s = Mathfx.Clamp01 (-d / a);  		t = 0.0F;  	}  	else {  		float invDet = 1.0F / det;  		s *= invDet;  		t *= invDet;  	}  }  else {  	if (s < 0.0F) {  		float tmp0 = b + d;  		float tmp1 = c + e;  		if (tmp1 > tmp0) {  			float numer = tmp1 - tmp0;  			float denom = a - 2 * b + c;  			s = Mathfx.Clamp01 (numer / denom);  			t = 1 - s;  		}  		else {  			t = Mathfx.Clamp01 (-e / c);  			s = 0.0F;  		}  	}  	else if (t < 0.0F) {  		if (a + d > b + e) {  			float numer = c + e - b - d;  			float denom = a - 2 * b + c;  			s = Mathfx.Clamp01 (numer / denom);  			t = 1 - s;  		}  		else {  			s = Mathfx.Clamp01 (-e / c);  			t = 0.0F;  		}  	}  	else {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1.0F - s;  	}  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (s + t < det) {  	if (s < 0.0F) {  		if (t < 0.0F) {  			if (d < 0.0F) {  				s = Mathfx.Clamp01 (-d / a);  				t = 0.0F;  			}  			else {  				s = 0.0F;  				t = Mathfx.Clamp01 (-e / c);  			}  		}  		else {  			s = 0.0F;  			t = Mathfx.Clamp01 (-e / c);  		}  	}  	else if (t < 0.0F) {  		s = Mathfx.Clamp01 (-d / a);  		t = 0.0F;  	}  	else {  		float invDet = 1.0F / det;  		s *= invDet;  		t *= invDet;  	}  }  else {  	if (s < 0.0F) {  		float tmp0 = b + d;  		float tmp1 = c + e;  		if (tmp1 > tmp0) {  			float numer = tmp1 - tmp0;  			float denom = a - 2 * b + c;  			s = Mathfx.Clamp01 (numer / denom);  			t = 1 - s;  		}  		else {  			t = Mathfx.Clamp01 (-e / c);  			s = 0.0F;  		}  	}  	else if (t < 0.0F) {  		if (a + d > b + e) {  			float numer = c + e - b - d;  			float denom = a - 2 * b + c;  			s = Mathfx.Clamp01 (numer / denom);  			t = 1 - s;  		}  		else {  			s = Mathfx.Clamp01 (-e / c);  			t = 0.0F;  		}  	}  	else {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1.0F - s;  	}  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (s + t < det) {  	if (s < 0.0F) {  		if (t < 0.0F) {  			if (d < 0.0F) {  				s = Mathfx.Clamp01 (-d / a);  				t = 0.0F;  			}  			else {  				s = 0.0F;  				t = Mathfx.Clamp01 (-e / c);  			}  		}  		else {  			s = 0.0F;  			t = Mathfx.Clamp01 (-e / c);  		}  	}  	else if (t < 0.0F) {  		s = Mathfx.Clamp01 (-d / a);  		t = 0.0F;  	}  	else {  		float invDet = 1.0F / det;  		s *= invDet;  		t *= invDet;  	}  }  else {  	if (s < 0.0F) {  		float tmp0 = b + d;  		float tmp1 = c + e;  		if (tmp1 > tmp0) {  			float numer = tmp1 - tmp0;  			float denom = a - 2 * b + c;  			s = Mathfx.Clamp01 (numer / denom);  			t = 1 - s;  		}  		else {  			t = Mathfx.Clamp01 (-e / c);  			s = 0.0F;  		}  	}  	else if (t < 0.0F) {  		if (a + d > b + e) {  			float numer = c + e - b - d;  			float denom = a - 2 * b + c;  			s = Mathfx.Clamp01 (numer / denom);  			t = 1 - s;  		}  		else {  			s = Mathfx.Clamp01 (-e / c);  			t = 0.0F;  		}  	}  	else {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1.0F - s;  	}  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (s < 0.0F) {  	float tmp0 = b + d;  	float tmp1 = c + e;  	if (tmp1 > tmp0) {  		float numer = tmp1 - tmp0;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		t = Mathfx.Clamp01 (-e / c);  		s = 0.0F;  	}  }  else if (t < 0.0F) {  	if (a + d > b + e) {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		s = Mathfx.Clamp01 (-e / c);  		t = 0.0F;  	}  }  else {  	float numer = c + e - b - d;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1.0F - s;  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (s < 0.0F) {  	float tmp0 = b + d;  	float tmp1 = c + e;  	if (tmp1 > tmp0) {  		float numer = tmp1 - tmp0;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		t = Mathfx.Clamp01 (-e / c);  		s = 0.0F;  	}  }  else if (t < 0.0F) {  	if (a + d > b + e) {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		s = Mathfx.Clamp01 (-e / c);  		t = 0.0F;  	}  }  else {  	float numer = c + e - b - d;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1.0F - s;  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (s < 0.0F) {  	float tmp0 = b + d;  	float tmp1 = c + e;  	if (tmp1 > tmp0) {  		float numer = tmp1 - tmp0;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		t = Mathfx.Clamp01 (-e / c);  		s = 0.0F;  	}  }  else if (t < 0.0F) {  	if (a + d > b + e) {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		s = Mathfx.Clamp01 (-e / c);  		t = 0.0F;  	}  }  else {  	float numer = c + e - b - d;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1.0F - s;  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (tmp1 > tmp0) {  	float numer = tmp1 - tmp0;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1 - s;  }  else {  	t = Mathfx.Clamp01 (-e / c);  	s = 0.0F;  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (t < 0.0F) {  	if (a + d > b + e) {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		s = Mathfx.Clamp01 (-e / c);  		t = 0.0F;  	}  }  else {  	float numer = c + e - b - d;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1.0F - s;  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (t < 0.0F) {  	if (a + d > b + e) {  		float numer = c + e - b - d;  		float denom = a - 2 * b + c;  		s = Mathfx.Clamp01 (numer / denom);  		t = 1 - s;  	}  	else {  		s = Mathfx.Clamp01 (-e / c);  		t = 0.0F;  	}  }  else {  	float numer = c + e - b - d;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1.0F - s;  }  
Magic Number,Pathfinding,Polygon,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarMath.cs,ClosesPointOnTriangle,The following statement contains a magic number: if (a + d > b + e) {  	float numer = c + e - b - d;  	float denom = a - 2 * b + c;  	s = Mathfx.Clamp01 (numer / denom);  	t = 1 - s;  }  else {  	s = Mathfx.Clamp01 (-e / c);  	t = 0.0F;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version == AstarPath.Version) {  	return new AstarSerializer (script);  }  else if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version == AstarPath.Version) {  	return new AstarSerializer (script);  }  else if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version == AstarPath.Version) {  	return new AstarSerializer (script);  }  else if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version == AstarPath.Version) {  	return new AstarSerializer (script);  }  else if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version == AstarPath.Version) {  	return new AstarSerializer (script);  }  else if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version == AstarPath.Version) {  	return new AstarSerializer (script);  }  else if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version > AstarPath.Version) {  	//Higher version' trying to load  	return new AstarSerializer (script);  }  else {  	//Load older version  	if (version >= new Version (3' 0' 7)) {  		return new AstarSerializer3_07 (script);  	}  	else if (version >= new Version (3' 0' 5)) {  		return new AstarSerializer3_05 (script);  	}  	else if (version >= new Version (3' 0' 4)) {  		return new AstarSerializer3_04 (script);  	}  	else {  		return new AstarSerializer3_01 (script);  	}  	/*if (version > new Version (3'0'1)) { 					return new AstarSerializer3_04 (script); 				} else { 					return new AstarSerializer3_01 (script); 				}*/}  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 7)) {  	return new AstarSerializer3_07 (script);  }  else if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 7)) {  	return new AstarSerializer3_07 (script);  }  else if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 7)) {  	return new AstarSerializer3_07 (script);  }  else if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 7)) {  	return new AstarSerializer3_07 (script);  }  else if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 7)) {  	return new AstarSerializer3_07 (script);  }  else if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 7)) {  	return new AstarSerializer3_07 (script);  }  else if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 5)) {  	return new AstarSerializer3_05 (script);  }  else if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetDeserializer,The following statement contains a magic number: if (version >= new Version (3' 0' 4)) {  	return new AstarSerializer3_04 (script);  }  else {  	return new AstarSerializer3_01 (script);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (!IgnoreVersionDifferences) {  	if (astarVersion > AstarPath.Version) {  		Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//error = SerializerError.WrongVersion;  		//return;  	}  	else if (astarVersion != AstarPath.Version) {  		Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//Select the appropriate deserializer  		if (astarVersion < new Version (3' 0' 4)) {  			returnSerializer = new AstarSerializer3_01 (active);  		}  		else if (astarVersion < new Version (3' 0' 5)) {  			returnSerializer = new AstarSerializer3_04 (active);  		}  		else if (astarVersion < new Version (3' 0' 6)) {  			returnSerializer = new AstarSerializer3_05 (active);  		}  		//Copy this serializer's loaded values to the new serializer  		returnSerializer.readerStream = readerStream;  		returnSerializer.anchors = anchors;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (!IgnoreVersionDifferences) {  	if (astarVersion > AstarPath.Version) {  		Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//error = SerializerError.WrongVersion;  		//return;  	}  	else if (astarVersion != AstarPath.Version) {  		Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//Select the appropriate deserializer  		if (astarVersion < new Version (3' 0' 4)) {  			returnSerializer = new AstarSerializer3_01 (active);  		}  		else if (astarVersion < new Version (3' 0' 5)) {  			returnSerializer = new AstarSerializer3_04 (active);  		}  		else if (astarVersion < new Version (3' 0' 6)) {  			returnSerializer = new AstarSerializer3_05 (active);  		}  		//Copy this serializer's loaded values to the new serializer  		returnSerializer.readerStream = readerStream;  		returnSerializer.anchors = anchors;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (!IgnoreVersionDifferences) {  	if (astarVersion > AstarPath.Version) {  		Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//error = SerializerError.WrongVersion;  		//return;  	}  	else if (astarVersion != AstarPath.Version) {  		Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//Select the appropriate deserializer  		if (astarVersion < new Version (3' 0' 4)) {  			returnSerializer = new AstarSerializer3_01 (active);  		}  		else if (astarVersion < new Version (3' 0' 5)) {  			returnSerializer = new AstarSerializer3_04 (active);  		}  		else if (astarVersion < new Version (3' 0' 6)) {  			returnSerializer = new AstarSerializer3_05 (active);  		}  		//Copy this serializer's loaded values to the new serializer  		returnSerializer.readerStream = readerStream;  		returnSerializer.anchors = anchors;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (!IgnoreVersionDifferences) {  	if (astarVersion > AstarPath.Version) {  		Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//error = SerializerError.WrongVersion;  		//return;  	}  	else if (astarVersion != AstarPath.Version) {  		Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//Select the appropriate deserializer  		if (astarVersion < new Version (3' 0' 4)) {  			returnSerializer = new AstarSerializer3_01 (active);  		}  		else if (astarVersion < new Version (3' 0' 5)) {  			returnSerializer = new AstarSerializer3_04 (active);  		}  		else if (astarVersion < new Version (3' 0' 6)) {  			returnSerializer = new AstarSerializer3_05 (active);  		}  		//Copy this serializer's loaded values to the new serializer  		returnSerializer.readerStream = readerStream;  		returnSerializer.anchors = anchors;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (!IgnoreVersionDifferences) {  	if (astarVersion > AstarPath.Version) {  		Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//error = SerializerError.WrongVersion;  		//return;  	}  	else if (astarVersion != AstarPath.Version) {  		Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//Select the appropriate deserializer  		if (astarVersion < new Version (3' 0' 4)) {  			returnSerializer = new AstarSerializer3_01 (active);  		}  		else if (astarVersion < new Version (3' 0' 5)) {  			returnSerializer = new AstarSerializer3_04 (active);  		}  		else if (astarVersion < new Version (3' 0' 6)) {  			returnSerializer = new AstarSerializer3_05 (active);  		}  		//Copy this serializer's loaded values to the new serializer  		returnSerializer.readerStream = readerStream;  		returnSerializer.anchors = anchors;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (!IgnoreVersionDifferences) {  	if (astarVersion > AstarPath.Version) {  		Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//error = SerializerError.WrongVersion;  		//return;  	}  	else if (astarVersion != AstarPath.Version) {  		Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  		//Select the appropriate deserializer  		if (astarVersion < new Version (3' 0' 4)) {  			returnSerializer = new AstarSerializer3_01 (active);  		}  		else if (astarVersion < new Version (3' 0' 5)) {  			returnSerializer = new AstarSerializer3_04 (active);  		}  		else if (astarVersion < new Version (3' 0' 6)) {  			returnSerializer = new AstarSerializer3_05 (active);  		}  		//Copy this serializer's loaded values to the new serializer  		returnSerializer.readerStream = readerStream;  		returnSerializer.anchors = anchors;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion > AstarPath.Version) {  	Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//error = SerializerError.WrongVersion;  	//return;  }  else if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion > AstarPath.Version) {  	Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//error = SerializerError.WrongVersion;  	//return;  }  else if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion > AstarPath.Version) {  	Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//error = SerializerError.WrongVersion;  	//return;  }  else if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion > AstarPath.Version) {  	Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//error = SerializerError.WrongVersion;  	//return;  }  else if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion > AstarPath.Version) {  	Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//error = SerializerError.WrongVersion;  	//return;  }  else if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion > AstarPath.Version) {  	Debug.LogError ("Loading graph saved with a newer version of the A* Pathfinding Project' trying to load' but you might get errors.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//error = SerializerError.WrongVersion;  	//return;  }  else if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion != AstarPath.Version) {  	Debug.LogWarning ("Loading graphs saved with an older version of the A* Pathfinding Project' trying to load.\nFile version: " + astarVersion + " Current A* version: " + AstarPath.Version);  	//Select the appropriate deserializer  	if (astarVersion < new Version (3' 0' 4)) {  		returnSerializer = new AstarSerializer3_01 (active);  	}  	else if (astarVersion < new Version (3' 0' 5)) {  		returnSerializer = new AstarSerializer3_04 (active);  	}  	else if (astarVersion < new Version (3' 0' 6)) {  		returnSerializer = new AstarSerializer3_05 (active);  	}  	//Copy this serializer's loaded values to the new serializer  	returnSerializer.readerStream = readerStream;  	returnSerializer.anchors = anchors;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 4)) {  	returnSerializer = new AstarSerializer3_01 (active);  }  else if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 4)) {  	returnSerializer = new AstarSerializer3_01 (active);  }  else if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 4)) {  	returnSerializer = new AstarSerializer3_01 (active);  }  else if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 4)) {  	returnSerializer = new AstarSerializer3_01 (active);  }  else if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 4)) {  	returnSerializer = new AstarSerializer3_01 (active);  }  else if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 4)) {  	returnSerializer = new AstarSerializer3_01 (active);  }  else if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 5)) {  	returnSerializer = new AstarSerializer3_04 (active);  }  else if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeserializeSerializationInfo,The following statement contains a magic number: if (astarVersion < new Version (3' 0' 6)) {  	returnSerializer = new AstarSerializer3_05 (active);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: if (mask == SMask.SaveNodeConnections) {  	if (node.connections != null) {  		if (node.connections.Length >= 256) {  			Debug.LogError ("Node connections over 256 (one byte)' can't serialize");  			WriteError ();  			return;  		}  		stream.Write ((byte)node.connections.Length);  		for (int i = 0; i < node.connections.Length; i++) {  			//The index value for each node is stored in the G variable (a bit dirty' but it saves memory)  			//H value = Graph index  			//G value = Node index in graph  			//Graph index as in' which graph  			int graphIndex = node.connections [i].h;  			int nodeIndex = node.connections [i].g;  			//Pack two numbers into a single 32 bit integer  			stream.Write ((nodeIndex & 0x3FFFFFF) | ((graphIndex & 0x3F) << 26));  			if (mask == SMask.SaveNodeConnectionCosts) {  				stream.Write (node.connectionCosts [i]);  			}  			//If the connection node is placed in a different graph  			if (graphIndex != node.h) {  				Node other = node.connections [i];  				bool containsLink = false;  				for (int q = 0; q < other.connections.Length; q++) {  					if (other.connections [q] == node) {  						containsLink = true;  						break;  					}  				}  				stream.Write (containsLink ? true : false);  			}  		}  	}  	else {  		stream.Write ((byte)0);  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: if (mask == SMask.SaveNodeConnections) {  	if (node.connections != null) {  		if (node.connections.Length >= 256) {  			Debug.LogError ("Node connections over 256 (one byte)' can't serialize");  			WriteError ();  			return;  		}  		stream.Write ((byte)node.connections.Length);  		for (int i = 0; i < node.connections.Length; i++) {  			//The index value for each node is stored in the G variable (a bit dirty' but it saves memory)  			//H value = Graph index  			//G value = Node index in graph  			//Graph index as in' which graph  			int graphIndex = node.connections [i].h;  			int nodeIndex = node.connections [i].g;  			//Pack two numbers into a single 32 bit integer  			stream.Write ((nodeIndex & 0x3FFFFFF) | ((graphIndex & 0x3F) << 26));  			if (mask == SMask.SaveNodeConnectionCosts) {  				stream.Write (node.connectionCosts [i]);  			}  			//If the connection node is placed in a different graph  			if (graphIndex != node.h) {  				Node other = node.connections [i];  				bool containsLink = false;  				for (int q = 0; q < other.connections.Length; q++) {  					if (other.connections [q] == node) {  						containsLink = true;  						break;  					}  				}  				stream.Write (containsLink ? true : false);  			}  		}  	}  	else {  		stream.Write ((byte)0);  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: if (node.connections != null) {  	if (node.connections.Length >= 256) {  		Debug.LogError ("Node connections over 256 (one byte)' can't serialize");  		WriteError ();  		return;  	}  	stream.Write ((byte)node.connections.Length);  	for (int i = 0; i < node.connections.Length; i++) {  		//The index value for each node is stored in the G variable (a bit dirty' but it saves memory)  		//H value = Graph index  		//G value = Node index in graph  		//Graph index as in' which graph  		int graphIndex = node.connections [i].h;  		int nodeIndex = node.connections [i].g;  		//Pack two numbers into a single 32 bit integer  		stream.Write ((nodeIndex & 0x3FFFFFF) | ((graphIndex & 0x3F) << 26));  		if (mask == SMask.SaveNodeConnectionCosts) {  			stream.Write (node.connectionCosts [i]);  		}  		//If the connection node is placed in a different graph  		if (graphIndex != node.h) {  			Node other = node.connections [i];  			bool containsLink = false;  			for (int q = 0; q < other.connections.Length; q++) {  				if (other.connections [q] == node) {  					containsLink = true;  					break;  				}  			}  			stream.Write (containsLink ? true : false);  		}  	}  }  else {  	stream.Write ((byte)0);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: if (node.connections != null) {  	if (node.connections.Length >= 256) {  		Debug.LogError ("Node connections over 256 (one byte)' can't serialize");  		WriteError ();  		return;  	}  	stream.Write ((byte)node.connections.Length);  	for (int i = 0; i < node.connections.Length; i++) {  		//The index value for each node is stored in the G variable (a bit dirty' but it saves memory)  		//H value = Graph index  		//G value = Node index in graph  		//Graph index as in' which graph  		int graphIndex = node.connections [i].h;  		int nodeIndex = node.connections [i].g;  		//Pack two numbers into a single 32 bit integer  		stream.Write ((nodeIndex & 0x3FFFFFF) | ((graphIndex & 0x3F) << 26));  		if (mask == SMask.SaveNodeConnectionCosts) {  			stream.Write (node.connectionCosts [i]);  		}  		//If the connection node is placed in a different graph  		if (graphIndex != node.h) {  			Node other = node.connections [i];  			bool containsLink = false;  			for (int q = 0; q < other.connections.Length; q++) {  				if (other.connections [q] == node) {  					containsLink = true;  					break;  				}  			}  			stream.Write (containsLink ? true : false);  		}  	}  }  else {  	stream.Write ((byte)0);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: if (node.connections.Length >= 256) {  	Debug.LogError ("Node connections over 256 (one byte)' can't serialize");  	WriteError ();  	return;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: for (int i = 0; i < node.connections.Length; i++) {  	//The index value for each node is stored in the G variable (a bit dirty' but it saves memory)  	//H value = Graph index  	//G value = Node index in graph  	//Graph index as in' which graph  	int graphIndex = node.connections [i].h;  	int nodeIndex = node.connections [i].g;  	//Pack two numbers into a single 32 bit integer  	stream.Write ((nodeIndex & 0x3FFFFFF) | ((graphIndex & 0x3F) << 26));  	if (mask == SMask.SaveNodeConnectionCosts) {  		stream.Write (node.connectionCosts [i]);  	}  	//If the connection node is placed in a different graph  	if (graphIndex != node.h) {  		Node other = node.connections [i];  		bool containsLink = false;  		for (int q = 0; q < other.connections.Length; q++) {  			if (other.connections [q] == node) {  				containsLink = true;  				break;  			}  		}  		stream.Write (containsLink ? true : false);  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,SerializeNode,The following statement contains a magic number: stream.Write ((nodeIndex & 0x3FFFFFF) | ((graphIndex & 0x3F) << 26));  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeSerializeNode,The following statement contains a magic number: if (mask == SMask.SaveNodeConnections) {  	if (tmpConnections == null) {  		tmpConnections = new List<Node> ();  		tmpConnectionCosts = new List<int> ();  	}  	else {  		tmpConnections.Clear ();  		tmpConnectionCosts.Clear ();  	}  	int numConn = (int)stream.ReadByte ();  	for (int i = 0; i < numConn; i++) {  		int nodeIndex = stream.ReadInt32 ();  		//Graph index as in' which graph  		int nodeGraphIndex = (nodeIndex >> 26) & 0x3F;  		nodeIndex &= 0x3FFFFFF;  		int cost = stream.ReadInt32 ();  		bool containsLink = false;  		/** \todo Don't use deserializingGraphIndex */if (nodeGraphIndex != graphIndex) {  			containsLink = stream.ReadBoolean ();  		}  		if (graphRefGuids [graphIndex] != -1) {  			Node other = active.astarData.GetNode (graphRefGuids [graphIndex]' nodeIndex' graphs);  			//Shouldn't really have to check for this' but just in case of corrupt serialization data  			if (other != null) {  				tmpConnections.Add (other);  				if (mask == SMask.SaveNodeConnectionCosts) {  					tmpConnectionCosts.Add (cost);  				}  				if (containsLink) {  					other.AddConnection (node' cost);  				}  			}  		}  	}  	node.connections = tmpConnections.ToArray ();  	if (mask == SMask.SaveNodeConnectionCosts) {  		node.connectionCosts = tmpConnectionCosts.ToArray ();  	}  	else {  		node.connectionCosts = new int[node.connections.Length];  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,DeSerializeNode,The following statement contains a magic number: for (int i = 0; i < numConn; i++) {  	int nodeIndex = stream.ReadInt32 ();  	//Graph index as in' which graph  	int nodeGraphIndex = (nodeIndex >> 26) & 0x3F;  	nodeIndex &= 0x3FFFFFF;  	int cost = stream.ReadInt32 ();  	bool containsLink = false;  	/** \todo Don't use deserializingGraphIndex */if (nodeGraphIndex != graphIndex) {  		containsLink = stream.ReadBoolean ();  	}  	if (graphRefGuids [graphIndex] != -1) {  		Node other = active.astarData.GetNode (graphRefGuids [graphIndex]' nodeIndex' graphs);  		//Shouldn't really have to check for this' but just in case of corrupt serialization data  		if (other != null) {  			tmpConnections.Add (other);  			if (mask == SMask.SaveNodeConnectionCosts) {  				tmpConnectionCosts.Add (cost);  			}  			if (containsLink) {  				other.AddConnection (node' cost);  			}  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddUnityReferenceValue,The following statement contains a magic number: if (value == active.gameObject) {  	stream.Write (-128);  	//Magic number (random) indicates that the reference is the A* object  }  else if (value == active.transform) {  	stream.Write (-129);  }  else {  	stream.Write (value.GetInstanceID ());  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddUnityReferenceValue,The following statement contains a magic number: if (value == active.gameObject) {  	stream.Write (-128);  	//Magic number (random) indicates that the reference is the A* object  }  else if (value == active.transform) {  	stream.Write (-129);  }  else {  	stream.Write (value.GetInstanceID ());  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddUnityReferenceValue,The following statement contains a magic number: stream.Write (-128);  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddUnityReferenceValue,The following statement contains a magic number: if (value == active.transform) {  	stream.Write (-129);  }  else {  	stream.Write (value.GetInstanceID ());  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddUnityReferenceValue,The following statement contains a magic number: stream.Write (-129);  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(int)) {  	stream.Write ((int)value);  }  else if (type == typeof(string)) {  	string st = (string)value;  	stream.Write (st);  }  else if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(int)) {  	stream.Write ((int)value);  }  else if (type == typeof(string)) {  	string st = (string)value;  	stream.Write (st);  }  else if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(int)) {  	stream.Write ((int)value);  }  else if (type == typeof(string)) {  	string st = (string)value;  	stream.Write (st);  }  else if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(string)) {  	string st = (string)value;  	stream.Write (st);  }  else if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(string)) {  	string st = (string)value;  	stream.Write (st);  }  else if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(string)) {  	string st = (string)value;  	stream.Write (st);  }  else if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(float)) {  	stream.Write ((float)value);  }  else if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(bool)) {  	stream.Write ((bool)value);  }  else if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Vector3)) {  	Vector3 d = (Vector3)value;  	stream.Write (d.x);  	stream.Write (d.y);  	stream.Write (d.z);  }  else if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Vector2)) {  	Vector2 d = (Vector2)value;  	stream.Write (d.x);  	stream.Write (d.y);  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = (Matrix4x4)value;  	for (int i = 0; i < 16; i++) {  		stream.Write (m [i]);  	}  }  else if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	stream.Write (m [i]);  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (type == typeof(Bounds)) {  	Bounds b = (Bounds)value;  	stream.Write (b.center.x);  	stream.Write (b.center.y);  	stream.Write (b.center.z);  	stream.Write (b.extents.x);  	stream.Write (b.extents.y);  	stream.Write (b.extents.z);  }  else {  	ISerializableObject sOb = value as ISerializableObject;  	if (sOb != null) {  		string prePrefix = sPrefix;  		//Add to the prefix to avoid name collisions  		sPrefix += key + ".";  		sOb.SerializeSettings (this);  		sPrefix = prePrefix;  	}  	else {  		UnityEngine.Object ueOb = value as UnityEngine.Object;  		if (ueOb != null) {  			Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  		else {  			Debug.LogError ("Can't serialize type '" + type.Name + "'");  			WriteError ();  			stream.BaseStream.Position -= 1;  			//Overwrite the previous magic number  			stream.Write ((byte)2);  			//Magic number indicating an error while serializing  		}  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (sOb != null) {  	string prePrefix = sPrefix;  	//Add to the prefix to avoid name collisions  	sPrefix += key + ".";  	sOb.SerializeSettings (this);  	sPrefix = prePrefix;  }  else {  	UnityEngine.Object ueOb = value as UnityEngine.Object;  	if (ueOb != null) {  		Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  		WriteError ();  		stream.BaseStream.Position -= 1;  		//Overwrite the previous magic number  		stream.Write ((byte)2);  		//Magic number indicating an error while serializing  	}  	else {  		Debug.LogError ("Can't serialize type '" + type.Name + "'");  		WriteError ();  		stream.BaseStream.Position -= 1;  		//Overwrite the previous magic number  		stream.Write ((byte)2);  		//Magic number indicating an error while serializing  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (sOb != null) {  	string prePrefix = sPrefix;  	//Add to the prefix to avoid name collisions  	sPrefix += key + ".";  	sOb.SerializeSettings (this);  	sPrefix = prePrefix;  }  else {  	UnityEngine.Object ueOb = value as UnityEngine.Object;  	if (ueOb != null) {  		Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  		WriteError ();  		stream.BaseStream.Position -= 1;  		//Overwrite the previous magic number  		stream.Write ((byte)2);  		//Magic number indicating an error while serializing  	}  	else {  		Debug.LogError ("Can't serialize type '" + type.Name + "'");  		WriteError ();  		stream.BaseStream.Position -= 1;  		//Overwrite the previous magic number  		stream.Write ((byte)2);  		//Magic number indicating an error while serializing  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (ueOb != null) {  	Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  	WriteError ();  	stream.BaseStream.Position -= 1;  	//Overwrite the previous magic number  	stream.Write ((byte)2);  	//Magic number indicating an error while serializing  }  else {  	Debug.LogError ("Can't serialize type '" + type.Name + "'");  	WriteError ();  	stream.BaseStream.Position -= 1;  	//Overwrite the previous magic number  	stream.Write ((byte)2);  	//Magic number indicating an error while serializing  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: if (ueOb != null) {  	Debug.LogWarning ("Unity Object References should be added using AddUnityReferenceValue");  	WriteError ();  	stream.BaseStream.Position -= 1;  	//Overwrite the previous magic number  	stream.Write ((byte)2);  	//Magic number indicating an error while serializing  }  else {  	Debug.LogError ("Can't serialize type '" + type.Name + "'");  	WriteError ();  	stream.BaseStream.Position -= 1;  	//Overwrite the previous magic number  	stream.Write ((byte)2);  	//Magic number indicating an error while serializing  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: stream.Write ((byte)2);  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,AddValue,The following statement contains a magic number: stream.Write ((byte)2);  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The following statement contains a magic number: if (magicNumber == 0) {  	return (defaultValue == null ? GetDefaultValue (type) : defaultValue) as UnityEngine.Object;  	//Null reference  }  else if (magicNumber == 2) {  	Debug.Log ("The variable '" + key + "' was not serialized correctly and can therefore not be deserialized");  	return (defaultValue == null ? GetDefaultValue (type) : defaultValue) as UnityEngine.Object;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The following statement contains a magic number: if (magicNumber == 2) {  	Debug.Log ("The variable '" + key + "' was not serialized correctly and can therefore not be deserialized");  	return (defaultValue == null ? GetDefaultValue (type) : defaultValue) as UnityEngine.Object;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The following statement contains a magic number: if (instanceID == -128) {  	//Magic number  	return active.gameObject;  }  else if (instanceID == -129) {  	//Magic number  	return active.transform;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The following statement contains a magic number: if (instanceID == -128) {  	//Magic number  	return active.gameObject;  }  else if (instanceID == -129) {  	//Magic number  	return active.transform;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetUnityReferenceValue,The following statement contains a magic number: if (instanceID == -129) {  	//Magic number  	return active.transform;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (magicNumber == 0) {  	return defaultValue == null ? GetDefaultValue (type) : defaultValue;  	//Null reference usually  }  else if (magicNumber == 2) {  	Debug.Log ("The variable '" + key + "' was not serialized correctly and can therefore not be deserialized");  	return defaultValue == null ? GetDefaultValue (type) : defaultValue;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (magicNumber == 2) {  	Debug.Log ("The variable '" + key + "' was not serialized correctly and can therefore not be deserialized");  	return defaultValue == null ? GetDefaultValue (type) : defaultValue;  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(int)) {  	ob = stream.ReadInt32 ();  }  else if (type == typeof(string)) {  	ob = stream.ReadString ();  }  else if (type == typeof(float)) {  	ob = stream.ReadSingle ();  }  else if (type == typeof(bool)) {  	ob = stream.ReadBoolean ();  }  else if (type == typeof(Vector3)) {  	ob = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Vector2)) {  	ob = new Vector2 (stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(string)) {  	ob = stream.ReadString ();  }  else if (type == typeof(float)) {  	ob = stream.ReadSingle ();  }  else if (type == typeof(bool)) {  	ob = stream.ReadBoolean ();  }  else if (type == typeof(Vector3)) {  	ob = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Vector2)) {  	ob = new Vector2 (stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(float)) {  	ob = stream.ReadSingle ();  }  else if (type == typeof(bool)) {  	ob = stream.ReadBoolean ();  }  else if (type == typeof(Vector3)) {  	ob = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Vector2)) {  	ob = new Vector2 (stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(bool)) {  	ob = stream.ReadBoolean ();  }  else if (type == typeof(Vector3)) {  	ob = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Vector2)) {  	ob = new Vector2 (stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(Vector3)) {  	ob = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Vector2)) {  	ob = new Vector2 (stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(Vector2)) {  	ob = new Vector2 (stream.ReadSingle ()' stream.ReadSingle ());  }  else if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: if (type == typeof(Matrix4x4)) {  	Matrix4x4 m = new Matrix4x4 ();  	for (int i = 0; i < 16; i++) {  		m [i] = stream.ReadSingle ();  	}  	ob = m;  }  else if (type == typeof(Bounds)) {  	Bounds b = new Bounds ();  	b.center = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	b.extents = new Vector3 (stream.ReadSingle ()' stream.ReadSingle ()' stream.ReadSingle ());  	ob = b;  }  else {  	if (type.GetConstructor (Type.EmptyTypes) != null) {  		System.Object testOb = Activator.CreateInstance (type);  		ISerializableObject sOb = (ISerializableObject)testOb;  		if (sOb != null) {  			string prePrefix = sPrefix;  			//Add to the prefix to avoid name collisions  			sPrefix += key + ".";  			sOb.DeSerializeSettings (this);  			ob = sOb;  			sPrefix = prePrefix;  		}  	}  	if (ob == null) {  		Debug.LogError ("Can't deSerialize type '" + type.Name + "'");  		ob = defaultValue == null ? GetDefaultValue (type) : defaultValue;  	}  }  
Magic Number,Pathfinding,AstarSerializer,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\AstarSerialize.cs,GetValue,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	m [i] = stream.ReadSingle ();  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.Manhattan) {  	h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale);  }  else if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.Manhattan) {  	h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale);  }  else if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.Manhattan) {  	h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale);  }  else if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.Manhattan) {  	h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale);  }  else if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.Manhattan) {  	h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale);  }  else if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.Manhattan) {  	h = Mathfx.RoundToInt ((Abs (position.x - targetPosition.x) + Abs (position.y - targetPosition.y) + Abs (position.z - targetPosition.z)) * scale);  }  else if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (heuristic == Heuristic.DiagonalManhattan) {  	int xDistance = Abs (position.x - targetPosition.x);  	int zDistance = Abs (position.z - targetPosition.z);  	if (xDistance > zDistance) {  		h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  	}  	else {  		h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  	}  	h = Mathfx.RoundToInt (h * scale);  }  else {  	h = Mathfx.RoundToInt ((position - targetPosition).magnitude * scale);  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (xDistance > zDistance) {  	h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  }  else {  	h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (xDistance > zDistance) {  	h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  }  else {  	h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (xDistance > zDistance) {  	h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  }  else {  	h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (xDistance > zDistance) {  	h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  }  else {  	h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (xDistance > zDistance) {  	h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  }  else {  	h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: if (xDistance > zDistance) {  	h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  }  else {  	h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  }  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: h = (14 * zDistance + 10 * (xDistance - zDistance)) / 10;  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  
Magic Number,Pathfinding,Node,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,UpdateH,The following statement contains a magic number: h = (14 * xDistance + 10 * (zDistance - xDistance)) / 10;  
Magic Number,Pathfinding,Int3,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return x * 9 + y * 10 + z * 11;  
Magic Number,Pathfinding,Int3,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return x * 9 + y * 10 + z * 11;  
Magic Number,Pathfinding,Int3,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return x * 9 + y * 10 + z * 11;  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BinaryHeap,The following statement contains a magic number: numberOfItems = 2;  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Add,The following statement contains a magic number: while (bubbleIndex != 1) {  	int parentIndex = bubbleIndex / 2;  	/*if (binaryHeap[parentIndex] == null) { 					Debug.Log ("WUT!!"); 					return; 				}*/if (nodeF <= binaryHeap [parentIndex].f) {  		//binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /** \todo Wouldn't it be more efficient with '<' instead of '<=' ? * /  		//Node tmpValue = binaryHeap[parentIndex];  		//tmpValue.heapIndex = bubbleIndex;//HeapIndex  		binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  		binaryHeap [parentIndex] = node;  		//binaryHeap[bubbleIndex];  		//binaryHeap[bubbleIndex].heapIndex = bubbleIndex; //Heap index  		//binaryHeap[parentIndex].heapIndex = parentIndex; //Heap index  		bubbleIndex = parentIndex;  	}  	else {  		/*if (binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /** \todo Wouldn't it be more efficient with '<' instead of '<=' ? * 					Node tmpValue = binaryHeap[parentIndex]; 					 					//tmpValue.heapIndex = bubbleIndex;//HeapIndex 					 					 					binaryHeap[parentIndex] = binaryHeap[bubbleIndex]; 					binaryHeap[bubbleIndex] = tmpValue; 					 					bubbleIndex = parentIndex; 				} else {*/break;  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Remove,The following statement contains a magic number: do {  	parent = swapItem;  	int p2 = parent * 2;  	if ((p2 + 1) <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].f >= binaryHeap [p2].f) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].f >= binaryHeap [p2 + 1].f) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].f >= binaryHeap [p2].f) {  			swapItem = p2;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		Node tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  }  while (parent != swapItem);  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,BubbleDown,The following statement contains a magic number: while (bubbleIndex != 1) {  	int parentIndex = bubbleIndex / 2;  	/* Can be optimized to use 'node' instead of 'binaryHeap[bubbleIndex]' */if (binaryHeap [bubbleIndex].f <= binaryHeap [parentIndex].f) {  		Node tmpValue = binaryHeap [parentIndex];  		binaryHeap [parentIndex] = binaryHeap [bubbleIndex];  		binaryHeap [bubbleIndex] = tmpValue;  		//binaryHeap[parentIndex].heapIndex = parentIndex;  		//binaryHeap[bubbleIndex].heapIndex = bubbleIndex;  		bubbleIndex = parentIndex;  	}  	else {  		return;  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Rebuild,The following statement contains a magic number: for (int i = 2; i < numberOfItems; i++) {  	int bubbleIndex = i;  	Node node = binaryHeap [i];  	int nodeF = node.f;  	while (bubbleIndex != 1) {  		int parentIndex = bubbleIndex / 2;  		if (nodeF < binaryHeap [parentIndex].f) {  			//Node tmpValue = binaryHeap[parentIndex];  			binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  			binaryHeap [parentIndex] = node;  			bubbleIndex = parentIndex;  		}  		else {  			break;  		}  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Rebuild,The following statement contains a magic number: for (int i = 2; i < numberOfItems; i++) {  	int bubbleIndex = i;  	Node node = binaryHeap [i];  	int nodeF = node.f;  	while (bubbleIndex != 1) {  		int parentIndex = bubbleIndex / 2;  		if (nodeF < binaryHeap [parentIndex].f) {  			//Node tmpValue = binaryHeap[parentIndex];  			binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  			binaryHeap [parentIndex] = node;  			bubbleIndex = parentIndex;  		}  		else {  			break;  		}  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Rebuild,The following statement contains a magic number: while (bubbleIndex != 1) {  	int parentIndex = bubbleIndex / 2;  	if (nodeF < binaryHeap [parentIndex].f) {  		//Node tmpValue = binaryHeap[parentIndex];  		binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  		binaryHeap [parentIndex] = node;  		bubbleIndex = parentIndex;  	}  	else {  		break;  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Rearrange,The following statement contains a magic number: for (int i = 0; i < numberOfItems; i++) {  	if (binaryHeap [i] == node) {  		int bubbleIndex = i;  		while (bubbleIndex != 1) {  			int parentIndex = bubbleIndex / 2;  			if (binaryHeap [bubbleIndex].f <= binaryHeap [parentIndex].f) {  				Node tmpValue = binaryHeap [parentIndex];  				binaryHeap [parentIndex] = binaryHeap [bubbleIndex];  				binaryHeap [bubbleIndex] = tmpValue;  				bubbleIndex = parentIndex;  			}  			else {  				return;  			}  		}  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Rearrange,The following statement contains a magic number: if (binaryHeap [i] == node) {  	int bubbleIndex = i;  	while (bubbleIndex != 1) {  		int parentIndex = bubbleIndex / 2;  		if (binaryHeap [bubbleIndex].f <= binaryHeap [parentIndex].f) {  			Node tmpValue = binaryHeap [parentIndex];  			binaryHeap [parentIndex] = binaryHeap [bubbleIndex];  			binaryHeap [bubbleIndex] = tmpValue;  			bubbleIndex = parentIndex;  		}  		else {  			return;  		}  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,Rearrange,The following statement contains a magic number: while (bubbleIndex != 1) {  	int parentIndex = bubbleIndex / 2;  	if (binaryHeap [bubbleIndex].f <= binaryHeap [parentIndex].f) {  		Node tmpValue = binaryHeap [parentIndex];  		binaryHeap [parentIndex] = binaryHeap [bubbleIndex];  		binaryHeap [bubbleIndex] = tmpValue;  		bubbleIndex = parentIndex;  	}  	else {  		return;  	}  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,ToString,The following statement contains a magic number: text.Append ("Number of items: ").Append (numberOfItems - 2);  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,ToString,The following statement contains a magic number: if (numberOfItems > 2) {  	WriteBranch (1' 1' text);  }  
Magic Number,Pathfinding,BinaryHeap,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,WriteBranch,The following statement contains a magic number: if (index > 1) {  	int parentIndex = index / 2;  	if (binaryHeap [index].f < binaryHeap [parentIndex].f) {  		text.Append ("	!!!");  	}  }  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,WillUpdateNode,The following statement contains a magic number: if (trackChangedNodes) {  	if (changedNodes == null) {  		changedNodes = new List<Node> ();  		backupData = new List<ulong> ();  	}  	changedNodes.Add (node);  	backupData.Add ((ulong)node.penalty << 32 | (ulong)node.flags);  }  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,WillUpdateNode,The following statement contains a magic number: backupData.Add ((ulong)node.penalty << 32 | (ulong)node.flags);  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,RevertFromBackup,The following statement contains a magic number: if (trackChangedNodes) {  	for (int i = 0; i < changedNodes.Count; i++) {  		changedNodes [i].penalty = (int)(backupData [i] >> 32);  		changedNodes [i].flags = (int)(backupData [i] & 0xFFFFFFFF);  	}  }  else {  	Debug.LogWarning ("Changed nodes have not been tracked' cannot revert from backup");  }  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,RevertFromBackup,The following statement contains a magic number: for (int i = 0; i < changedNodes.Count; i++) {  	changedNodes [i].penalty = (int)(backupData [i] >> 32);  	changedNodes [i].flags = (int)(backupData [i] & 0xFFFFFFFF);  }  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Core\astarclasses.cs,RevertFromBackup,The following statement contains a magic number: changedNodes [i].penalty = (int)(backupData [i] >> 32);  
Magic Number,Pathfinding,GraphCollision,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,DeSerializeSettings,The following statement contains a magic number: if (fromHeight == 0)  	fromHeight = 100;  
Magic Number,Pathfinding,GraphCollision,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,DeSerializeSettings,The following statement contains a magic number: fromHeight = 100;  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GridGraph,The following statement contains a magic number: unclampedSize = new Vector2 (10' 10);  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GridGraph,The following statement contains a magic number: unclampedSize = new Vector2 (10' 10);  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets = new int[8] {  	-width'  	1'  	width'  	-1'  	-width + 1'  	width + 1'  	width - 1'  	-width - 1  };  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts = new int[8] {  	straightCost'  	straightCost'  	straightCost'  	straightCost'  	diagonalCost'  	diagonalCost'  	diagonalCost'  	diagonalCost  };  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets = new int[8] {  	0'  	1'  	0'  	-1'  	1'  	1'  	-1'  	-1  };  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets = new int[8] {  	-1'  	0'  	1'  	0'  	-1'  	1'  	1'  	-1  };  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,Scan,The following statement contains a magic number: if (width > 1024 || depth > 1024) {  	Debug.LogError ("One of the grid's sides is longer than 1024 nodes");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,Scan,The following statement contains a magic number: if (width > 1024 || depth > 1024) {  	Debug.LogError ("One of the grid's sides is longer than 1024 nodes");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = 0; z < depth; z++) {  		for (int x = 0; x < width; x++) {  			GridNode node = graphNodes [z * width + x];  			if (!node.walkable) {  				int index = node.GetIndex ();  				for (int i = 0; i < 4; i++) {  					if (node.GetConnection (i)) {  						nodes [index + neighbourOffsets [i]].walkable = false;  					}  				}  			}  			else {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!node.GetConnection (i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.walkable = false;  				}  			}  		}  	}  	//Recalculate connections  	for (int z = 0; z < depth; z++) {  		for (int x = 0; x < width; x++) {  			GridNode node = graphNodes [z * width + x];  			CalculateConnections (graphNodes' x' z' node);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = 0; z < depth; z++) {  		for (int x = 0; x < width; x++) {  			GridNode node = graphNodes [z * width + x];  			if (!node.walkable) {  				int index = node.GetIndex ();  				for (int i = 0; i < 4; i++) {  					if (node.GetConnection (i)) {  						nodes [index + neighbourOffsets [i]].walkable = false;  					}  				}  			}  			else {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!node.GetConnection (i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.walkable = false;  				}  			}  		}  	}  	//Recalculate connections  	for (int z = 0; z < depth; z++) {  		for (int x = 0; x < width; x++) {  			GridNode node = graphNodes [z * width + x];  			CalculateConnections (graphNodes' x' z' node);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = 0; z < depth; z++) {  	for (int x = 0; x < width; x++) {  		GridNode node = graphNodes [z * width + x];  		if (!node.walkable) {  			int index = node.GetIndex ();  			for (int i = 0; i < 4; i++) {  				if (node.GetConnection (i)) {  					nodes [index + neighbourOffsets [i]].walkable = false;  				}  			}  		}  		else {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!node.GetConnection (i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.walkable = false;  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = 0; z < depth; z++) {  	for (int x = 0; x < width; x++) {  		GridNode node = graphNodes [z * width + x];  		if (!node.walkable) {  			int index = node.GetIndex ();  			for (int i = 0; i < 4; i++) {  				if (node.GetConnection (i)) {  					nodes [index + neighbourOffsets [i]].walkable = false;  				}  			}  		}  		else {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!node.GetConnection (i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.walkable = false;  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	GridNode node = graphNodes [z * width + x];  	if (!node.walkable) {  		int index = node.GetIndex ();  		for (int i = 0; i < 4; i++) {  			if (node.GetConnection (i)) {  				nodes [index + neighbourOffsets [i]].walkable = false;  			}  		}  	}  	else {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!node.GetConnection (i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.walkable = false;  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	GridNode node = graphNodes [z * width + x];  	if (!node.walkable) {  		int index = node.GetIndex ();  		for (int i = 0; i < 4; i++) {  			if (node.GetConnection (i)) {  				nodes [index + neighbourOffsets [i]].walkable = false;  			}  		}  	}  	else {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!node.GetConnection (i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.walkable = false;  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!node.walkable) {  	int index = node.GetIndex ();  	for (int i = 0; i < 4; i++) {  		if (node.GetConnection (i)) {  			nodes [index + neighbourOffsets [i]].walkable = false;  		}  	}  }  else {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!node.GetConnection (i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.walkable = false;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!node.walkable) {  	int index = node.GetIndex ();  	for (int i = 0; i < 4; i++) {  		if (node.GetConnection (i)) {  			nodes [index + neighbourOffsets [i]].walkable = false;  		}  	}  }  else {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!node.GetConnection (i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.walkable = false;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (node.GetConnection (i)) {  		nodes [index + neighbourOffsets [i]].walkable = false;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (!node.GetConnection (i)) {  		anyFalseConnections = true;  		break;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.flags = node.flags & -256;  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners == null) {  	corners = new int[4];  }  else {  	for (int i = 0; i < 4; i++) {  		corners [i] = 0;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners == null) {  	corners = new int[4];  }  else {  	for (int i = 0; i < 4; i++) {  		corners [i] = 0;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: corners = new int[4];  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	corners [i] = 0;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0' j = 3; i < 4; j = i' i++) {  	int nx = x + neighbourXOffsets [i];  	int nz = z + neighbourZOffsets [i];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = graphNodes [index + neighbourOffsets [i]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i' 1);  		corners [i]++;  		corners [j]++;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0' j = 3; i < 4; j = i' i++) {  	int nx = x + neighbourXOffsets [i];  	int nz = z + neighbourZOffsets [i];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = graphNodes [index + neighbourOffsets [i]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i' 1);  		corners [i]++;  		corners [j]++;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  				if (IsValidConnection (node' other)) {  					node.SetConnectionRaw (i + 4' 1);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  			if (IsValidConnection (node' other)) {  				node.SetConnectionRaw (i + 4' 1);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (IsValidConnection (node' other)) {  	node.SetConnectionRaw (i + 4' 1);  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.SetConnectionRaw (i + 4' 1);  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  		if (IsValidConnection (node' other)) {  			node.SetConnectionRaw (i + 4' 1);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = graphNodes [index + neighbourOffsets [i + 4]];  	if (IsValidConnection (node' other)) {  		node.SetConnectionRaw (i + 4' 1);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (IsValidConnection (node' other)) {  	node.SetConnectionRaw (i + 4' 1);  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.SetConnectionRaw (i + 4' 1);  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int z = 0; z < depth; z++) {  	for (int x = 0; x < width; x++) {  		GridNode node = graphNodes [z * width + x];  		if (!node.walkable) {  			// || node.activePath != AstarPath.active.debugPath)    			continue;  		}  		//Gizmos.color = node.walkable ? Color.green : Color.red;  		//Gizmos.DrawSphere (node.position'0.2F);  		Gizmos.color = NodeColor (node);  		//if (true) {  		//	Gizmos.DrawCube (node.position'Vector3.one*nodeSize);  		//}  		//else   		if (AstarPath.active.showSearchTree && Node.activePath != null && AstarPath.active.debugPath != null) {  			if (node.pathID == AstarPath.active.debugPath.pathID && node.parent != null) {  				Gizmos.DrawLine (node.position' node.parent.position);  			}  		}  		else {  			for (int i = 0; i < 8; i++) {  				if (node.GetConnection (i)) {  					GridNode other = graphNodes [node.GetIndex () + neighbourOffsets [i]];  					Gizmos.DrawLine (node.position' other.position);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	GridNode node = graphNodes [z * width + x];  	if (!node.walkable) {  		// || node.activePath != AstarPath.active.debugPath)    		continue;  	}  	//Gizmos.color = node.walkable ? Color.green : Color.red;  	//Gizmos.DrawSphere (node.position'0.2F);  	Gizmos.color = NodeColor (node);  	//if (true) {  	//	Gizmos.DrawCube (node.position'Vector3.one*nodeSize);  	//}  	//else   	if (AstarPath.active.showSearchTree && Node.activePath != null && AstarPath.active.debugPath != null) {  		if (node.pathID == AstarPath.active.debugPath.pathID && node.parent != null) {  			Gizmos.DrawLine (node.position' node.parent.position);  		}  	}  	else {  		for (int i = 0; i < 8; i++) {  			if (node.GetConnection (i)) {  				GridNode other = graphNodes [node.GetIndex () + neighbourOffsets [i]];  				Gizmos.DrawLine (node.position' other.position);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: if (AstarPath.active.showSearchTree && Node.activePath != null && AstarPath.active.debugPath != null) {  	if (node.pathID == AstarPath.active.debugPath.pathID && node.parent != null) {  		Gizmos.DrawLine (node.position' node.parent.position);  	}  }  else {  	for (int i = 0; i < 8; i++) {  		if (node.GetConnection (i)) {  			GridNode other = graphNodes [node.GetIndex () + neighbourOffsets [i]];  			Gizmos.DrawLine (node.position' other.position);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (node.GetConnection (i)) {  		GridNode other = graphNodes [node.GetIndex () + neighbourOffsets [i]];  		Gizmos.DrawLine (node.position' other.position);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CheckConnection,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	return node.GetConnection (dir);  }  else {  	int dir1 = (dir - 4 - 1) & 0x3;  	int dir2 = (dir - 4 + 1) & 0x3;  	if (!node.GetConnection (dir1) || !node.GetConnection (dir2)) {  		return false;  	}  	else {  		GridNode n1 = nodes [node.GetIndex () + neighbourOffsets [dir1]] as GridNode;  		GridNode n2 = nodes [node.GetIndex () + neighbourOffsets [dir2]] as GridNode;  		if (!n1.walkable || !n2.walkable) {  			return false;  		}  		if (!n2.GetConnection (dir1) || !n1.GetConnection (dir2)) {  			return false;  		}  	}  	return true;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,CheckConnection,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	return node.GetConnection (dir);  }  else {  	int dir1 = (dir - 4 - 1) & 0x3;  	int dir2 = (dir - 4 + 1) & 0x3;  	if (!node.GetConnection (dir1) || !node.GetConnection (dir2)) {  		return false;  	}  	else {  		GridNode n1 = nodes [node.GetIndex () + neighbourOffsets [dir1]] as GridNode;  		GridNode n2 = nodes [node.GetIndex () + neighbourOffsets [dir2]] as GridNode;  		if (!n1.walkable || !n2.walkable) {  			return false;  		}  		if (!n2.GetConnection (dir1) || !n1.GetConnection (dir2)) {  			return false;  		}  	}  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,GetGridIndex,The following statement contains a magic number: return indices >> 24;  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,SetGridIndex,The following statement contains a magic number: indices |= gridIndex << 24;  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateGridConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	//if (((flags >> i) & 1) == 1) {  	int nx = x + neighbourOffsetsX [i];  	int nz = z + neighbourOffsetsZ [i];  	if (nx < 0 || nz < 0 || nx >= graph.width || nz >= graph.depth) {  		continue;  	}  	GridNode node = (GridNode)graph.nodes [index + neighbourOffsets [i]];  	graph.CalculateConnections (graph.graphNodes' nx' nz' node);  	//}  }  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,RemoveConnection,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int nx = x + neighbourOffsetsX [i];  	int nz = z + neighbourOffsetsZ [i];  	if (nx < 0 || nz < 0 || nx >= graph.width || nz >= graph.depth) {  		continue;  	}  	GridNode gNode = (GridNode)graph.nodes [index + neighbourOffsets [i]];  	if (gNode == node) {  		SetConnection (i' 0);  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateAllG,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (((flags >> i) & 1) == 1) {  		Node node = nodes [index + neighbourOffsets [i]];  		if (node.parent == this && node.pathID == pathID) {  			node.UpdateAllG (open);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,FloodFill,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (((flags >> i) & 1) == 1) {  		Node node = nodes [index + neighbourOffsets [i]];  		if (node.walkable && node.area != area) {  			stack.Push (node);  			node.area = area;  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\GridGenerator.cs,Open,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (((flags >> i) & 1) == 1) {  		Node node = nodes [index + neighbourOffsets [i]];  		if (!path.CanTraverse (node))  			continue;  		if (node.pathID != pathID) {  			node.parent = this;  			node.pathID = pathID;  			node.cost = neighbourCosts [i];  			node.UpdateH (targetPosition' path.heuristic' path.heuristicScale);  			node.UpdateG ();  			open.Add (node);  		}  		else {  			//If not we can test if the path from the current node to this one is a better one then the one already used  			int tmpCost = neighbourCosts [i];  			//(current.costs == null || current.costs.Length == 0 ? costs[current.neighboursKeys[i]] : current.costs[current.neighboursKeys[i]]);  			if (g + tmpCost + node.penalty < node.g) {  				node.cost = tmpCost;  				//node.extraCost = extraCost2;  				node.parent = this;  				;  				node.UpdateAllG (open);  				//open.Add (node);  				//Debug.DrawLine (current.vectorPos'current.neighbours[i].vectorPos'Color.cyan); //Uncomment for @Debug  			}  			else if (node.g + tmpCost + penalty < g) {  				//Or if the path from this node ("node") to the current ("current") is better  				/*bool contains = false; 							 							//[Edit' no one-way links between nodes in a single grid] Make sure we don't travel along the wrong direction of a one way link now' make sure the Current node can be accesed from the Node. 							/*for (int y=0;y<node.connections.Length;y++) { 								if (node.connections[y].endNode == this) { 									contains = true; 									break; 								} 							} 							 							if (!contains) { 								continue; 							}*/parent = node;  				cost = tmpCost;  				//extraCost = extraCost2;  				UpdateAllG (open);  				//open.Add (this);  				//Debug.DrawLine (current.vectorPos'current.neighbours[i].vectorPos'Color.blue); //Uncomment for @Debug  				//open.Add (this);  			}  		}  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The following statement contains a magic number: if (nninfo.node != null) {  	MeshNode node = nninfo.node as MeshNode;  	//minNode2 as MeshNode;  	Vector3[] triangle = new Vector3[3] {  		vertices [node.v1]'  		vertices [node.v2]'  		vertices [node.v3]  	};  	Vector3 clP = Polygon.ClosesPointOnTriangle (triangle' position);  	nninfo.clampedPosition = clP;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The following statement contains a magic number: if (nninfo.constrainedNode != null) {  	MeshNode node = nninfo.constrainedNode as MeshNode;  	//minNode2 as MeshNode;  	Vector3[] triangle = new Vector3[3] {  		vertices [node.v1]'  		vertices [node.v2]'  		vertices [node.v3]  	};  	Vector3 clP = Polygon.ClosesPointOnTriangle (triangle' position);  	nninfo.constClampedPosition = clP;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	MeshNode n1 = path [i] as MeshNode;  	MeshNode n2 = path [i + 1] as MeshNode;  	bool foundFirst = false;  	int first = -1;  	int second = -1;  	for (int x = 0; x < 3; x++) {  		//Vector3 vertice1 = vertices[n1.vertices[x]];  		int vertice1 = n1.GetVertexIndex (x);  		for (int y = 0; y < 3; y++) {  			//Vector3 vertice2 = vertices[n2.vertices[y]];  			int vertice2 = n2.GetVertexIndex (y);  			if (vertice1 == vertice2) {  				if (foundFirst) {  					second = vertice2;  					break;  				}  				else {  					first = vertice2;  					foundFirst = true;  				}  			}  		}  	}  	if (first == -1 || second == -1) {  		left.Add (n1.position);  		right.Add (n1.position);  		left.Add (n2.position);  		right.Add (n2.position);  		lastLeftIndex = first;  		lastRightIndex = second;  	}  	else {  		//Debug.DrawLine ((Vector3)vertices[first]+Vector3.up*0.1F'(Vector3)vertices[second]+Vector3.up*0.1F'Color.cyan);  		//Debug.Log (first+" "+second);  		if (first == lastLeftIndex) {  			left.Add (vertices [first]);  			right.Add (vertices [second]);  			lastLeftIndex = first;  			lastRightIndex = second;  		}  		else if (first == lastRightIndex) {  			left.Add (vertices [second]);  			right.Add (vertices [first]);  			lastLeftIndex = second;  			lastRightIndex = first;  		}  		else if (second == lastLeftIndex) {  			left.Add (vertices [second]);  			right.Add (vertices [first]);  			lastLeftIndex = second;  			lastRightIndex = first;  		}  		else {  			left.Add (vertices [first]);  			right.Add (vertices [second]);  			lastLeftIndex = first;  			lastRightIndex = second;  		}  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	MeshNode n1 = path [i] as MeshNode;  	MeshNode n2 = path [i + 1] as MeshNode;  	bool foundFirst = false;  	int first = -1;  	int second = -1;  	for (int x = 0; x < 3; x++) {  		//Vector3 vertice1 = vertices[n1.vertices[x]];  		int vertice1 = n1.GetVertexIndex (x);  		for (int y = 0; y < 3; y++) {  			//Vector3 vertice2 = vertices[n2.vertices[y]];  			int vertice2 = n2.GetVertexIndex (y);  			if (vertice1 == vertice2) {  				if (foundFirst) {  					second = vertice2;  					break;  				}  				else {  					first = vertice2;  					foundFirst = true;  				}  			}  		}  	}  	if (first == -1 || second == -1) {  		left.Add (n1.position);  		right.Add (n1.position);  		left.Add (n2.position);  		right.Add (n2.position);  		lastLeftIndex = first;  		lastRightIndex = second;  	}  	else {  		//Debug.DrawLine ((Vector3)vertices[first]+Vector3.up*0.1F'(Vector3)vertices[second]+Vector3.up*0.1F'Color.cyan);  		//Debug.Log (first+" "+second);  		if (first == lastLeftIndex) {  			left.Add (vertices [first]);  			right.Add (vertices [second]);  			lastLeftIndex = first;  			lastRightIndex = second;  		}  		else if (first == lastRightIndex) {  			left.Add (vertices [second]);  			right.Add (vertices [first]);  			lastLeftIndex = second;  			lastRightIndex = first;  		}  		else if (second == lastLeftIndex) {  			left.Add (vertices [second]);  			right.Add (vertices [first]);  			lastLeftIndex = second;  			lastRightIndex = first;  		}  		else {  			left.Add (vertices [first]);  			right.Add (vertices [second]);  			lastLeftIndex = first;  			lastRightIndex = second;  		}  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int x = 0; x < 3; x++) {  	//Vector3 vertice1 = vertices[n1.vertices[x]];  	int vertice1 = n1.GetVertexIndex (x);  	for (int y = 0; y < 3; y++) {  		//Vector3 vertice2 = vertices[n2.vertices[y]];  		int vertice2 = n2.GetVertexIndex (y);  		if (vertice1 == vertice2) {  			if (foundFirst) {  				second = vertice2;  				break;  			}  			else {  				first = vertice2;  				foundFirst = true;  			}  		}  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int x = 0; x < 3; x++) {  	//Vector3 vertice1 = vertices[n1.vertices[x]];  	int vertice1 = n1.GetVertexIndex (x);  	for (int y = 0; y < 3; y++) {  		//Vector3 vertice2 = vertices[n2.vertices[y]];  		int vertice2 = n2.GetVertexIndex (y);  		if (vertice1 == vertice2) {  			if (foundFirst) {  				second = vertice2;  				break;  			}  			else {  				first = vertice2;  				foundFirst = true;  			}  		}  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int y = 0; y < 3; y++) {  	//Vector3 vertice2 = vertices[n2.vertices[y]];  	int vertice2 = n2.GetVertexIndex (y);  	if (vertice1 == vertice2) {  		if (foundFirst) {  			second = vertice2;  			break;  		}  		else {  			first = vertice2;  			foundFirst = true;  		}  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int i = 0; i < graph.nodes.Length; i++) {  	MeshNode node = graph.nodes [i] as MeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Vector3 vert = (Vector3)navgraph.vertices [node [v]];  		Vector2 vert2D = new Vector2 (vert.x' vert.z);  		if (r.Contains (vert2D)) {  			//Debug.DrawRay (vert'Vector3.up'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			continue;  		}  	}  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  		Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (!inside && ContainsPoint (node' a' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (a+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' b' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (b+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' c' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (c+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' d' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (d+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside) {  		continue;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.blue);  	//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.blue);  	//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.blue);  	//Debug.Break ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int i = 0; i < graph.nodes.Length; i++) {  	MeshNode node = graph.nodes [i] as MeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Vector3 vert = (Vector3)navgraph.vertices [node [v]];  		Vector2 vert2D = new Vector2 (vert.x' vert.z);  		if (r.Contains (vert2D)) {  			//Debug.DrawRay (vert'Vector3.up'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			continue;  		}  	}  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  		Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (!inside && ContainsPoint (node' a' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (a+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' b' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (b+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' c' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (c+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' d' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (d+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside) {  		continue;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.blue);  	//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.blue);  	//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.blue);  	//Debug.Break ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int i = 0; i < graph.nodes.Length; i++) {  	MeshNode node = graph.nodes [i] as MeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Vector3 vert = (Vector3)navgraph.vertices [node [v]];  		Vector2 vert2D = new Vector2 (vert.x' vert.z);  		if (r.Contains (vert2D)) {  			//Debug.DrawRay (vert'Vector3.up'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			continue;  		}  	}  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  		Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (!inside && ContainsPoint (node' a' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (a+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' b' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (b+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' c' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (c+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' d' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (d+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside) {  		continue;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.blue);  	//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.blue);  	//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.blue);  	//Debug.Break ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int i = 0; i < graph.nodes.Length; i++) {  	MeshNode node = graph.nodes [i] as MeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Vector3 vert = (Vector3)navgraph.vertices [node [v]];  		Vector2 vert2D = new Vector2 (vert.x' vert.z);  		if (r.Contains (vert2D)) {  			//Debug.DrawRay (vert'Vector3.up'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			continue;  		}  	}  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  		Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (!inside && ContainsPoint (node' a' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (a+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' b' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (b+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' c' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (c+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' d' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (d+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside) {  		continue;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.blue);  	//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.blue);  	//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.blue);  	//Debug.Break ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int i = 0; i < graph.nodes.Length; i++) {  	MeshNode node = graph.nodes [i] as MeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Vector3 vert = (Vector3)navgraph.vertices [node [v]];  		Vector2 vert2D = new Vector2 (vert.x' vert.z);  		if (r.Contains (vert2D)) {  			//Debug.DrawRay (vert'Vector3.up'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			continue;  		}  	}  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  		Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (!inside && ContainsPoint (node' a' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (a+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' b' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (b+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' c' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (c+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' d' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (d+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside) {  		continue;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.blue);  	//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.blue);  	//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.blue);  	//Debug.Break ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int i = 0; i < graph.nodes.Length; i++) {  	MeshNode node = graph.nodes [i] as MeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Vector3 vert = (Vector3)navgraph.vertices [node [v]];  		Vector2 vert2D = new Vector2 (vert.x' vert.z);  		if (r.Contains (vert2D)) {  			//Debug.DrawRay (vert'Vector3.up'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			continue;  		}  	}  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  		Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (!inside && ContainsPoint (node' a' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (a+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' b' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (b+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' c' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (c+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside && ContainsPoint (node' d' navgraph.vertices)) {  		inside = true;  	}  	//Debug.DrawRay (d+Vector3.right*0.01F*i'Vector3.up'Color.red); }  	if (!inside) {  		continue;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.blue);  	//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.blue);  	//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.blue);  	//Debug.Break ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int v = 0; v < 3; v++) {  	Vector3 vert = (Vector3)navgraph.vertices [node [v]];  	Vector2 vert2D = new Vector2 (vert.x' vert.z);  	if (r.Contains (vert2D)) {  		//Debug.DrawRay (vert'Vector3.up'Color.yellow);  		inside = true;  		break;  	}  	if (vert.x < r.xMin)  		allLeft++;  	if (vert.x > r.xMax)  		allRight++;  	if (vert.z < r.yMin)  		allTop++;  	if (vert.z > r.yMax)  		allBottom++;  	//if (!bounds.Contains (node[v]) {  	//	inside = false;  	//	break;  	//}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		continue;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		continue;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		continue;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		continue;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	continue;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	continue;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	continue;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	continue;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int v = 0; v < 3; v++) {  	int v2 = v > 1 ? 0 : v + 1;  	Vector3 vert1 = (Vector3)navgraph.vertices [node [v]];  	Vector3 vert2 = (Vector3)navgraph.vertices [node [v2]];  	if (Polygon.Intersects (a' b' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (a' c' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (c' d' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (d' b' vert1' vert2)) {  		inside = true;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ClosestPointOnNode,The following statement contains a magic number: return Polygon.ClosesPointOnTriangle (vertices [node [0]]' vertices [node [1]]' vertices [node [2]]' pos);  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	MeshNode node = (MeshNode)nodes [i];  	//new MeshNode ();  	node.walkable = true;  	node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  	node.v1 = triangles [i * 3];  	node.v2 = triangles [i * 3 + 1];  	node.v3 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v3]'Color.red);  		//Debug.DrawLine (vertices[node.v3]'vertices[node.v1]'Color.red);  		int tmp = node.v1;  		node.v1 = node.v3;  		node.v3 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v1]' vertices [node.v2]' vertices [node.v3])) {  		Debug.DrawLine (vertices [node.v1]' vertices [node.v2]' Color.red);  		Debug.DrawLine (vertices [node.v2]' vertices [node.v3]' Color.red);  		Debug.DrawLine (vertices [node.v3]' vertices [node.v1]' Color.red);  	}  	nodes [i] = node;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.position = (vertices [triangles [i * 3]] + vertices [triangles [i * 3 + 1]] + vertices [triangles [i * 3 + 2]]) / 3F;  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v1 = triangles [i * 3];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v2 = triangles [i * 3 + 1];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v3 = triangles [i * 3 + 2];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v3 = triangles [i * 3 + 2];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < triangles.Length; i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	Node node = nodes [i / 3];  	for (int x = 0; x < triangles.Length; x += 3) {  		if (x == i) {  			continue;  		}  		int count = 0;  		if (triangles [x] == triangles [i]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i]) {  			count++;  		}  		if (triangles [x] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 1]) {  			count++;  		}  		if (triangles [x] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 1] == triangles [i + 2]) {  			count++;  		}  		if (triangles [x + 2] == triangles [i + 2]) {  			count++;  		}  		if (count >= 3) {  			identicalError++;  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  			Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  			Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  		}  		if (count == 2) {  			Node other = nodes [x / 3];  			connections.Add (other);  			connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: i += 3
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int x = 0; x < triangles.Length; x += 3) {  	if (x == i) {  		continue;  	}  	int count = 0;  	if (triangles [x] == triangles [i]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i]) {  		count++;  	}  	if (triangles [x] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 1]) {  		count++;  	}  	if (triangles [x] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 1] == triangles [i + 2]) {  		count++;  	}  	if (triangles [x + 2] == triangles [i + 2]) {  		count++;  	}  	if (count >= 3) {  		identicalError++;  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  		Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  		Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  	}  	if (count == 2) {  		Node other = nodes [x / 3];  		connections.Add (other);  		connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: x += 3
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i + 1]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 1] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (triangles [x + 2] == triangles [i + 2]) {  	count++;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count >= 3) {  	identicalError++;  	Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  	Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  	Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count >= 3) {  	identicalError++;  	Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  	Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  	Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count >= 3) {  	identicalError++;  	Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 1]]' Color.red);  	Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  	Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: Debug.DrawLine (vertices [triangles [x]]' vertices [triangles [x + 2]]' Color.red);  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: Debug.DrawLine (vertices [triangles [x + 2]]' vertices [triangles [x + 1]]' Color.red);  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count == 2) {  	Node other = nodes [x / 3];  	connections.Add (other);  	connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (count == 2) {  	Node other = nodes [x / 3];  	connections.Add (other);  	connectionCosts.Add (Mathf.RoundToInt ((node.position - other.position).magnitude));  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,PostProcess,The following statement contains a magic number: connectionCosts.Add (Mathf.RoundToInt ((nodex.position - otherNode.position).magnitude * 100));  
Magic Number,Pathfinding,MeshNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetVertexIndex,The following statement contains a magic number: if (i == 0) {  	return v1;  }  else if (i == 1) {  	return v2;  }  else if (i == 2) {  	return v3;  }  else {  	throw new System.ArgumentOutOfRangeException ("A MeshNode only contains 3 vertices");  }  
Magic Number,Pathfinding,MeshNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetVertexIndex,The following statement contains a magic number: if (i == 1) {  	return v2;  }  else if (i == 2) {  	return v3;  }  else {  	throw new System.ArgumentOutOfRangeException ("A MeshNode only contains 3 vertices");  }  
Magic Number,Pathfinding,MeshNode,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetVertexIndex,The following statement contains a magic number: if (i == 2) {  	return v3;  }  else {  	throw new System.ArgumentOutOfRangeException ("A MeshNode only contains 3 vertices");  }  
Magic Number,Pathfinding,ConstantPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\ConstantPath.cs,CalculateStep,The following statement contains a magic number: while (!foundEnd && !error) {  	//@Performance Just for debug info  	searchedNodes++;  	//--- Here's the important stuff				  	//Close the current node' if the current node satisfies the ending condition' the path is finished  	if (endingCondition.TargetFound (this' current)) {  		foundEnd = true;  		break;  	}  	//Add Node to allNodes  	allNodes.Add (current);  	//--- Here the important stuff ends  	//Loop through all walkable neighbours of the node  	current.Open (open' hTarget' this);  	//any nodes left to search?  	if (open.numberOfItems <= 1) {  		//For this path type' this is actually a valid end  		foundEnd = true;  		break;  	}  	//Select the node with the lowest F score and remove it from the open list  	current = open.Remove ();  	//Check for time every 500 nodes  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if ((System.DateTime.Now.Ticks - startTime.Ticks) > maxTicks) {  			//searchedNodesThisFrame > 20000) {  			float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  			duration += durationThisFrame;  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return durationThisFrame;  		}  		counter = 0;  	}  	counter++;  }  
Magic Number,Pathfinding,ConstantPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\ConstantPath.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if ((System.DateTime.Now.Ticks - startTime.Ticks) > maxTicks) {  		//searchedNodesThisFrame > 20000) {  		float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  		duration += durationThisFrame;  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return durationThisFrame;  	}  	counter = 0;  }  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,CalculateStep,The following statement contains a magic number: while (!foundEnd && !error) {  	//@Performance Just for debug info  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finnished  	if (current == endNode) {  		foundEnd = true;  		break;  	}  	//Loop through all walkable neighbours of the node and add them to the open list.  	current.Open (open' hTarget' this);  	//any nodes left to search?  	if (open.numberOfItems <= 1) {  		LogError ("No open points' whole area searched");  		float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  		duration += durationThisFrame;  		return durationThisFrame;  	}  	//Select the node with the lowest F score and remove it from the open list  	current = open.Remove ();  	//Check for time every 500 nodes' roughly every 0.5 ms  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if ((System.DateTime.Now.Ticks - startTime.Ticks) > maxTicks) {  			float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  			duration += durationThisFrame;  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return durationThisFrame;  		}  		counter = 0;  	}  	counter++;  }  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if ((System.DateTime.Now.Ticks - startTime.Ticks) > maxTicks) {  		float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  		duration += durationThisFrame;  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return durationThisFrame;  	}  	counter = 0;  }  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Trace,The following statement contains a magic number: while (c != null) {  	c = c.parent;  	count++;  	if (count > 1024) {  		Debug.LogWarning ("Inifinity loop? >1024 node path");  		break;  	}  }  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,Trace,The following statement contains a magic number: if (count > 1024) {  	Debug.LogWarning ("Inifinity loop? >1024 node path");  	break;  }  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,DebugString,The following statement contains a magic number: if (!error) {  	text.Append (" Path Length ");  	text.Append (path == null ? "Null" : path.Length.ToString ());  	if (logMode == PathLog.Heavy) {  		text.Append ("\nSearch Iterations " + searchIterations);  		if (hasEndPoint && endNode != null) {  			text.Append ("\nEnd Node\n	G: ");  			text.Append (endNode.g);  			text.Append ("\n	H: ");  			text.Append (endNode.h);  			text.Append ("\n	F: ");  			text.Append (endNode.f);  			text.Append ("\n	Point: ");  			text.Append (((Vector3)endPoint).ToString ());  			text.Append ("\n	Graph: ");  			text.Append (endNode.graphIndex);  		}  		text.Append ("\nStart Node");  		text.Append ("\n	Point: ");  		text.Append (((Vector3)startPoint).ToString ());  		text.Append ("\n	Graph: ");  		text.Append (startNode.graphIndex);  		text.Append ("\nBinary Heap size at completion: ");  		text.Append (open == null ? "Null" : (open.numberOfItems - 2).ToString ());  		// -2 because numberOfItems includes the next item to be added and item zero is not used  	}  	/*"\nEnd node\n	G = "+p.endNode.g+"\n	H = "+p.endNode.h+"\n	F = "+p.endNode.f+"\n	Point	"+p.endPoint 				+"\nStart Point = "+p.startPoint+"\n"+"Start Node graph: "+p.startNode.graphIndex+" End Node graph: "+p.endNode.graphIndex+ 				"\nBinary Heap size at completion: "+(p.open == null ? "Null" : p.open.numberOfItems.ToString ())*/}  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,DebugString,The following statement contains a magic number: if (logMode == PathLog.Heavy) {  	text.Append ("\nSearch Iterations " + searchIterations);  	if (hasEndPoint && endNode != null) {  		text.Append ("\nEnd Node\n	G: ");  		text.Append (endNode.g);  		text.Append ("\n	H: ");  		text.Append (endNode.h);  		text.Append ("\n	F: ");  		text.Append (endNode.f);  		text.Append ("\n	Point: ");  		text.Append (((Vector3)endPoint).ToString ());  		text.Append ("\n	Graph: ");  		text.Append (endNode.graphIndex);  	}  	text.Append ("\nStart Node");  	text.Append ("\n	Point: ");  	text.Append (((Vector3)startPoint).ToString ());  	text.Append ("\n	Graph: ");  	text.Append (startNode.graphIndex);  	text.Append ("\nBinary Heap size at completion: ");  	text.Append (open == null ? "Null" : (open.numberOfItems - 2).ToString ());  	// -2 because numberOfItems includes the next item to be added and item zero is not used  }  
Magic Number,Pathfinding,Path,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\Path.cs,DebugString,The following statement contains a magic number: text.Append (open == null ? "Null" : (open.numberOfItems - 2).ToString ());  
Magic Number,Pathfinding,XPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\XPath.cs,CalculateStep,The following statement contains a magic number: while (!foundEnd && !error) {  	//@Performance Just for debug info  	searchedNodes++;  	//Close the current node' if the current node satisfies the ending condition' terminate the path  	if (endingCondition.TargetFound (this' current)) {  		foundEnd = true;  		endNode = current;  		break;  	}  	/*if (current == null) { 					Debug.LogWarning ("Current is Null"); 					return; 				}*///Debug.DrawRay ( current.position' Vector3.up*10'Color.cyan);  	//Loop through all walkable neighbours of the node  	current.Open (open' hTarget' this);  	//any nodes left to search?  	if (open.numberOfItems <= 1) {  		LogError ("No open points' whole area searched");  		float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  		duration += durationThisFrame;  		return durationThisFrame;  	}  	//Select the node with the lowest F score and remove it from the open list  	current = open.Remove ();  	//Check for time every 500 nodes to save cycles  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if ((System.DateTime.Now.Ticks - startTime.Ticks) > maxTicks) {  			//searchedNodesThisFrame > 20000) {  			float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  			duration += durationThisFrame;  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return durationThisFrame;  		}  		counter = 0;  	}  	counter++;  }  
Magic Number,Pathfinding,XPath,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Pathfinders\XPath.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if ((System.DateTime.Now.Ticks - startTime.Ticks) > maxTicks) {  		//searchedNodesThisFrame > 20000) {  		float durationThisFrame = (System.DateTime.Now.Ticks - startTime.Ticks) * 0.0001F;  		duration += durationThisFrame;  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return durationThisFrame;  	}  	counter = 0;  }  
Missing Default,Pathfinding,NavGraph,C:\repos\PileOfFish_PileOfFishProductions\Final2.0\BetaV1.42\protoPrototype\Assets\AstarPathfindingProject\Generators\Base.cs,NodeColor,The following switch statement is missing a default case: switch (AstarPath.active.debugMode) {  case GraphDebugMode.Areas:  	c = AstarColor.GetAreaColor (node.area);  	break;  case GraphDebugMode.G:  	//c = Mathfx.IntToColor (node.g'0.5F);  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.g / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.H:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.h / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.F:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.f / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.Penalty:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.penalty / (float)AstarPath.active.debugRoof);  	break;  /* Wasn't really usefull 				case GraphDebugMode.Position: 					float r = Mathf.PingPong (node.position.x/10000F'1F) + Mathf.PingPong (node.position.x/300000F'1F); 					float g = Mathf.PingPong (node.position.y/10000F'1F) + Mathf.PingPong (node.position.y/200000F'1F); 					float b = Mathf.PingPong (node.position.z/10000F'1F) + Mathf.PingPong (node.position.z/100000F'1F); 					 					 					c = new Color (r'g'b); 					break; 				*/}  
