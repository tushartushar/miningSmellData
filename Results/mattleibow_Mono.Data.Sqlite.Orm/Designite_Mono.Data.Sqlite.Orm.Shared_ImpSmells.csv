Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,CompileExpr,The method has 171 lines of code.
Complex Method,Mono.Data.Sqlite.Orm,OrmHelper,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\OrmHelper.cs,SqlType,Cyclomatic complexity of the method is 9
Complex Method,Mono.Data.Sqlite.Orm,SqliteWriter,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\SqliteWriter.cs,GetCreateSql,Cyclomatic complexity of the method is 13
Complex Method,Mono.Data.Sqlite.Orm,Column,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetCreateSql,Cyclomatic complexity of the method is 9
Long Parameter List,Mono.Data.Sqlite.Orm,TableMapping,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetUpdateSql,The method has 5 parameters. Parameters: propertyName' propertyValue' args' pk' pks
Long Statement,Mono.Data.Sqlite.Orm,SqliteSessionBase,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\SqliteSessionBase.cs,GetIndexList,The length of the statement  "            return Query<IndexListItem>(string.Format(CultureInfo.InvariantCulture' "pragma index_list({0});"' tableName)).ToList(); " is 120.
Long Statement,Mono.Data.Sqlite.Orm,TableMapping,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetUpdateSql,The length of the statement  "                string col = string.Join("' "' this.EditableColumns.Select(c => string.Format(CultureInfo.InvariantCulture' "[{0}] = ?"' c.Name)).ToArray()); " is 141.
Long Statement,Mono.Data.Sqlite.Orm,TableMapping,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetUpdateSql,The length of the statement  "                string pks = string.Join(" AND "' this.PrimaryKey.Columns.Select(c => string.Format(CultureInfo.InvariantCulture' "[{0}] = ?"' c.Name)).ToArray()); " is 147.
Long Statement,Mono.Data.Sqlite.Orm,TableMapping,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetDeleteSql,The length of the statement  "                string pks = string.Join(" AND "' this.PrimaryKey.Columns.Select(c => string.Format(CultureInfo.InvariantCulture' "[{0}] = ?"' c.Name)).ToArray()); " is 147.
Long Statement,Mono.Data.Sqlite.Orm,TableMapping,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetUpdateSql,The length of the statement  "            string whereClause = string.Join(" AND "' this.PrimaryKey.Columns.Select(c => string.Format(CultureInfo.InvariantCulture' "[{0}] = ?"' c.Name)).ToArray()); " is 155.
Long Statement,Mono.Data.Sqlite.Orm,TableMapping,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetUpdateSql,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "UPDATE [{0}] SET [{1}] = ? WHERE {2}"' this.TableName' propertyName' whereClause); " is 134.
Long Statement,Mono.Data.Sqlite.Orm,Column,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetCreateSql,The length of the statement  "                    constraints.Add(string.Join(" "' this.Checks.Select(c => string.Format(CultureInfo.InvariantCulture' "CHECK ({0})"' c)).ToArray())); " is 132.
Long Statement,Mono.Data.Sqlite.Orm,Column,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableMapping.cs,GetCreateSql,The length of the statement  "                return string.Format(CultureInfo.InvariantCulture' "[{0}] {1} {2}"' this.Name' OrmHelper.SqlType(this)' string.Join(" "' constraints.ToArray())); " is 145.
Complex Conditional,Mono.Data.Sqlite.Orm,OrmHelper,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\OrmHelper.cs,SqlType,The conditional expression  "clrType == typeof (Boolean) ||                  clrType == typeof (Byte) ||                  clrType == typeof (UInt16) ||                  clrType == typeof (SByte) ||                  clrType == typeof (Int16) ||                  clrType == typeof (Int32) ||                  clrType.IsEnum"  is complex.
Magic Number,Mono.Data.Sqlite.Orm,FullTextSearchSpecialCommands,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\FullTextSearchSpecialCommands.cs,RunMergeUntilOptimal,The following statement contains a magic number: while ((i = database.Merge(type)) >= 2)              {                  changes += i;              }
Magic Number,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,SingleOrDefault,The following statement contains a magic number: return Take(2).ToList().SingleOrDefault();
Magic Number,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,SingleOrDefault,The following statement contains a magic number: return Where(predicate).Take(2).ToList().SingleOrDefault();
Magic Number,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,Single,The following statement contains a magic number: return Take(2).ToList().Single();
Magic Number,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,Single,The following statement contains a magic number: return Where(predicate).Take(2).ToList().Single();
Magic Number,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,CompileExpr,The following statement contains a magic number: if (expr is BinaryExpression)              {                  var bin = (BinaryExpression)expr;                    CompileResult leftr = CompileExpr(bin.Left' queryArgs);                  CompileResult rightr = CompileExpr(bin.Right' queryArgs);                    //If either side is a parameter and is null' then handle the other side specially (for "is null"/"is not null")                  string text;                  if (leftr.CommandText == "?" && leftr.Value == null)                      text = CompileNullBinaryExpression(bin' rightr);                  else if (rightr.CommandText == "?" && rightr.Value == null)                      text = CompileNullBinaryExpression(bin' leftr);                  else                      text = "(" + leftr.CommandText + " " + GetSqlName(bin) + " " + rightr.CommandText + ")";                  return new CompileResult { CommandText = text };              }              else if (expr.NodeType == ExpressionType.Call)              {                  var call = (MethodCallExpression)expr;                  var args = new CompileResult[call.Arguments.Count];                  var obj = call.Object != null ? CompileExpr(call.Object' queryArgs) : null;                  string methodName = call.Method.Name;                  string sqlCall = string.Empty;                    for (int i = 0; i < args.Length; i++)                  {                      args[i] = CompileExpr(call.Arguments[i]' queryArgs);                  }                    if (methodName == "Contains")                  {                      if (args.Length == 1)                      {                          // string.Contains("xxx") or list.Contains(x)                          if (call.Object != null && call.Object.Type == typeof(string))                          {                              sqlCall = "({0} like ('%' || {1} || '%'))";                          }                          else                          {                              sqlCall = "({1} in {0})";                          }                            sqlCall = string.Format(sqlCall' obj.CommandText' args[0].CommandText);                      }                      else if (args.Length == 2)                      {                          sqlCall = string.Format("({0} in {1})"' args[1].CommandText' args[0].CommandText);                      }                  }                  else if (methodName == "StartsWith" || methodName == "EndsWith")                  {                      if (args.Length == 1)                      {                          if (methodName == "StartsWith")                          {                              sqlCall = "({0} like ({1} || '%'))";                          }                          else if (methodName == "EndsWith")                          {                              sqlCall = "({0} like ('%' || {1}))";                          }                            sqlCall = string.Format(sqlCall' obj.CommandText' args[0].CommandText);                      }                  }                  else if (methodName == "Matches" && args.Length == 2)                  {                      sqlCall = "({0} match {1})";                      sqlCall = string.Format(sqlCall' args[0].CommandText' args[1].CommandText);                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      sqlCall = "({0} = ({1}))";                      sqlCall = string.Format(sqlCall' obj.CommandText' args[0].CommandText);                  }                  else                  {                      var arguments = string.Join("'"' args.Select(a => a.CommandText).ToArray());                      sqlCall = string.Format("{0}({1})"' methodName.ToLower()' arguments);                  }                    return new CompileResult { CommandText = sqlCall };              }              else if (expr.NodeType == ExpressionType.Constant)              {                  var c = (ConstantExpression)expr;                  queryArgs.Add(c.Value);                  return new CompileResult                  {                      CommandText = "?"'                      Value = c.Value                  };              }              else if (expr.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)expr;                  Type ty = u.Type;                  CompileResult valr = CompileExpr(u.Operand' queryArgs);                    var underlyingType = Nullable.GetUnderlyingType(ty);                  if (underlyingType != null)                  {                      ty = underlyingType;                  }                    return new CompileResult                  {                      CommandText = valr.CommandText'                      Value = valr.Value != null ? Convert.ChangeType(valr.Value' ty' null) : null                  };              }              else if (expr.NodeType == ExpressionType.MemberAccess)              {                  var mem = (MemberExpression)expr;                    if (mem.Expression.NodeType == ExpressionType.Parameter)                  {                      //                      // This is a column of our table' output just the column name                      //                      return new CompileResult { CommandText = "\"" + OrmHelper.GetColumnName(mem.Member) + "\"" };                  }                  else                  {                      object obj = null;                      if (mem.Expression != null)                      {                          CompileResult r = CompileExpr(mem.Expression' queryArgs);                          if (r.Value == null)                          {                              throw new NotSupportedException("Member access failed to compile expression");                          }                          if (r.CommandText == "?")                          {                              queryArgs.RemoveAt(queryArgs.Count - 1);                          }                          obj = r.Value;                      }                        var val = this.Session.GetExpressionMemberValue(expr' mem' obj);                        //                      // Work special magic for enumerables                      //                      if (val != null && val is IEnumerable && !(val is string))                      {                          var sb = new StringBuilder();                          sb.Append("(");                          string head = "";                          foreach (object a in (IEnumerable)val)                          {                              queryArgs.Add(a);                              sb.Append(head);                              sb.Append("?");                              head = "'";                          }                          sb.Append(")");                          return new CompileResult                          {                              CommandText = sb.ToString()'                              Value = val                          };                      }                      else                      {                          queryArgs.Add(val);                          return new CompileResult                          {                              CommandText = "?"'                              Value = val                          };                      }                  }              }
Magic Number,Mono.Data.Sqlite.Orm,TableQuery<T>,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\TableQuery.cs,CompileExpr,The following statement contains a magic number: if (expr is BinaryExpression)              {                  var bin = (BinaryExpression)expr;                    CompileResult leftr = CompileExpr(bin.Left' queryArgs);                  CompileResult rightr = CompileExpr(bin.Right' queryArgs);                    //If either side is a parameter and is null' then handle the other side specially (for "is null"/"is not null")                  string text;                  if (leftr.CommandText == "?" && leftr.Value == null)                      text = CompileNullBinaryExpression(bin' rightr);                  else if (rightr.CommandText == "?" && rightr.Value == null)                      text = CompileNullBinaryExpression(bin' leftr);                  else                      text = "(" + leftr.CommandText + " " + GetSqlName(bin) + " " + rightr.CommandText + ")";                  return new CompileResult { CommandText = text };              }              else if (expr.NodeType == ExpressionType.Call)              {                  var call = (MethodCallExpression)expr;                  var args = new CompileResult[call.Arguments.Count];                  var obj = call.Object != null ? CompileExpr(call.Object' queryArgs) : null;                  string methodName = call.Method.Name;                  string sqlCall = string.Empty;                    for (int i = 0; i < args.Length; i++)                  {                      args[i] = CompileExpr(call.Arguments[i]' queryArgs);                  }                    if (methodName == "Contains")                  {                      if (args.Length == 1)                      {                          // string.Contains("xxx") or list.Contains(x)                          if (call.Object != null && call.Object.Type == typeof(string))                          {                              sqlCall = "({0} like ('%' || {1} || '%'))";                          }                          else                          {                              sqlCall = "({1} in {0})";                          }                            sqlCall = string.Format(sqlCall' obj.CommandText' args[0].CommandText);                      }                      else if (args.Length == 2)                      {                          sqlCall = string.Format("({0} in {1})"' args[1].CommandText' args[0].CommandText);                      }                  }                  else if (methodName == "StartsWith" || methodName == "EndsWith")                  {                      if (args.Length == 1)                      {                          if (methodName == "StartsWith")                          {                              sqlCall = "({0} like ({1} || '%'))";                          }                          else if (methodName == "EndsWith")                          {                              sqlCall = "({0} like ('%' || {1}))";                          }                            sqlCall = string.Format(sqlCall' obj.CommandText' args[0].CommandText);                      }                  }                  else if (methodName == "Matches" && args.Length == 2)                  {                      sqlCall = "({0} match {1})";                      sqlCall = string.Format(sqlCall' args[0].CommandText' args[1].CommandText);                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      sqlCall = "({0} = ({1}))";                      sqlCall = string.Format(sqlCall' obj.CommandText' args[0].CommandText);                  }                  else                  {                      var arguments = string.Join("'"' args.Select(a => a.CommandText).ToArray());                      sqlCall = string.Format("{0}({1})"' methodName.ToLower()' arguments);                  }                    return new CompileResult { CommandText = sqlCall };              }              else if (expr.NodeType == ExpressionType.Constant)              {                  var c = (ConstantExpression)expr;                  queryArgs.Add(c.Value);                  return new CompileResult                  {                      CommandText = "?"'                      Value = c.Value                  };              }              else if (expr.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)expr;                  Type ty = u.Type;                  CompileResult valr = CompileExpr(u.Operand' queryArgs);                    var underlyingType = Nullable.GetUnderlyingType(ty);                  if (underlyingType != null)                  {                      ty = underlyingType;                  }                    return new CompileResult                  {                      CommandText = valr.CommandText'                      Value = valr.Value != null ? Convert.ChangeType(valr.Value' ty' null) : null                  };              }              else if (expr.NodeType == ExpressionType.MemberAccess)              {                  var mem = (MemberExpression)expr;                    if (mem.Expression.NodeType == ExpressionType.Parameter)                  {                      //                      // This is a column of our table' output just the column name                      //                      return new CompileResult { CommandText = "\"" + OrmHelper.GetColumnName(mem.Member) + "\"" };                  }                  else                  {                      object obj = null;                      if (mem.Expression != null)                      {                          CompileResult r = CompileExpr(mem.Expression' queryArgs);                          if (r.Value == null)                          {                              throw new NotSupportedException("Member access failed to compile expression");                          }                          if (r.CommandText == "?")                          {                              queryArgs.RemoveAt(queryArgs.Count - 1);                          }                          obj = r.Value;                      }                        var val = this.Session.GetExpressionMemberValue(expr' mem' obj);                        //                      // Work special magic for enumerables                      //                      if (val != null && val is IEnumerable && !(val is string))                      {                          var sb = new StringBuilder();                          sb.Append("(");                          string head = "";                          foreach (object a in (IEnumerable)val)                          {                              queryArgs.Add(a);                              sb.Append(head);                              sb.Append("?");                              head = "'";                          }                          sb.Append(")");                          return new CompileResult                          {                              CommandText = sb.ToString()'                              Value = val                          };                      }                      else                      {                          queryArgs.Add(val);                          return new CompileResult                          {                              CommandText = "?"'                              Value = val                          };                      }                  }              }
Missing Default,Mono.Data.Sqlite.Orm,OrmHelper,C:\repos\mattleibow_Mono.Data.Sqlite.Orm\Mono.Data.Sqlite.Orm.Shared\OrmHelper.cs,GetForeignKeyActionString,The following switch statement is missing a default case: switch (action)              {                  case ForeignKeyAction.Cascade:                      result = "CASCADE";                      break;                  case ForeignKeyAction.NoAction:                      result = "NO ACTION";                      break;                  case ForeignKeyAction.Restrict:                      result = "RESTRICT";                      break;                  case ForeignKeyAction.SetDefault:                      result = "SET DEFAULT";                      break;                  case ForeignKeyAction.SetNull:                      result = "SET NULL";                      break;              }
