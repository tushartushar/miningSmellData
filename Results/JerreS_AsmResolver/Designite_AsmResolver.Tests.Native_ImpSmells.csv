Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,Cyclomatic complexity of the method is 10
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following statement contains a magic number: switch (register1Index)                          {                              case 4: // esp                                  continue;                              case 5: // ebp                                  if (operandType != 0)                                      continue;                                  operand1.Value = 0x1337u;                                  break;                          }
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following statement contains a magic number: switch (register1Index)                          {                              case 4: // esp                                  continue;                              case 5: // ebp                                  if (operandType != 0)                                      continue;                                  operand1.Value = 0x1337u;                                  break;                          }
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following statement contains a magic number: switch (operandType)                          {                              case 1:                                  operand1.Offset = 1;                                  operand1.OffsetType = X86OffsetType.Short;                                  break;                              case 2:                                  operand1.Offset = 0x1337;                                  operand1.OffsetType = X86OffsetType.Long;                                  break;                          }
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following statement contains a magic number: register1Index < 8
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following statement contains a magic number: register2Index < 8
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following statement contains a magic number: operandType < 3
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemSibTestInstructions,The following statement contains a magic number: scaledRegIndex == 4
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemSibTestInstructions,The following statement contains a magic number: switch (operandType)                          {                              case 1:                                  operand1.Offset = 1;                                  operand1.OffsetType = X86OffsetType.Short;                                  break;                              case 2:                                  operand1.Offset = 0x1337;                                  operand1.OffsetType = X86OffsetType.Long;                                  break;                          }
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemSibTestInstructions,The following statement contains a magic number: scaledRegIndex < 8
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemSibTestInstructions,The following statement contains a magic number: multiplier < 16
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemSibTestInstructions,The following statement contains a magic number: operandType < 3
Magic Number,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,Create3OperandsInstructions,The following statement contains a magic number: yield return new X86Instruction                      {                          OpCode = X86OpCodes.IMul_Reg1632_RegOrMem1632_Imm1632'                          Mnemonic = X86Mnemonic.Imul'                          Operand1 = operand1'                          Operand2 = operand2'                          Operand3 = new X86Operand(1337u)                      };
Missing Default,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following switch statement is missing a default case: switch (register1Index)                          {                              case 4: // esp                                  continue;                              case 5: // ebp                                  if (operandType != 0)                                      continue;                                  operand1.Value = 0x1337u;                                  break;                          }
Missing Default,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following switch statement is missing a default case: switch (operandType)                          {                              case 1:                                  operand1.Offset = 1;                                  operand1.OffsetType = X86OffsetType.Short;                                  break;                              case 2:                                  operand1.Offset = 0x1337;                                  operand1.OffsetType = X86OffsetType.Long;                                  break;                          }
Missing Default,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemTestInstructions,The following switch statement is missing a default case: switch (opcode.OperandSize3)                              {                                  case X86OperandSize.Byte:                                      instruction.Operand3 = new X86Operand((byte) 0x12);                                      break;                                  case X86OperandSize.WordOrDword:                                      instruction.Operand3 = new X86Operand(0x1337u);                                      break;                              }
Missing Default,AsmResolver.Tests.Native,X86AssemblerTests,D:\research\architectureSmells\repos\JerreS_AsmResolver\Tests\Native\AsmResolver.Tests.Native\X86AssemblerTests.cs,CreateRegOrMemSibTestInstructions,The following switch statement is missing a default case: switch (operandType)                          {                              case 1:                                  operand1.Offset = 1;                                  operand1.OffsetType = X86OffsetType.Short;                                  break;                              case 2:                                  operand1.Offset = 0x1337;                                  operand1.OffsetType = X86OffsetType.Long;                                  break;                          }
