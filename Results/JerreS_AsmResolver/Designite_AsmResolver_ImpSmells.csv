Implementation smell,Namespace,Class,File,Method,Description
Long Method,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The method has 105 lines of code.
Complex Method,AsmResolver.Net,DefaultNetAssemblyResolver,C:\repos\JerreS_AsmResolver\AsmResolver\Net\INetAssemblyResolver.cs,ResolveAssembly,Cyclomatic complexity of the method is 8
Complex Method,AsmResolver.Net,SignatureComparer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,MatchTypes,Cyclomatic complexity of the method is 17
Complex Method,AsmResolver.Net.Metadata,ReferenceImporter,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\ReferenceImporter.cs,ImportTypeSignature,Cyclomatic complexity of the method is 15
Complex Method,AsmResolver.Net.Metadata,ReferenceImporter,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\ReferenceImporter.cs,GetCorLibSignature,Cyclomatic complexity of the method is 8
Complex Method,AsmResolver.Net.Signatures,ArrayTypeSignature,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ArrayTypeSignature.cs,FromReader,Cyclomatic complexity of the method is 11
Long Parameter List,AsmResolver.X86,X86OpCode,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86OpCode.cs,X86OpCode,The method has 5 parameters. Parameters: mnemonics' opcodeValue' operandsValue' hasRegisterToken' hasOpCodeModifier
Long Parameter List,AsmResolver.X86,X86OpCode,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86OpCode.cs,X86OpCode,The method has 6 parameters. Parameters: mnemonics' opcodeValue' operandTypes1' sizes1' operandTypes2' sizes2
Long Parameter List,AsmResolver.X86,X86Operand,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Operand.cs,X86Operand,The method has 5 parameters. Parameters: operandUsage' value' scaledIndex' offset' offsetType
Long Identifier,AsmResolver,ImageDataDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageDataDirectory.cs,,The length of the parameter DelayImportDescrDirectoryIndex is 30.
Long Statement,AsmResolver.Builder,ImageImportDirectoryBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Builder\ImageImportDirectoryBuilder.cs,UpdateTableRvas,The length of the statement  "                module.ImportLookupTableRva = (uint)_offsetConverter.FileOffsetToRva(_lookupTablesBuilder.GetModuleLookupSegment(module).StartOffset); " is 134.
Long Statement,AsmResolver.Builder,ImageImportDirectoryBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Builder\ImageImportDirectoryBuilder.cs,UpdateTableRvas,The length of the statement  "                module.ImportAddressTableRva = (uint)_offsetConverter.FileOffsetToRva(AddressTablesBuilder.GetModuleLookupSegment(module).StartOffset); " is 135.
Long Statement,AsmResolver.Net,SignatureComparer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,MatchTypes,The length of the statement  "                && signature1.Dimensions.Where((d' i) => MatchArrayDimensions(d' signature2.Dimensions[i])).Count() == signature1.Dimensions.Count; " is 131.
Long Statement,AsmResolver.Net,VTableHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\VTablesDirectory.cs,FromReadingContext,The length of the statement  "            var tokensReader = readingContext.Reader.CreateSubReader(fileOffset' size * (tableHeader.Is32Bit ? sizeof (int) : sizeof (long))); " is 130.
Long Statement,AsmResolver.Net.Builder,MethodBodyTableBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Builder\MethodBodyTableBuilder.cs,GetPhysicalLength,The length of the statement  "            return (uint)(Segments[Segments.Count - 1].StartOffset - StartOffset + Segments[Segments.Count - 1].GetPhysicalLength()); " is 121.
Long Statement,AsmResolver.Net.Builder,SectionsTableBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Builder\NetAssemblyBuilder.cs,UpdateOffsets,The length of the statement  "                        _sectionBuilders[i].Header.StartOffset = _sectionBuilders[i - 1].Header.StartOffset + _sectionBuilders[i - 1].Header.GetPhysicalLength(); " is 137.
Long Statement,AsmResolver.Net.Metadata,MetadataMemberCollection<TOwner;TItem>,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MetadataMemberCollection.cs,Initialize,The length of the statement  "                        while (startIndex > 0 && Convert.ToUInt32(attributeTable[startIndex - 1].MetadataRow.GetAllColumns().ElementAt(_columnIndex)) == key) " is 133.
Long Statement,AsmResolver.Net.Metadata,MethodDefinition,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MethodDefinition.cs,SetMethodCodeTypeAttribute,The length of the statement  "            ImplAttributes = (MethodImplAttributes)((uint)ImplAttributes).SetMaskedAttribute((uint)MethodImplAttributes.CodeTypeMask' " is 121.
Long Statement,AsmResolver.Net.Msil,ExceptionHandler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\ExceptionHandler.cs,FromReader,The length of the statement  "                    handler.CatchType = (ITypeDefOrRef)((IOperandResolver)methodBody).ResolveMember(new MetadataToken(classTokenOrFilterOffset)); " is 125.
Long Statement,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The length of the statement  "                    instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48); " is 130.
Long Statement,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The length of the statement  "                    instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48); " is 130.
Long Statement,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The length of the statement  "                    instruction.Operand = ((IOperandResolver) this).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48); " is 131.
Complex Conditional,AsmResolver,BinaryStreamReaderExtensions,C:\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamReader.cs,TryReadCompressedUInt32,The conditional expression  "((firstByte & 0x80) == 0 && reader.CanRead(sizeof(byte))) ||                  ((firstByte & 0x40) == 0 && reader.CanRead(sizeof(ushort))) ||                  (reader.CanRead(sizeof(uint)))"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteOperandValue,The conditional expression  "(operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp)"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteNumber,The conditional expression  "value is sbyte || value is short || value is int || value is long"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteNumber,The conditional expression  "value is sbyte || value is short || value is int || value is long"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteNumber,The conditional expression  "value is sbyte || value is short || value is int || value is long"  is complex.
Complex Conditional,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The conditional expression  "(operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp)"  is complex.
Magic Number,AsmResolver,BaseRelocationBlock,C:\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationBlock.cs,FromReadingContext,The following statement contains a magic number: block._entriesReadingContext = context.CreateSubContext(reader.Position' (int)(block.BlockSize - (2 * sizeof (uint))));
Magic Number,AsmResolver,BaseRelocationBlock,C:\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationBlock.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            Entries.Count * sizeof (ushort));
Magic Number,AsmResolver,BaseRelocationEntry,C:\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationEntry.cs,FromReadingContext,The following statement contains a magic number: return new BaseRelocationEntry((BaseRelocationType) (value >> 12)' (ushort) (value & 0x0FFF))              {                  StartOffset = offset              };
Magic Number,AsmResolver,BaseRelocationEntry,C:\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationEntry.cs,Write,The following statement contains a magic number: context.Writer.WriteUInt16((ushort)((ushort)Type << 12 | (Offset & 0x0FFF)));
Magic Number,AsmResolver,HintName,C:\repos\JerreS_AsmResolver\AsmResolver\HintName.cs,FromReadingContext,The following statement contains a magic number: if (reader.Position % 2 != 0)                  reader.Position++;
Magic Number,AsmResolver,HintName,C:\repos\JerreS_AsmResolver\AsmResolver\HintName.cs,GetPhysicalLength,The following statement contains a magic number: if ((StartOffset + size) % 2 != 0)                  size++;
Magic Number,AsmResolver,HintName,C:\repos\JerreS_AsmResolver\AsmResolver\HintName.cs,Write,The following statement contains a magic number: if (writer.Position % 2 != 0)                  writer.WriteByte(0);
Magic Number,AsmResolver,BinaryStreamReaderExtensions,C:\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamReader.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((firstByte & 0x40) == 0)                  return (uint)(((firstByte & 0x7F) << 8) | reader.ReadByte());
Magic Number,AsmResolver,ImageDataDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageDataDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint);
Magic Number,AsmResolver,ImageImportDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageImportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)((ModuleImports.Count + 1) * 5 * sizeof (uint));
Magic Number,AsmResolver,ImageRelocationDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageRelocationDirectory.cs,FromReadingContext,The following statement contains a magic number: while (context.Reader.Position < context.Reader.StartPosition + relocDirectory.Size)              {                  var block = BaseRelocationBlock.FromReadingContext(context);                  directory.Blocks.Add(block);                  context.Reader.Position += block.BlockSize - 2 * sizeof (uint);              }
Magic Number,AsmResolver,ImageExportDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageExportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) +                     2 * sizeof (ushort) +                     7 * sizeof (uint);
Magic Number,AsmResolver,ImageExportDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageExportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) +                     2 * sizeof (ushort) +                     7 * sizeof (uint);
Magic Number,AsmResolver,ImageExportDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageExportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) +                     2 * sizeof (ushort) +                     7 * sizeof (uint);
Magic Number,AsmResolver,ImageFileHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageFileHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     3 * sizeof (uint) +                     2 * sizeof (ushort);
Magic Number,AsmResolver,ImageFileHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageFileHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     3 * sizeof (uint) +                     2 * sizeof (ushort);
Magic Number,AsmResolver,ImageFileHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageFileHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     3 * sizeof (uint) +                     2 * sizeof (ushort);
Magic Number,AsmResolver,ImageSymbolImport,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSymbolImport.cs,FromReadingContext,The following statement contains a magic number: import.IsImportByOrdinal = import.Lookup >> (optionalHeader.Magic == OptionalHeaderMagic.Pe32Plus ? 63 : 31) == 1;
Magic Number,AsmResolver,ImageSymbolImport,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSymbolImport.cs,FromReadingContext,The following statement contains a magic number: import.IsImportByOrdinal = import.Lookup >> (optionalHeader.Magic == OptionalHeaderMagic.Pe32Plus ? 63 : 31) == 1;
Magic Number,AsmResolver,ImageSectionHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,FromReadingContext,The following statement contains a magic number: return new ImageSectionHeader              {                  StartOffset = reader.Position'                  Name = Encoding.ASCII.GetString(reader.ReadBytes(8))'                  VirtualSize = reader.ReadUInt32()'                  VirtualAddress = reader.ReadUInt32()'                  SizeOfRawData = reader.ReadUInt32()'                  PointerToRawData = reader.ReadUInt32()'                  PointerToRelocations = reader.ReadUInt32()'                  PointerToLinenumbers = reader.ReadUInt32()'                  NumberOfRelocations = reader.ReadUInt16()'                  NumberOfLinenumbers = reader.ReadUInt16()'                  Attributes = (ImageSectionAttributes)reader.ReadUInt32()'              };
Magic Number,AsmResolver,ImageSectionHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 8 * sizeof(byte) +                     6 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * sizeof (uint);
Magic Number,AsmResolver,ImageSectionHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 8 * sizeof(byte) +                     6 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * sizeof (uint);
Magic Number,AsmResolver,ImageSectionHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 8 * sizeof(byte) +                     6 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * sizeof (uint);
Magic Number,AsmResolver,ImageSectionHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,Write,The following statement contains a magic number: writer.WriteBytes(new byte[8 - nameBytes.Length]);
Magic Number,AsmResolver,ImageModuleImport,C:\repos\JerreS_AsmResolver\AsmResolver\ImageModuleImport.cs,GetPhysicalLength,The following statement contains a magic number: return 5 * sizeof (uint);
Magic Number,AsmResolver,OutputStreamExtensions,C:\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamWriter.cs,GetCompressedSize,The following statement contains a magic number: if (value < 0x4000)                  return 2;
Magic Number,AsmResolver,OutputStreamExtensions,C:\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamWriter.cs,GetCompressedSize,The following statement contains a magic number: return 4;
Magic Number,AsmResolver,OutputStreamExtensions,C:\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamWriter.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value < 0x80)                  writer.WriteByte((byte)value);              else if (value < 0x4000)              {                  writer.WriteByte((byte)(0x80 | value >> 8));                  writer.WriteByte((byte)(value & 0xFF));              }              else              {                  writer.WriteByte((byte)(0x80 | 0x40 | value >> 0x18));                  writer.WriteByte((byte)(value >> 0x10 & 0xFF));                  writer.WriteByte((byte)(value >> 0x08 & 0xFF));                  writer.WriteByte((byte)(value & 0xFF));              }
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt16,The following statement contains a magic number: Advance(2);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt16,The following statement contains a magic number: return BitConverter.ToUInt16(_data' _position - 2);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt32,The following statement contains a magic number: Advance(4);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt32,The following statement contains a magic number: return BitConverter.ToUInt32(_data' _position - 4);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt64,The following statement contains a magic number: Advance(8);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt64,The following statement contains a magic number: return BitConverter.ToUInt64(_data' _position - 8);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt16,The following statement contains a magic number: Advance(2);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt16,The following statement contains a magic number: return BitConverter.ToInt16(_data' _position - 2);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt32,The following statement contains a magic number: Advance(4);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt32,The following statement contains a magic number: return BitConverter.ToInt32(_data' _position - 4);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt64,The following statement contains a magic number: Advance(8);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt64,The following statement contains a magic number: return BitConverter.ToInt64(_data' _position - 8);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadSingle,The following statement contains a magic number: Advance(4);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadSingle,The following statement contains a magic number: return BitConverter.ToSingle(_data' _position - 4);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadDouble,The following statement contains a magic number: Advance(8);
Magic Number,AsmResolver,MemoryStreamReader,C:\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadDouble,The following statement contains a magic number: return BitConverter.ToDouble(_data' _position - 8);
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,C:\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageResourceDataEntry,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDataEntry.cs,GetPhysicalLength,The following statement contains a magic number: return 4 * sizeof (uint);
Magic Number,AsmResolver,ImageResourceDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            4 * sizeof (ushort) +                            Entries.Count * 2 * sizeof (uint));
Magic Number,AsmResolver,ImageResourceDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            4 * sizeof (ushort) +                            Entries.Count * 2 * sizeof (uint));
Magic Number,AsmResolver,ImageResourceDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            4 * sizeof (ushort) +                            Entries.Count * 2 * sizeof (uint));
Magic Number,AsmResolver,ImageResourceDirectoryEntry,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: entry.HasData = (entry.OffsetToData >> 31) == 0;
Magic Number,AsmResolver,ImageResourceDirectoryEntry,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: uint actualDataOffset = entry.OffsetToData & ~(1 << 31);
Magic Number,AsmResolver,ImageResourceDirectoryEntry,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: entry.HasName = (entry.NameId >> 31) == 1;
Magic Number,AsmResolver,ImageResourceDirectoryEntry,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: if (entry.HasName)              {                  entry._nameReadingContext =                      context.CreateSubContext(context.Assembly.RvaToFileOffset(resourceDirectory.VirtualAddress) +                                               (entry.NameId & ~(1 << 31)));              }
Magic Number,AsmResolver,ImageResourceDirectoryEntry,C:\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint);
Magic Number,AsmResolver.Builder,DirectoryTablesBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Builder\ResourceDirectoryBuilder.cs,UpdateReferences,The following statement contains a magic number: foreach (var entry in directory.Entries)                  {                      if (entry.HasData)                          entry.OffsetToData = (uint)(entry.DataEntry.StartOffset - resourcesFileOffset);                      else                          entry.OffsetToData = (uint)((entry.SubDirectory.StartOffset - resourcesFileOffset) | (1 << 31));                  }
Magic Number,AsmResolver.Net,BlobStreamBuffer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\BlobStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align(_length' 4);
Magic Number,AsmResolver.Net,GuidStream,C:\repos\JerreS_AsmResolver\AsmResolver\Net\GuidStream.cs,ReadGuid,The following statement contains a magic number: if (!_cachedGuids.TryGetValue(offset' out guid))                  _cachedGuids.Add(offset' guid = new Guid(reader.ReadBytes(16)));              else                  reader.Position += 16;
Magic Number,AsmResolver.Net,GuidStream,C:\repos\JerreS_AsmResolver\AsmResolver\Net\GuidStream.cs,ReadGuid,The following statement contains a magic number: if (!_cachedGuids.TryGetValue(offset' out guid))                  _cachedGuids.Add(offset' guid = new Guid(reader.ReadBytes(16)));              else                  reader.Position += 16;
Magic Number,AsmResolver.Net,GuidStreamBuffer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\GuidStream.cs,GetGuidOffset,The following statement contains a magic number: if (!_guidOffsetMapping.TryGetValue(guid' out offset))              {                  _guidOffsetMapping.Add(guid' offset = _length + 1);                  _length += 16;              }
Magic Number,AsmResolver.Net,ImageNetDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\ImageNetDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * dirLength +                     2 * sizeof (uint) +                     6 * dirLength;
Magic Number,AsmResolver.Net,ImageNetDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\ImageNetDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * dirLength +                     2 * sizeof (uint) +                     6 * dirLength;
Magic Number,AsmResolver.Net,ImageNetDirectory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\ImageNetDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * dirLength +                     2 * sizeof (uint) +                     6 * dirLength;
Magic Number,AsmResolver.Net,NetAssemblyFactory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeOptionalHeader,The following statement contains a magic number: optionalHeader.MajorOperatingSystemVersion = 4;
Magic Number,AsmResolver.Net,NetAssemblyFactory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeOptionalHeader,The following statement contains a magic number: optionalHeader.MajorSubsystemVersion = 4;
Magic Number,AsmResolver.Net,NetAssemblyFactory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeOptionalHeader,The following statement contains a magic number: optionalHeader.MajorLinkerVersion = 6;
Magic Number,AsmResolver.Net,NetAssemblyFactory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeNetDirectory,The following statement contains a magic number: directory.MajorRuntimeVersion = 2;
Magic Number,AsmResolver.Net,NetAssemblyFactory,C:\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeMetadata,The following statement contains a magic number: var tableStream = new TableStream              {                  SortedBitVector = 0x000016003325FA00'                  MajorVersion = 2'                  Reserved2 = 1              };
Magic Number,AsmResolver.Net,MetadataHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(1 * sizeof (uint) +                            2 * sizeof (ushort) +                            2 * sizeof (uint) +                            VersionLength +                            2 * sizeof (ushort) +                            StreamHeaders.Sum(x => x.GetPhysicalLength()));
Magic Number,AsmResolver.Net,MetadataHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(1 * sizeof (uint) +                            2 * sizeof (ushort) +                            2 * sizeof (uint) +                            VersionLength +                            2 * sizeof (ushort) +                            StreamHeaders.Sum(x => x.GetPhysicalLength()));
Magic Number,AsmResolver.Net,MetadataHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(1 * sizeof (uint) +                            2 * sizeof (ushort) +                            2 * sizeof (uint) +                            VersionLength +                            2 * sizeof (ushort) +                            StreamHeaders.Sum(x => x.GetPhysicalLength()));
Magic Number,AsmResolver.Net,MetadataStreamHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,FromReadingContext,The following statement contains a magic number: var header = new MetadataStreamHeader              {                  _readingContext = context'                    StartOffset = reader.Position'                    Offset = reader.ReadUInt32()'                  Size = reader.ReadUInt32()'                  Name = reader.ReadAlignedAsciiString(4)'                };
Magic Number,AsmResolver.Net,MetadataStreamHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,GetPhysicalLength,The following statement contains a magic number: var length = Align((uint)(Encoding.ASCII.GetByteCount(Name) + 1)' 4);
Magic Number,AsmResolver.Net,MetadataStreamHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) + length);
Magic Number,AsmResolver.Net,MetadataStreamHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,Write,The following statement contains a magic number: do              {                  context.Writer.WriteByte(0);                  length++;              } while (length % 4 != 0);
Magic Number,AsmResolver.Net,StringStreamBuffer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\StringStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align(_length' 4);
Magic Number,AsmResolver.Net,StringStreamBuffer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\StringStream.cs,Write,The following statement contains a magic number: writer.WriteZeroes((int)(Align(_length' 4) - _length));
Magic Number,AsmResolver.Net,TableStream,C:\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align((uint)(1 * sizeof (uint) +                                  4 * sizeof (byte) +                                  2 * sizeof (ulong) +                                  presentTables.Length * sizeof (uint) +                                  presentTables.Sum(x => x.GetPhysicalLength()))' 4);
Magic Number,AsmResolver.Net,TableStream,C:\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align((uint)(1 * sizeof (uint) +                                  4 * sizeof (byte) +                                  2 * sizeof (ulong) +                                  presentTables.Length * sizeof (uint) +                                  presentTables.Sum(x => x.GetPhysicalLength()))' 4);
Magic Number,AsmResolver.Net,TableStream,C:\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align((uint)(1 * sizeof (uint) +                                  4 * sizeof (byte) +                                  2 * sizeof (ulong) +                                  presentTables.Length * sizeof (uint) +                                  presentTables.Sum(x => x.GetPhysicalLength()))' 4);
Magic Number,AsmResolver.Net,TypeSystem,C:\repos\JerreS_AsmResolver\AsmResolver\Net\TypeSystem.cs,TypeSystem,The following statement contains a magic number: if (!isMsCorLib)              {                  MsCorLibReference = header.GetStream<TableStream>().GetTable<AssemblyReference>().FirstOrDefault(x => x.Name == "mscorlib");                  if (MsCorLibReference == null)                  {                      MsCorLibReference = new AssemblyReference(new ReflectionAssemblyNameWrapper(typeof(object).Assembly.GetName()))                      {                          Header = header'                          Culture = "neutral"'                          Version = new Version(header.VersionString[1] - 48' 0' 0' 0)                      };                  }              }
Magic Number,AsmResolver.Net,UserStringStream,C:\repos\JerreS_AsmResolver\AsmResolver\Net\UserStringStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align(_length' 4);
Magic Number,AsmResolver.Net,UserStringStreamBuffer,C:\repos\JerreS_AsmResolver\AsmResolver\Net\UserStringStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align(_length' 4);
Magic Number,AsmResolver.Net,VTableHeader,C:\repos\JerreS_AsmResolver\AsmResolver\Net\VTablesDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint)                     + 2 * sizeof (ushort);
Magic Number,AsmResolver.Net.Builder,MethodBodyTableBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Builder\MethodBodyTableBuilder.cs,UpdateOffsets,The following statement contains a magic number: for (int i = 0; i < Segments.Count; i++)              {                  if (i == 0)                      Segments[i].StartOffset = StartOffset;                  else                      Segments[i].StartOffset = Segments[i - 1].StartOffset + Segments[i - 1].GetPhysicalLength();                    var methodBody = Segments[i] as MethodBody;                  if (methodBody != null && methodBody.IsFat)                      methodBody.StartOffset = Align((uint)methodBody.StartOffset' 4);              }
Magic Number,AsmResolver.Net.Builder,NetAssemblyBuilder,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Builder\NetAssemblyBuilder.cs,UpdateRelocations,The following statement contains a magic number: if (Assembly.RelocationDirectory != null)              {                  var block = Assembly.RelocationDirectory.Blocks[0];                  var relocationRva = Assembly.NtHeaders.OptionalHeader.AddressOfEntrypoint + 2;                  block.PageRva = (uint)(relocationRva & ~0xFFF);                  block.Entries[0].Offset = (ushort)(relocationRva - block.PageRva);              }
Magic Number,AsmResolver.Net.Metadata,AssemblyDefinition,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\AssemblyDefinition.cs,ComputePublicKeyToken,The following statement contains a magic number: using (hashAlgorithm)              {                  var token = hashAlgorithm.ComputeHash(key);                  return token.Reverse().Take(8).ToArray();              }
Magic Number,AsmResolver.Net.Metadata,IndexEncoder,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\IndexEncoder.cs,IndexEncoder,The following statement contains a magic number: _tableIndexBitCount = (int)Math.Ceiling(Math.Log(tables.Length' 2));
Magic Number,AsmResolver.Net.Metadata,IndexEncoder,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\IndexEncoder.cs,IndexEncoder,The following statement contains a magic number: _tableIndexBitMask = (int)(Math.Pow(2' _tableIndexBitCount) - 1);
Magic Number,AsmResolver.Net.Metadata,MetadataTable,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MetadataTable.cs,GetMemberByKey,The following statement contains a magic number: while (left <= right)              {                  int m = (left + right) / 2;                  var member = GetMember(m);                  uint current = Convert.ToUInt32(member.MetadataRow.GetAllColumns().ElementAt(columnIndex));                    if (current > key)                      right = m - 1;                  else if (current < key)                      left = m + 1;                  else                      return member;              }
Magic Number,AsmResolver.Net.Signatures,ArrayMarshalDescriptor,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ArrayMarshalDescriptor.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (byte) +                     (ParameterIndex.HasValue                         ? ParameterIndex.Value.GetCompressedSize() +                           (NumberOfElements.HasValue ? NumberOfElements.Value.GetCompressedSize() : 0)                         : 0);
Magic Number,AsmResolver.Net.Signatures,CustomMarshalDescriptor,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\CustomMarshalDescriptor.cs,GetPhysicalLength,The following statement contains a magic number: return sizeof (byte) +                     sizeof(byte) + 38 +                     UnmanagedType.GetSerStringSize() +                     ManagedType.GetSerStringSize() +                     Cookie.GetSerStringSize();
Magic Number,AsmResolver.Net.Signatures,SafeArrayMarshalDescriptor,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\SafeArrayMarshalDescriptor.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (byte);
Magic Number,AsmResolver.Net.Signatures,SecurityAttributeSignature,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\SecurityAttributeSignature.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(TypeName.GetSerStringSize() +                            (NamedArguments.Count == 0                                ? 2 * sizeof (byte)                                : NamedArguments.Count.GetCompressedSize() +                                  argumentsSize.GetCompressedSize() +                                  argumentsSize));
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: if (hexString.Length % 2 != 0)                  throw new FormatException();
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: var bytes = new byte[hexString.Length / 2];
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)                  bytes[i] = byte.Parse(hexString.Substring(i * 2' 2)' NumberStyles.HexNumber);
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)                  bytes[i] = byte.Parse(hexString.Substring(i * 2' 2)' NumberStyles.HexNumber);
Magic Number,AsmResolver.Net.Msil,ExceptionHandler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\ExceptionHandler.cs,GetPhysicalLength,The following statement contains a magic number: if (IsFat)                  return 7 * sizeof (uint);
Magic Number,AsmResolver.Net.Msil,ExceptionHandler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\ExceptionHandler.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     1 * sizeof (byte) +                     1 * sizeof (ushort) +                     1 * sizeof (byte) +                     2 * sizeof (uint);
Magic Number,AsmResolver.Net.Msil,ExceptionHandler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\ExceptionHandler.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     1 * sizeof (byte) +                     1 * sizeof (ushort) +                     1 * sizeof (byte) +                     2 * sizeof (uint);
Magic Number,AsmResolver.Net.Msil,MsilAssembler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilAssembler.cs,WriteOpCode,The following statement contains a magic number: if (opCode.Size == 2)                  _writer.WriteByte(opCode.Op1);
Magic Number,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return 0;                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                  case MsilOperandType.ShortInlineI:                  case MsilOperandType.ShortInlineBrTarget:                      return 1;                  case MsilOperandType.InlineVar:                  case MsilOperandType.InlineArgument:                      return 2;                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                  case MsilOperandType.InlineBrTarget:                      return 4;                    case MsilOperandType.InlineR:                  case MsilOperandType.InlineI8:                      return 8;                    case MsilOperandType.InlineSwitch:                      var array = Operand as Array;                      if (array == null)                          return 4;                      return 4 * (array.GetLength(0) + 1);              }
Magic Number,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return 0;                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                  case MsilOperandType.ShortInlineI:                  case MsilOperandType.ShortInlineBrTarget:                      return 1;                  case MsilOperandType.InlineVar:                  case MsilOperandType.InlineArgument:                      return 2;                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                  case MsilOperandType.InlineBrTarget:                      return 4;                    case MsilOperandType.InlineR:                  case MsilOperandType.InlineI8:                      return 8;                    case MsilOperandType.InlineSwitch:                      var array = Operand as Array;                      if (array == null)                          return 4;                      return 4 * (array.GetLength(0) + 1);              }
Magic Number,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return 0;                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                  case MsilOperandType.ShortInlineI:                  case MsilOperandType.ShortInlineBrTarget:                      return 1;                  case MsilOperandType.InlineVar:                  case MsilOperandType.InlineArgument:                      return 2;                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                  case MsilOperandType.InlineBrTarget:                      return 4;                    case MsilOperandType.InlineR:                  case MsilOperandType.InlineI8:                      return 8;                    case MsilOperandType.InlineSwitch:                      var array = Operand as Array;                      if (array == null)                          return 4;                      return 4 * (array.GetLength(0) + 1);              }
Magic Number,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return 0;                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                  case MsilOperandType.ShortInlineI:                  case MsilOperandType.ShortInlineBrTarget:                      return 1;                  case MsilOperandType.InlineVar:                  case MsilOperandType.InlineArgument:                      return 2;                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                  case MsilOperandType.InlineBrTarget:                      return 4;                    case MsilOperandType.InlineR:                  case MsilOperandType.InlineI8:                      return 8;                    case MsilOperandType.InlineSwitch:                      var array = Operand as Array;                      if (array == null)                          return 4;                      return 4 * (array.GetLength(0) + 1);              }
Magic Number,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return 0;                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                  case MsilOperandType.ShortInlineI:                  case MsilOperandType.ShortInlineBrTarget:                      return 1;                  case MsilOperandType.InlineVar:                  case MsilOperandType.InlineArgument:                      return 2;                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                  case MsilOperandType.InlineBrTarget:                      return 4;                    case MsilOperandType.InlineR:                  case MsilOperandType.InlineI8:                      return 8;                    case MsilOperandType.InlineSwitch:                      var array = Operand as Array;                      if (array == null)                          return 4;                      return 4 * (array.GetLength(0) + 1);              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,FromReadingContext,The following statement contains a magic number: if ((bodyHeader & 0x3) == 0x3)              {                  reader.Position--;                  var fatBodyHeader = reader.ReadUInt16();                  var headerSize = (fatBodyHeader >> 12) * 4;                    var hasSections = (fatBodyHeader & 0x8) == 0x8;                  body.InitLocals = (fatBodyHeader & 0x10) == 0x10;                  body.MaxStack = reader.ReadUInt16();                  codeSize = reader.ReadUInt32();                    var localVarSig = reader.ReadUInt32();                  if (localVarSig != 0)                  {                      var header = method.Header;                      var tableStream = header.GetStream<TableStream>();                        MetadataMember signature;                      tableStream.TryResolveMember(new MetadataToken(localVarSig)' out signature);                      body.Signature = signature as StandAloneSignature;                  }                    if (hasSections)                  {                      body._sectionReadingContext = context.CreateSubContext(reader.Position + codeSize);                      body._sectionReadingContext.Reader.Align(4);                  }              }              else if ((bodyHeader & 0x2) == 0x2)              {                  codeSize = (uint)(bodyHeader >> 2);                  body.MaxStack = 8;              }              else                  throw new ArgumentException("Invalid method body header signature.");
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,FromReadingContext,The following statement contains a magic number: if ((bodyHeader & 0x3) == 0x3)              {                  reader.Position--;                  var fatBodyHeader = reader.ReadUInt16();                  var headerSize = (fatBodyHeader >> 12) * 4;                    var hasSections = (fatBodyHeader & 0x8) == 0x8;                  body.InitLocals = (fatBodyHeader & 0x10) == 0x10;                  body.MaxStack = reader.ReadUInt16();                  codeSize = reader.ReadUInt32();                    var localVarSig = reader.ReadUInt32();                  if (localVarSig != 0)                  {                      var header = method.Header;                      var tableStream = header.GetStream<TableStream>();                        MetadataMember signature;                      tableStream.TryResolveMember(new MetadataToken(localVarSig)' out signature);                      body.Signature = signature as StandAloneSignature;                  }                    if (hasSections)                  {                      body._sectionReadingContext = context.CreateSubContext(reader.Position + codeSize);                      body._sectionReadingContext.Reader.Align(4);                  }              }              else if ((bodyHeader & 0x2) == 0x2)              {                  codeSize = (uint)(bodyHeader >> 2);                  body.MaxStack = 8;              }              else                  throw new ArgumentException("Invalid method body header signature.");
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,FromReadingContext,The following statement contains a magic number: if ((bodyHeader & 0x3) == 0x3)              {                  reader.Position--;                  var fatBodyHeader = reader.ReadUInt16();                  var headerSize = (fatBodyHeader >> 12) * 4;                    var hasSections = (fatBodyHeader & 0x8) == 0x8;                  body.InitLocals = (fatBodyHeader & 0x10) == 0x10;                  body.MaxStack = reader.ReadUInt16();                  codeSize = reader.ReadUInt32();                    var localVarSig = reader.ReadUInt32();                  if (localVarSig != 0)                  {                      var header = method.Header;                      var tableStream = header.GetStream<TableStream>();                        MetadataMember signature;                      tableStream.TryResolveMember(new MetadataToken(localVarSig)' out signature);                      body.Signature = signature as StandAloneSignature;                  }                    if (hasSections)                  {                      body._sectionReadingContext = context.CreateSubContext(reader.Position + codeSize);                      body._sectionReadingContext.Reader.Align(4);                  }              }              else if ((bodyHeader & 0x2) == 0x2)              {                  codeSize = (uint)(bodyHeader >> 2);                  body.MaxStack = 8;              }              else                  throw new ArgumentException("Invalid method body header signature.");
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,FromReadingContext,The following statement contains a magic number: if ((bodyHeader & 0x3) == 0x3)              {                  reader.Position--;                  var fatBodyHeader = reader.ReadUInt16();                  var headerSize = (fatBodyHeader >> 12) * 4;                    var hasSections = (fatBodyHeader & 0x8) == 0x8;                  body.InitLocals = (fatBodyHeader & 0x10) == 0x10;                  body.MaxStack = reader.ReadUInt16();                  codeSize = reader.ReadUInt32();                    var localVarSig = reader.ReadUInt32();                  if (localVarSig != 0)                  {                      var header = method.Header;                      var tableStream = header.GetStream<TableStream>();                        MetadataMember signature;                      tableStream.TryResolveMember(new MetadataToken(localVarSig)' out signature);                      body.Signature = signature as StandAloneSignature;                  }                    if (hasSections)                  {                      body._sectionReadingContext = context.CreateSubContext(reader.Position + codeSize);                      body._sectionReadingContext.Reader.Align(4);                  }              }              else if ((bodyHeader & 0x2) == 0x2)              {                  codeSize = (uint)(bodyHeader >> 2);                  body.MaxStack = 8;              }              else                  throw new ArgumentException("Invalid method body header signature.");
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,FromReadingContext,The following statement contains a magic number: if ((bodyHeader & 0x3) == 0x3)              {                  reader.Position--;                  var fatBodyHeader = reader.ReadUInt16();                  var headerSize = (fatBodyHeader >> 12) * 4;                    var hasSections = (fatBodyHeader & 0x8) == 0x8;                  body.InitLocals = (fatBodyHeader & 0x10) == 0x10;                  body.MaxStack = reader.ReadUInt16();                  codeSize = reader.ReadUInt32();                    var localVarSig = reader.ReadUInt32();                  if (localVarSig != 0)                  {                      var header = method.Header;                      var tableStream = header.GetStream<TableStream>();                        MetadataMember signature;                      tableStream.TryResolveMember(new MetadataToken(localVarSig)' out signature);                      body.Signature = signature as StandAloneSignature;                  }                    if (hasSections)                  {                      body._sectionReadingContext = context.CreateSubContext(reader.Position + codeSize);                      body._sectionReadingContext.Reader.Align(4);                  }              }              else if ((bodyHeader & 0x2) == 0x2)              {                  codeSize = (uint)(bodyHeader >> 2);                  body.MaxStack = 8;              }              else                  throw new ArgumentException("Invalid method body header signature.");
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,MethodBody,The following statement contains a magic number: MaxStack = 8;
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ReadExceptionHandlers,The following statement contains a magic number: do              {                  sectionHeader = reader.ReadByte();                  if ((sectionHeader & 0x01) == 0x01)                  {                      var isFat = (sectionHeader & 0x40) == 0x40;                      var handlerCount = 0;                      if (isFat)                      {                          handlerCount = ((reader.ReadByte() |                                           (reader.ReadByte() << 0x08) |                                           reader.ReadByte() << 0x10) / 24);                      }                      else                      {                          handlerCount = reader.ReadByte() / 12;                          reader.ReadUInt16();                      }                        for (int i = 0; i < handlerCount; i++)                          yield return ExceptionHandler.FromReader(this' reader' isFat);                  }              } while ((sectionHeader & 0x80) == 0x80);
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ReadExceptionHandlers,The following statement contains a magic number: do              {                  sectionHeader = reader.ReadByte();                  if ((sectionHeader & 0x01) == 0x01)                  {                      var isFat = (sectionHeader & 0x40) == 0x40;                      var handlerCount = 0;                      if (isFat)                      {                          handlerCount = ((reader.ReadByte() |                                           (reader.ReadByte() << 0x08) |                                           reader.ReadByte() << 0x10) / 24);                      }                      else                      {                          handlerCount = reader.ReadByte() / 12;                          reader.ReadUInt16();                      }                        for (int i = 0; i < handlerCount; i++)                          yield return ExceptionHandler.FromReader(this' reader' isFat);                  }              } while ((sectionHeader & 0x80) == 0x80);
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Br_S:                      instruction.OpCode = MsilOpCodes.Br;                      break;                  case MsilCode.Leave_S:                      instruction.OpCode = MsilOpCodes.Leave;                      break;                  case MsilCode.Brfalse_S:                      instruction.OpCode = MsilOpCodes.Brfalse;                      break;                  case MsilCode.Brtrue_S:                      instruction.OpCode = MsilOpCodes.Brtrue;                      break;                  case MsilCode.Beq_S:                      instruction.OpCode = MsilOpCodes.Beq;                      break;                  case MsilCode.Bge_S:                      instruction.OpCode = MsilOpCodes.Bge;                      break;                  case MsilCode.Bge_Un_S:                      instruction.OpCode = MsilOpCodes.Bge_Un;                      break;                  case MsilCode.Bgt_S:                      instruction.OpCode = MsilOpCodes.Bgt;                      break;                  case MsilCode.Bgt_Un_S:                      instruction.OpCode = MsilOpCodes.Bgt_Un;                      break;                  case MsilCode.Ble_S:                      instruction.OpCode = MsilOpCodes.Ble;                      break;                  case MsilCode.Ble_Un_S:                      instruction.OpCode = MsilOpCodes.Ble_Un;                      break;                  case MsilCode.Blt_S:                      instruction.OpCode = MsilOpCodes.Blt;                      break;                  case MsilCode.Blt_Un_S:                      instruction.OpCode = MsilOpCodes.Blt_Un;                      break;                  case MsilCode.Bne_Un_S:                      instruction.OpCode = MsilOpCodes.Bne_Un;                      break;                    case MsilCode.Ldloc_S:                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Ldloca_S:                      instruction.OpCode = MsilOpCodes.Ldloca;                      break;                    case MsilCode.Ldloc_0:                  case MsilCode.Ldloc_1:                  case MsilCode.Ldloc_2:                  case MsilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Stloc_S:                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Stloc_0:                  case MsilCode.Stloc_1:                  case MsilCode.Stloc_2:                  case MsilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Ldarg_S:                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Ldarga_S:                      instruction.OpCode = MsilOpCodes.Ldarga;                      break;                    case MsilCode.Ldarg_0:                  case MsilCode.Ldarg_1:                  case MsilCode.Ldarg_2:                  case MsilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) this).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Starg_S:                      instruction.OpCode = MsilOpCodes.Starg;                      break;                    case MsilCode.Ldc_I4_0:                  case MsilCode.Ldc_I4_1:                  case MsilCode.Ldc_I4_2:                  case MsilCode.Ldc_I4_3:                  case MsilCode.Ldc_I4_4:                  case MsilCode.Ldc_I4_5:                  case MsilCode.Ldc_I4_6:                  case MsilCode.Ldc_I4_7:                  case MsilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_S:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_M1:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Br_S:                      instruction.OpCode = MsilOpCodes.Br;                      break;                  case MsilCode.Leave_S:                      instruction.OpCode = MsilOpCodes.Leave;                      break;                  case MsilCode.Brfalse_S:                      instruction.OpCode = MsilOpCodes.Brfalse;                      break;                  case MsilCode.Brtrue_S:                      instruction.OpCode = MsilOpCodes.Brtrue;                      break;                  case MsilCode.Beq_S:                      instruction.OpCode = MsilOpCodes.Beq;                      break;                  case MsilCode.Bge_S:                      instruction.OpCode = MsilOpCodes.Bge;                      break;                  case MsilCode.Bge_Un_S:                      instruction.OpCode = MsilOpCodes.Bge_Un;                      break;                  case MsilCode.Bgt_S:                      instruction.OpCode = MsilOpCodes.Bgt;                      break;                  case MsilCode.Bgt_Un_S:                      instruction.OpCode = MsilOpCodes.Bgt_Un;                      break;                  case MsilCode.Ble_S:                      instruction.OpCode = MsilOpCodes.Ble;                      break;                  case MsilCode.Ble_Un_S:                      instruction.OpCode = MsilOpCodes.Ble_Un;                      break;                  case MsilCode.Blt_S:                      instruction.OpCode = MsilOpCodes.Blt;                      break;                  case MsilCode.Blt_Un_S:                      instruction.OpCode = MsilOpCodes.Blt_Un;                      break;                  case MsilCode.Bne_Un_S:                      instruction.OpCode = MsilOpCodes.Bne_Un;                      break;                    case MsilCode.Ldloc_S:                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Ldloca_S:                      instruction.OpCode = MsilOpCodes.Ldloca;                      break;                    case MsilCode.Ldloc_0:                  case MsilCode.Ldloc_1:                  case MsilCode.Ldloc_2:                  case MsilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Stloc_S:                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Stloc_0:                  case MsilCode.Stloc_1:                  case MsilCode.Stloc_2:                  case MsilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Ldarg_S:                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Ldarga_S:                      instruction.OpCode = MsilOpCodes.Ldarga;                      break;                    case MsilCode.Ldarg_0:                  case MsilCode.Ldarg_1:                  case MsilCode.Ldarg_2:                  case MsilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) this).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Starg_S:                      instruction.OpCode = MsilOpCodes.Starg;                      break;                    case MsilCode.Ldc_I4_0:                  case MsilCode.Ldc_I4_1:                  case MsilCode.Ldc_I4_2:                  case MsilCode.Ldc_I4_3:                  case MsilCode.Ldc_I4_4:                  case MsilCode.Ldc_I4_5:                  case MsilCode.Ldc_I4_6:                  case MsilCode.Ldc_I4_7:                  case MsilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_S:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_M1:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Br_S:                      instruction.OpCode = MsilOpCodes.Br;                      break;                  case MsilCode.Leave_S:                      instruction.OpCode = MsilOpCodes.Leave;                      break;                  case MsilCode.Brfalse_S:                      instruction.OpCode = MsilOpCodes.Brfalse;                      break;                  case MsilCode.Brtrue_S:                      instruction.OpCode = MsilOpCodes.Brtrue;                      break;                  case MsilCode.Beq_S:                      instruction.OpCode = MsilOpCodes.Beq;                      break;                  case MsilCode.Bge_S:                      instruction.OpCode = MsilOpCodes.Bge;                      break;                  case MsilCode.Bge_Un_S:                      instruction.OpCode = MsilOpCodes.Bge_Un;                      break;                  case MsilCode.Bgt_S:                      instruction.OpCode = MsilOpCodes.Bgt;                      break;                  case MsilCode.Bgt_Un_S:                      instruction.OpCode = MsilOpCodes.Bgt_Un;                      break;                  case MsilCode.Ble_S:                      instruction.OpCode = MsilOpCodes.Ble;                      break;                  case MsilCode.Ble_Un_S:                      instruction.OpCode = MsilOpCodes.Ble_Un;                      break;                  case MsilCode.Blt_S:                      instruction.OpCode = MsilOpCodes.Blt;                      break;                  case MsilCode.Blt_Un_S:                      instruction.OpCode = MsilOpCodes.Blt_Un;                      break;                  case MsilCode.Bne_Un_S:                      instruction.OpCode = MsilOpCodes.Bne_Un;                      break;                    case MsilCode.Ldloc_S:                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Ldloca_S:                      instruction.OpCode = MsilOpCodes.Ldloca;                      break;                    case MsilCode.Ldloc_0:                  case MsilCode.Ldloc_1:                  case MsilCode.Ldloc_2:                  case MsilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Stloc_S:                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Stloc_0:                  case MsilCode.Stloc_1:                  case MsilCode.Stloc_2:                  case MsilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Ldarg_S:                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Ldarga_S:                      instruction.OpCode = MsilOpCodes.Ldarga;                      break;                    case MsilCode.Ldarg_0:                  case MsilCode.Ldarg_1:                  case MsilCode.Ldarg_2:                  case MsilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) this).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Starg_S:                      instruction.OpCode = MsilOpCodes.Starg;                      break;                    case MsilCode.Ldc_I4_0:                  case MsilCode.Ldc_I4_1:                  case MsilCode.Ldc_I4_2:                  case MsilCode.Ldc_I4_3:                  case MsilCode.Ldc_I4_4:                  case MsilCode.Ldc_I4_5:                  case MsilCode.Ldc_I4_6:                  case MsilCode.Ldc_I4_7:                  case MsilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_S:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_M1:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Br_S:                      instruction.OpCode = MsilOpCodes.Br;                      break;                  case MsilCode.Leave_S:                      instruction.OpCode = MsilOpCodes.Leave;                      break;                  case MsilCode.Brfalse_S:                      instruction.OpCode = MsilOpCodes.Brfalse;                      break;                  case MsilCode.Brtrue_S:                      instruction.OpCode = MsilOpCodes.Brtrue;                      break;                  case MsilCode.Beq_S:                      instruction.OpCode = MsilOpCodes.Beq;                      break;                  case MsilCode.Bge_S:                      instruction.OpCode = MsilOpCodes.Bge;                      break;                  case MsilCode.Bge_Un_S:                      instruction.OpCode = MsilOpCodes.Bge_Un;                      break;                  case MsilCode.Bgt_S:                      instruction.OpCode = MsilOpCodes.Bgt;                      break;                  case MsilCode.Bgt_Un_S:                      instruction.OpCode = MsilOpCodes.Bgt_Un;                      break;                  case MsilCode.Ble_S:                      instruction.OpCode = MsilOpCodes.Ble;                      break;                  case MsilCode.Ble_Un_S:                      instruction.OpCode = MsilOpCodes.Ble_Un;                      break;                  case MsilCode.Blt_S:                      instruction.OpCode = MsilOpCodes.Blt;                      break;                  case MsilCode.Blt_Un_S:                      instruction.OpCode = MsilOpCodes.Blt_Un;                      break;                  case MsilCode.Bne_Un_S:                      instruction.OpCode = MsilOpCodes.Bne_Un;                      break;                    case MsilCode.Ldloc_S:                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Ldloca_S:                      instruction.OpCode = MsilOpCodes.Ldloca;                      break;                    case MsilCode.Ldloc_0:                  case MsilCode.Ldloc_1:                  case MsilCode.Ldloc_2:                  case MsilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Stloc_S:                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Stloc_0:                  case MsilCode.Stloc_1:                  case MsilCode.Stloc_2:                  case MsilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Ldarg_S:                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Ldarga_S:                      instruction.OpCode = MsilOpCodes.Ldarga;                      break;                    case MsilCode.Ldarg_0:                  case MsilCode.Ldarg_1:                  case MsilCode.Ldarg_2:                  case MsilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) this).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Starg_S:                      instruction.OpCode = MsilOpCodes.Starg;                      break;                    case MsilCode.Ldc_I4_0:                  case MsilCode.Ldc_I4_1:                  case MsilCode.Ldc_I4_2:                  case MsilCode.Ldc_I4_3:                  case MsilCode.Ldc_I4_4:                  case MsilCode.Ldc_I4_5:                  case MsilCode.Ldc_I4_6:                  case MsilCode.Ldc_I4_7:                  case MsilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_S:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_M1:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeBranch,The following statement contains a magic number: int relativeOperand = operand.Offset - (instruction.Offset + 2);
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeVariable,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Ldloc:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Ldloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Ldloc_S;                      }                      break;                  case MsilCode.Ldloca:                      instruction.OpCode = MsilOpCodes.Ldloca_S;                      break;                  case MsilCode.Stloc:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Stloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Stloc_S;                      }                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeVariable,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Ldloc:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Ldloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Ldloc_S;                      }                      break;                  case MsilCode.Ldloca:                      instruction.OpCode = MsilOpCodes.Ldloca_S;                      break;                  case MsilCode.Stloc:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Stloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Stloc_S;                      }                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeArgument,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case MsilCode.Ldarg:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Ldarg_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Ldarg_S;                      }                      break;                  case MsilCode.Ldarga:                      instruction.OpCode = MsilOpCodes.Ldarga_S;                      break;              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeLdc,The following statement contains a magic number: if (value >= -1 && value <= 8)              {                  instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Ldc_I4_0.Op2 + value];                  instruction.Operand = null;              }              else if (value >= sbyte.MinValue && value <= sbyte.MaxValue)              {                  instruction.OpCode = MsilOpCodes.Ldc_I4_S;                  instruction.Operand = Convert.ToSByte(value);              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,Write,The following statement contains a magic number: if (IsFat)              {                  writer.WriteUInt16((ushort)((ExceptionHandlers.Count > 0 ? 0x8 : 0) |                                              (InitLocals ? 0x10 : 0) | 0x3003));                  writer.WriteUInt16((ushort)MaxStack);                  writer.WriteUInt32(GetCodeSize());                  writer.WriteUInt32(Signature == null ? 0 : Signature.MetadataToken.ToUInt32());              }              else              {                  writer.WriteByte((byte)(0x2 | GetCodeSize() << 2));              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,WriteExceptionHandlers,The following statement contains a magic number: writer.Align(4);
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,WriteExceptionHandlers,The following statement contains a magic number: if (useFatFormat)              {                  var byteLength = ExceptionHandlers.Count * 24;                  writer.WriteByte((byte)(byteLength & 0xFF));                  writer.WriteByte((byte)((byteLength & 0xFF00) >> 0x08));                  writer.WriteByte((byte)((byteLength & 0xFF0000) >> 0x10));              }              else              {                  writer.WriteByte((byte)(ExceptionHandlers.Count * 12));                  writer.WriteUInt16(0);              }
Magic Number,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,WriteExceptionHandlers,The following statement contains a magic number: if (useFatFormat)              {                  var byteLength = ExceptionHandlers.Count * 24;                  writer.WriteByte((byte)(byteLength & 0xFF));                  writer.WriteByte((byte)((byteLength & 0xFF00) >> 0x08));                  writer.WriteByte((byte)((byteLength & 0xFF0000) >> 0x10));              }              else              {                  writer.WriteByte((byte)(ExceptionHandlers.Count * 12));                  writer.WriteUInt16(0);              }
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: StackBehaviourPop = (MsilStackBehaviour)(flags >> 12 & 31);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: StackBehaviourPop = (MsilStackBehaviour)(flags >> 12 & 31);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: StackBehaviourPush = (MsilStackBehaviour)(flags >> 17 & 31);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: StackBehaviourPush = (MsilStackBehaviour)(flags >> 17 & 31);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: OperandType = (MsilOperandType)(flags & 31);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: OpCodeType = (MsilOpCodeType)(flags >> 9 & 7);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: OpCodeType = (MsilOpCodeType)(flags >> 9 & 7);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: Size = (flags >> 22 & 3);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: Size = (flags >> 22 & 3);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: Op1 = (byte)((ushort)value >> 8);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: FlowControl = (MsilFlowControl)(flags >> 5 & 15);
Magic Number,AsmResolver.Net.Msil,MsilOpCode,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilOpCode.cs,MsilOpCode,The following statement contains a magic number: FlowControl = (MsilFlowControl)(flags >> 5 & 15);
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,Write,The following statement contains a magic number: if (opcode.HasRegisterToken)              {                  var token = (byte)(ComputeRegisterTokenPart(opcode.OperandTypes1[mnemonicIndex]'                                          opcode.OperandSizes1[mnemonicIndex]' instruction.Operand1) |                                     ComputeRegisterTokenPart(opcode.OperandTypes2[mnemonicIndex]'                                         opcode.OperandSizes2[mnemonicIndex]' instruction.Operand2));                    if (opcode.HasOpCodeModifier)                  {                      token |= (byte)(mnemonicIndex << 3);                  }                    _writer.WriteByte(token);              }
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegisterTokenPart,The following statement contains a magic number: switch (method)              {                  case X86OperandType.Register:                  {                      return (byte)(ComputeRegisterToken((X86Register)operand.Value) << 3);                  }                  case X86OperandType.RegisterOrMemoryAddress:                  {                      return ComputeRegOrMemToken(operand);                  }              }
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegisterToken,The following statement contains a magic number: return (byte)((byte)(register) & 7);
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegOrMemToken,The following statement contains a magic number: var token = (byte)((byte)modifier << 6);
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegOrMemSibToken,The following statement contains a magic number: if (operand.ScaledIndex == null)                  token |= 0x20;              else              {                  token |= (byte)(ComputeRegisterToken(operand.ScaledIndex.Register) << 3);                  switch (operand.ScaledIndex.Multiplier)                  {                      case 1:                          break;                      case 2:                          token |= 0x40;                          break;                      case 4:                          token |= 0x80;                          break;                      case 8:                          token |= 0xC0;                          break;                      default:                          throw new ArgumentException("Operand has an invalid scaled index multiplier."' "operand");                  }              }
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegOrMemSibToken,The following statement contains a magic number: if (operand.ScaledIndex == null)                  token |= 0x20;              else              {                  token |= (byte)(ComputeRegisterToken(operand.ScaledIndex.Register) << 3);                  switch (operand.ScaledIndex.Multiplier)                  {                      case 1:                          break;                      case 2:                          token |= 0x40;                          break;                      case 4:                          token |= 0x80;                          break;                      case 8:                          token |= 0xC0;                          break;                      default:                          throw new ArgumentException("Operand has an invalid scaled index multiplier."' "operand");                  }              }
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegOrMemSibToken,The following statement contains a magic number: if (operand.ScaledIndex == null)                  token |= 0x20;              else              {                  token |= (byte)(ComputeRegisterToken(operand.ScaledIndex.Register) << 3);                  switch (operand.ScaledIndex.Multiplier)                  {                      case 1:                          break;                      case 2:                          token |= 0x40;                          break;                      case 4:                          token |= 0x80;                          break;                      case 8:                          token |= 0xC0;                          break;                      default:                          throw new ArgumentException("Operand has an invalid scaled index multiplier."' "operand");                  }              }
Magic Number,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegOrMemSibToken,The following statement contains a magic number: if (operand.ScaledIndex == null)                  token |= 0x20;              else              {                  token |= (byte)(ComputeRegisterToken(operand.ScaledIndex.Register) << 3);                  switch (operand.ScaledIndex.Multiplier)                  {                      case 1:                          break;                      case 2:                          token |= 0x40;                          break;                      case 4:                          token |= 0x80;                          break;                      case 8:                          token |= 0xC0;                          break;                      default:                          throw new ArgumentException("Operand has an invalid scaled index multiplier."' "operand");                  }              }
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadNextInstruction,The following statement contains a magic number: var mnemonicIndex = instruction.OpCode.HasOpCodeModifier ? (registerToken >> 3) & 7 : 0;
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadNextInstruction,The following statement contains a magic number: var mnemonicIndex = instruction.OpCode.HasOpCodeModifier ? (registerToken >> 3) & 7 : 0;
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following statement contains a magic number: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following statement contains a magic number: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following statement contains a magic number: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegOrMemOperand32,The following statement contains a magic number: var modifier = (X86RegOrMemModifier)(registerToken >> 6);
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The following statement contains a magic number: switch (operandType)              {                  case X86OperandType.None:                  case X86OperandType.ControlRegister:                  case X86OperandType.DebugRegister:                  case X86OperandType.StackRegister:                  case X86OperandType.Register:                  case X86OperandType.RegisterCl:                  case X86OperandType.RegisterDx:                  case X86OperandType.RegisterEax:                  case X86OperandType.RegisterAl:                  case X86OperandType.ImmediateOne:                  case X86OperandType.SegmentRegister:                  case X86OperandType.OpCodeRegister:                      break;                    case X86OperandType.DirectAddress:                  case X86OperandType.MemoryAddress:                      size += 4;                      break;                    case X86OperandType.RelativeOffset:                  case X86OperandType.ImmediateData:                      size += GetSize(operandSize);                      break;                    case X86OperandType.RegisterOrMemoryAddress:                  case X86OperandType.StackRegisterOrMemoryAddress:                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          size += 1;                      if (!(operand.Value is X86Register))                          size += 4;                      break;              }
Magic Number,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The following statement contains a magic number: switch (operandType)              {                  case X86OperandType.None:                  case X86OperandType.ControlRegister:                  case X86OperandType.DebugRegister:                  case X86OperandType.StackRegister:                  case X86OperandType.Register:                  case X86OperandType.RegisterCl:                  case X86OperandType.RegisterDx:                  case X86OperandType.RegisterEax:                  case X86OperandType.RegisterAl:                  case X86OperandType.ImmediateOne:                  case X86OperandType.SegmentRegister:                  case X86OperandType.OpCodeRegister:                      break;                    case X86OperandType.DirectAddress:                  case X86OperandType.MemoryAddress:                      size += 4;                      break;                    case X86OperandType.RelativeOffset:                  case X86OperandType.ImmediateData:                      size += GetSize(operandSize);                      break;                    case X86OperandType.RegisterOrMemoryAddress:                  case X86OperandType.StackRegisterOrMemoryAddress:                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          size += 1;                      if (!(operand.Value is X86Register))                          size += 4;                      break;              }
Magic Number,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Magic Number,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Magic Number,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Missing Default,AsmResolver.Net.Metadata,ReferenceImporter,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\ReferenceImporter.cs,GetCorLibSignature,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Boolean:                      return _typeSystem.Boolean;                  case TypeCode.Byte:                      return _typeSystem.Byte;                  case TypeCode.Char:                      return _typeSystem.Char;                  case TypeCode.Double:                      return _typeSystem.Double;                  case TypeCode.Int16:                      return _typeSystem.Int16;                  case TypeCode.Int32:                      return _typeSystem.Int32;                  case TypeCode.Int64:                      return _typeSystem.Int64;                  case TypeCode.SByte:                      return _typeSystem.SByte;                  case TypeCode.Single:                      return _typeSystem.Single;                  case TypeCode.String:                      return _typeSystem.String;                  case TypeCode.UInt16:                      return _typeSystem.UInt16;                  case TypeCode.UInt32:                      return _typeSystem.UInt32;                  case TypeCode.UInt64:                      return _typeSystem.UInt64;              }
Missing Default,AsmResolver.Net.Metadata,FieldRva,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\FieldRva.cs,ReadElement,The following switch statement is missing a default case: switch (elementType)              {                  case ElementType.I1:                      return reader.ReadSByte();                  case ElementType.I2:                      return reader.ReadInt16();                  case ElementType.I4:                      return reader.ReadInt32();                  case ElementType.I8:                      return reader.ReadInt64();                  case ElementType.U1:                      return reader.ReadByte();                  case ElementType.U2:                      return reader.ReadUInt16();                  case ElementType.U4:                      return reader.ReadUInt32();                  case ElementType.U8:                      return reader.ReadUInt64();                  case ElementType.R4:                      return reader.ReadSingle();                  case ElementType.R8:                      return reader.ReadDouble();              }
Missing Default,AsmResolver.Net.Signatures,CallingConventionSignature,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\CallingConventionSignature.cs,FromReader,The following switch statement is missing a default case: switch ((CallingConventionAttributes)flag & SignatureTypeMask)              {                  case CallingConventionAttributes.Default:                  case CallingConventionAttributes.C:                  case CallingConventionAttributes.ExplicitThis:                  case CallingConventionAttributes.FastCall:                  case CallingConventionAttributes.StdCall:                  case CallingConventionAttributes.ThisCall:                  case CallingConventionAttributes.VarArg:                      return MethodSignature.FromReader(header' reader);                  case CallingConventionAttributes.Property:                      return PropertySignature.FromReader(header' reader);                  case CallingConventionAttributes.Local:                      return LocalVariableSignature.FromReader(header' reader);                  case CallingConventionAttributes.GenericInstance:                      return GenericInstanceMethodSignature.FromReader(header' reader);                  case CallingConventionAttributes.Field:                      return FieldSignature.FromReader(header' reader);              }
Missing Default,AsmResolver.Net.Signatures,TypeNameParser,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,ReadTypeSignature,The following switch statement is missing a default case: switch (name[position])                  {                      case '*':                          return new PointerTypeSignature(elementType);                      case '&':                          return new ByReferenceTypeSignature(elementType);                      case '[':                          position++;                          if (name[position] == ']')                          {                              position++;                              return new SzArrayTypeSignature(elementType);                          }                            // TODO: support generic types + generic instances.                          break;                  }
Missing Default,AsmResolver.Net.Signatures,DataBlobSignature,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\DataBlobSignature.cs,InterpretData,The following switch statement is missing a default case: switch (constantType)              {                  case ElementType.Boolean:                      return Data[0] == 1;                  case ElementType.Char:                      return (char)BitConverter.ToUInt16(Data' 0);                  case ElementType.I1:                      return unchecked((sbyte)Data[0]);                  case ElementType.I2:                      return BitConverter.ToInt16(Data' 0);                  case ElementType.I4:                      return BitConverter.ToInt32(Data' 0);                  case ElementType.I8:                      return BitConverter.ToInt64(Data' 0);                  case ElementType.U1:                      return Data[0];                  case ElementType.U2:                      return BitConverter.ToUInt16(Data' 0);                  case ElementType.U4:                      return BitConverter.ToUInt32(Data' 0);                  case ElementType.U8:                      return BitConverter.ToUInt64(Data' 0);                  case ElementType.R4:                      return BitConverter.ToSingle(Data' 0);                  case ElementType.R8:                      return BitConverter.ToDouble(Data' 0);                  case ElementType.String:                      return Encoding.Unicode.GetString(Data);                  case ElementType.Class:                      return null;              }
Missing Default,AsmResolver.Net.Signatures,ElementSignature,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ElementSignature.cs,ReadValue,The following switch statement is missing a default case: switch (typeSignature.ElementType)              {                  case ElementType.Boolean:                      return reader.ReadByte() == 1;                  case ElementType.Char:                      return (char)reader.ReadUInt16();                  case ElementType.R4:                      return reader.ReadSingle();                  case ElementType.R8:                      return reader.ReadDouble();                  case ElementType.I1:                      return reader.ReadSByte();                  case ElementType.I2:                      return reader.ReadInt16();                  case ElementType.I4:                      return reader.ReadInt32();                  case ElementType.I8:                      return reader.ReadInt64();                  case ElementType.U1:                      return reader.ReadByte();                  case ElementType.U2:                      return reader.ReadUInt16();                  case ElementType.U4:                      return reader.ReadUInt32();                  case ElementType.U8:                      return reader.ReadUInt64();                  case ElementType.String:                      return reader.ReadSerString();                  case ElementType.Object:                      return ReadValue(header' TypeSignature.ReadFieldOrPropType(header' reader)' reader);                  case ElementType.Class:                  case ElementType.Enum:                  case ElementType.ValueType:                      var enumTypeDef = header.MetadataResolver.ResolveType(typeSignature);                      if (enumTypeDef == null)                          throw new MemberResolutionException(typeSignature);                        if (enumTypeDef.IsEnum)                          return ReadValue(header' enumTypeDef.GetEnumUnderlyingType()' reader);                      break;              }
Missing Default,AsmResolver.Net.Signatures,ElementSignature,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ElementSignature.cs,GetPhysicalLength,The following switch statement is missing a default case: switch(Type.GetTypeCode(Value.GetType()))              {                  case TypeCode.Boolean:                  case TypeCode.Byte:                  case TypeCode.SByte:                      return sizeof (byte);                  case TypeCode.Char:                  case TypeCode.Int16:                  case TypeCode.UInt16:                      return sizeof (ushort);                  case TypeCode.Single:                  case TypeCode.Int32:                  case TypeCode.UInt32:                      return sizeof(uint);                  case TypeCode.Double:                  case TypeCode.Int64:                  case TypeCode.UInt64:                      return sizeof (ulong);                  case TypeCode.String:                      return ((Value as string).GetSerStringSize());              }
Missing Default,AsmResolver.Net.Msil,ExceptionHandler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\ExceptionHandler.cs,FromReader,The following switch statement is missing a default case: switch (handler.HandlerType)              {                  case ExceptionHandlerType.Exception:                      handler.CatchType = (ITypeDefOrRef)((IOperandResolver)methodBody).ResolveMember(new MetadataToken(classTokenOrFilterOffset));                      break;                  case ExceptionHandlerType.Filter:                      handler.FilterStart = methodBody.GetInstructionByOffset((int)classTokenOrFilterOffset);                      break;              }
Missing Default,AsmResolver.Net.Msil,MsilAssembler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilAssembler.cs,WriteOperand,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType)              {                  case MsilOperandType.InlineArgument:                      _writer.WriteUInt16((ushort)_builder.GetParameterIndex((ParameterSignature)instruction.Operand));                      break;                  case MsilOperandType.ShortInlineArgument:                      _writer.WriteByte((byte)_builder.GetParameterIndex((ParameterSignature)instruction.Operand));                      break;                    case MsilOperandType.InlineVar:                      _writer.WriteUInt16((ushort)_builder.GetVariableIndex((VariableSignature)instruction.Operand));                      break;                  case MsilOperandType.ShortInlineVar:                      _writer.WriteByte((byte)_builder.GetVariableIndex((VariableSignature)instruction.Operand));                      break;                    case MsilOperandType.ShortInlineI:                      _writer.WriteSByte((sbyte)instruction.Operand);                      break;                  case MsilOperandType.InlineI:                      _writer.WriteInt32((int)instruction.Operand);                      break;                  case MsilOperandType.InlineI8:                      _writer.WriteInt64((long)instruction.Operand);                      break;                  case MsilOperandType.ShortInlineR:                      _writer.WriteSingle((float)instruction.Operand);                      break;                  case MsilOperandType.InlineR:                      _writer.WriteDouble((double)instruction.Operand);                      break;                    case MsilOperandType.InlineBrTarget:                      _writer.WriteInt32(((MsilInstruction)instruction.Operand).Offset -                          (instruction.Offset + instruction.Size));                      break;                    case MsilOperandType.ShortInlineBrTarget:                      _writer.WriteSByte((sbyte)(((MsilInstruction)instruction.Operand).Offset -                           (instruction.Offset + instruction.Size)));                      break;                    case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                      var token = _builder.GetMemberToken((MetadataMember)instruction.Operand);                      if (token.Rid == 0)                          throw new InvalidOperationException(string.Format("Member {0} has an invalid metadata token."'                              instruction.Operand));                      _writer.WriteUInt32(token.ToUInt32());                      break;                    case MsilOperandType.InlineString:                      _writer.WriteUInt32(_builder.GetStringOffset((string)instruction.Operand));                      break;                    case MsilOperandType.InlineSwitch:                      var targets = (MsilInstruction[])instruction.Operand;                      _writer.WriteInt32(targets.Length);                      foreach (var target in targets)                          _writer.WriteInt32(target.Offset - (instruction.Offset + instruction.Size));                      break;                    case MsilOperandType.InlineNone:                      break;              }
Missing Default,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,Create,The following switch statement is missing a default case: switch (code.OperandType)              {                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                      return new MsilInstruction(0' code' operand);              }
Missing Default,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,GetOperandSize,The following switch statement is missing a default case: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return 0;                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                  case MsilOperandType.ShortInlineI:                  case MsilOperandType.ShortInlineBrTarget:                      return 1;                  case MsilOperandType.InlineVar:                  case MsilOperandType.InlineArgument:                      return 2;                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                  case MsilOperandType.InlineBrTarget:                      return 4;                    case MsilOperandType.InlineR:                  case MsilOperandType.InlineI8:                      return 8;                    case MsilOperandType.InlineSwitch:                      var array = Operand as Array;                      if (array == null)                          return 4;                      return 4 * (array.GetLength(0) + 1);              }
Missing Default,AsmResolver.Net.Msil,MsilInstruction,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilInstruction.cs,OperandToString,The following switch statement is missing a default case: switch (OpCode.OperandType)              {                  case MsilOperandType.InlineNone:                      return string.Empty;                    case MsilOperandType.InlineArgument:                  case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.InlineVar:                  case MsilOperandType.ShortInlineVar:                      // TODO: return index                    case MsilOperandType.InlineR:                  case MsilOperandType.ShortInlineR:                  case MsilOperandType.InlineI:                  case MsilOperandType.InlineI8:                  case MsilOperandType.ShortInlineI:                      return Convert.ToString(Operand' CultureInfo.InvariantCulture);                    case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                      var member = Operand as IMetadataMember;                      return member != null                          ? member.ToString()                          : "TOKEN<0x" + ((MetadataToken) Operand) + ">";                    case MsilOperandType.InlineString:                      return Operand is string                          ? string.Format("\"{0}\""' Operand)                          : "TOKEN<0x" + ((MetadataToken) Operand) + ">";                  case MsilOperandType.InlineSwitch:                      return string.Join("' "' ((MsilInstruction[])Operand).Select(x => "IL_" + x.Offset.ToString("X4")));                    case MsilOperandType.InlineBrTarget:                  case MsilOperandType.ShortInlineBrTarget:                      return "IL_" + ((MsilInstruction)Operand).Offset.ToString("X4");              }
Missing Default,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,ExpandMacro,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case MsilCode.Br_S:                      instruction.OpCode = MsilOpCodes.Br;                      break;                  case MsilCode.Leave_S:                      instruction.OpCode = MsilOpCodes.Leave;                      break;                  case MsilCode.Brfalse_S:                      instruction.OpCode = MsilOpCodes.Brfalse;                      break;                  case MsilCode.Brtrue_S:                      instruction.OpCode = MsilOpCodes.Brtrue;                      break;                  case MsilCode.Beq_S:                      instruction.OpCode = MsilOpCodes.Beq;                      break;                  case MsilCode.Bge_S:                      instruction.OpCode = MsilOpCodes.Bge;                      break;                  case MsilCode.Bge_Un_S:                      instruction.OpCode = MsilOpCodes.Bge_Un;                      break;                  case MsilCode.Bgt_S:                      instruction.OpCode = MsilOpCodes.Bgt;                      break;                  case MsilCode.Bgt_Un_S:                      instruction.OpCode = MsilOpCodes.Bgt_Un;                      break;                  case MsilCode.Ble_S:                      instruction.OpCode = MsilOpCodes.Ble;                      break;                  case MsilCode.Ble_Un_S:                      instruction.OpCode = MsilOpCodes.Ble_Un;                      break;                  case MsilCode.Blt_S:                      instruction.OpCode = MsilOpCodes.Blt;                      break;                  case MsilCode.Blt_Un_S:                      instruction.OpCode = MsilOpCodes.Blt_Un;                      break;                  case MsilCode.Bne_Un_S:                      instruction.OpCode = MsilOpCodes.Bne_Un;                      break;                    case MsilCode.Ldloc_S:                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Ldloca_S:                      instruction.OpCode = MsilOpCodes.Ldloca;                      break;                    case MsilCode.Ldloc_0:                  case MsilCode.Ldloc_1:                  case MsilCode.Ldloc_2:                  case MsilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldloc;                      break;                    case MsilCode.Stloc_S:                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Stloc_0:                  case MsilCode.Stloc_1:                  case MsilCode.Stloc_2:                  case MsilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) this).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Stloc;                      break;                    case MsilCode.Ldarg_S:                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Ldarga_S:                      instruction.OpCode = MsilOpCodes.Ldarga;                      break;                    case MsilCode.Ldarg_0:                  case MsilCode.Ldarg_1:                  case MsilCode.Ldarg_2:                  case MsilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) this).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = MsilOpCodes.Ldarg;                      break;                    case MsilCode.Starg_S:                      instruction.OpCode = MsilOpCodes.Starg;                      break;                    case MsilCode.Ldc_I4_0:                  case MsilCode.Ldc_I4_1:                  case MsilCode.Ldc_I4_2:                  case MsilCode.Ldc_I4_3:                  case MsilCode.Ldc_I4_4:                  case MsilCode.Ldc_I4_5:                  case MsilCode.Ldc_I4_6:                  case MsilCode.Ldc_I4_7:                  case MsilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_S:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      break;                  case MsilCode.Ldc_I4_M1:                      instruction.OpCode = MsilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Missing Default,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,OptimizeMacro,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType)              {                  case MsilOperandType.InlineBrTarget:                      TryOptimizeBranch(instruction);                      break;                  case MsilOperandType.InlineVar:                      TryOptimizeVariable(instruction);                      break;                  case MsilOperandType.InlineArgument:                      TryOptimizeArgument(instruction);                      break;              }
Missing Default,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeBranch,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case MsilCode.Br:                      instruction.OpCode = MsilOpCodes.Br_S;                      break;                  case MsilCode.Leave:                      instruction.OpCode = MsilOpCodes.Leave_S;                      break;                  case MsilCode.Brfalse:                      instruction.OpCode = MsilOpCodes.Brfalse_S;                      break;                  case MsilCode.Brtrue:                      instruction.OpCode = MsilOpCodes.Brtrue_S;                      break;                  case MsilCode.Beq:                      instruction.OpCode = MsilOpCodes.Beq_S;                      break;                  case MsilCode.Bge:                      instruction.OpCode = MsilOpCodes.Bge_S;                      break;                  case MsilCode.Bge_Un:                      instruction.OpCode = MsilOpCodes.Bge_Un_S;                      break;                  case MsilCode.Bgt:                      instruction.OpCode = MsilOpCodes.Bgt_S;                      break;                  case MsilCode.Bgt_Un:                      instruction.OpCode = MsilOpCodes.Bgt_Un_S;                      break;                  case MsilCode.Ble:                      instruction.OpCode = MsilOpCodes.Ble_S;                      break;                  case MsilCode.Ble_Un:                      instruction.OpCode = MsilOpCodes.Ble_Un_S;                      break;                  case MsilCode.Blt:                      instruction.OpCode = MsilOpCodes.Blt_S;                      break;                  case MsilCode.Blt_Un:                      instruction.OpCode = MsilOpCodes.Blt_Un_S;                      break;                  case MsilCode.Bne_Un:                      instruction.OpCode = MsilOpCodes.Bne_Un_S;                      break;              }
Missing Default,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeVariable,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case MsilCode.Ldloc:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Ldloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Ldloc_S;                      }                      break;                  case MsilCode.Ldloca:                      instruction.OpCode = MsilOpCodes.Ldloca_S;                      break;                  case MsilCode.Stloc:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Stloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Stloc_S;                      }                      break;              }
Missing Default,AsmResolver.Net.Msil,MethodBody,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MethodBody.cs,TryOptimizeArgument,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case MsilCode.Ldarg:                      if (index <= 3)                      {                          instruction.OpCode = MsilOpCodes.SingleByteOpCodes[MsilOpCodes.Ldarg_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = MsilOpCodes.Ldarg_S;                      }                      break;                  case MsilCode.Ldarga:                      instruction.OpCode = MsilOpCodes.Ldarga_S;                      break;              }
Missing Default,AsmResolver.Net.Msil,MsilDisassembler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilDisassembler.cs,ReadRawOperand,The following switch statement is missing a default case: switch (msilOperandType)              {                  case MsilOperandType.InlineNone:                      return null;                    case MsilOperandType.InlineArgument:                  case MsilOperandType.InlineVar:                      return reader.ReadUInt16();                    case MsilOperandType.InlineI:                  case MsilOperandType.InlineBrTarget:                      return reader.ReadInt32();                    case MsilOperandType.ShortInlineArgument:                  case MsilOperandType.ShortInlineVar:                      return reader.ReadByte();                    case MsilOperandType.ShortInlineBrTarget:                  case MsilOperandType.ShortInlineI:                      return reader.ReadSByte();                    case MsilOperandType.ShortInlineR:                      return reader.ReadSingle();                  case MsilOperandType.InlineR:                      return reader.ReadDouble();                  case MsilOperandType.InlineI8:                      return reader.ReadInt64();                    case MsilOperandType.InlineField :                  case MsilOperandType.InlineMethod :                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                  case MsilOperandType.InlineString:                      return new MetadataToken(reader.ReadUInt32());                    case MsilOperandType.InlineSwitch:                      var offsets = new int[reader.ReadUInt32()];                      for (int i = 0; i < offsets.Length; i++)                          offsets[i] = reader.ReadInt32();                      return offsets;              }
Missing Default,AsmResolver.Net.Msil,MsilDisassembler,C:\repos\JerreS_AsmResolver\AsmResolver\Net\Msil\MsilDisassembler.cs,ResolveOperand,The following switch statement is missing a default case: switch (current.OpCode.OperandType)              {                  case MsilOperandType.InlineArgument:                  case MsilOperandType.ShortInlineArgument:                      var parameter = _resolver.ResolveParameter(Convert.ToInt32(current.Operand));                      if (parameter != null)                          current.Operand = parameter;                      break;                    case MsilOperandType.InlineVar:                  case MsilOperandType.ShortInlineVar:                      var variable = _resolver.ResolveVariable(Convert.ToInt32(current.Operand));                      if (variable != null)                          current.Operand = variable;                      break;                    case MsilOperandType.ShortInlineBrTarget:                  case MsilOperandType.InlineBrTarget:                      var targetInstruction = instructions.FirstOrDefault(                          x => x.Offset == nextOffset + Convert.ToInt32(current.Operand));                      if (targetInstruction != null)                          current.Operand = targetInstruction;                      break;                    case MsilOperandType.InlineField:                  case MsilOperandType.InlineMethod:                  case MsilOperandType.InlineSig:                  case MsilOperandType.InlineTok:                  case MsilOperandType.InlineType:                      var member = _resolver.ResolveMember((MetadataToken)current.Operand);                      if (member != null)                          current.Operand = member;                      break;                    case MsilOperandType.InlineString:                      var stringValue = _resolver.ResolveString(((MetadataToken)current.Operand).ToUInt32());                      if (stringValue != null)                          current.Operand = stringValue;                      break;                    case MsilOperandType.InlineSwitch:                      var targetOffsets = (int[])current.Operand;                      var targets = new MsilInstruction[targetOffsets.Length];                      for (int i = 0; i < targetOffsets.Length; i++)                          targets[i] = instructions.FirstOrDefault(                              x => x.Offset == nextOffset + targetOffsets[i]);                      current.Operand = targets;                      break;              }
Missing Default,AsmResolver.X86,X86Formatter,C:\repos\JerreS_AsmResolver\AsmResolver\X86\IX86Formatter.cs,FormatValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(value.GetType()))              {                  case TypeCode.Byte:                      return FormatByte((byte)value);                  case TypeCode.UInt16:                      return FormatWord((ushort)value);                  case TypeCode.UInt32:                      return FormatDword((uint)value);                  case TypeCode.UInt64:                      return FormatQword((ulong)value);              }
Missing Default,AsmResolver.X86,FasmX86Formatter,C:\repos\JerreS_AsmResolver\AsmResolver\X86\IX86Formatter.cs,FormatOperandUsagePrefix,The following switch statement is missing a default case: switch (operandUsage)              {                  case X86OperandUsage.Normal:                      return null;                  case X86OperandUsage.BytePointer:                      return "byte";                  case X86OperandUsage.WordPointer:                      return "word";                  case X86OperandUsage.DwordPointer:                      return "dword";                  case X86OperandUsage.FwordPointer:                      return "fword";              }
Missing Default,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteOperandValue,The following switch statement is missing a default case: switch (method)              {                  case X86OperandType.MemoryAddress:                  case X86OperandType.DirectAddress:                  case X86OperandType.ImmediateData:                  {                      WriteNumber(operand.Value' size);                      break;                  }                  case X86OperandType.RegisterOrMemoryAddress:                  {                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          _writer.WriteByte(ComputeRegOrMemSibToken(operand));                      else if (!(operand.Value is X86Register))                          WriteNumber(operand.Value' X86OperandSize.Dword);                      break;                  }                  case X86OperandType.RelativeOffset:                  {                      WriteNumber(Convert.ToUInt32(operand.Value) - (_writer.Position + sizeof (sbyte))' size);                      break;                  }              }
Missing Default,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegisterTokenPart,The following switch statement is missing a default case: switch (method)              {                  case X86OperandType.Register:                  {                      return (byte)(ComputeRegisterToken((X86Register)operand.Value) << 3);                  }                  case X86OperandType.RegisterOrMemoryAddress:                  {                      return ComputeRegOrMemToken(operand);                  }              }
Missing Default,AsmResolver.X86,X86Assembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,DetermineRegOrMemModifier,The following switch statement is missing a default case: switch (operand.OffsetType)                  {                      case X86OffsetType.None:                          return operand.OperandUsage == X86OperandUsage.Normal                              ? X86RegOrMemModifier.RegisterOnly                              : X86RegOrMemModifier.RegisterPointer;                      case X86OffsetType.Short:                          return X86RegOrMemModifier.RegisterDispShortPointer;                      case X86OffsetType.Long:                          return X86RegOrMemModifier.RegisterDispLongPointer;                  }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following switch statement is missing a default case: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadSignedImmediateData,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return _reader.ReadSByte();                  case X86OperandSize.Word:                      return _reader.ReadInt16();                  case X86OperandSize.Dword:                      return _reader.ReadInt32();                  case X86OperandSize.WordOrDword:                      return _reader.ReadInt32(); // TODO: use operand-size override opcode                  // TODO: fword              }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadImmediateData,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return _reader.ReadByte();                  case X86OperandSize.Word:                      return _reader.ReadUInt16();                  case X86OperandSize.Dword:                      return _reader.ReadUInt32();                  case X86OperandSize.WordOrDword:                      return _reader.ReadUInt32(); // TODO: use operand-size override opcode                      // TODO: fword              }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegisterSize,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return X86RegisterSize.Byte;                  case X86OperandSize.Word:                      return X86RegisterSize.Word;                  case X86OperandSize.Dword:                      return X86RegisterSize.Dword;                  case X86OperandSize.WordOrDword:                      return X86RegisterSize.Dword ; // TODO: use operand-size override opcode              }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetOperandType,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return X86OperandUsage.BytePointer;                  case X86OperandSize.Dword:                      return X86OperandUsage.DwordPointer;                  case X86OperandSize.WordOrDword:                      return X86OperandUsage.DwordPointer; // TODO: use operand-size override opcode                  case X86OperandSize.Fword:                      return X86OperandUsage.FwordPointer;              }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegOrMemOperand32,The following switch statement is missing a default case: switch (modifier)              {                  case X86RegOrMemModifier.RegisterDispShortPointer:                      operand.Offset = _reader.ReadSByte();                      operand.OffsetType = X86OffsetType.Short;                      break;                  case X86RegOrMemModifier.RegisterDispLongPointer:                      operand.Offset = _reader.ReadInt32();                      operand.OffsetType = X86OffsetType.Long;                      break;              }
Missing Default,AsmResolver.X86,X86Disassembler,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegisterFromToken,The following switch statement is missing a default case: switch (size)              {                  case X86RegisterSize.Byte:                      return register;                  case X86RegisterSize.Word:                      return register | X86Register.Ax;                  case X86RegisterSize.Dword:                      return register | X86Register.Eax;              }
Missing Default,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The following switch statement is missing a default case: switch (operandType)              {                  case X86OperandType.None:                  case X86OperandType.ControlRegister:                  case X86OperandType.DebugRegister:                  case X86OperandType.StackRegister:                  case X86OperandType.Register:                  case X86OperandType.RegisterCl:                  case X86OperandType.RegisterDx:                  case X86OperandType.RegisterEax:                  case X86OperandType.RegisterAl:                  case X86OperandType.ImmediateOne:                  case X86OperandType.SegmentRegister:                  case X86OperandType.OpCodeRegister:                      break;                    case X86OperandType.DirectAddress:                  case X86OperandType.MemoryAddress:                      size += 4;                      break;                    case X86OperandType.RelativeOffset:                  case X86OperandType.ImmediateData:                      size += GetSize(operandSize);                      break;                    case X86OperandType.RegisterOrMemoryAddress:                  case X86OperandType.StackRegisterOrMemoryAddress:                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          size += 1;                      if (!(operand.Value is X86Register))                          size += 4;                      break;              }
Missing Default,AsmResolver.X86,X86Instruction,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following switch statement is missing a default case: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Missing Default,AsmResolver.X86,X86Operand,C:\repos\JerreS_AsmResolver\AsmResolver\X86\X86Operand.cs,ToString,The following switch statement is missing a default case: switch (OperandUsage)              {                  case X86OperandUsage.Normal:                      return Value.ToString();                  case X86OperandUsage.BytePointer:                      return string.Format("byte [{0}]"' Value);                  case X86OperandUsage.DwordPointer:                      return string.Format("dword [{0}]"' Value);                  case X86OperandUsage.FwordPointer:                      return string.Format("fword [{0}]"' Value);              }
