Implementation smell,Namespace,Class,File,Method,Description
Long Method,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The method has 108 lines of code.
Complex Method,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,Cyclomatic complexity of the method is 16
Complex Method,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,Cyclomatic complexity of the method is 26
Complex Method,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeBranch,Cyclomatic complexity of the method is 16
Complex Method,AsmResolver.Net.Cil,CilInstructionFormatter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionFormatter.cs,FormatOperand,Cyclomatic complexity of the method is 11
Complex Method,AsmResolver.Net.Cil,CilMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilMethodBody.cs,ComputeMaxStack,Cyclomatic complexity of the method is 15
Complex Method,AsmResolver.Net.Cil,CilAssembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilAssembler.cs,WriteOperand,Cyclomatic complexity of the method is 17
Complex Method,AsmResolver.Net.Cil,CilDisassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilDisassembler.cs,ReadRawOperand,Cyclomatic complexity of the method is 11
Complex Method,AsmResolver.Net.Cil,CilDisassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilDisassembler.cs,ResolveOperand,Cyclomatic complexity of the method is 12
Complex Method,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,Cyclomatic complexity of the method is 12
Complex Method,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetStackPopCount,Cyclomatic complexity of the method is 9
Complex Method,AsmResolver.Net.Cts,MemberCloner,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MemberCloner.cs,DeclareMemberStubs,Cyclomatic complexity of the method is 8
Complex Method,AsmResolver.Net.Cts,MemberCloner,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MemberCloner.cs,CloneInstructions,Cyclomatic complexity of the method is 8
Complex Method,AsmResolver.Net.Cts,FieldRva,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldRva.cs,GetDataSize,Cyclomatic complexity of the method is 9
Complex Method,AsmResolver.Net.Cts,FieldRva,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldRva.cs,ReadElement,Cyclomatic complexity of the method is 10
Complex Method,AsmResolver.Net.Cts,ReferenceImporter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ReferenceImporter.cs,ImportTypeSignature,Cyclomatic complexity of the method is 15
Complex Method,AsmResolver.Net.Cts,ReferenceImporter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ReferenceImporter.cs,GetCorLibSignature,Cyclomatic complexity of the method is 19
Complex Method,AsmResolver.Net.Cts,DefaultMetadataResolver,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\IMetadataResolver.cs,ResolveType,Cyclomatic complexity of the method is 8
Complex Method,AsmResolver.Net.Emit,CompactNetTextContents,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\CompactNetTextContents.cs,CompactNetTextContents,Cyclomatic complexity of the method is 10
Complex Method,AsmResolver.Net.Emit,TableStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\TableStreamBuffer.cs,FinalizeTypeRow,Cyclomatic complexity of the method is 10
Complex Method,AsmResolver.Net.Metadata,FieldRvaTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\FieldRvaTable.cs,GetDataSize,Cyclomatic complexity of the method is 9
Complex Method,AsmResolver.Net.Metadata,MetadataTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MetadataTable.cs,GetRowIndexClosestToKey,Cyclomatic complexity of the method is 8
Complex Method,AsmResolver.Net.Signatures,ArrayTypeSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ArrayTypeSignature.cs,FromReader,Cyclomatic complexity of the method is 11
Complex Method,AsmResolver.Net.Signatures,DataBlobSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\DataBlobSignature.cs,InterpretData,Cyclomatic complexity of the method is 14
Complex Method,AsmResolver.Net.Signatures,ElementSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ElementSignature.cs,ReadValue,Cyclomatic complexity of the method is 18
Complex Method,AsmResolver.Net.Signatures,ElementSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ElementSignature.cs,Write,Cyclomatic complexity of the method is 16
Complex Method,AsmResolver.Net.Signatures,TypeSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeSignature.cs,ReadTypeSignature,Cyclomatic complexity of the method is 16
Complex Method,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,Cyclomatic complexity of the method is 12
Long Parameter List,AsmResolver.Net.Cts.Collections,RangedMemberCollection<TOwner;TMember>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\Collections\RangedMemberCollection.cs,RangedMemberCollection,The method has 5 parameters. Parameters: owner' itemTable' listColumnIndex' getOwner' setOwner
Long Parameter List,AsmResolver.Net.Cts.Collections,RangedMemberCollection<TOwner;TMember>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\Collections\RangedMemberCollection.cs,RangedMemberCollection,The method has 5 parameters. Parameters: owner' itemTable' listColumnIndex' getOwner' setOwner
Long Parameter List,AsmResolver.Net.Cts,ExportedType,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ExportedType.cs,ExportedType,The method has 5 parameters. Parameters: implementation' typeDefId' name' namespace' attributes
Long Parameter List,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The method has 5 parameters. Parameters: prefixes' method' size' opcode' registerToken
Long Parameter List,AsmResolver.X86,X86OpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86OpCode.cs,X86OpCode,The method has 5 parameters. Parameters: mnemonics' opcodeValue' operands12Value' hasRegisterToken' hasOpCodeModifier
Long Parameter List,AsmResolver.X86,X86OpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86OpCode.cs,X86OpCode,The method has 6 parameters. Parameters: mnemonics' opcodeValue' operands12Value' operands34Value' hasRegisterToken' hasOpCodeModifier
Long Parameter List,AsmResolver.X86,X86OpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86OpCode.cs,X86OpCode,The method has 6 parameters. Parameters: mnemonics' opcodeValue' operandTypes1' sizes1' operandTypes2' sizes2
Long Parameter List,AsmResolver.X86,X86Operand,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Operand.cs,X86Operand,The method has 5 parameters. Parameters: operandUsage' value' scaledIndex' offset' offsetType
Long Identifier,AsmResolver,ImageDataDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageDataDirectory.cs,,The length of the parameter DelayImportDescrDirectoryIndex is 30.
Long Identifier,AsmResolver.X86,X86OpCodes,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\MultiByteOpCodes.cs,,The length of the parameter IMul_Reg1632_RegOrMem1632_Imm1632 is 33.
Long Identifier,AsmResolver.X86,X86OpCodes,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\MultiByteOpCodes.cs,,The length of the parameter IMul_Reg1632_RegOrMem1632_Imm8 is 30.
Long Statement,AsmResolver.Emit,ImportDirectoryBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Emit\ImportDirectoryBuffer.cs,UpdateTableRvas,The length of the statement  "                module.ImportLookupTableRva = (uint)_offsetConverter.FileOffsetToRva(LookupTables.GetModuleLookupTable(module).StartOffset); " is 124.
Long Statement,AsmResolver.Emit,ImportDirectoryBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Emit\ImportDirectoryBuffer.cs,UpdateTableRvas,The length of the statement  "                module.ImportAddressTableRva = (uint)_offsetConverter.FileOffsetToRva(AddressTables.GetModuleLookupTable(module).StartOffset); " is 126.
Long Statement,AsmResolver.Net,VTableHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\VTableHeader.cs,FromReadingContext,The length of the statement  "            var tokensReader = readingContext.Reader.CreateSubReader(fileOffset' size * (tableHeader.Is32Bit ? sizeof (int) : sizeof (long))); " is 130.
Long Statement,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The length of the statement  "                    instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48); " is 131.
Long Statement,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The length of the statement  "                    instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48); " is 131.
Long Statement,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The length of the statement  "                    instruction.Operand = ((IOperandResolver) Owner).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48); " is 132.
Long Statement,AsmResolver.Net.Cts,MemberCloner,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MemberCloner.cs,CloneCustomAttributes,The length of the statement  "                var newAttribute = new CustomAttribute((ICustomAttributeType) _importer.ImportReference(attribute.Constructor)' signature); " is 123.
Long Statement,AsmResolver.Net.Emit,BootstrapperSegment,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\BootstrapperSegment.cs,UpdateReferences,The length of the statement  "                throw new ArgumentException(".NET bootstrapper requires a reference to mscoree.dll!_CorDllMain or mscoree.dll!_CorExeMain."); " is 125.
Long Statement,AsmResolver.Net.Emit,BootstrapperSegment,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\BootstrapperSegment.cs,UpdateReferences,The length of the statement  "            _addressSegment.Data = BitConverter.GetBytes((uint)(address | context.Builder.Assembly.NtHeaders.OptionalHeader.ImageBase)); " is 124.
Long Statement,AsmResolver.Net.Emit,CompactNetTextContents,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\CompactNetTextContents.cs,UpdateNetDirectory,The length of the statement  "                NetDirectory.ResourcesDirectory.VirtualAddress = (uint) assembly.FileOffsetToRva(NetDirectory.ResourcesManifest.StartOffset); " is 125.
Long Statement,AsmResolver.Net.Emit,TableStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\TableStreamBuffer.cs,GetMemberReferenceToken,The length of the statement  "                    Column1 = _tableStream.GetIndexEncoder(CodedIndex.MemberRefParent).EncodeToken(GetMemberRefParentToken(reference.Parent))' " is 122.
Long Statement,AsmResolver.Net.Emit,TableStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\TableStreamBuffer.cs,AddAssembly,The length of the statement  "            var assemblyRow = new MetadataRow<AssemblyHashAlgorithm' ushort' ushort' ushort' ushort' AssemblyAttributes' uint' uint' uint> " is 126.
Long Statement,AsmResolver.Net.Emit,TableStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\TableStreamBuffer.cs,AddCustomAttribute,The length of the statement  "                Column2 = _tableStream.GetIndexEncoder(CodedIndex.CustomAttributeType).EncodeToken(GetMethodToken(attribute.Constructor))' " is 122.
Long Statement,AsmResolver.Net.Metadata,AssemblyDefinitionTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\AssemblyDefinitionTable.cs,ReadRow,The length of the statement  "            return new MetadataRow<AssemblyHashAlgorithm' ushort' ushort' ushort' ushort' AssemblyAttributes' uint' uint' uint>(token) " is 122.
Long Statement,AsmResolver.Net.Metadata,FieldRvaTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\FieldRvaTable.cs,GetDataSize,The length of the statement  "            var blobReader = TableStream.MetadataHeader.GetStream<BlobStream>().CreateBlobReader(fieldTable[(int) (fieldRid - 1)].Column3); " is 127.
Long Statement,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,ComputeSize,The length of the statement  "                size += GetTotalOperandSize(Prefixes' OpCode.OperandTypes1[mnemonicIndex]' OpCode.OperandSizes1[mnemonicIndex]' Operand1); " is 122.
Long Statement,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,ComputeSize,The length of the statement  "                    size += GetTotalOperandSize(Prefixes' OpCode.OperandTypes2[mnemonicIndex]' OpCode.OperandSizes2[mnemonicIndex]' Operand2); " is 122.
Complex Conditional,AsmResolver,BinaryStreamReaderExtensions,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamReader.cs,TryReadCompressedUInt32,The conditional expression  "((firstByte & 0x80) == 0 && reader.CanRead(sizeof(byte))) ||                  ((firstByte & 0x40) == 0 && reader.CanRead(sizeof(ushort))) ||                  (reader.CanRead(sizeof(uint)))"  is complex.
Complex Conditional,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The conditional expression  "!((string.IsNullOrEmpty(info1.Culture) || info1.Culture == "neutral")                        && (string.IsNullOrEmpty(info2.Culture) || info2.Culture == "neutral"))"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteOperandValue,The conditional expression  "(operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp)"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteNumber,The conditional expression  "value is sbyte || value is short || value is int || value is long"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteNumber,The conditional expression  "value is sbyte || value is short || value is int || value is long"  is complex.
Complex Conditional,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteNumber,The conditional expression  "value is sbyte || value is short || value is int || value is long"  is complex.
Complex Conditional,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The conditional expression  "(operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp)"  is complex.
Virtual Method Call from Constructor,AsmResolver.Net.Cts.Collections,RangedMemberCollection<TOwner;TMember>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\Collections\RangedMemberCollection.cs,RangedMemberCollection,The constructor "RangedMemberCollection" calls a virtual method "GetRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts.Collections,RangedMemberCollection<TOwner;TMember>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\Collections\RangedMemberCollection.cs,RangedMemberCollection,The constructor "RangedMemberCollection" calls a virtual method "GetAllColumns".
Virtual Method Call from Constructor,AsmResolver.Net.Cts.Collections,RangedMemberCollection<TOwner;TMember>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\Collections\RangedMemberCollection.cs,RangedMemberCollection,The constructor "RangedMemberCollection" calls a virtual method "GetRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts.Collections,RangedMemberCollection<TOwner;TMember>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\Collections\RangedMemberCollection.cs,RangedMemberCollection,The constructor "RangedMemberCollection" calls a virtual method "GetAllColumns".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,AssemblyRefOs,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\AssemblyRefOs.cs,AssemblyRefOs,The constructor "AssemblyRefOs" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,AssemblyRefProcessor,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\AssemblyRefProcessor.cs,AssemblyRefProcessor,The constructor "AssemblyRefProcessor" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,ClassLayout,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ClassLayout.cs,ClassLayout,The constructor "ClassLayout" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,EventDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\EventDefinition.cs,EventDefinition,The constructor "EventDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,EventMap,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\EventMap.cs,EventMap,The constructor "EventMap" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The constructor "FieldDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The constructor "FieldDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The constructor "FieldDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The constructor "FieldDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The constructor "FieldDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The constructor "FieldDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldLayout,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldLayout.cs,FieldLayout,The constructor "FieldLayout" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldMarshal,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldMarshal.cs,FieldMarshal,The constructor "FieldMarshal" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldRva,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldRva.cs,FieldRva,The constructor "FieldRva" calls a virtual method "GetRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,FieldRva,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldRva.cs,FieldRva,The constructor "FieldRva" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,GenericParameterConstraint,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\GenericParameterConstraint.cs,GenericParameterConstraint,The constructor "GenericParameterConstraint" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,ImplementationMap,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ImplementationMap.cs,ImplementationMap,The constructor "ImplementationMap" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,InterfaceImplementation,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\InterfaceImplementation.cs,InterfaceImplementation,The constructor "InterfaceImplementation" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,MetadataImage,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MetadataImage.cs,MetadataImage,The constructor "MetadataImage" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,MethodDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodDefinition.cs,MethodDefinition,The constructor "MethodDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,MethodDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodDefinition.cs,MethodDefinition,The constructor "MethodDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,MethodImplementation,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodImplementation.cs,MethodImplementation,The constructor "MethodImplementation" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,MethodSemantics,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodSemantics.cs,MethodSemantics,The constructor "MethodSemantics" calls a virtual method "GetRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,MethodSemantics,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodSemantics.cs,MethodSemantics,The constructor "MethodSemantics" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,NestedClass,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\NestedClass.cs,NestedClass,The constructor "NestedClass" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,NestedClass,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\NestedClass.cs,NestedClass,The constructor "NestedClass" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,ParameterDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ParameterDefinition.cs,ParameterDefinition,The constructor "ParameterDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,ParameterDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ParameterDefinition.cs,ParameterDefinition,The constructor "ParameterDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,ParameterDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ParameterDefinition.cs,ParameterDefinition,The constructor "ParameterDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,PropertyDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\PropertyDefinition.cs,PropertyDefinition,The constructor "PropertyDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,PropertyDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\PropertyDefinition.cs,PropertyDefinition,The constructor "PropertyDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,PropertyMap,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\PropertyMap.cs,PropertyMap,The constructor "PropertyMap" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,PropertyMap,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\PropertyMap.cs,PropertyMap,The constructor "PropertyMap" calls a virtual method "GetRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The constructor "TypeDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The constructor "TypeDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The constructor "TypeDefinition" calls a virtual method "GetMemberFromRow".
Virtual Method Call from Constructor,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The constructor "TypeDefinition" calls a virtual method "GetMemberFromRow".
Magic Number,AsmResolver,BaseRelocationBlock,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationBlock.cs,FromReadingContext,The following statement contains a magic number: block._entriesReadingContext = context.CreateSubContext(reader.Position' (int)(block.BlockSize - (2 * sizeof (uint))));
Magic Number,AsmResolver,BaseRelocationBlock,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationBlock.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            Entries.Count * sizeof (ushort));
Magic Number,AsmResolver,BaseRelocationEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationEntry.cs,FromReadingContext,The following statement contains a magic number: return new BaseRelocationEntry((BaseRelocationType) (value >> 12)' (ushort) (value & 0x0FFF))              {                  StartOffset = offset              };
Magic Number,AsmResolver,BaseRelocationEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\BaseRelocationEntry.cs,Write,The following statement contains a magic number: context.Writer.WriteUInt16((ushort)((ushort)Type << 12 | (Offset & 0x0FFF)));
Magic Number,AsmResolver,HintName,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\HintName.cs,FromReadingContext,The following statement contains a magic number: reader.Position % 2 != 0
Magic Number,AsmResolver,HintName,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\HintName.cs,GetPhysicalLength,The following statement contains a magic number: (StartOffset + size) % 2 != 0
Magic Number,AsmResolver,HintName,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\HintName.cs,Write,The following statement contains a magic number: writer.Position % 2 != 0
Magic Number,AsmResolver,BinaryStreamReaderExtensions,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamReader.cs,ReadCompressedUInt32,The following statement contains a magic number: return (uint)(((firstByte & 0x7F) << 8) | reader.ReadByte());
Magic Number,AsmResolver,ImageDataDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageDataDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint);
Magic Number,AsmResolver,ImageImportDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageImportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)((ModuleImports.Count + 1) * 5 * sizeof (uint));
Magic Number,AsmResolver,ImageRelocationDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageRelocationDirectory.cs,FromReadingContext,The following statement contains a magic number: context.Reader.Position += block.BlockSize - 2 * sizeof (uint);
Magic Number,AsmResolver,ImageExportDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageExportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) +                     2 * sizeof (ushort) +                     7 * sizeof (uint);
Magic Number,AsmResolver,ImageExportDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageExportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) +                     2 * sizeof (ushort) +                     7 * sizeof (uint);
Magic Number,AsmResolver,ImageExportDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageExportDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) +                     2 * sizeof (ushort) +                     7 * sizeof (uint);
Magic Number,AsmResolver,ImageFileHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageFileHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     3 * sizeof (uint) +                     2 * sizeof (ushort);
Magic Number,AsmResolver,ImageFileHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageFileHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     3 * sizeof (uint) +                     2 * sizeof (ushort);
Magic Number,AsmResolver,ImageFileHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageFileHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (ushort) +                     3 * sizeof (uint) +                     2 * sizeof (ushort);
Magic Number,AsmResolver,ImageSymbolImport,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSymbolImport.cs,FromReadingContext,The following statement contains a magic number: import.IsImportByOrdinal = import.Lookup >> (optionalHeader.Magic == OptionalHeaderMagic.Pe32Plus ? 63 : 31) == 1;
Magic Number,AsmResolver,ImageSymbolImport,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSymbolImport.cs,FromReadingContext,The following statement contains a magic number: import.IsImportByOrdinal = import.Lookup >> (optionalHeader.Magic == OptionalHeaderMagic.Pe32Plus ? 63 : 31) == 1;
Magic Number,AsmResolver,ImageSectionHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,FromReadingContext,The following statement contains a magic number: var header = new ImageSectionHeader              {                  StartOffset = reader.Position'                  Name = Encoding.ASCII.GetString(reader.ReadBytes(8))'                  VirtualSize = reader.ReadUInt32()'                  VirtualAddress = reader.ReadUInt32()'                  SizeOfRawData = reader.ReadUInt32()'                  PointerToRawData = reader.ReadUInt32()'                  PointerToRelocations = reader.ReadUInt32()'                  PointerToLinenumbers = reader.ReadUInt32()'                  NumberOfRelocations = reader.ReadUInt16()'                  NumberOfLinenumbers = reader.ReadUInt16()'                  Attributes = (ImageSectionAttributes)reader.ReadUInt32()'                                };
Magic Number,AsmResolver,ImageSectionHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 8 * sizeof(byte) +                     6 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * sizeof (uint);
Magic Number,AsmResolver,ImageSectionHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 8 * sizeof(byte) +                     6 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * sizeof (uint);
Magic Number,AsmResolver,ImageSectionHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 8 * sizeof(byte) +                     6 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * sizeof (uint);
Magic Number,AsmResolver,ImageSectionHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageSectionHeader.cs,Write,The following statement contains a magic number: writer.WriteBytes(new byte[8 - nameBytes.Length]);
Magic Number,AsmResolver,ImageModuleImport,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageModuleImport.cs,GetPhysicalLength,The following statement contains a magic number: return 5 * sizeof (uint);
Magic Number,AsmResolver,OutputStreamExtensions,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamWriter.cs,GetCompressedSize,The following statement contains a magic number: return 2;
Magic Number,AsmResolver,OutputStreamExtensions,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\IBinaryStreamWriter.cs,GetCompressedSize,The following statement contains a magic number: return 4;
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt16,The following statement contains a magic number: Advance(2);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt16,The following statement contains a magic number: return BitConverter.ToUInt16(_data' _position - 2);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt32,The following statement contains a magic number: Advance(4);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt32,The following statement contains a magic number: return BitConverter.ToUInt32(_data' _position - 4);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt64,The following statement contains a magic number: Advance(8);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadUInt64,The following statement contains a magic number: return BitConverter.ToUInt64(_data' _position - 8);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt16,The following statement contains a magic number: Advance(2);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt16,The following statement contains a magic number: return BitConverter.ToInt16(_data' _position - 2);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt32,The following statement contains a magic number: Advance(4);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt32,The following statement contains a magic number: return BitConverter.ToInt32(_data' _position - 4);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt64,The following statement contains a magic number: Advance(8);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadInt64,The following statement contains a magic number: return BitConverter.ToInt64(_data' _position - 8);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadSingle,The following statement contains a magic number: Advance(4);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadSingle,The following statement contains a magic number: return BitConverter.ToSingle(_data' _position - 4);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadDouble,The following statement contains a magic number: Advance(8);
Magic Number,AsmResolver,MemoryStreamReader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\MemoryStreamReader.cs,ReadDouble,The following statement contains a magic number: return BitConverter.ToDouble(_data' _position - 8);
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,ImageOptionalHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageOptionalHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(sizeof (ushort) +                            2 * sizeof (byte) +                            5 * sizeof (uint) +                              sizeof (ulong) + // 2x uint or 1x ulong                              2 * sizeof (uint) +                            6 * sizeof (ushort) +                            4 * sizeof (uint) +                            2 * sizeof (ushort) +                              4 * (Magic == OptionalHeaderMagic.Pe32 ? sizeof (uint) : sizeof (ulong)) +                              2 * sizeof (uint) +                            DataDirectories.Count * DataDirectories[0].GetPhysicalLength());
Magic Number,AsmResolver,PointerSegment,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\PointerSegment.cs,GetPhysicalLength,The following statement contains a magic number: return Is32Bit ? 4u : 8u;
Magic Number,AsmResolver,PointerSegment,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\PointerSegment.cs,GetPhysicalLength,The following statement contains a magic number: return Is32Bit ? 4u : 8u;
Magic Number,AsmResolver,ImageResourceDataEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDataEntry.cs,GetPhysicalLength,The following statement contains a magic number: return 4 * sizeof (uint);
Magic Number,AsmResolver,ImageResourceDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            4 * sizeof (ushort) +                            Entries.Count * 2 * sizeof (uint));
Magic Number,AsmResolver,ImageResourceDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            4 * sizeof (ushort) +                            Entries.Count * 2 * sizeof (uint));
Magic Number,AsmResolver,ImageResourceDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(2 * sizeof (uint) +                            4 * sizeof (ushort) +                            Entries.Count * 2 * sizeof (uint));
Magic Number,AsmResolver,ImageResourceDirectoryEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: entry.HasData = (entry.OffsetToData >> 31) == 0;
Magic Number,AsmResolver,ImageResourceDirectoryEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: uint actualDataOffset = entry.OffsetToData & ~(1 << 31);
Magic Number,AsmResolver,ImageResourceDirectoryEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: entry.HasName = (entry.NameId >> 31) == 1;
Magic Number,AsmResolver,ImageResourceDirectoryEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,FromReadingContext,The following statement contains a magic number: entry._nameReadingContext =                      context.CreateSubContext(context.Assembly.RvaToFileOffset(resourceDirectory.VirtualAddress) +                                               (entry.NameId & ~(1 << 31)));
Magic Number,AsmResolver,ImageResourceDirectoryEntry,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\ImageResourceDirectoryEntry.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint);
Magic Number,AsmResolver.Net,GuidStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\GuidStream.cs,ReadGuid,The following statement contains a magic number: _cachedGuids.Add(offset' guid = new Guid(reader.ReadBytes(16)));
Magic Number,AsmResolver.Net,ImageNetDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\ImageNetDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * dirLength +                     2 * sizeof (uint) +                     6 * dirLength;
Magic Number,AsmResolver.Net,ImageNetDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\ImageNetDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * dirLength +                     2 * sizeof (uint) +                     6 * dirLength;
Magic Number,AsmResolver.Net,ImageNetDirectory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\ImageNetDirectory.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint) +                     2 * sizeof (ushort) +                     1 * dirLength +                     2 * sizeof (uint) +                     6 * dirLength;
Magic Number,AsmResolver.Net,VTableHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\VTableHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 1 * sizeof (uint)                     + 2 * sizeof (ushort);
Magic Number,AsmResolver.Net,NetAssemblyFactory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeOptionalHeader,The following statement contains a magic number: optionalHeader.MajorOperatingSystemVersion = 4;
Magic Number,AsmResolver.Net,NetAssemblyFactory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeOptionalHeader,The following statement contains a magic number: optionalHeader.MajorSubsystemVersion = 4;
Magic Number,AsmResolver.Net,NetAssemblyFactory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeOptionalHeader,The following statement contains a magic number: optionalHeader.MajorLinkerVersion = 6;
Magic Number,AsmResolver.Net,NetAssemblyFactory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeNetDirectory,The following statement contains a magic number: directory.MajorRuntimeVersion = 2;
Magic Number,AsmResolver.Net,NetAssemblyFactory,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\NetAssemblyFactory.cs,InitializeMetadata,The following statement contains a magic number: var tableStream = new TableStream              {                  SortedBitVector = 0x000016003325FA00'                  MajorVersion = 2'                  Reserved2 = 1              };
Magic Number,AsmResolver.Net,MetadataHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(1 * sizeof (uint) +                            2 * sizeof (ushort) +                            2 * sizeof (uint) +                            VersionLength +                            2 * sizeof (ushort) +                            StreamHeaders.Sum(x => x.GetPhysicalLength()));
Magic Number,AsmResolver.Net,MetadataHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(1 * sizeof (uint) +                            2 * sizeof (ushort) +                            2 * sizeof (uint) +                            VersionLength +                            2 * sizeof (ushort) +                            StreamHeaders.Sum(x => x.GetPhysicalLength()));
Magic Number,AsmResolver.Net,MetadataHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataHeader.cs,GetPhysicalLength,The following statement contains a magic number: return (uint)(1 * sizeof (uint) +                            2 * sizeof (ushort) +                            2 * sizeof (uint) +                            VersionLength +                            2 * sizeof (ushort) +                            StreamHeaders.Sum(x => x.GetPhysicalLength()));
Magic Number,AsmResolver.Net,MetadataStreamHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,FromReadingContext,The following statement contains a magic number: var header = new MetadataStreamHeader              {                  StartOffset = reader.Position'                    Offset = reader.ReadUInt32()'                  Size = reader.ReadUInt32()'                  Name = reader.ReadAlignedAsciiString(4)'              };
Magic Number,AsmResolver.Net,MetadataStreamHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,GetPhysicalLength,The following statement contains a magic number: var length = Align((uint)(Encoding.ASCII.GetByteCount(Name) + 1)' 4);
Magic Number,AsmResolver.Net,MetadataStreamHeader,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\MetadataStreamHeader.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (uint) + length;
Magic Number,AsmResolver.Net,TableStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,FromReadingContext,The following statement contains a magic number: currentOffset += 4;
Magic Number,AsmResolver.Net,TableStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,TableStream,The following statement contains a magic number: MajorVersion = 2;
Magic Number,AsmResolver.Net,TableStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align((uint)(1 * sizeof (uint) +                                  4 * sizeof (byte) +                                  2 * sizeof (ulong) +                                  presentTables.Length * sizeof (uint) +                                  presentTables.Sum(x => x.GetPhysicalLength()))' 4);
Magic Number,AsmResolver.Net,TableStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align((uint)(1 * sizeof (uint) +                                  4 * sizeof (byte) +                                  2 * sizeof (ulong) +                                  presentTables.Length * sizeof (uint) +                                  presentTables.Sum(x => x.GetPhysicalLength()))' 4);
Magic Number,AsmResolver.Net,TableStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\TableStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align((uint)(1 * sizeof (uint) +                                  4 * sizeof (byte) +                                  2 * sizeof (ulong) +                                  presentTables.Length * sizeof (uint) +                                  presentTables.Sum(x => x.GetPhysicalLength()))' 4);
Magic Number,AsmResolver.Net,UserStringStream,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\UserStringStream.cs,GetPhysicalLength,The following statement contains a magic number: return Align(_length' 4);
Magic Number,AsmResolver.Net.Cil,CilExtraSection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilExtraSection.cs,GetPhysicalLength,The following statement contains a magic number: return (uint) Data.Length + 4;
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,GetIndexByOffset,The following statement contains a magic number: int m = (left + right) / 2;
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Br_S:                      instruction.OpCode = CilOpCodes.Br;                      break;                  case CilCode.Leave_S:                      instruction.OpCode = CilOpCodes.Leave;                      break;                  case CilCode.Brfalse_S:                      instruction.OpCode = CilOpCodes.Brfalse;                      break;                  case CilCode.Brtrue_S:                      instruction.OpCode = CilOpCodes.Brtrue;                      break;                  case CilCode.Beq_S:                      instruction.OpCode = CilOpCodes.Beq;                      break;                  case CilCode.Bge_S:                      instruction.OpCode = CilOpCodes.Bge;                      break;                  case CilCode.Bge_Un_S:                      instruction.OpCode = CilOpCodes.Bge_Un;                      break;                  case CilCode.Bgt_S:                      instruction.OpCode = CilOpCodes.Bgt;                      break;                  case CilCode.Bgt_Un_S:                      instruction.OpCode = CilOpCodes.Bgt_Un;                      break;                  case CilCode.Ble_S:                      instruction.OpCode = CilOpCodes.Ble;                      break;                  case CilCode.Ble_Un_S:                      instruction.OpCode = CilOpCodes.Ble_Un;                      break;                  case CilCode.Blt_S:                      instruction.OpCode = CilOpCodes.Blt;                      break;                  case CilCode.Blt_Un_S:                      instruction.OpCode = CilOpCodes.Blt_Un;                      break;                  case CilCode.Bne_Un_S:                      instruction.OpCode = CilOpCodes.Bne_Un;                      break;                    case CilCode.Ldloc_S:                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Ldloca_S:                      instruction.OpCode = CilOpCodes.Ldloca;                      break;                    case CilCode.Ldloc_0:                  case CilCode.Ldloc_1:                  case CilCode.Ldloc_2:                  case CilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Stloc_S:                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Stloc_0:                  case CilCode.Stloc_1:                  case CilCode.Stloc_2:                  case CilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Ldarg_S:                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Ldarga_S:                      instruction.OpCode = CilOpCodes.Ldarga;                      break;                    case CilCode.Ldarg_0:                  case CilCode.Ldarg_1:                  case CilCode.Ldarg_2:                  case CilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Starg_S:                      instruction.OpCode = CilOpCodes.Starg;                      break;                    case CilCode.Ldc_I4_0:                  case CilCode.Ldc_I4_1:                  case CilCode.Ldc_I4_2:                  case CilCode.Ldc_I4_3:                  case CilCode.Ldc_I4_4:                  case CilCode.Ldc_I4_5:                  case CilCode.Ldc_I4_6:                  case CilCode.Ldc_I4_7:                  case CilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = CilOpCodes.Ldc_I4;                      break;                                    case CilCode.Ldc_I4_S:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = Convert.ToInt32(instruction.Operand);                      break;                                    case CilCode.Ldc_I4_M1:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Br_S:                      instruction.OpCode = CilOpCodes.Br;                      break;                  case CilCode.Leave_S:                      instruction.OpCode = CilOpCodes.Leave;                      break;                  case CilCode.Brfalse_S:                      instruction.OpCode = CilOpCodes.Brfalse;                      break;                  case CilCode.Brtrue_S:                      instruction.OpCode = CilOpCodes.Brtrue;                      break;                  case CilCode.Beq_S:                      instruction.OpCode = CilOpCodes.Beq;                      break;                  case CilCode.Bge_S:                      instruction.OpCode = CilOpCodes.Bge;                      break;                  case CilCode.Bge_Un_S:                      instruction.OpCode = CilOpCodes.Bge_Un;                      break;                  case CilCode.Bgt_S:                      instruction.OpCode = CilOpCodes.Bgt;                      break;                  case CilCode.Bgt_Un_S:                      instruction.OpCode = CilOpCodes.Bgt_Un;                      break;                  case CilCode.Ble_S:                      instruction.OpCode = CilOpCodes.Ble;                      break;                  case CilCode.Ble_Un_S:                      instruction.OpCode = CilOpCodes.Ble_Un;                      break;                  case CilCode.Blt_S:                      instruction.OpCode = CilOpCodes.Blt;                      break;                  case CilCode.Blt_Un_S:                      instruction.OpCode = CilOpCodes.Blt_Un;                      break;                  case CilCode.Bne_Un_S:                      instruction.OpCode = CilOpCodes.Bne_Un;                      break;                    case CilCode.Ldloc_S:                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Ldloca_S:                      instruction.OpCode = CilOpCodes.Ldloca;                      break;                    case CilCode.Ldloc_0:                  case CilCode.Ldloc_1:                  case CilCode.Ldloc_2:                  case CilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Stloc_S:                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Stloc_0:                  case CilCode.Stloc_1:                  case CilCode.Stloc_2:                  case CilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Ldarg_S:                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Ldarga_S:                      instruction.OpCode = CilOpCodes.Ldarga;                      break;                    case CilCode.Ldarg_0:                  case CilCode.Ldarg_1:                  case CilCode.Ldarg_2:                  case CilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Starg_S:                      instruction.OpCode = CilOpCodes.Starg;                      break;                    case CilCode.Ldc_I4_0:                  case CilCode.Ldc_I4_1:                  case CilCode.Ldc_I4_2:                  case CilCode.Ldc_I4_3:                  case CilCode.Ldc_I4_4:                  case CilCode.Ldc_I4_5:                  case CilCode.Ldc_I4_6:                  case CilCode.Ldc_I4_7:                  case CilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = CilOpCodes.Ldc_I4;                      break;                                    case CilCode.Ldc_I4_S:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = Convert.ToInt32(instruction.Operand);                      break;                                    case CilCode.Ldc_I4_M1:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Br_S:                      instruction.OpCode = CilOpCodes.Br;                      break;                  case CilCode.Leave_S:                      instruction.OpCode = CilOpCodes.Leave;                      break;                  case CilCode.Brfalse_S:                      instruction.OpCode = CilOpCodes.Brfalse;                      break;                  case CilCode.Brtrue_S:                      instruction.OpCode = CilOpCodes.Brtrue;                      break;                  case CilCode.Beq_S:                      instruction.OpCode = CilOpCodes.Beq;                      break;                  case CilCode.Bge_S:                      instruction.OpCode = CilOpCodes.Bge;                      break;                  case CilCode.Bge_Un_S:                      instruction.OpCode = CilOpCodes.Bge_Un;                      break;                  case CilCode.Bgt_S:                      instruction.OpCode = CilOpCodes.Bgt;                      break;                  case CilCode.Bgt_Un_S:                      instruction.OpCode = CilOpCodes.Bgt_Un;                      break;                  case CilCode.Ble_S:                      instruction.OpCode = CilOpCodes.Ble;                      break;                  case CilCode.Ble_Un_S:                      instruction.OpCode = CilOpCodes.Ble_Un;                      break;                  case CilCode.Blt_S:                      instruction.OpCode = CilOpCodes.Blt;                      break;                  case CilCode.Blt_Un_S:                      instruction.OpCode = CilOpCodes.Blt_Un;                      break;                  case CilCode.Bne_Un_S:                      instruction.OpCode = CilOpCodes.Bne_Un;                      break;                    case CilCode.Ldloc_S:                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Ldloca_S:                      instruction.OpCode = CilOpCodes.Ldloca;                      break;                    case CilCode.Ldloc_0:                  case CilCode.Ldloc_1:                  case CilCode.Ldloc_2:                  case CilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Stloc_S:                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Stloc_0:                  case CilCode.Stloc_1:                  case CilCode.Stloc_2:                  case CilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Ldarg_S:                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Ldarga_S:                      instruction.OpCode = CilOpCodes.Ldarga;                      break;                    case CilCode.Ldarg_0:                  case CilCode.Ldarg_1:                  case CilCode.Ldarg_2:                  case CilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Starg_S:                      instruction.OpCode = CilOpCodes.Starg;                      break;                    case CilCode.Ldc_I4_0:                  case CilCode.Ldc_I4_1:                  case CilCode.Ldc_I4_2:                  case CilCode.Ldc_I4_3:                  case CilCode.Ldc_I4_4:                  case CilCode.Ldc_I4_5:                  case CilCode.Ldc_I4_6:                  case CilCode.Ldc_I4_7:                  case CilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = CilOpCodes.Ldc_I4;                      break;                                    case CilCode.Ldc_I4_S:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = Convert.ToInt32(instruction.Operand);                      break;                                    case CilCode.Ldc_I4_M1:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Br_S:                      instruction.OpCode = CilOpCodes.Br;                      break;                  case CilCode.Leave_S:                      instruction.OpCode = CilOpCodes.Leave;                      break;                  case CilCode.Brfalse_S:                      instruction.OpCode = CilOpCodes.Brfalse;                      break;                  case CilCode.Brtrue_S:                      instruction.OpCode = CilOpCodes.Brtrue;                      break;                  case CilCode.Beq_S:                      instruction.OpCode = CilOpCodes.Beq;                      break;                  case CilCode.Bge_S:                      instruction.OpCode = CilOpCodes.Bge;                      break;                  case CilCode.Bge_Un_S:                      instruction.OpCode = CilOpCodes.Bge_Un;                      break;                  case CilCode.Bgt_S:                      instruction.OpCode = CilOpCodes.Bgt;                      break;                  case CilCode.Bgt_Un_S:                      instruction.OpCode = CilOpCodes.Bgt_Un;                      break;                  case CilCode.Ble_S:                      instruction.OpCode = CilOpCodes.Ble;                      break;                  case CilCode.Ble_Un_S:                      instruction.OpCode = CilOpCodes.Ble_Un;                      break;                  case CilCode.Blt_S:                      instruction.OpCode = CilOpCodes.Blt;                      break;                  case CilCode.Blt_Un_S:                      instruction.OpCode = CilOpCodes.Blt_Un;                      break;                  case CilCode.Bne_Un_S:                      instruction.OpCode = CilOpCodes.Bne_Un;                      break;                    case CilCode.Ldloc_S:                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Ldloca_S:                      instruction.OpCode = CilOpCodes.Ldloca;                      break;                    case CilCode.Ldloc_0:                  case CilCode.Ldloc_1:                  case CilCode.Ldloc_2:                  case CilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Stloc_S:                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Stloc_0:                  case CilCode.Stloc_1:                  case CilCode.Stloc_2:                  case CilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Ldarg_S:                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Ldarga_S:                      instruction.OpCode = CilOpCodes.Ldarga;                      break;                    case CilCode.Ldarg_0:                  case CilCode.Ldarg_1:                  case CilCode.Ldarg_2:                  case CilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Starg_S:                      instruction.OpCode = CilOpCodes.Starg;                      break;                    case CilCode.Ldc_I4_0:                  case CilCode.Ldc_I4_1:                  case CilCode.Ldc_I4_2:                  case CilCode.Ldc_I4_3:                  case CilCode.Ldc_I4_4:                  case CilCode.Ldc_I4_5:                  case CilCode.Ldc_I4_6:                  case CilCode.Ldc_I4_7:                  case CilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = CilOpCodes.Ldc_I4;                      break;                                    case CilCode.Ldc_I4_S:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = Convert.ToInt32(instruction.Operand);                      break;                                    case CilCode.Ldc_I4_M1:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeBranch,The following statement contains a magic number: int relativeOperand = operand.Offset - (instruction.Offset + 2);
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeVariable,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Ldloc:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Ldloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Ldloc_S;                      }                      break;                  case CilCode.Ldloca:                      instruction.OpCode = CilOpCodes.Ldloca_S;                      break;                  case CilCode.Stloc:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Stloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Stloc_S;                      }                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeVariable,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Ldloc:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Ldloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Ldloc_S;                      }                      break;                  case CilCode.Ldloca:                      instruction.OpCode = CilOpCodes.Ldloca_S;                      break;                  case CilCode.Stloc:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Stloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Stloc_S;                      }                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeArgument,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case CilCode.Ldarg:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Ldarg_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Ldarg_S;                      }                      break;                  case CilCode.Ldarga:                      instruction.OpCode = CilOpCodes.Ldarga_S;                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeLdc,The following statement contains a magic number: value >= -1 && value <= 8
Magic Number,AsmResolver.Net.Cil,CilRawFatMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilRawFatMethodBody.cs,FromReader,The following statement contains a magic number: reader.Align(4);
Magic Number,AsmResolver.Net.Cil,CilRawFatMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilRawFatMethodBody.cs,GetPhysicalLength,The following statement contains a magic number: uint length = (uint) (12 + Code.Length);
Magic Number,AsmResolver.Net.Cil,CilRawFatMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilRawFatMethodBody.cs,GetPhysicalLength,The following statement contains a magic number: uint sectionsOffset = Align(endOffset' 4);
Magic Number,AsmResolver.Net.Cil,CilRawFatMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilRawFatMethodBody.cs,Write,The following statement contains a magic number: writer.Align(4);
Magic Number,AsmResolver.Net.Cil,CilRawSmallMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilRawSmallMethodBody.cs,FromReader,The following statement contains a magic number: int codeSize = reader.ReadByte() >> 2;
Magic Number,AsmResolver.Net.Cil,CilRawSmallMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilRawSmallMethodBody.cs,Write,The following statement contains a magic number: writer.WriteByte((byte) (0x2 | (Code.Length << 2)));
Magic Number,AsmResolver.Net.Cil,CilMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilMethodBody.cs,CilMethodBody,The following statement contains a magic number: MaxStack = 8;
Magic Number,AsmResolver.Net.Cil,CilAssembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilAssembler.cs,WriteOpCode,The following statement contains a magic number: opCode.Size == 2
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetLdcValue,The following statement contains a magic number: switch (OpCode.Code)              {                  case CilCode.Ldc_I4_M1:                      return -1;                  case CilCode.Ldc_I4_0:                      return 0;                  case CilCode.Ldc_I4_1:                      return 1;                  case CilCode.Ldc_I4_2:                      return 2;                  case CilCode.Ldc_I4_3:                      return 3;                  case CilCode.Ldc_I4_4:                      return 4;                  case CilCode.Ldc_I4_5:                      return 5;                  case CilCode.Ldc_I4_6:                      return 6;                  case CilCode.Ldc_I4_7:                      return 7;                  case CilCode.Ldc_I4_8:                      return 8;                  case CilCode.Ldc_I4:                  case CilCode.Ldc_I4_S:                      return Convert.ToInt32(Operand);                  default:                      throw new ArgumentException("Instruction is not an ldc.i4 variant.");              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return 0;                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                  case CilOperandType.ShortInlineI:                  case CilOperandType.ShortInlineBrTarget:                      return 1;                  case CilOperandType.InlineVar:                  case CilOperandType.InlineArgument:                      return 2;                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                  case CilOperandType.InlineBrTarget:                      return 4;                    case CilOperandType.InlineR:                  case CilOperandType.InlineI8:                      return 8;                    case CilOperandType.InlineSwitch:                      var array = Operand as IList;                      if (array == null)                          return 4;                      return 4 * (array.Count + 1);              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return 0;                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                  case CilOperandType.ShortInlineI:                  case CilOperandType.ShortInlineBrTarget:                      return 1;                  case CilOperandType.InlineVar:                  case CilOperandType.InlineArgument:                      return 2;                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                  case CilOperandType.InlineBrTarget:                      return 4;                    case CilOperandType.InlineR:                  case CilOperandType.InlineI8:                      return 8;                    case CilOperandType.InlineSwitch:                      var array = Operand as IList;                      if (array == null)                          return 4;                      return 4 * (array.Count + 1);              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return 0;                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                  case CilOperandType.ShortInlineI:                  case CilOperandType.ShortInlineBrTarget:                      return 1;                  case CilOperandType.InlineVar:                  case CilOperandType.InlineArgument:                      return 2;                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                  case CilOperandType.InlineBrTarget:                      return 4;                    case CilOperandType.InlineR:                  case CilOperandType.InlineI8:                      return 8;                    case CilOperandType.InlineSwitch:                      var array = Operand as IList;                      if (array == null)                          return 4;                      return 4 * (array.Count + 1);              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return 0;                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                  case CilOperandType.ShortInlineI:                  case CilOperandType.ShortInlineBrTarget:                      return 1;                  case CilOperandType.InlineVar:                  case CilOperandType.InlineArgument:                      return 2;                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                  case CilOperandType.InlineBrTarget:                      return 4;                    case CilOperandType.InlineR:                  case CilOperandType.InlineI8:                      return 8;                    case CilOperandType.InlineSwitch:                      var array = Operand as IList;                      if (array == null)                          return 4;                      return 4 * (array.Count + 1);              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetOperandSize,The following statement contains a magic number: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return 0;                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                  case CilOperandType.ShortInlineI:                  case CilOperandType.ShortInlineBrTarget:                      return 1;                  case CilOperandType.InlineVar:                  case CilOperandType.InlineArgument:                      return 2;                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                  case CilOperandType.InlineBrTarget:                      return 4;                    case CilOperandType.InlineR:                  case CilOperandType.InlineI8:                      return 8;                    case CilOperandType.InlineSwitch:                      var array = Operand as IList;                      if (array == null)                          return 4;                      return 4 * (array.Count + 1);              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetStackPopCount,The following statement contains a magic number: switch (OpCode.StackBehaviourPop)              {                  case CilStackBehaviour.Pop1:                  case CilStackBehaviour.Popi:                  case CilStackBehaviour.Popref:                      return 1;                                    case CilStackBehaviour.Pop1_pop1:                  case CilStackBehaviour.Popi_pop1:                  case CilStackBehaviour.Popi_popi:                  case CilStackBehaviour.Popi_popi8:                  case CilStackBehaviour.Popi_popr4:                  case CilStackBehaviour.Popi_popr8:                  case CilStackBehaviour.Popref_pop1:                  case CilStackBehaviour.Popref_popi:                      return 2;                                    case CilStackBehaviour.Popi_popi_popi:                  case CilStackBehaviour.Popref_popi_pop1:                  case CilStackBehaviour.Popref_popi_popi:                  case CilStackBehaviour.Popref_popi_popi8:                  case CilStackBehaviour.Popref_popi_popr4:                  case CilStackBehaviour.Popref_popi_popr8:                  case CilStackBehaviour.Popref_popi_popref:                      return 3;                                    case CilStackBehaviour.Varpop:                      if (signature == null)                      {                          if (OpCode.Code == CilCode.Ret)                              return parent.Method.Signature.ReturnType.IsTypeOf("System"' "Void") ? 0 : 1;                      }                      else                      {                          int count = signature.Parameters.Count;                          if (signature.HasThis && OpCode.Code != CilCode.Newobj)                              count++;                          return count;                      }                        break;              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetStackPopCount,The following statement contains a magic number: switch (OpCode.StackBehaviourPop)              {                  case CilStackBehaviour.Pop1:                  case CilStackBehaviour.Popi:                  case CilStackBehaviour.Popref:                      return 1;                                    case CilStackBehaviour.Pop1_pop1:                  case CilStackBehaviour.Popi_pop1:                  case CilStackBehaviour.Popi_popi:                  case CilStackBehaviour.Popi_popi8:                  case CilStackBehaviour.Popi_popr4:                  case CilStackBehaviour.Popi_popr8:                  case CilStackBehaviour.Popref_pop1:                  case CilStackBehaviour.Popref_popi:                      return 2;                                    case CilStackBehaviour.Popi_popi_popi:                  case CilStackBehaviour.Popref_popi_pop1:                  case CilStackBehaviour.Popref_popi_popi:                  case CilStackBehaviour.Popref_popi_popi8:                  case CilStackBehaviour.Popref_popi_popr4:                  case CilStackBehaviour.Popref_popi_popr8:                  case CilStackBehaviour.Popref_popi_popref:                      return 3;                                    case CilStackBehaviour.Varpop:                      if (signature == null)                      {                          if (OpCode.Code == CilCode.Ret)                              return parent.Method.Signature.ReturnType.IsTypeOf("System"' "Void") ? 0 : 1;                      }                      else                      {                          int count = signature.Parameters.Count;                          if (signature.HasThis && OpCode.Code != CilCode.Newobj)                              count++;                          return count;                      }                        break;              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetStackPushCount,The following statement contains a magic number: switch (OpCode.StackBehaviourPush)              {                  case CilStackBehaviour.Push1:                  case CilStackBehaviour.Pushi:                  case CilStackBehaviour.Pushi8:                  case CilStackBehaviour.Pushr4:                  case CilStackBehaviour.Pushr8:                  case CilStackBehaviour.Pushref:                      return 1;                                    case CilStackBehaviour.Push1_push1:                      return 2;                                    case CilStackBehaviour.Varpush:                      if (signature != null                          && (!signature.ReturnType.IsTypeOf("System"' "Void") || OpCode.Code == CilCode.Newobj))                          return 1;                      break;              }
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ OpCode.GetHashCode();
Magic Number,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (Operand != null ? Operand.GetHashCode() : 0);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: StackBehaviourPop = (CilStackBehaviour)(flags >> 12 & 31);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: StackBehaviourPop = (CilStackBehaviour)(flags >> 12 & 31);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: StackBehaviourPush = (CilStackBehaviour)(flags >> 17 & 31);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: StackBehaviourPush = (CilStackBehaviour)(flags >> 17 & 31);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: OperandType = (CilOperandType)(flags & 31);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: OpCodeType = (CilOpCodeType)(flags >> 9 & 7);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: OpCodeType = (CilOpCodeType)(flags >> 9 & 7);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: Size = (flags >> 22 & 3);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: Size = (flags >> 22 & 3);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: Op1 = (byte)((ushort)value >> 8);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: FlowControl = (CilFlowControl)(flags >> 5 & 15);
Magic Number,AsmResolver.Net.Cil,CilOpCode,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilOpCode.cs,CilOpCode,The following statement contains a magic number: FlowControl = (CilFlowControl)(flags >> 5 & 15);
Magic Number,AsmResolver.Net.Cts,FieldDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldDefinition.cs,FieldDefinition,The following statement contains a magic number: _declaringType = new LazyValue<TypeDefinition>(() =>              {                  var table = image.Header.GetStream<TableStream>().GetTable(MetadataTokenType.TypeDef);                  var typeRow = table.GetRowClosestToKey(4' row.MetadataToken.Rid);                  return (TypeDefinition) table.GetMemberFromRow(image' typeRow);              });
Magic Number,AsmResolver.Net.Cts,AssemblyDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\AssemblyDefinition.cs,ComputePublicKeyToken,The following statement contains a magic number: return token.Reverse().Take(8).ToArray();
Magic Number,AsmResolver.Net.Cts,MethodDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodDefinition.cs,MethodDefinition,The following statement contains a magic number: _declaringType = new LazyValue<TypeDefinition>(() =>              {                  var table = image.Header.GetStream<TableStream>().GetTable(MetadataTokenType.TypeDef);                  var typeRow = table.GetRowClosestToKey(5' row.MetadataToken.Rid);                  return (TypeDefinition) table.GetMemberFromRow(image' typeRow);              });
Magic Number,AsmResolver.Net.Cts,MethodDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MethodDefinition.cs,MethodDefinition,The following statement contains a magic number: Parameters = new RangedMemberCollection<MethodDefinition' ParameterDefinition>(this'                  MetadataTokenType.Param' 5' GetParamOwner' SetParamOwner);
Magic Number,AsmResolver.Net.Cts,ParameterDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ParameterDefinition.cs,ParameterDefinition,The following statement contains a magic number: _method =  new LazyValue<MethodDefinition>(() =>              {                  var table = image.Header.GetStream<TableStream>().GetTable(MetadataTokenType.Method);                  var methodRow = table.GetRowClosestToKey(5' row.MetadataToken.Rid);                  return (MethodDefinition) table.GetMemberFromRow(image' methodRow);              });
Magic Number,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The following statement contains a magic number: Fields = new RangedMemberCollection<TypeDefinition' FieldDefinition>(this' MetadataTokenType.Field' 4' GetFieldOwner' SetFieldOwner);
Magic Number,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The following statement contains a magic number: Methods = new RangedMemberCollection<TypeDefinition' MethodDefinition>(this' MetadataTokenType.Method' 5' GetMethodOwner' SetMethodOwner);
Magic Number,AsmResolver.Net.Cts,TypeDefinition,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\TypeDefinition.cs,TypeDefinition,The following statement contains a magic number: _classLayout = new LazyValue<ClassLayout>(() =>              {                  var table = image.Header.GetStream<TableStream>().GetTable(MetadataTokenType.ClassLayout);                  var layoutRow = table.GetRowByKey(2' row.MetadataToken.Rid);                  return layoutRow != null ? (ClassLayout) table.GetMemberFromRow(image' layoutRow) : null;              });
Magic Number,AsmResolver.Net.Emit,BlobStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\BlobStreamBuffer.cs,CreateStream,The following statement contains a magic number: writer.WriteZeroes((int) (FileSegment.Align(_length' 4) - _length));
Magic Number,AsmResolver.Net.Emit,CompactNetAssemblyBuilder,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\CompactNetAssemblyBuilder.cs,UpdateRelocations,The following statement contains a magic number: var relocationRva = Assembly.NtHeaders.OptionalHeader.AddressOfEntrypoint + 2;
Magic Number,AsmResolver.Net.Emit,GuidStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\GuidStreamBuffer.cs,GetGuidOffset,The following statement contains a magic number: _length += 16;
Magic Number,AsmResolver.Net.Emit,MethodBodyTableBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\MethodBodyTableBuffer.cs,UpdateOffsets,The following statement contains a magic number: body.StartOffset = Align((uint) body.StartOffset' 4);
Magic Number,AsmResolver.Net.Emit,StringStreamBuffer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Emit\StringStreamBuffer.cs,CreateStream,The following statement contains a magic number: writer.WriteZeroes((int)(FileSegment.Align(_length' 4) - _length));
Magic Number,AsmResolver.Net.Metadata,ConstantTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\ConstantTable.cs,FindConstantOfOwner,The following statement contains a magic number: return (MetadataRow<ElementType' byte' uint' uint>) GetRowByKey(2' encoder.EncodeToken(ownersToken));
Magic Number,AsmResolver.Net.Metadata,FieldRvaTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\FieldRvaTable.cs,GetDataSize,The following statement contains a magic number: switch (elementType)              {                  case ElementType.Boolean:                  case ElementType.I1:                  case ElementType.U1:                      return sizeof (byte);                  case ElementType.I2:                  case ElementType.U2:                      return sizeof (ushort);                  case ElementType.I4:                  case ElementType.U4:                  case ElementType.R4:                      return sizeof (uint);                  case ElementType.I8:                  case ElementType.U8:                  case ElementType.R8:                      return sizeof (ulong);                  case ElementType.Class:                  case ElementType.ValueType:                      uint codedIndex;                      if (!blobReader.TryReadCompressedUInt32(out codedIndex))                          return 0;                      var typeToken = TableStream.GetIndexEncoder(CodedIndex.TypeDefOrRef).DecodeIndex(codedIndex);                      if (typeToken.TokenType == MetadataTokenType.TypeDef)                      {                          var classLayoutTable = (ClassLayoutTable) TableStream.GetTable(MetadataTokenType.ClassLayout);                          var row = classLayoutTable.GetRowByKey(2' typeToken.Rid);                          if (row != null)                              return (int) row.Column2;                      }                        return 0;                  default:                      return 0;              }
Magic Number,AsmResolver.Net.Metadata,IndexEncoder,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\IndexEncoder.cs,IndexEncoder,The following statement contains a magic number: _tableIndexBitCount = (int)Math.Ceiling(Math.Log(tables.Length' 2));
Magic Number,AsmResolver.Net.Metadata,IndexEncoder,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\IndexEncoder.cs,IndexEncoder,The following statement contains a magic number: _tableIndexBitMask = (int)(Math.Pow(2' _tableIndexBitCount) - 1);
Magic Number,AsmResolver.Net.Metadata,MetadataTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MetadataTable.cs,GetRowByKey,The following statement contains a magic number: int m = (left + right) / 2;
Magic Number,AsmResolver.Net.Metadata,MetadataTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MetadataTable.cs,GetRowIndexClosestToKey,The following statement contains a magic number: middle = (left + right) / 2;
Magic Number,AsmResolver.Net.Metadata,SortedMetadataTable<TRow>,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MetadataTable.cs,Add,The following statement contains a magic number: item.MetadataToken = new MetadataToken(TokenType' (uint) (index + 2));
Magic Number,AsmResolver.Net.Metadata,MethodSemanticsTable,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Metadata\MethodSemanticsTable.cs,FindSemanticsOfOwner,The following statement contains a magic number: return (MetadataRow<MethodSemanticsAttributes' uint' uint>) GetRowByKey(2' encoder.EncodeToken(ownersToken));
Magic Number,AsmResolver.Net.Signatures,ArrayMarshalDescriptor,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ArrayMarshalDescriptor.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (byte) +                     (ParameterIndex.HasValue                         ? ParameterIndex.Value.GetCompressedSize() +                           (NumberOfElements.HasValue ? NumberOfElements.Value.GetCompressedSize() : 0)                         : 0)                  + base.GetPhysicalLength(buffer);
Magic Number,AsmResolver.Net.Signatures,CustomMarshalDescriptor,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\CustomMarshalDescriptor.cs,GetPhysicalLength,The following statement contains a magic number: return sizeof(byte) +                     sizeof(byte) + 38 +                     UnmanagedType.GetSerStringSize() +                     ManagedType.GetSerStringSize() +                     Cookie.GetSerStringSize() +                     base.GetPhysicalLength(buffer);
Magic Number,AsmResolver.Net.Signatures,SafeArrayMarshalDescriptor,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\SafeArrayMarshalDescriptor.cs,GetPhysicalLength,The following statement contains a magic number: return 2 * sizeof (byte)                  + base.GetPhysicalLength(buffer);
Magic Number,AsmResolver.Net.Signatures,SecurityAttributeSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\SecurityAttributeSignature.cs,GetPhysicalLength,The following statement contains a magic number: return TypeName.GetSerStringSize() +                     (NamedArguments.Count == 0                         ? 2 * sizeof(byte)                         : NamedArguments.Count.GetCompressedSize() +                           argumentsSize.GetCompressedSize() +                           argumentsSize)                     + base.GetPhysicalLength(buffer);
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: hexString.Length % 2 != 0
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: var bytes = new byte[hexString.Length / 2];
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: bytes[i] = byte.Parse(hexString.Substring(i * 2' 2)' NumberStyles.HexNumber);
Magic Number,AsmResolver.Net.Signatures,TypeNameParser,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,HexToByteArray,The following statement contains a magic number: bytes[i] = byte.Parse(hexString.Substring(i * 2' 2)' NumberStyles.HexNumber);
Magic Number,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,Write,The following statement contains a magic number: token |= (byte)(mnemonicIndex << 3);
Magic Number,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegisterTokenPart,The following statement contains a magic number: switch (method)              {                  case X86OperandType.Register:                  {                      return (byte)(ComputeRegisterToken((X86Register)operand.Value) << 3);                  }                  case X86OperandType.RegisterOrMemoryAddress:                  {                      return ComputeRegOrMemToken(operand);                  }              }
Magic Number,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegisterToken,The following statement contains a magic number: return (byte)((byte)(register) & 7);
Magic Number,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegOrMemToken,The following statement contains a magic number: var token = (byte)((byte)modifier << 6);
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadNextInstruction,The following statement contains a magic number: var mnemonicIndex = instruction.OpCode.HasOpCodeModifier ? (registerToken >> 3) & 7 : 0;
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadNextInstruction,The following statement contains a magic number: var mnemonicIndex = instruction.OpCode.HasOpCodeModifier ? (registerToken >> 3) & 7 : 0;
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadNextOpCode,The following statement contains a magic number: prefixBytes = new List<byte>(4);
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadNextOpCode,The following statement contains a magic number: i < 4
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following statement contains a magic number: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(prefixes' size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(prefixes' size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(prefixes' registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(prefixes' size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(prefixes' size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following statement contains a magic number: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(prefixes' size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(prefixes' size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(prefixes' registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(prefixes' size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(prefixes' size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following statement contains a magic number: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(prefixes' size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(prefixes' size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(prefixes' registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(prefixes' size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(prefixes' size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegOrMemOperand32,The following statement contains a magic number: var modifier = (X86RegOrMemModifier)(registerToken >> 6);
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,MakeScaledIndexOperandFromToken,The following statement contains a magic number: var scaledIndex = new X86ScaledIndex              {                  Register = GetRegisterFromToken((byte)((token >> 3) & 7)' X86RegisterSize.Dword)'                  Multiplier = 1 << ((token >> 6) & 3)'              };
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,ComputeSize,The following statement contains a magic number: int size = OpCode.TwoBytePrefix == 0 ? 1 : 2;
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The following statement contains a magic number: switch (operandType)              {                  case X86OperandType.None:                  case X86OperandType.ControlRegister:                  case X86OperandType.DebugRegister:                  case X86OperandType.StackRegister:                  case X86OperandType.Register:                  case X86OperandType.RegisterCl:                  case X86OperandType.RegisterDx:                  case X86OperandType.RegisterEax:                  case X86OperandType.RegisterAl:                  case X86OperandType.ImmediateOne:                  case X86OperandType.SegmentRegister:                  case X86OperandType.OpCodeRegister:                      break;                    case X86OperandType.DirectAddress:                  case X86OperandType.MemoryAddress:                      size += 4;                      break;                    case X86OperandType.RelativeOffset:                  case X86OperandType.ImmediateData:                      size += GetSize(prefixes' operandSize);                      break;                    case X86OperandType.RegisterOrMemoryAddress:                  case X86OperandType.StackRegisterOrMemoryAddress:                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          size += 1;                      if (!(operand.Value is X86Register))                          size += 4;                      break;              }
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The following statement contains a magic number: switch (operandType)              {                  case X86OperandType.None:                  case X86OperandType.ControlRegister:                  case X86OperandType.DebugRegister:                  case X86OperandType.StackRegister:                  case X86OperandType.Register:                  case X86OperandType.RegisterCl:                  case X86OperandType.RegisterDx:                  case X86OperandType.RegisterEax:                  case X86OperandType.RegisterAl:                  case X86OperandType.ImmediateOne:                  case X86OperandType.SegmentRegister:                  case X86OperandType.OpCodeRegister:                      break;                    case X86OperandType.DirectAddress:                  case X86OperandType.MemoryAddress:                      size += 4;                      break;                    case X86OperandType.RelativeOffset:                  case X86OperandType.ImmediateData:                      size += GetSize(prefixes' operandSize);                      break;                    case X86OperandType.RegisterOrMemoryAddress:                  case X86OperandType.StackRegisterOrMemoryAddress:                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          size += 1;                      if (!(operand.Value is X86Register))                          size += 4;                      break;              }
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride) ? 2 : 4;                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride) ? 2 : 4;                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride) ? 2 : 4;                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride) ? 2 : 4;                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Magic Number,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following statement contains a magic number: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride) ? 2 : 4;                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The following switch statement is missing a default case: switch (scope1)              {                  case ModuleDefinition module:                      return Equals(module' scope2 as ModuleDefinition);                                    case ModuleReference moduleRef:                      return Equals(moduleRef' scope2 as ModuleReference);                                    case AssemblyReference assemblyRef:                      return Equals((IAssemblyDescriptor) assemblyRef' scope2 as AssemblyReference);                                    case TypeReference typeRef:                      return Equals((ITypeDefOrRef) typeRef' scope2 as TypeReference);                 }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,GetHashCode,The following switch statement is missing a default case: switch (obj)              {                  case ModuleDefinition module:                      return GetHashCode(module);                                    case ModuleReference moduleRef:                      return GetHashCode(moduleRef);                                    case AssemblyReference assemblyRef:                      return GetHashCode((IAssemblyDescriptor) assemblyRef);                                    case TypeReference typeRef:                      return GetHashCode((ITypeDescriptor) typeRef);              }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The following switch statement is missing a default case: switch (signature1)              {                  case TypeDefOrRefSignature typeDefOrRefSig:                      return Equals(typeDefOrRefSig' descriptor);                                 case MsCorLibTypeSignature corlibType:                      return Equals(corlibType' descriptor);              }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The following switch statement is missing a default case: switch (signature1)              {                  case TypeDefOrRefSignature typeDefOrRef:                      return Equals(typeDefOrRef' (ITypeDescriptor) signature2);                                    case MsCorLibTypeSignature corlibType:                      return Equals(corlibType' (ITypeDescriptor) signature2);                                    case ArrayTypeSignature arrayType:                      return Equals(arrayType' signature2 as ArrayTypeSignature);                                    case BoxedTypeSignature boxedType:                      return Equals(boxedType' signature2 as BoxedTypeSignature);                                    case ByReferenceTypeSignature byRefType:                      return Equals(byRefType' signature2 as ByReferenceTypeSignature);                                    case FunctionPointerTypeSignature functionPtrType:                      return Equals(functionPtrType' signature2 as FunctionPointerTypeSignature);                                    case GenericInstanceTypeSignature genericType:                      return Equals(genericType' signature2 as GenericInstanceTypeSignature);                                    case GenericParameterSignature genericParam:                      return Equals(genericParam' signature2 as GenericParameterSignature);                                    case OptionalModifierSignature modOptType:                      return Equals(modOptType' signature2 as OptionalModifierSignature);                                    case PinnedTypeSignature pinnedType:                      return Equals(pinnedType' signature2 as PinnedTypeSignature);                                    case PointerTypeSignature pointerType:                      return Equals(pointerType' signature2 as PointerTypeSignature);                                    case RequiredModifierSignature modReqType:                      return Equals(modReqType' signature2 as RequiredModifierSignature);                                    case SentinelTypeSignature sentinelType:                      return Equals(sentinelType' signature2 as SentinelTypeSignature);                                    case SzArrayTypeSignature szArrayType:                      return Equals(szArrayType' signature2 as SzArrayTypeSignature);              }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The following switch statement is missing a default case: switch (descriptor)              {                  case TypeDefOrRefSignature signature2:                      return Equals(reference1' signature2.Type);                                 case MsCorLibTypeSignature corlibType:                      return Equals(reference1' corlibType.Type);                    case ITypeDefOrRef typeDefOrRef:                      return Equals(reference1' typeDefOrRef);              }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The following switch statement is missing a default case: switch (reference1)              {                  case ICallableMemberReference callable:                      return Equals(callable' reference2 as ICallableMemberReference);                  case ITypeDefOrRef type:                      return Equals(type' (ITypeDefOrRef) reference1);              }
Missing Default,AsmResolver.Net,SignatureComparer,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\SignatureComparer.cs,Equals,The following switch statement is missing a default case: switch (signature1)              {                  case FieldSignature fieldSignature:                      return Equals(fieldSignature' signature2 as FieldSignature);                  case MethodSignature methodSignature:                      return Equals(methodSignature' signature2 as MethodSignature);                  case PropertySignature propertySignature:                      return Equals(propertySignature' signature2 as PropertySignature);                  case GenericInstanceMethodSignature genericInstanceSignature:                      return Equals(genericInstanceSignature' signature2 as GenericInstanceMethodSignature);              }
Missing Default,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,ExpandMacro,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case CilCode.Br_S:                      instruction.OpCode = CilOpCodes.Br;                      break;                  case CilCode.Leave_S:                      instruction.OpCode = CilOpCodes.Leave;                      break;                  case CilCode.Brfalse_S:                      instruction.OpCode = CilOpCodes.Brfalse;                      break;                  case CilCode.Brtrue_S:                      instruction.OpCode = CilOpCodes.Brtrue;                      break;                  case CilCode.Beq_S:                      instruction.OpCode = CilOpCodes.Beq;                      break;                  case CilCode.Bge_S:                      instruction.OpCode = CilOpCodes.Bge;                      break;                  case CilCode.Bge_Un_S:                      instruction.OpCode = CilOpCodes.Bge_Un;                      break;                  case CilCode.Bgt_S:                      instruction.OpCode = CilOpCodes.Bgt;                      break;                  case CilCode.Bgt_Un_S:                      instruction.OpCode = CilOpCodes.Bgt_Un;                      break;                  case CilCode.Ble_S:                      instruction.OpCode = CilOpCodes.Ble;                      break;                  case CilCode.Ble_Un_S:                      instruction.OpCode = CilOpCodes.Ble_Un;                      break;                  case CilCode.Blt_S:                      instruction.OpCode = CilOpCodes.Blt;                      break;                  case CilCode.Blt_Un_S:                      instruction.OpCode = CilOpCodes.Blt_Un;                      break;                  case CilCode.Bne_Un_S:                      instruction.OpCode = CilOpCodes.Bne_Un;                      break;                    case CilCode.Ldloc_S:                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Ldloca_S:                      instruction.OpCode = CilOpCodes.Ldloca;                      break;                    case CilCode.Ldloc_0:                  case CilCode.Ldloc_1:                  case CilCode.Ldloc_2:                  case CilCode.Ldloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldloc;                      break;                    case CilCode.Stloc_S:                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Stloc_0:                  case CilCode.Stloc_1:                  case CilCode.Stloc_2:                  case CilCode.Stloc_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveVariable(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Stloc;                      break;                    case CilCode.Ldarg_S:                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Ldarga_S:                      instruction.OpCode = CilOpCodes.Ldarga;                      break;                    case CilCode.Ldarg_0:                  case CilCode.Ldarg_1:                  case CilCode.Ldarg_2:                  case CilCode.Ldarg_3:                      instruction.Operand = ((IOperandResolver) Owner).ResolveParameter(instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48);                      instruction.OpCode = CilOpCodes.Ldarg;                      break;                    case CilCode.Starg_S:                      instruction.OpCode = CilOpCodes.Starg;                      break;                    case CilCode.Ldc_I4_0:                  case CilCode.Ldc_I4_1:                  case CilCode.Ldc_I4_2:                  case CilCode.Ldc_I4_3:                  case CilCode.Ldc_I4_4:                  case CilCode.Ldc_I4_5:                  case CilCode.Ldc_I4_6:                  case CilCode.Ldc_I4_7:                  case CilCode.Ldc_I4_8:                      instruction.Operand = instruction.OpCode.Name[instruction.OpCode.Name.Length - 1] - 48;                      instruction.OpCode = CilOpCodes.Ldc_I4;                      break;                                    case CilCode.Ldc_I4_S:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = Convert.ToInt32(instruction.Operand);                      break;                                    case CilCode.Ldc_I4_M1:                      instruction.OpCode = CilOpCodes.Ldc_I4;                      instruction.Operand = -1;                      break;              }
Missing Default,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,OptimizeMacro,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType)              {                  case CilOperandType.InlineBrTarget:                      TryOptimizeBranch(instruction);                      break;                  case CilOperandType.InlineVar:                      TryOptimizeVariable(instruction);                      break;                  case CilOperandType.InlineArgument:                      TryOptimizeArgument(instruction);                      break;              }
Missing Default,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeBranch,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case CilCode.Br:                      instruction.OpCode = CilOpCodes.Br_S;                      break;                  case CilCode.Leave:                      instruction.OpCode = CilOpCodes.Leave_S;                      break;                  case CilCode.Brfalse:                      instruction.OpCode = CilOpCodes.Brfalse_S;                      break;                  case CilCode.Brtrue:                      instruction.OpCode = CilOpCodes.Brtrue_S;                      break;                  case CilCode.Beq:                      instruction.OpCode = CilOpCodes.Beq_S;                      break;                  case CilCode.Bge:                      instruction.OpCode = CilOpCodes.Bge_S;                      break;                  case CilCode.Bge_Un:                      instruction.OpCode = CilOpCodes.Bge_Un_S;                      break;                  case CilCode.Bgt:                      instruction.OpCode = CilOpCodes.Bgt_S;                      break;                  case CilCode.Bgt_Un:                      instruction.OpCode = CilOpCodes.Bgt_Un_S;                      break;                  case CilCode.Ble:                      instruction.OpCode = CilOpCodes.Ble_S;                      break;                  case CilCode.Ble_Un:                      instruction.OpCode = CilOpCodes.Ble_Un_S;                      break;                  case CilCode.Blt:                      instruction.OpCode = CilOpCodes.Blt_S;                      break;                  case CilCode.Blt_Un:                      instruction.OpCode = CilOpCodes.Blt_Un_S;                      break;                  case CilCode.Bne_Un:                      instruction.OpCode = CilOpCodes.Bne_Un_S;                      break;              }
Missing Default,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeVariable,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case CilCode.Ldloc:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Ldloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Ldloc_S;                      }                      break;                  case CilCode.Ldloca:                      instruction.OpCode = CilOpCodes.Ldloca_S;                      break;                  case CilCode.Stloc:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Stloc_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Stloc_S;                      }                      break;              }
Missing Default,AsmResolver.Net.Cil,CilInstructionCollection,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionCollection.cs,TryOptimizeArgument,The following switch statement is missing a default case: switch (instruction.OpCode.Code)              {                  case CilCode.Ldarg:                      if (index <= 3)                      {                          instruction.OpCode = CilOpCodes.SingleByteOpCodes[CilOpCodes.Ldarg_0.Op2 + index];                          instruction.Operand = null;                      }                      else                      {                          instruction.OpCode = CilOpCodes.Ldarg_S;                      }                      break;                  case CilCode.Ldarga:                      instruction.OpCode = CilOpCodes.Ldarga_S;                      break;              }
Missing Default,AsmResolver.Net.Cil,CilInstructionFormatter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionFormatter.cs,FormatArgument,The following switch statement is missing a default case: switch (operand)              {                  case ParameterSignature signature:                      int index = _methodBody.Method.Signature.Parameters.IndexOf(signature);                      if (index != -1)                      {                          var paramDef = _methodBody.Method.Parameters.FirstOrDefault(x => x.Sequence == index);                          return paramDef != null ? paramDef.Name : "A_" + index;                      }                      break;                                    case short longIndex:                      return "A_" + longIndex;                                    case byte shortIndex:                      return "A_" + shortIndex;              }
Missing Default,AsmResolver.Net.Cil,CilInstructionFormatter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstructionFormatter.cs,FormatSignature,The following switch statement is missing a default case: switch (operand)              {                  case StandAloneSignature signature:                      return signature.Signature.ToString();                                    case MetadataToken token:                      return FormatToken(token);              }
Missing Default,AsmResolver.Net.Cil,ExceptionHandler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\ExceptionHandler.cs,FromReader,The following switch statement is missing a default case: switch (handler.HandlerType)              {                  case ExceptionHandlerType.Exception:                      handler.CatchType = (ITypeDefOrRef) ((IOperandResolver) cilMethodBody).ResolveMember(                              new MetadataToken(classTokenOrFilterOffset));                      break;                  case ExceptionHandlerType.Filter:                      handler.FilterStart = cilMethodBody.Instructions.GetByOffset((int)classTokenOrFilterOffset);                      break;              }
Missing Default,AsmResolver.Net.Cil,CilMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilMethodBody.cs,ComputeMaxStack,The following switch statement is missing a default case: switch (instruction.OpCode.FlowControl)                      {                          case CilFlowControl.Branch:                              agenda.Push(new StackState(                                  Instructions.GetIndexByOffset(((CilInstruction) instruction.Operand).Offset)'                                  nextStackSize));                              break;                          case CilFlowControl.CondBranch:                              switch (instruction.OpCode.OperandType)                              {                                  case CilOperandType.InlineBrTarget:                                  case CilOperandType.ShortInlineBrTarget:                                      agenda.Push(new StackState(                                          Instructions.GetIndexByOffset(((CilInstruction) instruction.Operand).Offset)'                                          nextStackSize));                                      break;                                  case CilOperandType.InlineSwitch:                                      foreach (var target in ((IEnumerable<CilInstruction>) instruction.Operand))                                      {                                          agenda.Push(new StackState(                                              Instructions.GetIndexByOffset(target.Offset)'                                              nextStackSize));                                      }                                      break;                              }                              agenda.Push(new StackState(                                  currentState.InstructionIndex + 1'                                  nextStackSize));                              break;                          case CilFlowControl.Call:                          case CilFlowControl.Break:                          case CilFlowControl.Meta:                          case CilFlowControl.Phi:                          case CilFlowControl.Next:                              agenda.Push(new StackState(                                  currentState.InstructionIndex + 1'                                  nextStackSize));                              break;                          case CilFlowControl.Return:                              if (nextStackSize != 0)                                  throw new StackInbalanceException(this' instruction.Offset);                              break;                      }
Missing Default,AsmResolver.Net.Cil,CilMethodBody,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilMethodBody.cs,ComputeMaxStack,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType)                              {                                  case CilOperandType.InlineBrTarget:                                  case CilOperandType.ShortInlineBrTarget:                                      agenda.Push(new StackState(                                          Instructions.GetIndexByOffset(((CilInstruction) instruction.Operand).Offset)'                                          nextStackSize));                                      break;                                  case CilOperandType.InlineSwitch:                                      foreach (var target in ((IEnumerable<CilInstruction>) instruction.Operand))                                      {                                          agenda.Push(new StackState(                                              Instructions.GetIndexByOffset(target.Offset)'                                              nextStackSize));                                      }                                      break;                              }
Missing Default,AsmResolver.Net.Cil,CilAssembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilAssembler.cs,WriteOperand,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType)              {                  case CilOperandType.InlineArgument:                      _writer.WriteUInt16((ushort)_builder.GetParameterIndex(instruction.Operand as ParameterSignature));                      break;                  case CilOperandType.ShortInlineArgument:                      _writer.WriteByte((byte)_builder.GetParameterIndex(instruction.Operand as ParameterSignature));                      break;                    case CilOperandType.InlineVar:                      _writer.WriteUInt16((ushort)_builder.GetVariableIndex(instruction.Operand as VariableSignature));                      break;                  case CilOperandType.ShortInlineVar:                      _writer.WriteByte((byte)_builder.GetVariableIndex(instruction.Operand as VariableSignature));                      break;                    case CilOperandType.ShortInlineI:                      _writer.WriteSByte((sbyte)instruction.Operand);                      break;                  case CilOperandType.InlineI:                      _writer.WriteInt32((int)instruction.Operand);                      break;                  case CilOperandType.InlineI8:                      _writer.WriteInt64((long)instruction.Operand);                      break;                  case CilOperandType.ShortInlineR:                      _writer.WriteSingle((float)instruction.Operand);                      break;                  case CilOperandType.InlineR:                      _writer.WriteDouble((double)instruction.Operand);                      break;                    case CilOperandType.InlineBrTarget:                      _writer.WriteInt32(((CilInstruction)instruction.Operand).Offset -                          (instruction.Offset + instruction.Size));                      break;                    case CilOperandType.ShortInlineBrTarget:                      _writer.WriteSByte((sbyte) (((CilInstruction) instruction.Operand).Offset -                                                  (instruction.Offset + instruction.Size)));                      break;                    case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                      var token = _builder.GetMetadataToken((IMetadataMember) instruction.Operand);                      if (token.Rid == 0)                          throw new InvalidOperationException($"Member {instruction.Operand} has an invalid metadata token.");                        _writer.WriteUInt32(token.ToUInt32());                      break;                    case CilOperandType.InlineString:                      _writer.WriteUInt32(_builder.GetStringOffset((string)instruction.Operand));                      break;                    case CilOperandType.InlineSwitch:                      var targets = (IList<CilInstruction>) instruction.Operand;                      _writer.WriteInt32(targets.Count);                      foreach (var target in targets)                          _writer.WriteInt32(target.Offset - (instruction.Offset + instruction.Size));                      break;                    case CilOperandType.InlineNone:                      break;              }
Missing Default,AsmResolver.Net.Cil,CilDisassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilDisassembler.cs,ReadRawOperand,The following switch statement is missing a default case: switch (cilOperandType)              {                  case CilOperandType.InlineNone:                      return null;                    case CilOperandType.InlineArgument:                  case CilOperandType.InlineVar:                      return reader.ReadUInt16();                    case CilOperandType.InlineI:                  case CilOperandType.InlineBrTarget:                      return reader.ReadInt32();                    case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                      return reader.ReadByte();                    case CilOperandType.ShortInlineBrTarget:                  case CilOperandType.ShortInlineI:                      return reader.ReadSByte();                    case CilOperandType.ShortInlineR:                      return reader.ReadSingle();                  case CilOperandType.InlineR:                      return reader.ReadDouble();                  case CilOperandType.InlineI8:                      return reader.ReadInt64();                    case CilOperandType.InlineField :                  case CilOperandType.InlineMethod :                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                      return new MetadataToken(reader.ReadUInt32());                    case CilOperandType.InlineSwitch:                      var offsets = new int[reader.ReadUInt32()];                      for (int i = 0; i < offsets.Length; i++)                          offsets[i] = reader.ReadInt32();                      return offsets;              }
Missing Default,AsmResolver.Net.Cil,CilDisassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilDisassembler.cs,ResolveOperand,The following switch statement is missing a default case: switch (current.OpCode.OperandType)              {                  case CilOperandType.InlineArgument:                  case CilOperandType.ShortInlineArgument:                      var parameter = _resolver.ResolveParameter(Convert.ToInt32(current.Operand));                      if (parameter != null)                          current.Operand = parameter;                      break;                    case CilOperandType.InlineVar:                  case CilOperandType.ShortInlineVar:                      var variable = _resolver.ResolveVariable(Convert.ToInt32(current.Operand));                      if (variable != null)                          current.Operand = variable;                      break;                    case CilOperandType.ShortInlineBrTarget:                  case CilOperandType.InlineBrTarget:                      var targetInstruction = instructions.FirstOrDefault(                          x => x.Offset == nextOffset + Convert.ToInt32(current.Operand));                      if (targetInstruction != null)                          current.Operand = targetInstruction;                      break;                    case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                      var member = _resolver.ResolveMember((MetadataToken)current.Operand);                      if (member != null)                          current.Operand = member;                      break;                    case CilOperandType.InlineString:                      var stringValue = _resolver.ResolveString(((MetadataToken) current.Operand).ToUInt32());                      if (stringValue != null)                          current.Operand = stringValue;                      break;                    case CilOperandType.InlineSwitch:                      var targetOffsets = (IList<int>) current.Operand;                      var targets = new List<CilInstruction>(targetOffsets.Count);                      for (int i = 0; i < targetOffsets.Count; i++)                      {                          targets.Add(instructions.FirstOrDefault(                              x => x.Offset == nextOffset + targetOffsets[i]));                      }                      current.Operand = targets;                      break;              }
Missing Default,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,Create,The following switch statement is missing a default case: switch (code.OperandType)              {                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                      return new CilInstruction(0' code' operand);              }
Missing Default,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetOperandSize,The following switch statement is missing a default case: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return 0;                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.ShortInlineVar:                  case CilOperandType.ShortInlineI:                  case CilOperandType.ShortInlineBrTarget:                      return 1;                  case CilOperandType.InlineVar:                  case CilOperandType.InlineArgument:                      return 2;                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                  case CilOperandType.InlineString:                  case CilOperandType.InlineBrTarget:                      return 4;                    case CilOperandType.InlineR:                  case CilOperandType.InlineI8:                      return 8;                    case CilOperandType.InlineSwitch:                      var array = Operand as IList;                      if (array == null)                          return 4;                      return 4 * (array.Count + 1);              }
Missing Default,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,OperandToString,The following switch statement is missing a default case: switch (OpCode.OperandType)              {                  case CilOperandType.InlineNone:                      return string.Empty;                    case CilOperandType.InlineArgument:                  case CilOperandType.ShortInlineArgument:                  case CilOperandType.InlineVar:                  case CilOperandType.ShortInlineVar:                      // TODO: return index                    case CilOperandType.InlineR:                  case CilOperandType.ShortInlineR:                  case CilOperandType.InlineI:                  case CilOperandType.InlineI8:                  case CilOperandType.ShortInlineI:                      return Convert.ToString(Operand' CultureInfo.InvariantCulture);                    case CilOperandType.InlineField:                  case CilOperandType.InlineMethod:                  case CilOperandType.InlineSig:                  case CilOperandType.InlineTok:                  case CilOperandType.InlineType:                      return Operand is IMetadataMember member                          ? member.ToString()                          : "TOKEN<0x" + ((MetadataToken) Operand) + ">";                    case CilOperandType.InlineString:                      return Operand is string                          ? $"\"{Operand}\""                          : "TOKEN<0x" + ((MetadataToken) Operand) + ">";                  case CilOperandType.InlineSwitch:                      return string.Join("' "'                          ((IList<CilInstruction>) Operand).Select(x => "IL_" + x.Offset.ToString("X4")));                    case CilOperandType.InlineBrTarget:                  case CilOperandType.ShortInlineBrTarget:                      return "IL_" + ((CilInstruction) Operand).Offset.ToString("X4");              }
Missing Default,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetStackPopCount,The following switch statement is missing a default case: switch (OpCode.StackBehaviourPop)              {                  case CilStackBehaviour.Pop1:                  case CilStackBehaviour.Popi:                  case CilStackBehaviour.Popref:                      return 1;                                    case CilStackBehaviour.Pop1_pop1:                  case CilStackBehaviour.Popi_pop1:                  case CilStackBehaviour.Popi_popi:                  case CilStackBehaviour.Popi_popi8:                  case CilStackBehaviour.Popi_popr4:                  case CilStackBehaviour.Popi_popr8:                  case CilStackBehaviour.Popref_pop1:                  case CilStackBehaviour.Popref_popi:                      return 2;                                    case CilStackBehaviour.Popi_popi_popi:                  case CilStackBehaviour.Popref_popi_pop1:                  case CilStackBehaviour.Popref_popi_popi:                  case CilStackBehaviour.Popref_popi_popi8:                  case CilStackBehaviour.Popref_popi_popr4:                  case CilStackBehaviour.Popref_popi_popr8:                  case CilStackBehaviour.Popref_popi_popref:                      return 3;                                    case CilStackBehaviour.Varpop:                      if (signature == null)                      {                          if (OpCode.Code == CilCode.Ret)                              return parent.Method.Signature.ReturnType.IsTypeOf("System"' "Void") ? 0 : 1;                      }                      else                      {                          int count = signature.Parameters.Count;                          if (signature.HasThis && OpCode.Code != CilCode.Newobj)                              count++;                          return count;                      }                        break;              }
Missing Default,AsmResolver.Net.Cil,CilInstruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cil\CilInstruction.cs,GetStackPushCount,The following switch statement is missing a default case: switch (OpCode.StackBehaviourPush)              {                  case CilStackBehaviour.Push1:                  case CilStackBehaviour.Pushi:                  case CilStackBehaviour.Pushi8:                  case CilStackBehaviour.Pushr4:                  case CilStackBehaviour.Pushr8:                  case CilStackBehaviour.Pushref:                      return 1;                                    case CilStackBehaviour.Push1_push1:                      return 2;                                    case CilStackBehaviour.Varpush:                      if (signature != null                          && (!signature.ReturnType.IsTypeOf("System"' "Void") || OpCode.Code == CilCode.Newobj))                          return 1;                      break;              }
Missing Default,AsmResolver.Net.Cts,MemberCloner,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MemberCloner.cs,CloneInstructions,The following switch statement is missing a default case: switch (operand)                  {                      case IMemberReference member:                          // Import reference.                          operand = _importer.ImportReference((IMemberReference) operand);                          break;                                            case VariableSignature variable:                          // Reference the new variable instead.                          var oldVarSig = (LocalVariableSignature) body.Signature.Signature;                          var newVarSig = (LocalVariableSignature) newBody.Signature.Signature;                          operand = newVarSig.Variables[oldVarSig.Variables.IndexOf(variable)];                          break;                                                case ParameterSignature parameter:                          // Reference the new parameter instead.                          var oldParameters = body.Method.Signature.Parameters;                          var newParameters = newBody.Method.Signature.Parameters;                          operand = newParameters[oldParameters.IndexOf((ParameterSignature) operand)];                          break;                  }
Missing Default,AsmResolver.Net.Cts,MemberCloner,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\MemberCloner.cs,CloneInstructions,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType)                  {                      case CilOperandType.InlineBrTarget:                      case CilOperandType.ShortInlineBrTarget:                          branchInstructions.Add(newInstruction);                          break;                      case CilOperandType.InlineSwitch:                          switchInstructions.Add(newInstruction);                          break;                  }
Missing Default,AsmResolver.Net.Cts,FieldRva,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\FieldRva.cs,ReadElement,The following switch statement is missing a default case: switch (elementType)              {                  case ElementType.I1:                      return reader.ReadSByte();                  case ElementType.I2:                      return reader.ReadInt16();                  case ElementType.I4:                      return reader.ReadInt32();                  case ElementType.I8:                      return reader.ReadInt64();                  case ElementType.U1:                      return reader.ReadByte();                  case ElementType.U2:                      return reader.ReadUInt16();                  case ElementType.U4:                      return reader.ReadUInt32();                  case ElementType.U8:                      return reader.ReadUInt64();                  case ElementType.R4:                      return reader.ReadSingle();                  case ElementType.R8:                      return reader.ReadDouble();              }
Missing Default,AsmResolver.Net.Cts,ReferenceImporter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Cts\ReferenceImporter.cs,GetCorLibSignature,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Boolean:                      return _typeSystem.Boolean;                  case TypeCode.Byte:                      return _typeSystem.Byte;                  case TypeCode.Char:                      return _typeSystem.Char;                  case TypeCode.Double:                      return _typeSystem.Double;                  case TypeCode.Int16:                      return _typeSystem.Int16;                  case TypeCode.Int32:                      return _typeSystem.Int32;                  case TypeCode.Int64:                      return _typeSystem.Int64;                  case TypeCode.SByte:                      return _typeSystem.SByte;                  case TypeCode.Single:                      return _typeSystem.Single;                  case TypeCode.String:                      return _typeSystem.String;                  case TypeCode.UInt16:                      return _typeSystem.UInt16;                  case TypeCode.UInt32:                      return _typeSystem.UInt32;                  case TypeCode.UInt64:                      return _typeSystem.UInt64;              }
Missing Default,AsmResolver.Net.Signatures,CallingConventionSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\CallingConventionSignature.cs,ReadSignature,The following switch statement is missing a default case: switch ((CallingConventionAttributes) flag & SignatureTypeMask)              {                  case CallingConventionAttributes.Default:                  case CallingConventionAttributes.C:                  case CallingConventionAttributes.ExplicitThis:                  case CallingConventionAttributes.FastCall:                  case CallingConventionAttributes.StdCall:                  case CallingConventionAttributes.ThisCall:                  case CallingConventionAttributes.VarArg:                      return MethodSignature.FromReader(image' reader' false' protection);                  case CallingConventionAttributes.Property:                      return PropertySignature.FromReader(image' reader' false' protection);                  case CallingConventionAttributes.Local:                      return LocalVariableSignature.FromReader(image' reader' false'protection);                  case CallingConventionAttributes.GenericInstance:                      return GenericInstanceMethodSignature.FromReader(image' reader' protection);                  case CallingConventionAttributes.Field:                      return FieldSignature.FromReader(image' reader' false' protection);              }
Missing Default,AsmResolver.Net.Signatures,DataBlobSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\DataBlobSignature.cs,InterpretData,The following switch statement is missing a default case: switch (constantType)              {                  case ElementType.Boolean:                      return Data[0] == 1;                  case ElementType.Char:                      return (char)BitConverter.ToUInt16(Data' 0);                  case ElementType.I1:                      return unchecked((sbyte)Data[0]);                  case ElementType.I2:                      return BitConverter.ToInt16(Data' 0);                  case ElementType.I4:                      return BitConverter.ToInt32(Data' 0);                  case ElementType.I8:                      return BitConverter.ToInt64(Data' 0);                  case ElementType.U1:                      return Data[0];                  case ElementType.U2:                      return BitConverter.ToUInt16(Data' 0);                  case ElementType.U4:                      return BitConverter.ToUInt32(Data' 0);                  case ElementType.U8:                      return BitConverter.ToUInt64(Data' 0);                  case ElementType.R4:                      return BitConverter.ToSingle(Data' 0);                  case ElementType.R8:                      return BitConverter.ToDouble(Data' 0);                  case ElementType.String:                      return Encoding.Unicode.GetString(Data);                  case ElementType.Class:                      return null;              }
Missing Default,AsmResolver.Net.Signatures,ElementSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ElementSignature.cs,ReadValue,The following switch statement is missing a default case: switch (typeSignature.ElementType)              {                  case ElementType.Boolean:                      return reader.ReadByte() == 1;                  case ElementType.Char:                      return (char)reader.ReadUInt16();                  case ElementType.R4:                      return reader.ReadSingle();                  case ElementType.R8:                      return reader.ReadDouble();                  case ElementType.I1:                      return reader.ReadSByte();                  case ElementType.I2:                      return reader.ReadInt16();                  case ElementType.I4:                      return reader.ReadInt32();                  case ElementType.I8:                      return reader.ReadInt64();                  case ElementType.U1:                      return reader.ReadByte();                  case ElementType.U2:                      return reader.ReadUInt16();                  case ElementType.U4:                      return reader.ReadUInt32();                  case ElementType.U8:                      return reader.ReadUInt64();                  case ElementType.String:                      return reader.ReadSerString();                  case ElementType.Object:                      return ReadValue(image' TypeSignature.ReadFieldOrPropType(image' reader)' reader);                  case ElementType.Class:                  case ElementType.Enum:                  case ElementType.ValueType:                      var enumTypeDef = image.MetadataResolver.ResolveType(typeSignature);                      if (enumTypeDef == null)                          throw new MemberResolutionException(typeSignature);                        if (enumTypeDef.IsEnum)                          return ReadValue(image' enumTypeDef.GetEnumUnderlyingType()' reader);                      break;              }
Missing Default,AsmResolver.Net.Signatures,ElementSignature,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\ElementSignature.cs,GetPhysicalLength,The following switch statement is missing a default case: switch (Type.GetTypeCode(Value.GetType()))              {                  case TypeCode.Boolean:                  case TypeCode.Byte:                  case TypeCode.SByte:                      return sizeof(byte);                  case TypeCode.Char:                  case TypeCode.Int16:                  case TypeCode.UInt16:                      return sizeof(ushort);                  case TypeCode.Single:                  case TypeCode.Int32:                  case TypeCode.UInt32:                      return sizeof(uint);                  case TypeCode.Double:                  case TypeCode.Int64:                  case TypeCode.UInt64:                      return sizeof(ulong);                  case TypeCode.String:                      return ((Value as string).GetSerStringSize());              }
Missing Default,AsmResolver.Net.Signatures,TypeNameParser,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\Net\Signatures\TypeNameParser.cs,ReadTypeSignature,The following switch statement is missing a default case: switch (name[position])                  {                      case '*':                          return new PointerTypeSignature(elementType);                      case '&':                          return new ByReferenceTypeSignature(elementType);                      case '[':                          position++;                          if (name[position] == ']')                          {                              position++;                              return new SzArrayTypeSignature(elementType);                          }                            // TODO: support generic types + generic instances.                          break;                  }
Missing Default,AsmResolver.X86,X86Formatter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\IX86Formatter.cs,FormatValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(value.GetType()))              {                  case TypeCode.Byte:                      return FormatByte((byte)value);                  case TypeCode.UInt16:                      return FormatWord((ushort)value);                  case TypeCode.UInt32:                      return FormatDword((uint)value);                  case TypeCode.UInt64:                      return FormatQword((ulong)value);              }
Missing Default,AsmResolver.X86,FasmX86Formatter,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\IX86Formatter.cs,FormatOperandUsagePrefix,The following switch statement is missing a default case: switch (operandUsage)              {                  case X86OperandUsage.Normal:                      return null;                  case X86OperandUsage.BytePointer:                      return "byte";                  case X86OperandUsage.WordPointer:                      return "word";                  case X86OperandUsage.DwordPointer:                      return "dword";                  case X86OperandUsage.FwordPointer:                      return "fword";              }
Missing Default,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,WriteOperandValue,The following switch statement is missing a default case: switch (method)              {                  case X86OperandType.MemoryAddress:                  case X86OperandType.DirectAddress:                  case X86OperandType.ImmediateData:                  {                      WriteNumber(operand.Value' size);                      break;                  }                  case X86OperandType.RegisterOrMemoryAddress:                  {                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          _writer.WriteByte(ComputeRegOrMemSibToken(operand));                      else if (!(operand.Value is X86Register))                          WriteNumber(operand.Value' X86OperandSize.Dword);                      break;                  }                  case X86OperandType.RelativeOffset:                  {                      WriteNumber(Convert.ToUInt32(operand.Value) - (_writer.Position + (int) size)' size);                      break;                  }              }
Missing Default,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,ComputeRegisterTokenPart,The following switch statement is missing a default case: switch (method)              {                  case X86OperandType.Register:                  {                      return (byte)(ComputeRegisterToken((X86Register)operand.Value) << 3);                  }                  case X86OperandType.RegisterOrMemoryAddress:                  {                      return ComputeRegOrMemToken(operand);                  }              }
Missing Default,AsmResolver.X86,X86Assembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Assembler.cs,DetermineRegOrMemModifier,The following switch statement is missing a default case: switch (operand.OffsetType)                  {                      case X86OffsetType.None:                          return operand.OperandUsage == X86OperandUsage.Normal                              ? X86RegOrMemModifier.RegisterOnly                              : X86RegOrMemModifier.RegisterPointer;                      case X86OffsetType.Short:                          return X86RegOrMemModifier.RegisterDispShortPointer;                      case X86OffsetType.Long:                          return X86RegOrMemModifier.RegisterDispLongPointer;                  }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadOperand,The following switch statement is missing a default case: switch (method)              {                  case X86OperandType.OpCodeRegister:                      return new X86Operand(GetRegisterFromToken((byte)(opcode & 7)' GetRegisterSize(prefixes' size)));                    case X86OperandType.Register:                      return new X86Operand(GetRegisterFromToken((byte)((registerToken >> 3) & 7)'                          GetRegisterSize(prefixes' size)));                    case X86OperandType.RegisterOrMemoryAddress:                      return GetRegOrMemOperand32(prefixes' registerToken' size);                    case X86OperandType.ImmediateData:                      return new X86Operand(ReadImmediateData(prefixes' size));                    case X86OperandType.MemoryAddress:                      return new X86Operand(GetOperandType(prefixes' size)' _reader.ReadUInt32());                    case X86OperandType.RegisterAl:                      return new X86Operand(X86Register.Al);                    case X86OperandType.RegisterCl:                      return new X86Operand(X86Register.Cl);                    case X86OperandType.RegisterDx:                      return new X86Operand(X86Register.Dx);                    case X86OperandType.RegisterEax:                      return new X86Operand(X86Register.Eax);                                        case X86OperandType.ImmediateOne:                      return new X86Operand(1);                    case X86OperandType.RelativeOffset:                      return new X86Operand((ulong)(Convert.ToInt64(ReadSignedImmediateData(size)) + BaseAddress + _reader.Position));                    case X86OperandType.None:                      return null;                }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadSignedImmediateData,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return _reader.ReadSByte();                  case X86OperandSize.Word:                      return _reader.ReadInt16();                  case X86OperandSize.Dword:                      return _reader.ReadInt32();                  case X86OperandSize.WordOrDword:                      return _reader.ReadInt32(); // TODO: use operand-size override opcode                  // TODO: fword              }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,ReadImmediateData,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return _reader.ReadByte();                  case X86OperandSize.Word:                      return _reader.ReadUInt16();                  case X86OperandSize.Dword:                      return _reader.ReadUInt32();                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride)                           ? _reader.ReadUInt16()                          : _reader.ReadUInt32();                      // TODO: fword              }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegisterSize,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return X86RegisterSize.Byte;                  case X86OperandSize.Word:                      return X86RegisterSize.Word;                  case X86OperandSize.Dword:                      return X86RegisterSize.Dword;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride)                          ? X86RegisterSize.Word                          : X86RegisterSize.Dword;              }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetOperandType,The following switch statement is missing a default case: switch (size)              {                  case X86OperandSize.Byte:                      return X86OperandUsage.BytePointer;                  case X86OperandSize.Word:                      return X86OperandUsage.WordPointer;                  case X86OperandSize.Dword:                      return X86OperandUsage.DwordPointer;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride)                          ? X86OperandUsage.WordPointer                          : X86OperandUsage.DwordPointer;                  case X86OperandSize.Fword:                      return X86OperandUsage.FwordPointer;              }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegOrMemOperand32,The following switch statement is missing a default case: switch (modifier)              {                  case X86RegOrMemModifier.RegisterDispShortPointer:                      operand.Offset = _reader.ReadSByte();                      operand.OffsetType = X86OffsetType.Short;                      break;                  case X86RegOrMemModifier.RegisterDispLongPointer:                      operand.Offset = _reader.ReadInt32();                      operand.OffsetType = X86OffsetType.Long;                      break;              }
Missing Default,AsmResolver.X86,X86Disassembler,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Disassembler.cs,GetRegisterFromToken,The following switch statement is missing a default case: switch (size)              {                  case X86RegisterSize.Byte:                      return register;                  case X86RegisterSize.Word:                      return register | X86Register.Ax;                  case X86RegisterSize.Dword:                      return register | X86Register.Eax;              }
Missing Default,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetTotalOperandSize,The following switch statement is missing a default case: switch (operandType)              {                  case X86OperandType.None:                  case X86OperandType.ControlRegister:                  case X86OperandType.DebugRegister:                  case X86OperandType.StackRegister:                  case X86OperandType.Register:                  case X86OperandType.RegisterCl:                  case X86OperandType.RegisterDx:                  case X86OperandType.RegisterEax:                  case X86OperandType.RegisterAl:                  case X86OperandType.ImmediateOne:                  case X86OperandType.SegmentRegister:                  case X86OperandType.OpCodeRegister:                      break;                    case X86OperandType.DirectAddress:                  case X86OperandType.MemoryAddress:                      size += 4;                      break;                    case X86OperandType.RelativeOffset:                  case X86OperandType.ImmediateData:                      size += GetSize(prefixes' operandSize);                      break;                    case X86OperandType.RegisterOrMemoryAddress:                  case X86OperandType.StackRegisterOrMemoryAddress:                      if ((operand.ScaledIndex != null) ||                          (operand.OperandUsage != X86OperandUsage.Normal && operand.Value is X86Register &&                           (X86Register)operand.Value == X86Register.Esp))                          size += 1;                      if (!(operand.Value is X86Register))                          size += 4;                      break;              }
Missing Default,AsmResolver.X86,X86Instruction,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Instruction.cs,GetSize,The following switch statement is missing a default case: switch (operandSize)              {                  case X86OperandSize.Byte:                      return 1;                  case X86OperandSize.Word:                      return 2;                  case X86OperandSize.WordOrDword:                      return prefixes.Contains(X86Prefixes.OperandSizeOverride) ? 2 : 4;                  case X86OperandSize.Dword:                      return 4;                  case X86OperandSize.Fword:                      return 6;              }
Missing Default,AsmResolver.X86,X86Operand,D:\research\architectureSmells\repos\JerreS_AsmResolver\AsmResolver\X86\X86Operand.cs,ToString,The following switch statement is missing a default case: switch (OperandUsage)              {                  case X86OperandUsage.Normal:                      return Value.ToString();                  case X86OperandUsage.BytePointer:                      return string.Format("byte [{0}]"' Value);                  case X86OperandUsage.DwordPointer:                      return string.Format("dword [{0}]"' Value);                  case X86OperandUsage.FwordPointer:                      return string.Format("fword [{0}]"' Value);              }
