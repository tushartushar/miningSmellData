Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AssemblyVisualizer.HAL.ILSpy,Converter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\HAL\ILSpy\Converter.cs,Assembly,Cyclomatic complexity of the method is 9
Complex Method,AssemblyVisualizer.HAL.ILSpy,Converter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\HAL\ILSpy\Converter.cs,Type,Cyclomatic complexity of the method is 8
Complex Method,AssemblyVisualizer.InteractionBrowser,InteractionBrowserWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\InteractionBrowserWindowViewModel.cs,CreateGraph,Cyclomatic complexity of the method is 11
Complex Method,AssemblyVisualizer.AncestryBrowser,TypeViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AncestryBrowser\TypeViewModel.cs,UpdateMembers,Cyclomatic complexity of the method is 14
Complex Method,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,ChangeState,Cyclomatic complexity of the method is 8
Complex Method,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,Cyclomatic complexity of the method is 12
Complex Method,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,Horizontal,Cyclomatic complexity of the method is 8
Complex Method,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,HorizontalImproved,Cyclomatic complexity of the method is 14
Complex Method,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,Vertical,Cyclomatic complexity of the method is 8
Complex Method,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,VerticalImproved,Cyclomatic complexity of the method is 14
Long Parameter List,AssemblyVisualizer.Controls.Graph,IAnimation,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\IAnimation.cs,Animate,The method has 5 parameters. Parameters: context' control' x' y' duration
Long Parameter List,AssemblyVisualizer.Controls.Graph.Animations,SimpleMoveAnimation,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Animations\SimpleMoveAnimation.cs,Animate,The method has 5 parameters. Parameters: context' control' x' y' duration
Long Parameter List,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,CompoundLayoutContext<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\CompoundLayoutContext.cs,CompoundLayoutContext,The method has 6 parameters. Parameters: graph' positions' sizes' mode' vertexBorders' layoutTypes
Long Parameter List,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LayoutIterationEventArgs<TVertex;TEdge;TVertexInfo;TEdgeInfo>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LayoutIterationEventArgs.cs,LayoutIterationEventArgs,The method has 6 parameters. Parameters: iteration' statusInPercent' message' vertexPositions' vertexInfos' edgeInfos
Long Parameter List,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LayoutState<TVertex;TEdge>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LayoutState.cs,LayoutState,The method has 6 parameters. Parameters: positions' overlapRemovedPositions' routeInfos' computationTime' iteration' message
Long Parameter List,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,QuadTree,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.QuadTree.cs,QuadTree,The method has 5 parameters. Parameters: index' position' weight' minPos' maxPos
Long Parameter List,AssemblyVisualizer.Controls.Graph.QuickGraph,BidirectionalGraph<TVertex;TEdge>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\QuickGraph\BidirectionalGraph.cs,BidirectionalGraph,The method has 5 parameters. Parameters: vertexInEdges' vertexOutEdges' edgeCount' edgeCapacity' allowParallelEdges
Long Parameter List,AssemblyVisualizer.Controls,NativeMethods,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\PopupNonTopmost.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hwndInsertAfter' x' y' cx' cy' wFlags
Long Parameter List,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,GetCoercedTranslate,The method has 5 parameters. Parameters: translate' zoom' contentSize' desiredSize' actualSize
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter AnimationDisablerVertexCountProperty is 36.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter AnimationDisablerEdgeCountProperty is 34.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter EdgeRoutingAlgorithmFactoryProperty is 35.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter EdgeRoutingAlgorithmPropertyKey is 31.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter EdgeRoutingAlgorithmTypeProperty is 32.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter HighlightAlgorithmFactoryProperty is 33.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter HighlightAlgorithmTypeProperty is 30.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter LayoutAlgorithmFactoryProperty is 30.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter LayoutStatusPercentPropertyKey is 30.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter OverlapRemovalAlgorithmFactoryProperty is 38.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter OverlapRemovalAlgorithmProperty is 31.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter OverlapRemovalAlgorithmPropertyKey is 34.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter OverlapRemovalAlgorithmTypeProperty is 35.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter OverlapRemovalConstraintProperty is 32.
Long Identifier,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,,The length of the parameter OverlapRemovalParametersProperty is 32.
Long Identifier,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,,The length of the parameter ZoomBoxBorderThicknessProperty is 30.
Long Statement,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "				"EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9)."); " is 142.
Long Statement,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\ContextualLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "					return new DoubleTreeLayoutAlgorithm<TVertex' TEdge' TGraph>( layoutContext.Graph' layoutContext.Positions' layoutContext.Sizes' parameters as DoubleTreeLayoutParameters' layoutContext.SelectedVertex ); " is 202.
Long Statement,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\ContextualLayoutAlgorithmFactory.cs,CreateAlgorithm,The length of the statement  "					return new BalloonTreeLayoutAlgorithm<TVertex' TEdge' TGraph>( layoutContext.Graph' layoutContext.Positions' layoutContext.Sizes' parameters as BalloonTreeLayoutParameters' layoutContext.SelectedVertex );*/ " is 206.
Long Statement,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\ContextualLayoutAlgorithmFactory.cs,CreateParameters,The length of the statement  "					return !( oldParameters is DoubleTreeLayoutParameters ) ? new DoubleTreeLayoutParameters() : (DoubleTreeLayoutParameters)( oldParameters as DoubleTreeLayoutParameters ).Clone(); " is 177.
Long Statement,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,ContextualLayoutAlgorithmFactory<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\ContextualLayoutAlgorithmFactory.cs,CreateParameters,The length of the statement  "					return !( oldParameters is BalloonTreeLayoutParameters ) ? new BalloonTreeLayoutParameters() : (BalloonTreeLayoutParameters)( oldParameters as BalloonTreeLayoutParameters ).Clone();*/ " is 183.
Complex Conditional,AssemblyVisualizer.DependencyBrowser,DependencyBrowserWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\DependencyBrowser\DependencyBrowserWindowViewModel.cs,SelectUnreachableAssemblies,The conditional expression  "!assembly.IsRemoved && !assembly.IsProcessed  				    && !assembly.IsRoot && !assembly.IsSelected"  is complex.
Complex Conditional,AssemblyVisualizer.DependencyBrowser,DependencyBrowserWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\DependencyBrowser\DependencyBrowserWindowViewModel.cs,ProcessRec,The conditional expression  "!refAssembly.IsRemoved && !refAssembly.IsProcessed  				    && !refAssembly.IsRoot && !refAssembly.IsSelected"  is complex.
Complex Conditional,AssemblyVisualizer.Controls.Graph,GraphCanvas,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphCanvas.cs,ArrangeOverride,The conditional expression  "double.IsNaN(graphSize.X) || double.IsNaN(graphSize.Y) ||  			    double.IsInfinity(graphSize.X) || double.IsInfinity(graphSize.Y)"  is complex.
Complex Conditional,AssemblyVisualizer.Controls.Graph,GraphCanvas,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphCanvas.cs,MeasureOverride,The conditional expression  "double.IsNaN(graphSize.Width) || double.IsNaN(graphSize.Height) ||  			    double.IsInfinity(graphSize.Width) || double.IsInfinity(graphSize.Height)"  is complex.
Complex Conditional,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,OverlapRemoval,The conditional expression  "OverlapRemovalConstraint == AlgorithmConstraints.Skip  			    ||  			    OverlapRemovalConstraint == AlgorithmConstraints.Automatic &&  			    (!LayoutAlgorithmFactory.NeedOverlapRemoval(LayoutAlgorithmType) || !isValidAlgorithm)  			    || OverlapRemovalConstraint == AlgorithmConstraints.Must && !isValidAlgorithm"  is complex.
Complex Conditional,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,force,The conditional expression  "Gij >= gij && gij > 0 || -Gij <= gij && gij < 0 || gij == 0"  is complex.
Complex Conditional,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,force,The conditional expression  "Gij < gij && gij > 0 || -Gij > gij && gij < 0"  is complex.
Complex Conditional,AssemblyVisualizer,WindowManager,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\WindowManager.cs,ClearCacheIfPossible,The conditional expression  "AssemblyBrowsers.Count == 0  			    && AncestryBrowsers.Count == 0  			    && DependencyBrowsers.Count == 0  			    && InteractionBrowsers.Count == 0"  is complex.
Empty Catch Block,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,HighlightTriggerEventHandler,The method has an empty catch block.
Empty Catch Block,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,RecreateGraphElements,The method has an empty catch block.
Magic Number,AssemblyVisualizer.Common,BrushProvider,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Common\BrushProvider.cs,MakeTransparent,The following statement contains a magic number: var transparentColor = new Color  			{  				A = 136'  				R = brush.Color.R'  				G = brush.Color.G'  				B = brush.Color.B  			};
Magic Number,AssemblyVisualizer.InteractionBrowser,InteractionBrowserWindow,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\InteractionBrowserWindow.xaml.cs,OriginalSizeRequestHandler,The following statement contains a magic number: var animation = new DoubleAnimation(1' TimeSpan.FromSeconds(0.5));
Magic Number,AssemblyVisualizer.InteractionBrowser,SelectionWindow,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\SelectionWindow.xaml.cs,SelectionWindow,The following statement contains a magic number: var animation = new DoubleAnimation(1' new Duration(TimeSpan.FromSeconds(0.5)));
Magic Number,AssemblyVisualizer.InteractionBrowser,SelectionWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\SelectionWindowViewModel.cs,SelectionWindowViewModel,The following statement contains a magic number: _pieceHeight = 250;
Magic Number,AssemblyVisualizer.InteractionBrowser,SelectionWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\SelectionWindowViewModel.cs,SelectionWindowViewModel,The following statement contains a magic number: _pieceWidth = 250;
Magic Number,AssemblyVisualizer.InteractionBrowser,SelectionWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\SelectionWindowViewModel.cs,Refresh,The following statement contains a magic number: if (rowsNumber > 3)  				rowsNumber = 3;
Magic Number,AssemblyVisualizer.InteractionBrowser,SelectionWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\SelectionWindowViewModel.cs,Refresh,The following statement contains a magic number: if (rowsNumber > 3)  				rowsNumber = 3;
Magic Number,AssemblyVisualizer.InteractionBrowser,TypeViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\TypeViewModel.cs,GetForeground,The following statement contains a magic number: var foregroundColor = new Color  			{  				A = 255'  				R = (byte) (backgroundColor.R / 2.5)'  				G = (byte) (backgroundColor.G / 2.5)'  				B = (byte) (backgroundColor.B / 2.5)  			};
Magic Number,AssemblyVisualizer.InteractionBrowser,TypeViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\TypeViewModel.cs,GetForeground,The following statement contains a magic number: var foregroundColor = new Color  			{  				A = 255'  				R = (byte) (backgroundColor.R / 2.5)'  				G = (byte) (backgroundColor.G / 2.5)'  				B = (byte) (backgroundColor.B / 2.5)  			};
Magic Number,AssemblyVisualizer.InteractionBrowser,TypeViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\TypeViewModel.cs,GetForeground,The following statement contains a magic number: var foregroundColor = new Color  			{  				A = 255'  				R = (byte) (backgroundColor.R / 2.5)'  				G = (byte) (backgroundColor.G / 2.5)'  				B = (byte) (backgroundColor.B / 2.5)  			};
Magic Number,AssemblyVisualizer.InteractionBrowser,TypeViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\InteractionBrowser\TypeViewModel.cs,GetForeground,The following statement contains a magic number: var foregroundColor = new Color  			{  				A = 255'  				R = (byte) (backgroundColor.R / 2.5)'  				G = (byte) (backgroundColor.G / 2.5)'  				B = (byte) (backgroundColor.B / 2.5)  			};
Magic Number,AssemblyVisualizer.AncestryBrowser,AncestryBrowserWindowViewModel,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AncestryBrowser\AncestryBrowserWindowViewModel.cs,AncestryBrowserWindowViewModel,The following statement contains a magic number: foreach (var assembly in Assemblies)  			{  				var brush = BrushProvider.BrushPairs[currentIndex].Background as SolidColorBrush;  				brush = new SolidColorBrush(  					new Color {A = 72' R = brush.Color.R' G = brush.Color.G' B = brush.Color.B});    				assembly.BackgroundBrush = brush;  				assembly.CaptionBrush = BrushProvider.BrushPairs[currentIndex].Caption;  				currentIndex++;  				if (currentIndex == BrushProvider.BrushPairs.Count)  					currentIndex = 0;  			}
Magic Number,AssemblyVisualizer.DependencyBrowser,DependencyBrowserWindow,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\DependencyBrowser\DependencyBrowserWindow.xaml.cs,OriginalSizeRequestHandler,The following statement contains a magic number: var animation = new DoubleAnimation(1' TimeSpan.FromSeconds(0.5));
Magic Number,AssemblyVisualizer.AssemblyBrowser.UserControls,ScreenPresenter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\UserControls\ScreenPresenter.xaml.cs,ShowSearch,The following statement contains a magic number: var animation = new DoubleAnimation(1' TimeSpan.FromMilliseconds(350));
Magic Number,AssemblyVisualizer.AssemblyBrowser.UserControls,ScreenPresenter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\UserControls\ScreenPresenter.xaml.cs,HideSearch,The following statement contains a magic number: var animationLength = instant ? 0 : 350;
Magic Number,AssemblyVisualizer.AssemblyBrowser.Screens,GraphScreen,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\Screens\GraphScreen.cs,CreateGraph,The following statement contains a magic number: if (adjustExpansion)  			{  				ExpandAll(typeViewModel);  				if (typeViewModel.DescendantsCount > 100)  					AdjustExpansion(typeViewModel);  			}  			else  			{  				typeViewModel.IsExpanded = true;  				if (typeViewModel.DescendantsCount <= 100)  					ExpandAll(typeViewModel);  			}
Magic Number,AssemblyVisualizer.AssemblyBrowser.Screens,GraphScreen,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\Screens\GraphScreen.cs,CreateGraph,The following statement contains a magic number: if (adjustExpansion)  			{  				ExpandAll(typeViewModel);  				if (typeViewModel.DescendantsCount > 100)  					AdjustExpansion(typeViewModel);  			}  			else  			{  				typeViewModel.IsExpanded = true;  				if (typeViewModel.DescendantsCount <= 100)  					ExpandAll(typeViewModel);  			}
Magic Number,AssemblyVisualizer.AssemblyBrowser.Screens,GraphScreen,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\Screens\GraphScreen.cs,AdjustExpansion,The following statement contains a magic number: foreach (var type in typeViewModel.DerivedTypes)  			{  				if (type.DirectDescendantsCount > 3)  					type.IsExpanded = false;  				AdjustExpansion(type);  			}
Magic Number,AssemblyVisualizer.AssemblyBrowser.Screens,GraphScreenView,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\Screens\GraphScreenView.xaml.cs,ShowDetailsRequestHandler,The following statement contains a magic number: detailsPopup.MaxHeight = ActualHeight - 38;
Magic Number,AssemblyVisualizer.AssemblyBrowser.Screens,GraphScreenView,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\Screens\GraphScreenView.xaml.cs,OriginalSizeRequestHandler,The following statement contains a magic number: var animation = new DoubleAnimation(1' TimeSpan.FromSeconds(0.5));
Magic Number,AssemblyVisualizer.AssemblyBrowser.Screens,SearchScreen,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\AssemblyBrowser\Screens\SearchScreen.cs,InitializeSearchTimer,The following statement contains a magic number: _searchTimer = new DispatcherTimer(DispatcherPriority.Normal' WindowViewModel.Dispatcher)  			{  				Interval = TimeSpan.FromMilliseconds(400)  			};
Magic Number,AssemblyVisualizer.Controls.Graph,CompoundVertexControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl == args.OriginalSource)  			{  				//move the children with the same amount  				foreach (var childVertexControl in compoundVertexControl.Vertices)  				{  					GraphCanvas.SetX(childVertexControl' GraphCanvas.GetX(childVertexControl) + args.XChange);  					GraphCanvas.SetY(childVertexControl' GraphCanvas.GetY(childVertexControl) + args.YChange);  				}  			}  			else  			{  				//we are moving the parent or one of it's child  				var childVertexControl = args.OriginalSource as VertexControl;  				if (childVertexControl == null)  					return;  				if (compoundVertexControl.Vertices.Contains(childVertexControl))  					foreach (var cvc in compoundVertexControl.Vertices)  					{  						if (cvc == childVertexControl)  							continue;  						var childCenterPos = new Point(cvc.ActualWidth / 2' cvc.ActualHeight / 2);  						var translatedChildCenterPos = cvc.TranslatePoint(childCenterPos' cvc.RootCanvas);  						GraphCanvas.SetX(cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  						GraphCanvas.SetY(cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  					}  			}
Magic Number,AssemblyVisualizer.Controls.Graph,CompoundVertexControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl == args.OriginalSource)  			{  				//move the children with the same amount  				foreach (var childVertexControl in compoundVertexControl.Vertices)  				{  					GraphCanvas.SetX(childVertexControl' GraphCanvas.GetX(childVertexControl) + args.XChange);  					GraphCanvas.SetY(childVertexControl' GraphCanvas.GetY(childVertexControl) + args.YChange);  				}  			}  			else  			{  				//we are moving the parent or one of it's child  				var childVertexControl = args.OriginalSource as VertexControl;  				if (childVertexControl == null)  					return;  				if (compoundVertexControl.Vertices.Contains(childVertexControl))  					foreach (var cvc in compoundVertexControl.Vertices)  					{  						if (cvc == childVertexControl)  							continue;  						var childCenterPos = new Point(cvc.ActualWidth / 2' cvc.ActualHeight / 2);  						var translatedChildCenterPos = cvc.TranslatePoint(childCenterPos' cvc.RootCanvas);  						GraphCanvas.SetX(cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  						GraphCanvas.SetY(cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  					}  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphCanvas,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphCanvas.cs,ArrangeOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)  			{  				var x = GetX(child);  				var y = GetY(child);  				if (double.IsNaN(x) || double.IsNaN(y))  				{  					//not a vertex' set the coordinates of the top-left corner  					x = double.IsNaN(x) ? translate.X : x;  					y = double.IsNaN(y) ? translate.Y : y;  				}  				else  				{  					//this is a vertex  					x += translate.X;  					y += translate.Y;    					//get the top-left corner  					x -= child.DesiredSize.Width * 0.5;  					y -= child.DesiredSize.Height * 0.5;  				}  				child.Arrange(new Rect(new Point(x' y)' child.DesiredSize));    				graphSize.X = Math.Max(0' Math.Max(graphSize.X' x + child.DesiredSize.Width));  				graphSize.Y = Math.Max(0' Math.Max(graphSize.Y' y + child.DesiredSize.Height));  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphCanvas,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphCanvas.cs,ArrangeOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)  			{  				var x = GetX(child);  				var y = GetY(child);  				if (double.IsNaN(x) || double.IsNaN(y))  				{  					//not a vertex' set the coordinates of the top-left corner  					x = double.IsNaN(x) ? translate.X : x;  					y = double.IsNaN(y) ? translate.Y : y;  				}  				else  				{  					//this is a vertex  					x += translate.X;  					y += translate.Y;    					//get the top-left corner  					x -= child.DesiredSize.Width * 0.5;  					y -= child.DesiredSize.Height * 0.5;  				}  				child.Arrange(new Rect(new Point(x' y)' child.DesiredSize));    				graphSize.X = Math.Max(0' Math.Max(graphSize.X' x + child.DesiredSize.Width));  				graphSize.Y = Math.Max(0' Math.Max(graphSize.Y' y + child.DesiredSize.Height));  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphCanvas,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphCanvas.cs,MeasureOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)  			{  				//measure the child  				child.Measure(constraint);    				//get the position of the vertex  				var left = GetX(child);  				var top = GetY(child);    				var halfWidth = child.DesiredSize.Width * 0.5;  				var halfHeight = child.DesiredSize.Height * 0.5;    				if (double.IsNaN(left) || double.IsNaN(top))  				{  					left = halfWidth;  					top = halfHeight;  				}    				//get the top left corner point  				topLeft.X = Math.Min(topLeft.X' left - halfWidth - Origo.X);  				topLeft.Y = Math.Min(topLeft.Y' top - halfHeight - Origo.Y);    				//calculate the bottom right corner point  				bottomRight.X = Math.Max(bottomRight.X' left + halfWidth - Origo.X);  				bottomRight.Y = Math.Max(bottomRight.Y' top + halfHeight - Origo.Y);  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphCanvas,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphCanvas.cs,MeasureOverride,The following statement contains a magic number: foreach (UIElement child in InternalChildren)  			{  				//measure the child  				child.Measure(constraint);    				//get the position of the vertex  				var left = GetX(child);  				var top = GetY(child);    				var halfWidth = child.DesiredSize.Width * 0.5;  				var halfHeight = child.DesiredSize.Height * 0.5;    				if (double.IsNaN(left) || double.IsNaN(top))  				{  					left = halfWidth;  					top = halfHeight;  				}    				//get the top left corner point  				topLeft.X = Math.Min(topLeft.X' left - halfWidth - Origo.X);  				topLeft.Y = Math.Min(topLeft.Y' top - halfHeight - Origo.Y);    				//calculate the bottom right corner point  				bottomRight.X = Math.Max(bottomRight.X' left + halfWidth - Origo.X);  				bottomRight.Y = Math.Max(bottomRight.Y' top + halfHeight - Origo.Y);  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GraphLayout,The following statement contains a magic number: if (DesignerProperties.GetIsInDesignMode(this))  			{  				var g = new BidirectionalGraph<object' IEdge<object>>();  				var vertices = new object[] {"S"' "A"' "M"' "P"' "L"' "E"};  				var edges = new IEdge<object>[]  				{  					new Edge<object>(vertices[0]' vertices[1])'  					new Edge<object>(vertices[1]' vertices[2])'  					new Edge<object>(vertices[1]' vertices[3])'  					new Edge<object>(vertices[3]' vertices[4])'  					new Edge<object>(vertices[0]' vertices[4])'  					new Edge<object>(vertices[4]' vertices[5])  				};  				g.AddVerticesAndEdgeRange(edges);  				OverlapRemovalAlgorithmType = "FSA";  				LayoutAlgorithmType = "FR";  				Graph = g;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,CreateOverlapRemovalContext,The following statement contains a magic number: foreach (var vertex in Graph.Vertices)  			{  				Point position;  				Size size;  				if (!positions.TryGetValue(vertex' out position) || !sizes.TryGetValue(vertex' out size))  					continue;    				rectangles[vertex] =  					new Rect(  						position.X - size.Width * (float) 0.5'  						position.Y - size.Height * (float) 0.5'  						size.Width'  						size.Height);  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,CreateOverlapRemovalContext,The following statement contains a magic number: foreach (var vertex in Graph.Vertices)  			{  				Point position;  				Size size;  				if (!positions.TryGetValue(vertex' out position) || !sizes.TryGetValue(vertex' out size))  					continue;    				rectangles[vertex] =  					new Rect(  						position.X - size.Width * (float) 0.5'  						position.Y - size.Height * (float) 0.5'  						size.Width'  						size.Height);  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GetLatestVertexPositions,The following statement contains a magic number: if (ActualLayoutMode == LayoutMode.Simple)  			{  				foreach (var vc in _vertexControls)  				{  					var x = GetX(vc.Value);  					var y = GetY(vc.Value);  					vertexPositions[vc.Key] =  						new Point(  							double.IsNaN(x) ? 0.0 : x'  							double.IsNaN(y) ? 0.0 : y);  				}  			}  			else  			{  				var topLeft = new Point(0' 0);  				foreach (var vc in _vertexControls)  				{  					var position = vc.Value.TranslatePoint(topLeft' this);  					position.X += vc.Value.ActualWidth / 2;  					position.Y += vc.Value.ActualHeight / 2;  					vertexPositions[vc.Key] = position;  				}  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GetLatestVertexPositions,The following statement contains a magic number: if (ActualLayoutMode == LayoutMode.Simple)  			{  				foreach (var vc in _vertexControls)  				{  					var x = GetX(vc.Value);  					var y = GetY(vc.Value);  					vertexPositions[vc.Key] =  						new Point(  							double.IsNaN(x) ? 0.0 : x'  							double.IsNaN(y) ? 0.0 : y);  				}  			}  			else  			{  				var topLeft = new Point(0' 0);  				foreach (var vc in _vertexControls)  				{  					var position = vc.Value.TranslatePoint(topLeft' this);  					position.X += vc.Value.ActualWidth / 2;  					position.Y += vc.Value.ActualHeight / 2;  					vertexPositions[vc.Key] = position;  				}  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GetRelativePosition,The following statement contains a magic number: return vc.TranslatePoint(new Point(vc.ActualWidth / 2.0' vc.ActualHeight / 2.0)' relativeTo);
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,GetRelativePosition,The following statement contains a magic number: return vc.TranslatePoint(new Point(vc.ActualWidth / 2.0' vc.ActualHeight / 2.0)' relativeTo);
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,OnLayoutFinished,The following statement contains a magic number: LayoutStatusPercent = 100;
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,OverlapRemoval,The following statement contains a magic number: if (OverlapRemovalAlgorithm != null)  			{  				OverlapRemovalAlgorithm.Compute();    				var result = new Dictionary<TVertex' Point>();  				foreach (var res in OverlapRemovalAlgorithm.Rectangles)  					result[res.Key] = new Point(  						res.Value.Left + res.Value.Size.Width * 0.5'  						res.Value.Top + res.Value.Size.Height * 0.5);    				return result;  			}
Magic Number,AssemblyVisualizer.Controls.Graph,GraphLayout<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphLayout.cs,OverlapRemoval,The following statement contains a magic number: if (OverlapRemovalAlgorithm != null)  			{  				OverlapRemovalAlgorithm.Compute();    				var result = new Dictionary<TVertex' Point>();  				foreach (var res in OverlapRemovalAlgorithm.Rectangles)  					result[res.Key] = new Point(  						res.Value.Left + res.Value.Size.Width * 0.5'  						res.Value.Top + res.Value.Size.Height * 0.5);    				return result;  			}
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,CoordinatesToPointConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\CoordinatesToPointConverter.cs,Convert,The following statement contains a magic number: Debug.Assert(values != null && values.Length == 2'  				"CoordinatesToPointConverter.Convert should get 2 values as input: X and Y coordinates");
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: Debug.Assert(values != null && values.Length == 9'  				"EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var sourceSize = new Size  			{  				Width = values[2] != DependencyProperty.UnsetValue ? (double) values[2] : 0.0'  				Height = values[3] != DependencyProperty.UnsetValue ? (double) values[3] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var sourceSize = new Size  			{  				Width = values[2] != DependencyProperty.UnsetValue ? (double) values[2] : 0.0'  				Height = values[3] != DependencyProperty.UnsetValue ? (double) values[3] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var sourceSize = new Size  			{  				Width = values[2] != DependencyProperty.UnsetValue ? (double) values[2] : 0.0'  				Height = values[3] != DependencyProperty.UnsetValue ? (double) values[3] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var sourceSize = new Size  			{  				Width = values[2] != DependencyProperty.UnsetValue ? (double) values[2] : 0.0'  				Height = values[3] != DependencyProperty.UnsetValue ? (double) values[3] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetPos = new Point  			{  				X = values[4] != DependencyProperty.UnsetValue ? (double) values[4] : 0.0'  				Y = values[5] != DependencyProperty.UnsetValue ? (double) values[5] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetPos = new Point  			{  				X = values[4] != DependencyProperty.UnsetValue ? (double) values[4] : 0.0'  				Y = values[5] != DependencyProperty.UnsetValue ? (double) values[5] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetPos = new Point  			{  				X = values[4] != DependencyProperty.UnsetValue ? (double) values[4] : 0.0'  				Y = values[5] != DependencyProperty.UnsetValue ? (double) values[5] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetPos = new Point  			{  				X = values[4] != DependencyProperty.UnsetValue ? (double) values[4] : 0.0'  				Y = values[5] != DependencyProperty.UnsetValue ? (double) values[5] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetSize = new Size  			{  				Width = values[6] != DependencyProperty.UnsetValue ? (double) values[6] : 0.0'  				Height = values[7] != DependencyProperty.UnsetValue ? (double) values[7] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetSize = new Size  			{  				Width = values[6] != DependencyProperty.UnsetValue ? (double) values[6] : 0.0'  				Height = values[7] != DependencyProperty.UnsetValue ? (double) values[7] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetSize = new Size  			{  				Width = values[6] != DependencyProperty.UnsetValue ? (double) values[6] : 0.0'  				Height = values[7] != DependencyProperty.UnsetValue ? (double) values[7] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var targetSize = new Size  			{  				Width = values[6] != DependencyProperty.UnsetValue ? (double) values[6] : 0.0'  				Height = values[7] != DependencyProperty.UnsetValue ? (double) values[7] : 0.0  			};
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var routeInformation = values[8] != DependencyProperty.UnsetValue ? (Point[]) values[8] : null;
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var routeInformation = values[8] != DependencyProperty.UnsetValue ? (Point[]) values[8] : null;
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: v = v / v.Length * 5;
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var n = new Vector(-v.Y' v.X) * 0.3;
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,EdgeRouteToPathConverter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: var pfc = new PathFigureCollection(2);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: var sides = new double[4];
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides[0] = (s.X - sourceSize.Width / 2.0 - t.X) / (s.X - t.X);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides[1] = (s.Y - sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides[2] = (s.X + sourceSize.Width / 2.0 - t.X) / (s.X - t.X);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides[2] = (s.X + sourceSize.Width / 2.0 - t.X) / (s.X - t.X);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides[3] = (s.Y + sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides[3] = (s.Y + sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);
Magic Number,AssemblyVisualizer.Controls.Graph.Converters,GraphConverterHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: for (var i = 0; i < 4; i++)  				if (sides[i] <= 1)  					fi = Math.Max(fi' sides[i]);
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions(1' 1' -0.5' -0.5);
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: InitializeWithRandomPositions(1' 1' -0.5' -0.5);
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,InternalCompute,The following statement contains a magic number: for (var step = 1; step <= Parameters.iterationCount; step++)  			{  				ComputeBaryCenter();  				quadTree = BuildQuadTree();    				#region hϋlιsi fόggvιny meghatαrozαsa    				if (Parameters.iterationCount >= 50 && finalRepuExponent < 1.0)  				{  					Parameters.attractionExponent = finalAttrExponent;  					Parameters.repulsiveExponent = finalRepuExponent;  					if (step <= 0.6 * Parameters.iterationCount)  					{  						// use energy model with few local minima   						Parameters.attractionExponent += 1.1 * (1.0 - finalRepuExponent);  						Parameters.repulsiveExponent += 0.9 * (1.0 - finalRepuExponent);  					}  					else if (step <= 0.9 * Parameters.iterationCount)  					{  						// gradually move to final energy model  						Parameters.attractionExponent +=  							1.1 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  						Parameters.repulsiveExponent +=  							0.9 * (1.0 - finalRepuExponent) * (0.9 - step / (double) Parameters.iterationCount) / 0.3;  					}  				}    				#endregion    				#region Move each node    				for (var i = 0; i < vertices.Length; i++)  				{  					var v = vertices[i];  					var oldEnergy = GetEnergy(i' quadTree);    					// compute direction of the move of the node  					Vector bestDir;  					GetDirection(i' quadTree' out bestDir);    					// line search: compute length of the move  					var oldPos = v.Position;    					var bestEnergy = oldEnergy;  					var bestMultiple = 0;  					bestDir /= 32;  					//kisebb mozgatαsok esetιn a legjobb eset meghatαrozαsa  					for (var multiple = 32;  						multiple >= 1 && (bestMultiple == 0 || bestMultiple / 2 == multiple);  						multiple /= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//nagyobb mozgatαs esetιn van-e jobb megoldαs?  					for (var multiple = 64;  						multiple <= 128 && bestMultiple == multiple / 2;  						multiple *= 2)  					{  						v.Position = oldPos + bestDir * multiple;  						var curEnergy = GetEnergy(i' quadTree);  						if (curEnergy < bestEnergy)  						{  							bestEnergy = curEnergy;  							bestMultiple = multiple;  						}  					}    					//legjobb megoldαssal mozgatαs  					v.Position = oldPos + bestDir * bestMultiple;  					if (bestMultiple > 0)  						quadTree.MoveNode(oldPos' v.Position' v.RepulsionWeight);  				}    				#endregion    				if (ReportOnIterationEndNeeded)  					Report(step);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,Report,The following statement contains a magic number: OnIterationEnded(step' step / (double) Parameters.iterationCount * 100' "Iteration " + step + " finished."' true);
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if (dir2 != 0.0)  			{  				dir /= dir2;    				var length = dir.Length;  				if (length > quadTree.Width / 8)  				{  					length /= quadTree.Width / 8;  					dir /= length;  				}  			}  			else  			{  				dir = new Vector(0' 0);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,GetDirection,The following statement contains a magic number: if (dir2 != 0.0)  			{  				dir /= dir2;    				var length = dir.Length;  				if (length > quadTree.Width / 8)  				{  					length /= quadTree.Width / 8;  					dir /= length;  				}  			}  			else  			{  				dir = new Vector(0' 0);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,AddGravitationDirection,The following statement contains a magic number: var tmp = Parameters.gravitationMultiplier * repulsionMultiplier * Math.Max(v.RepulsionWeight' 1) *  			          Math.Pow(dist' Parameters.attractionExponent - 2);
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,AddAttractionDirection,The following statement contains a magic number: foreach (var e in v.Attractions)  			{  				//onhurkok elhagyasa  				if (e.Target == v)  					continue;    				var attractionVector = e.Target.Position - v.Position;  				var dist = attractionVector.Length;  				if (dist <= 0)  					continue;    				var tmp = e.AttractionWeight * Math.Pow(dist' Parameters.attractionExponent - 2);  				dir2 += tmp * Math.Abs(Parameters.attractionExponent - 1);    				dir += (e.Target.Position - v.Position) * tmp;  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The following statement contains a magic number: if (quadTree.Index < 0 && dist < 2.0 * quadTree.Width)  			{  				var dir2 = 0.0;  				for (var i = 0; i < quadTree.Children.Length; i++)  					dir2 += AddRepulsionDirection(index' quadTree.Children[i]' ref dir);  				return dir2;  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,AddRepulsionDirection,The following statement contains a magic number: if (dist != 0.0)  			{  				var tmp = repulsionMultiplier * v.RepulsionWeight * quadTree.Weight  				          * Math.Pow(dist' Parameters.repulsiveExponent - 2);  				dir -= repulsionVector * tmp;  				return tmp * Math.Abs(Parameters.repulsiveExponent - 1);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,GetRepulsionEnergy,The following statement contains a magic number: if (tree.Index < 0 && dist < 2 * tree.Width)  			{  				var energy = 0.0;  				for (var i = 0; i < tree.Children.Length; i++)  					energy += GetRepulsionEnergy(index' tree.Children[i]);    				return energy;  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: if (repulsionSum > 0 && attractionSum > 0)  				return attractionSum / Math.Pow(repulsionSum' 2) *  				       Math.Pow(repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent));
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,LinLogLayoutAlgorithm<TVertex;TEdge;TGraph>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.cs,ComputeRepulsionMultiplier,The following statement contains a magic number: if (repulsionSum > 0 && attractionSum > 0)  				return attractionSum / Math.Pow(repulsionSum' 2) *  				       Math.Pow(repulsionSum' 0.5 * (Parameters.attractionExponent - Parameters.repulsiveExponent));
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,QuadTree,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.QuadTree.cs,AddNode2,The following statement contains a magic number: var middleX = (minPos.X + maxPos.X) / 2;
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,QuadTree,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.QuadTree.cs,AddNode2,The following statement contains a magic number: var middleY = (minPos.Y + maxPos.Y) / 2;
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,QuadTree,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.QuadTree.cs,AddNode2,The following statement contains a magic number: if (nodePos.Y > middleY)  					childIndex += 2;
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,QuadTree,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.QuadTree.cs,MoveNode,The following statement contains a magic number: var middleX = (minPos.X + maxPos.X) / 2;
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.Layout,QuadTree,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\Layout\LinLogLayoutAlgorithm.QuadTree.cs,MoveNode,The following statement contains a magic number: var middleY = (minPos.Y + maxPos.Y) / 2;
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,force,The following statement contains a magic number: if (Gij >= gij && gij > 0 || -Gij <= gij && gij < 0 || gij == 0)  			{  				// vi and vj touch with y-direction boundaries  				f.X = d.X / adx * ((vi.Width + vj.Width) / 2.0 - adx);  				f.Y = f.X * gij;  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,force,The following statement contains a magic number: if (Gij < gij && gij > 0 || -Gij > gij && gij < 0)  			{  				// vi and vj touch with x-direction boundaries  				f.Y = d.Y / ady * ((vi.Height + vj.Height) / 2.0 - ady);  				f.X = f.Y / gij;  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,force2,The following statement contains a magic number: if (vi.IntersectsWith(vj))  			{  				f.X = (vi.Width + vj.Width) / 2.0 - d.X;  				f.Y = (vi.Height + vj.Height) / 2.0 - d.Y;  				// in the x dimension  				if (f.X > f.Y && gij != 0)  					f.X = f.Y / gij;  				f.X = Math.Max(f.X' 0);  				f.Y = Math.Max(f.Y' 0);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,FSAAlgorithm<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\FSAAlgorithm.cs,force2,The following statement contains a magic number: if (vi.IntersectsWith(vj))  			{  				f.X = (vi.Width + vj.Width) / 2.0 - d.X;  				f.Y = (vi.Height + vj.Height) / 2.0 - d.Y;  				// in the x dimension  				if (f.X > f.Y && gij != 0)  					f.X = f.Y / gij;  				f.X = Math.Max(f.X' 0);  				f.Y = Math.Max(f.Y' 0);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles)  			{  				r.Rectangle.Width += Parameters.HorizontalGap;  				r.Rectangle.Height += Parameters.VerticalGap;  				r.Rectangle.Offset(-Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,AddGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles)  			{  				r.Rectangle.Width += Parameters.HorizontalGap;  				r.Rectangle.Height += Parameters.VerticalGap;  				r.Rectangle.Offset(-Parameters.HorizontalGap / 2' -Parameters.VerticalGap / 2);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles)  			{  				r.Rectangle.Width -= Parameters.HorizontalGap;  				r.Rectangle.Height -= Parameters.VerticalGap;  				r.Rectangle.Offset(Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,OverlapRemovalAlgorithmBase<TObject;TParam>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\OverlapRemovalAlgorithmBase.cs,RemoveGaps,The following statement contains a magic number: foreach (var r in wrappedRectangles)  			{  				r.Rectangle.Width -= Parameters.HorizontalGap;  				r.Rectangle.Height -= Parameters.VerticalGap;  				r.Rectangle.Offset(Parameters.HorizontalGap / 2' Parameters.VerticalGap / 2);  			}
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,OverlapRemovalHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\OverlapRemovalHelper.cs,GetCenter,The following statement contains a magic number: return new Point(r.Left + r.Width / 2' r.Top + r.Height / 2);
Magic Number,AssemblyVisualizer.Controls.Graph.GraphSharp.OverlapRemoval,OverlapRemovalHelper,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\GraphSharp\OverlapRemoval\OverlapRemovalHelper.cs,GetCenter,The following statement contains a magic number: return new Point(r.Left + r.Width / 2' r.Top + r.Height / 2);
Magic Number,AssemblyVisualizer.Controls.Graph.QuickGraph,BidirectionalGraph<TVertex;TEdge>,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\QuickGraph\BidirectionalGraph.cs,MergeVertexIf,The following statement contains a magic number: var mergeVertices = new VertexList<TVertex>(VertexCount / 4);
Magic Number,AssemblyVisualizer.Controls.Graph.Transitions,FadeTransition,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\Graph\Transitions\FadeTransition.cs,Run,The following statement contains a magic number: fadeAnimation.BeginTime = TimeSpan.FromMilliseconds(duration.TotalMilliseconds * (rounds - 1) * 2);
Magic Number,AssemblyVisualizer.Controls,PopupNonTopmost,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\PopupNonTopmost.cs,UpdateWindow,The following statement contains a magic number: if (NativeMethods.GetWindowRect(hwnd' out rect))  			{  				var result = NativeMethods.SetWindowPos(hwnd' Topmost ? -1 : -2' rect.Left' rect.Top' (int) Width' (int) Height' 0);  				if (result != 1)  					throw new InvalidOperationException("Cannot show popup.");  			}
Magic Number,AssemblyVisualizer.Controls.ZoomControl.Converters,DoubleToLog10Converter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\Converters\DoubleToLog10Converter.cs,ConvertBack,The following statement contains a magic number: return Math.Pow(10' val);
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomContentPresenter,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomContentPresenter.cs,MeasureOverride,The following statement contains a magic number: var max = 1000000000;
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,ZoomTo,The following statement contains a magic number: var startHandlePosition = new Point(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,ZoomTo,The following statement contains a magic number: var startHandlePosition = new Point(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,ZoomControl_MouseWheel,The following statement contains a magic number: var origoPosition = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,ZoomControl_MouseWheel,The following statement contains a magic number: var origoPosition = new Point(ActualWidth / 2' ActualHeight / 2);
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,ZoomControl_MouseWheel,The following statement contains a magic number: var minifiedRawDelta = e.Delta / 70.0;
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,StartAnimation,The following statement contains a magic number: var animation = new DoubleAnimation(toValue' duration)  			{  				AccelerationRatio = 0.2'  				DecelerationRatio = 0.2  			};
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,StartAnimation,The following statement contains a magic number: var animation = new DoubleAnimation(toValue' duration)  			{  				AccelerationRatio = 0.2'  				DecelerationRatio = 0.2  			};
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,GetInitialTranslate,The following statement contains a magic number: var tX = -w / 2.0;
Magic Number,AssemblyVisualizer.Controls.ZoomControl,ZoomControl,C:\repos\manunt_AssemblyVisualizer\Sources\AssemblyVisualizer\Controls\ZoomControl\ZoomControl.cs,GetInitialTranslate,The following statement contains a magic number: var tY = -h / 2.0;
