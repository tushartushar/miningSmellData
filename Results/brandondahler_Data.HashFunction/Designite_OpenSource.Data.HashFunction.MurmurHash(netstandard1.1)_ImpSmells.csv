Implementation smell,Namespace,Class,File,Method,Description
Complex Method,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,Cyclomatic complexity of the method is 9
Complex Method,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,Cyclomatic complexity of the method is 16
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: var remainderCount = dataCount % 4;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: hashValue ^= hashValue >> 16;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: hashValue ^= hashValue >> 16;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: hashValue ^= hashValue >> 10;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: hashValue ^= hashValue >> 17;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: return new HashValue(                  BitConverter.GetBytes(hashValue)'                  32);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (_config.HashSizeInBits)              {                  case 32:                      return ComputeHash32(data' cancellationToken);                    case 64:                      return ComputeHash64(data' cancellationToken);                    default:                      throw new NotImplementedException();              }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHashInternal,The following statement contains a magic number: switch (_config.HashSizeInBits)              {                  case 32:                      return ComputeHash32(data' cancellationToken);                    case 64:                      return ComputeHash64(data' cancellationToken);                    default:                      throw new NotImplementedException();              }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: var remainderCount = dataCount % 4;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: k ^= k >> 24;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: hashValue ^= hashValue >> 13;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: hashValue ^= hashValue >> 15;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following statement contains a magic number: return new HashValue(                  BitConverter.GetBytes(hashValue)'                  32);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: var remainderCount = dataCount % 8;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: k ^= k >> 47;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: hashValue ^= hashValue >> 47;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: hashValue ^= hashValue >> 47;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following statement contains a magic number: return new HashValue(                  BitConverter.GetBytes(hashValue)'                  64);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash3_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,CreateBlockTransformer,The following statement contains a magic number: switch (_config.HashSizeInBits)              {                  case 32:                      return new BlockTransformer32((UInt32) _config.Seed);                    case 128:                      return new BlockTransformer128(_config.Seed);                    default:                      throw new NotImplementedException();              }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,MurmurHash3_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,CreateBlockTransformer,The following statement contains a magic number: switch (_config.HashSizeInBits)              {                  case 32:                      return new BlockTransformer32((UInt32) _config.Seed);                    case 128:                      return new BlockTransformer128(_config.Seed);                    default:                      throw new NotImplementedException();              }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: k1 = RotateLeft(k1' 15);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: tempHashValue = RotateLeft(tempHashValue' 13);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: tempHashValue = (tempHashValue * 5) + 0xe6546b64;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: k2 = RotateLeft(k2' 15);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: return new HashValue(                      BitConverter.GetBytes(tempHashValue)'                      32);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,Mix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,Mix,The following statement contains a magic number: h ^= h >> 13;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,Mix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,RotateLeft,The following statement contains a magic number: return                      (operand << shiftCount) |                      (operand >> (32 - shiftCount));
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: UInt64 k2 = BitConverter.ToUInt64(dataArray' currentOffset + 8);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: k1 = RotateLeft(k1' 31);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: tempHashValue1 = RotateLeft(tempHashValue1' 27);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: tempHashValue1 = (tempHashValue1 * 5) + 0x52dce729;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: k2 = RotateLeft(k2' 33);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: tempHashValue2 = RotateLeft(tempHashValue2' 31);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,TransformByteGroupsInternal,The following statement contains a magic number: tempHashValue2 = (tempHashValue2 * 5) + 0x38495ab5;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: k1  = RotateLeft(k1' 31);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following statement contains a magic number: return new HashValue(hashValueBytes' 128);
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,Mix,The following statement contains a magic number: k ^= k >> 33;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,Mix,The following statement contains a magic number: k ^= k >> 33;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,Mix,The following statement contains a magic number: k ^= k >> 33;
Magic Number,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,RotateLeft,The following statement contains a magic number: return                      (operand << shiftCount) |                      (operand >> (64 - shiftCount));
Missing Default,OpenSource.Data.HashFunction.MurmurHash,MurmurHash1_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash1_Implementation.cs,ComputeHashInternal,The following switch statement is missing a default case: switch (remainderCount)                  {                      case 3: hashValue += (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue += (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue += (UInt32) dataArray[remainderOffset];                          break;                  }
Missing Default,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash32,The following switch statement is missing a default case: switch (remainderCount)                  {                      case 3: hashValue ^= (UInt32) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt32) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt32) dataArray[remainderOffset];                          break;                  }
Missing Default,OpenSource.Data.HashFunction.MurmurHash,MurmurHash2_Implementation,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash2_Implementation.cs,ComputeHash64,The following switch statement is missing a default case: switch (remainderCount)                  {                      case 7: hashValue ^= (UInt64) dataArray[remainderOffset + 6] << 48; goto case 6;                      case 6: hashValue ^= (UInt64) dataArray[remainderOffset + 5] << 40; goto case 5;                      case 5: hashValue ^= (UInt64) dataArray[remainderOffset + 4] << 32; goto case 4;                      case 4:                          hashValue ^= (UInt64) BitConverter.ToUInt32(dataArray' remainderOffset);                          break;                        case 3: hashValue ^= (UInt64) dataArray[remainderOffset + 2] << 16; goto case 2;                      case 2: hashValue ^= (UInt64) dataArray[remainderOffset + 1] << 8; goto case 1;                      case 1:                          hashValue ^= (UInt64) dataArray[remainderOffset];                          break;                  }
Missing Default,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer32,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following switch statement is missing a default case: switch (remainderCount)                      {                          case 3: k2 ^= (UInt32)remainder[2] << 16; goto case 2;                          case 2: k2 ^= (UInt32)remainder[1] << 8; goto case 1;                          case 1:                              k2 ^= (UInt32)remainder[0];                              break;                      }
Missing Default,OpenSource.Data.HashFunction.MurmurHash,BlockTransformer128,D:\research\architectureSmells\repos\brandondahler_Data.HashFunction\src\OpenSource.Data.HashFunction.MurmurHash\MurmurHash3_Implementation.cs,FinalizeHashValueInternal,The following switch statement is missing a default case: switch(remainderCount)                      {                          case 15: k2 ^= (UInt64) remainder[14] << 48;   goto case 14;                          case 14: k2 ^= (UInt64) remainder[13] << 40;   goto case 13;                          case 13: k2 ^= (UInt64) remainder[12] << 32;   goto case 12;                          case 12: k2 ^= (UInt64) remainder[11] << 24;   goto case 11;                          case 11: k2 ^= (UInt64) remainder[10] << 16;   goto case 10;                          case 10: k2 ^= (UInt64) remainder[ 9] <<  8;   goto case 9;                          case  9:                              k2 ^= ((UInt64) remainder[8]);                              k2 *= c2_128;                               k2  = RotateLeft(k2' 33);                               k2 *= c1_128;                              tempHashValue2 ^= k2;                                goto case 8;                            case  8:                              k1 ^= BitConverter.ToUInt64(remainder' 0);                              break;                            case  7: k1 ^= (UInt64) remainder[6] << 48;    goto case 6;                          case  6: k1 ^= (UInt64) remainder[5] << 40;    goto case 5;                          case  5: k1 ^= (UInt64) remainder[4] << 32;    goto case 4;                          case  4: k1 ^= (UInt64) remainder[3] << 24;    goto case 3;                          case  3: k1 ^= (UInt64) remainder[2] << 16;    goto case 2;                          case  2: k1 ^= (UInt64) remainder[1] <<  8;    goto case 1;                          case  1:                               k1 ^= (UInt64) remainder[0];                              break;                      }
