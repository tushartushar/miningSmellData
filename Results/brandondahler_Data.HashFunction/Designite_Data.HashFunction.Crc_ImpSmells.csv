Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ProcessBytes,The method has 6 parameters. Parameters: hash' crcTable' mostSignificantShift' dataBytes' position' length
Long Parameter List,System.Data.HashFunction,Setting,C:\repos\brandondahler_Data.HashFunction\src\CRC\Settings.cs,Setting,The method has 6 parameters. Parameters: bits' polynomial' initialValue' reflectIn' reflectOut' xOrOut
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ComputeHashInternal,The following statement contains a magic number: int mostSignificantShift = HashSize - 8;
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ComputeHashInternal,The following statement contains a magic number: if (HashSize < 8)                  mostSignificantShift = HashSize - 1;
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ComputeHashAsyncInternal,The following statement contains a magic number: int mostSignificantShift = HashSize - 8;
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ComputeHashAsyncInternal,The following statement contains a magic number: if (HashSize < 8)                  mostSignificantShift = HashSize - 1;
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ProcessBytes,The following statement contains a magic number: for (var x = position; x < position + length; ++x)              {                  if (HashSize >= 8)                  {                      // Process per byte' treating hash differently based on input endianness                      if (Settings.ReflectIn)                          hash = (hash >> 8) ^ crcTable[(byte) hash ^ dataBytes[x]];                      else                          hash = (hash << 8) ^ crcTable[((byte) (hash >> mostSignificantShift)) ^ dataBytes[x]];                    } else {                      // Process per bit' treating hash differently based on input endianness                      for (int y = 0; y < 8; ++y)                      {                          if (Settings.ReflectIn)                              hash = (hash >> 1) ^ crcTable[(byte) (hash & 1) ^ ((byte) (dataBytes[x] >> y) & 1)];                          else                              hash =  (hash << 1) ^ crcTable[(byte) ((hash >> mostSignificantShift) & 1) ^ ((byte) (dataBytes[x] >> (7 - y)) & 1)];                      }                    }              }
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ProcessBytes,The following statement contains a magic number: for (var x = position; x < position + length; ++x)              {                  if (HashSize >= 8)                  {                      // Process per byte' treating hash differently based on input endianness                      if (Settings.ReflectIn)                          hash = (hash >> 8) ^ crcTable[(byte) hash ^ dataBytes[x]];                      else                          hash = (hash << 8) ^ crcTable[((byte) (hash >> mostSignificantShift)) ^ dataBytes[x]];                    } else {                      // Process per bit' treating hash differently based on input endianness                      for (int y = 0; y < 8; ++y)                      {                          if (Settings.ReflectIn)                              hash = (hash >> 1) ^ crcTable[(byte) (hash & 1) ^ ((byte) (dataBytes[x] >> y) & 1)];                          else                              hash =  (hash << 1) ^ crcTable[(byte) ((hash >> mostSignificantShift) & 1) ^ ((byte) (dataBytes[x] >> (7 - y)) & 1)];                      }                    }              }
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ProcessBytes,The following statement contains a magic number: for (var x = position; x < position + length; ++x)              {                  if (HashSize >= 8)                  {                      // Process per byte' treating hash differently based on input endianness                      if (Settings.ReflectIn)                          hash = (hash >> 8) ^ crcTable[(byte) hash ^ dataBytes[x]];                      else                          hash = (hash << 8) ^ crcTable[((byte) (hash >> mostSignificantShift)) ^ dataBytes[x]];                    } else {                      // Process per bit' treating hash differently based on input endianness                      for (int y = 0; y < 8; ++y)                      {                          if (Settings.ReflectIn)                              hash = (hash >> 1) ^ crcTable[(byte) (hash & 1) ^ ((byte) (dataBytes[x] >> y) & 1)];                          else                              hash =  (hash << 1) ^ crcTable[(byte) ((hash >> mostSignificantShift) & 1) ^ ((byte) (dataBytes[x] >> (7 - y)) & 1)];                      }                    }              }
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ProcessBytes,The following statement contains a magic number: for (var x = position; x < position + length; ++x)              {                  if (HashSize >= 8)                  {                      // Process per byte' treating hash differently based on input endianness                      if (Settings.ReflectIn)                          hash = (hash >> 8) ^ crcTable[(byte) hash ^ dataBytes[x]];                      else                          hash = (hash << 8) ^ crcTable[((byte) (hash >> mostSignificantShift)) ^ dataBytes[x]];                    } else {                      // Process per bit' treating hash differently based on input endianness                      for (int y = 0; y < 8; ++y)                      {                          if (Settings.ReflectIn)                              hash = (hash >> 1) ^ crcTable[(byte) (hash & 1) ^ ((byte) (dataBytes[x] >> y) & 1)];                          else                              hash =  (hash << 1) ^ crcTable[(byte) ((hash >> mostSignificantShift) & 1) ^ ((byte) (dataBytes[x] >> (7 - y)) & 1)];                      }                    }              }
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,ProcessBytes,The following statement contains a magic number: for (var x = position; x < position + length; ++x)              {                  if (HashSize >= 8)                  {                      // Process per byte' treating hash differently based on input endianness                      if (Settings.ReflectIn)                          hash = (hash >> 8) ^ crcTable[(byte) hash ^ dataBytes[x]];                      else                          hash = (hash << 8) ^ crcTable[((byte) (hash >> mostSignificantShift)) ^ dataBytes[x]];                    } else {                      // Process per bit' treating hash differently based on input endianness                      for (int y = 0; y < 8; ++y)                      {                          if (Settings.ReflectIn)                              hash = (hash >> 1) ^ crcTable[(byte) (hash & 1) ^ ((byte) (dataBytes[x] >> y) & 1)];                          else                              hash =  (hash << 1) ^ crcTable[(byte) ((hash >> mostSignificantShift) & 1) ^ ((byte) (dataBytes[x] >> (7 - y)) & 1)];                      }                    }              }
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,CalculateTable,The following statement contains a magic number: var perBitCount = 8;
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,CalculateTable,The following statement contains a magic number: if (settings.Bits < 8)                  perBitCount = 1;
Magic Number,System.Data.HashFunction,CRC,C:\repos\brandondahler_Data.HashFunction\src\CRC\CRC.cs,CalculateTable,The following statement contains a magic number: for (uint x = 0; x < crcTable.Length; ++x)              {                  UInt64 curValue = x;                    if (perBitCount > 1 && settings.ReflectIn)                      curValue = curValue.ReflectBits(perBitCount);                      curValue <<= (settings.Bits - perBitCount);                      for (int y = 0; y < perBitCount; ++y)                  {                      if ((curValue & mostSignificantBit) > 0UL)                          curValue = (curValue << 1) ^ settings.Polynomial;                      else                          curValue <<= 1;                  }                      if (settings.ReflectIn)                      curValue = curValue.ReflectBits(settings.Bits);                      curValue &= (UInt64.MaxValue >> (64 - settings.Bits));                                    crcTable[x] = curValue;              }
Magic Number,System.Data.HashFunction,Setting,C:\repos\brandondahler_Data.HashFunction\src\CRC\Settings.cs,Setting,The following statement contains a magic number: if (bits < 1 || bits > 64)                      throw new ArgumentOutOfRangeException("bits"' "bitLength must be in the range [1' 64].");
Magic Number,System.Data.HashFunction,Setting,C:\repos\brandondahler_Data.HashFunction\src\CRC\Settings.cs,CheckInput,The following statement contains a magic number: var maxInputValue = UInt64.MaxValue >> (64 - bitLength);
