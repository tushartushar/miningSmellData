Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The method has 5 parameters. Parameters: h1' h2' dataGroup' position' length
Long Parameter List,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The method has 5 parameters. Parameters: h1' h2' remainder' position' length
Long Parameter List,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessGroup,The method has 5 parameters. Parameters: h' m' dataGroup' position' length
Long Parameter List,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessGroup,The method has 5 parameters. Parameters: h' m' dataGroup' position' length
Long Parameter List,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The method has 5 parameters. Parameters: h' m' remainder' position' length
Long Parameter List,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The method has 5 parameters. Parameters: h' m' remainder' position' length
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  UInt32 k1 = BitConverter.ToUInt32(dataGroup' x);                    k1 *= c1_32;                  k1 = k1.RotateLeft(15);                  k1 *= c2_32;                    h1 ^= k1;                  h1 = h1.RotateLeft(13);                  h1 = (h1 * 5) + 0xe6546b64;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  UInt32 k1 = BitConverter.ToUInt32(dataGroup' x);                    k1 *= c1_32;                  k1 = k1.RotateLeft(15);                  k1 *= c2_32;                    h1 ^= k1;                  h1 = h1.RotateLeft(13);                  h1 = (h1 * 5) + 0xe6546b64;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  UInt32 k1 = BitConverter.ToUInt32(dataGroup' x);                    k1 *= c1_32;                  k1 = k1.RotateLeft(15);                  k1 *= c2_32;                    h1 ^= k1;                  h1 = h1.RotateLeft(13);                  h1 = (h1 * 5) + 0xe6546b64;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  UInt32 k1 = BitConverter.ToUInt32(dataGroup' x);                    k1 *= c1_32;                  k1 = k1.RotateLeft(15);                  k1 *= c2_32;                    h1 ^= k1;                  h1 = h1.RotateLeft(13);                  h1 = (h1 * 5) + 0xe6546b64;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 16)              {                  UInt64 k1 = BitConverter.ToUInt64(dataGroup' x);                  UInt64 k2 = BitConverter.ToUInt64(dataGroup' x + 8);                    k1 *= c1_128;                  k1 = k1.RotateLeft(31);                  k1 *= c2_128;                  h1 ^= k1;                    h1 = h1.RotateLeft(27);                  h1 += h2;                  h1 = (h1 * 5) + 0x52dce729;                    k2 *= c2_128;                  k2 = k2.RotateLeft(33);                  k2 *= c1_128;                  h2 ^= k2;                    h2 = h2.RotateLeft(31);                  h2 += h1;                  h2 = (h2 * 5) + 0x38495ab5;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: k2 = k2.RotateLeft(15);
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following statement contains a magic number: k1  = k1.RotateLeft(31);
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,Mix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,Mix,The following statement contains a magic number: h ^= h >> 13;
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,Mix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,Mix,The following statement contains a magic number: k ^= k >> 33;
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,Mix,The following statement contains a magic number: k ^= k >> 33;
Magic Number,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,Mix,The following statement contains a magic number: k ^= k >> 33;
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  UInt32 k = BitConverter.ToUInt32(dataGroup' x);                    k *= m;                  k ^= k >> 24;                  k *= m;                    h *= m;                  h ^= k;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  UInt32 k = BitConverter.ToUInt32(dataGroup' x);                    k *= m;                  k ^= k >> 24;                  k *= m;                    h *= m;                  h ^= k;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 8)              {                  UInt64 k = BitConverter.ToUInt64(dataGroup' x);                    k *= m;                  k ^= k >> 47;                  k *= m;                    h ^= k;                  h *= m;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 8)              {                  UInt64 k = BitConverter.ToUInt64(dataGroup' x);                    k *= m;                  k ^= k >> 47;                  k *= m;                    h ^= k;                  h *= m;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ComputeHashInternal,The following statement contains a magic number: data.ForEachGroup(4'                   (dataGroup' position' length) => {                      ProcessGroup(ref h' dataGroup' position' length);                  }'                  (remainder' position' length) => {                      ProcessRemainder(ref h' remainder' position' length);                  });
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ComputeHashInternal,The following statement contains a magic number: h ^= h >> 10;
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ComputeHashInternal,The following statement contains a magic number: h ^= h >> 17;
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ComputeHashAsyncInternal,The following statement contains a magic number: await data.ForEachGroupAsync(4'                  (dataGroup' position' length) => {                      ProcessGroup(ref h' dataGroup' position' length);                  }'                  (remainder' position' length) => {                      ProcessRemainder(ref h' remainder' position' length);                  }).ConfigureAwait(false);
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ComputeHashAsyncInternal,The following statement contains a magic number: h ^= h >> 10;
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ComputeHashAsyncInternal,The following statement contains a magic number: h ^= h >> 17;
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  h += BitConverter.ToUInt32(dataGroup' x);                  h *= m;                  h ^= h >> 16;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessGroup,The following statement contains a magic number: for (var x = position; x < position + length; x += 4)              {                  h += BitConverter.ToUInt32(dataGroup' x);                  h *= m;                  h ^= h >> 16;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
Magic Number,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following statement contains a magic number: h ^= h >> 16;
Missing Default,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashInternal,The following switch statement is missing a default case: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          });                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      data.ForEachGroup(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          });                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          var hashBytes = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hashBytes' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hashBytes' 8);                        hash = hashBytes;                      break;                  }              }
Missing Default,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ComputeHashAsyncInternal,The following switch statement is missing a default case: switch (HashSize)              {                  case 32:                  {                      UInt32 h1 = Seed;                      int dataCount = 0;                          await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                                      h1 ^= (UInt32) dataCount;                      Mix(ref h1);                        hash = BitConverter.GetBytes(h1);                      break;                  }                    case 128:                  {                      UInt64 h1 = (UInt64) Seed;                      UInt64 h2 = (UInt64) Seed;                        int dataCount = 0;                                      await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              ProcessGroup(ref h1' ref h2' dataGroup' position' length);                                dataCount += length;                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h1' ref h2' remainder' position' length);                                dataCount += length;                          }).ConfigureAwait(false);                          h1 ^= (UInt64) dataCount;                       h2 ^= (UInt64) dataCount;                        h1 += h2;                      h2 += h1;                        Mix(ref h1);                      Mix(ref h2);                        h1 += h2;                      h2 += h1;                          hash = new byte[16];                        BitConverter.GetBytes(h1)                          .CopyTo(hash' 0);                        BitConverter.GetBytes(h2)                          .CopyTo(hash' 8);                        break;                  }              }
Missing Default,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following switch statement is missing a default case: switch (length)              {                  case 3: k2 ^= (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: k2 ^= (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      k2 ^= (UInt32) remainder[position];                              break;              }
Missing Default,System.Data.HashFunction,MurmurHash3,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash3.cs,ProcessRemainder,The following switch statement is missing a default case: switch(length)              {                  case 15: k2 ^= (UInt64) remainder[position + 14] << 48;   goto case 14;                  case 14: k2 ^= (UInt64) remainder[position + 13] << 40;   goto case 13;                  case 13: k2 ^= (UInt64) remainder[position + 12] << 32;   goto case 12;                  case 12: k2 ^= (UInt64) remainder[position + 11] << 24;   goto case 11;                  case 11: k2 ^= (UInt64) remainder[position + 10] << 16;   goto case 10;                  case 10: k2 ^= (UInt64) remainder[position +  9] <<  8;   goto case 9;                  case  9:                       k2 ^= ((UInt64) remainder[position + 8]) <<  0;                      k2 *= c2_128;                       k2  = k2.RotateLeft(33);                       k2 *= c1_128; h2 ^= k2;                        goto case 8;                    case  8:                      k1 ^= BitConverter.ToUInt64(remainder' position);                      break;                    case  7: k1 ^= (UInt64) remainder[position + 6] << 48;    goto case 6;                  case  6: k1 ^= (UInt64) remainder[position + 5] << 40;    goto case 5;                  case  5: k1 ^= (UInt64) remainder[position + 4] << 32;    goto case 4;                  case  4: k1 ^= (UInt64) remainder[position + 3] << 24;    goto case 3;                  case  3: k1 ^= (UInt64) remainder[position + 2] << 16;    goto case 2;                  case  2: k1 ^= (UInt64) remainder[position + 1] <<  8;    goto case 1;                  case  1:                       k1 ^= (UInt64) remainder[position] << 0;                      break;              }
Missing Default,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashInternal,The following switch statement is missing a default case: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        data.ForEachGroup(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    data.ForEachGroup(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          });                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Missing Default,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ComputeHashAsyncInternal,The following switch statement is missing a default case: switch (HashSize)              {                  case 32:                  {                              const UInt32 m = unchecked((UInt32) MixConstant);                        UInt32 h = (UInt32) Seed ^ (UInt32) data.Length;                        await data.ForEachGroupAsync(4'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                           (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                        // Do a few final mixes of the hash to ensure the last few                      // bytes are well-incorporated.                        h ^= h >> 13;                      h *= m;                      h ^= h >> 15;                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       const UInt64 m = MixConstant;                        UInt64 h = Seed ^ ((UInt64) data.Length * m);                                    await data.ForEachGroupAsync(8'                           (dataGroup' position' length) => {                              ProcessGroup(ref h' m' dataGroup' position' length);                          }'                          (remainder' position' length) => {                              ProcessRemainder(ref h' m' remainder' position' length);                          }).ConfigureAwait(false);                         h ^= h >> 47;                      h *= m;                      h ^= h >> 47;                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Missing Default,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following switch statement is missing a default case: switch (length)              {                  case 3: h ^= (UInt32) remainder[position + 2] << 16;   goto case 2;                  case 2: h ^= (UInt32) remainder[position + 1] <<  8;   goto case 1;                  case 1:                      h ^= remainder[position];                      break;              }
Missing Default,System.Data.HashFunction,MurmurHash2,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash2.cs,ProcessRemainder,The following switch statement is missing a default case: switch (length)              {                  case 7: h ^= (UInt64) remainder[position + 6] << 48;  goto case 6;                  case 6: h ^= (UInt64) remainder[position + 5] << 40;  goto case 5;                  case 5: h ^= (UInt64) remainder[position + 4] << 32;  goto case 4;                  case 4:                       h ^= (UInt64) BitConverter.ToUInt32(remainder' position);                      break;                    case 3: h ^= (UInt64) remainder[position + 2] << 16;  goto case 2;                  case 2: h ^= (UInt64) remainder[position + 1] <<  8;  goto case 1;                  case 1:                       h ^= (UInt64) remainder[position];                      break;              }
Missing Default,System.Data.HashFunction,MurmurHash1,C:\repos\brandondahler_Data.HashFunction\src\MurmurHash\MurmurHash1.cs,ProcessRemainder,The following switch statement is missing a default case: switch (length)              {                  case 3: h += (UInt32) remainder[position + 2] << 16; goto case 2;                  case 2: h += (UInt32) remainder[position + 1] <<  8; goto case 1;                  case 1:                      h += (UInt32) remainder[position];                      break;              }
