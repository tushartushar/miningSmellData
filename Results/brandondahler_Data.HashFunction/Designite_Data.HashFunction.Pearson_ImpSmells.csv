Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,ProcessBytes,The method has 5 parameters. Parameters: h' firstByte' dataBytes' position' length
Magic Number,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,PearsonBase,The following statement contains a magic number: if (t.Count != 256 || t.Distinct().Count() != 256)                  throw new ArgumentException("t must be a permutation of [0' 255]."' "t");
Magic Number,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,PearsonBase,The following statement contains a magic number: if (t.Count != 256 || t.Distinct().Count() != 256)                  throw new ArgumentException("t must be a permutation of [0' 255]."' "t");
Magic Number,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,PearsonBase,The following statement contains a magic number: if (hashSize <= 0 || hashSize % 8 != 0)                  throw new ArgumentOutOfRangeException("hashSize"' "hashSize must be a positive integer that is divisible by 8.");
Magic Number,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,ComputeHashInternal,The following statement contains a magic number: var h = new byte[HashSize / 8];
Magic Number,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,ComputeHashAsyncInternal,The following statement contains a magic number: var h = new byte[HashSize / 8];
Magic Number,System.Data.HashFunction,PearsonBase,C:\repos\brandondahler_Data.HashFunction\src\Pearson\PearsonBase.cs,ProcessBytes,The following statement contains a magic number: for (var x = position; x < position + length; ++x)              {                  for (int y = 0; y < HashSize / 8; ++y)                  {                      if (!firstByte)                          h[y] = T[h[y] ^ dataBytes[x]];                      else                          h[y] = T[(dataBytes[x] + y) & 0xff];                  }                    firstByte = false;              }
