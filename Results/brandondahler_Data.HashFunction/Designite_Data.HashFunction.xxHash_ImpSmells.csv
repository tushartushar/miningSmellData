Implementation smell,Namespace,Class,File,Method,Description
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following statement contains a magic number: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 16)              {                  h = initValues[0].RotateLeft(1) +                       initValues[1].RotateLeft(7) +                       initValues[2].RotateLeft(12) +                       initValues[3].RotateLeft(18);              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 16)              {                  h = initValues[0].RotateLeft(1) +                       initValues[1].RotateLeft(7) +                       initValues[2].RotateLeft(12) +                       initValues[3].RotateLeft(18);              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 16)              {                  h = initValues[0].RotateLeft(1) +                       initValues[1].RotateLeft(7) +                       initValues[2].RotateLeft(12) +                       initValues[3].RotateLeft(18);              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 16)              {                  h = initValues[0].RotateLeft(1) +                       initValues[1].RotateLeft(7) +                       initValues[2].RotateLeft(12) +                       initValues[3].RotateLeft(18);              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 16)              {                  h = initValues[0].RotateLeft(1) +                       initValues[1].RotateLeft(7) +                       initValues[2].RotateLeft(12) +                       initValues[3].RotateLeft(18);              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 16)              {                  h = initValues[0].RotateLeft(1) +                       initValues[1].RotateLeft(7) +                       initValues[2].RotateLeft(12) +                       initValues[3].RotateLeft(18);              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                  // In 4-byte chunks' process all process all full chunks                  for (int x = 0; x < remainder.Length / 4; ++x)                  {                      h += BitConverter.ToUInt32(remainder' x * 4) * _primes32[2];                      h  = h.RotateLeft(17) * _primes32[3];                  }                      // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h += (UInt32) remainder[x] * _primes32[4];                      h  = h.RotateLeft(11) * _primes32[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h ^= h >> 15;
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h ^= h >> 13;
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h *= _primes32[2];
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h ^= h >> 16;
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (dataCount >= 32)              {                  h = initValues[0].RotateLeft(1) +                      initValues[1].RotateLeft(7) +                      initValues[2].RotateLeft(12) +                      initValues[3].RotateLeft(18);                      for (var x = 0; x < initValues.Length; ++x)                  {                      initValues[x] *= _primes64[1];                      initValues[x] = initValues[x].RotateLeft(31);                      initValues[x] *= _primes64[0];                        h ^= initValues[x];                      h = (h * _primes64[0]) + _primes64[3];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: if (remainder != null)              {                   // In 8-byte chunks' process all full chunks                  for (int x = 0; x < remainder.Length / 8; ++x)                  {                      h ^= (BitConverter.ToUInt64(remainder' x * 8) * _primes64[1]).RotateLeft(31) * _primes64[0];                      h  = (h.RotateLeft(27) * _primes64[0]) + _primes64[3];                  }                      // Process a 4-byte chunk if it exists                  if ((remainder.Length % 8) >= 4)                  {                      h ^= ((UInt64) BitConverter.ToUInt32(remainder' remainder.Length - (remainder.Length % 8))) * _primes64[0];                      h  = (h.RotateLeft(23) * _primes64[1]) + _primes64[2];                  }                    // Process last 4 bytes in 1-byte chunks (only runs if data.Length % 4 != 0)                  for (int x = remainder.Length - (remainder.Length % 4); x < remainder.Length; ++x)                  {                      h ^= (UInt64) remainder[x] * _primes64[4];                      h  = h.RotateLeft(11) * _primes64[0];                  }              }
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h ^= h >> 33;
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h ^= h >> 29;
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h *= _primes64[2];
Magic Number,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,PostProcess,The following statement contains a magic number: h ^= h >> 32;
Missing Default,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashInternal,The following switch statement is missing a default case: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        data.ForEachGroup(16'                           (dataGroup' position' length) => {                              for (int x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong)length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong)length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          data.ForEachGroup(32'                           (dataGroup' position' length) => {                                for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          });                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
Missing Default,System.Data.HashFunction,xxHash,C:\repos\brandondahler_Data.HashFunction\src\xxHash\xxHash.cs,ComputeHashAsyncInternal,The following switch statement is missing a default case: switch (HashSize)              {                  case 32:                  {                      var h = ((UInt32) InitVal) + _primes32[4];                        ulong dataCount = 0;                      byte[] remainder = null;                          var initValues = new[] {                          ((UInt32) InitVal) + _primes32[0] + _primes32[1]'                          ((UInt32) InitVal) + _primes32[1]'                          ((UInt32) InitVal)'                          ((UInt32) InitVal) - _primes32[0]                      };                        await data.ForEachGroupAsync(16'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 16)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt32(dataGroup' x + (y * 4)) * _primes32[1];                                      initValues[y] = initValues[y].RotateLeft(13);                                      initValues[y] *= _primes32[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) length;                          }).ConfigureAwait(false);                        PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }                    case 64:                  {                       var h = InitVal + _primes64[4];                        ulong dataCount = 0;                      byte[] remainder = null;                        var initValues = new[] {                          InitVal + _primes64[0] + _primes64[1]'                          InitVal + _primes64[1]'                          InitVal'                          InitVal - _primes64[0]                      };                          await data.ForEachGroupAsync(32'                           (dataGroup' position' length) => {                              for (var x = position; x < position + length; x += 32)                              {                                  for (var y = 0; y < 4; ++y)                                  {                                      initValues[y] += BitConverter.ToUInt64(dataGroup' x + (y * 8)) * _primes64[1];                                      initValues[y] = initValues[y].RotateLeft(31);                                      initValues[y] *= _primes64[0];                                  }                              }                                dataCount += (ulong) length;                          }'                          (remainderData' position' length) => {                              remainder = new byte[length];                              Array.Copy(remainderData' position' remainder' 0' length);                                dataCount += (ulong) remainder.Length;                          }).ConfigureAwait(false);                          PostProcess(ref h' initValues' dataCount' remainder);                        hash = BitConverter.GetBytes(h);                      break;                  }              }
