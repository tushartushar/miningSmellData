Implementation smell,Namespace,Class,File,Method,Description
Long Method,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The method has 133 lines of code.
Complex Method,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,IsCommandPossible,Cyclomatic complexity of the method is 9
Long Parameter List,ARDrone.Control.Workers,CommandSender,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\CommandSender.cs,CommandSender,The method has 5 parameters. Parameters: networkConnector' remoteIpAddress' port' timeoutValue' defaultCameraMode
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanQueryInterface,The method has 7 parameters. Parameters: clientHandle' interfaceGuid' opCode' pReserved' dataSize' ppData' wlanOpcodeValueType
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanSetInterface,The method has 6 parameters. Parameters: clientHandle' interfaceGuid' opCode' dataSize' pData' pReserved
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanScan,The method has 5 parameters. Parameters: clientHandle' interfaceGuid' pDot11Ssid' pIeData' pReserved
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanGetAvailableNetworkList,The method has 5 parameters. Parameters: clientHandle' interfaceGuid' flags' reservedPtr' availableNetworkListPtr
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanSetProfile,The method has 8 parameters. Parameters: clientHandle' interfaceGuid' flags' profileXml' allUserProfileSecurity' overwrite' pReserved' reasonCode
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanGetProfile,The method has 7 parameters. Parameters: clientHandle' interfaceGuid' profileName' pReserved' profileXml' flags' grantedAccess
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanRegisterNotification,The method has 7 parameters. Parameters: clientHandle' notifSource' ignoreDuplicate' funcCallback' callbackContext' reserved' prevNotifSource
Long Parameter List,NativeWifi,Wlan,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,WlanGetNetworkBssList,The method has 7 parameters. Parameters: clientHandle' interfaceGuid' dot11SsidInt' dot11BssType' securityEnabled' reservedPtr' wlanBssList
Long Parameter List,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,ConnectSynchronously,The method has 5 parameters. Parameters: connectionMode' bssType' ssid' flags' connectTimeout
Long Identifier,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,,The length of the parameter DefaultSupportedFirmwareVersion is 31.
Long Identifier,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,,The length of the parameter thresholdBetweenSettingCommands is 31.
Long Identifier,ARDrone.Control.Workers,NetworkConnector,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NetworkConnector.cs,,The length of the parameter notificationCodeScanSuccessful is 30.
Long Identifier,ARDrone.Control.Workers,NetworkConnector,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NetworkConnector.cs,,The length of the parameter currentlyScannedNetworkInterfaceNumber is 38.
Long Identifier,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,,The length of the parameter currentNavigationDataHeaderStruct is 33.
Long Statement,ARDrone.Control.Commands,FlightMoveCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\FlightMoveCommand.cs,CreateCommand,The length of the statement  "            return String.Format("AT*PCMD={0}'{1}'{2}'{3}'{4}'{5}\r"' sequenceNumber' 1' NormalizeValue(roll)' NormalizeValue(pitch)' NormalizeValue(gaz)' NormalizeValue(yaw)); " is 164.
Long Statement,ARDrone.Control.Commands,HoverModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\HoverModeCommand.cs,CreateCommand,The length of the statement  "            return String.Format("AT*PCMD={0}'{1}'{2}'{3}'{4}'{5}\r"' sequenceNumber' (mode == DroneHoverMode.Hover) ? 0 : 1' 0' 0' 0' 0); " is 126.
Long Statement,ARDrone.Control.Commands,PlayLedAnimationCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\PlayLedAnimationCommand.cs,CreateCommand,The length of the statement  "            return String.Format("AT*LED={0}'{1}'{2}'{3}\r"' sequenceNumber' (int)ledAnimation' NormalizeValue(frequency)' duration); " is 121.
Long Statement,ARDrone.Control.Data,DroneFirmwareVersion,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\DroneFirmwareVersion.cs,GetVersionRange,The length of the statement  "            MemberInfo memberInfo = typeof(SupportedFirmwareVersion).GetMember(supportedFirmwareVersion.ToString()).FirstOrDefault(); " is 121.
Long Statement,ARDrone.Control.Data,DroneFirmwareVersion,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\DroneFirmwareVersion.cs,GetVersionRange,The length of the statement  "                VersionBetweenAttribute attribute = (VersionBetweenAttribute)memberInfo.GetCustomAttributes(typeof(VersionBetweenAttribute)' false).FirstOrDefault(); " is 149.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CreateDroneWorkers,The length of the statement  "            networkConnector = new NetworkConnector(droneConfig.DroneNetworkIdentifierStart' droneConfig.StandardOwnIpAddress' droneConfig.DroneIpAddress); " is 143.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CreateDroneWorkers,The length of the statement  "            videoDataRetriever = new VideoDataRetriever(networkConnector' droneConfig.DroneIpAddress' droneConfig.VideoPort' droneConfig.TimeoutValue); " is 139.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CreateDroneWorkers,The length of the statement  "            navigationDataRetriever = new NavigationDataRetriever(networkConnector' droneConfig.DroneIpAddress' droneConfig.NavigationPort' droneConfig.TimeoutValue); " is 154.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CreateDroneWorkers,The length of the statement  "            commandSender = new CommandSender(networkConnector' droneConfig.DroneIpAddress' droneConfig.CommandPort' droneConfig.TimeoutValue' droneConfig.DefaultCameraMode); " is 162.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CreateDroneWorkers,The length of the statement  "            networkSanityChecker = new NetworkSanityChecker(videoDataRetriever' navigationDataRetriever' commandSender' droneConfig.FirmwareVersion); " is 137.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,ProcessSanityCheckResult,The length of the statement  "                InvokeError(new Exception("Error while connecting to the drone. Have you connected to the drone network?"' e.Exception)); " is 121.
Long Statement,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,GetFirmwareVersionToUse,The length of the statement  "                DroneFirmwareVersion droneVersion = new DroneFirmwareVersion(internalDroneConfiguration.GeneralConfiguration.SoftwareVersion); " is 126.
Long Statement,ARDrone.Control.Utils,ConfigReader,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\ConfigReader.cs,GetSectionName,The length of the statement  "            Regex mainSectionRegex = new Regex(@"^\[(?<section>[a-zA-Z0-9_]+)\]$"' RegexOptions.Compiled);          // Matches [abc_9] " is 122.
Long Statement,ARDrone.Control.Utils,ConfigReader,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\ConfigReader.cs,GetEntryOption,The length of the statement  "            Regex optionRegex = new Regex(@"^(?<key>[a-zA-Z0-9_]+)\s*\=\s*(?<value>.*)$"' RegexOptions.Compiled);   // Matches abc_9 = [ bla ] " is 130.
Long Statement,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The length of the statement  "            streamLength += zeroCount + 1; // - position bit pointer to keep track off how many bits to consume later on the stream. " is 120.
Long Statement,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The length of the statement  "                temp = (int)(streamCode >> (32 - (zeroCount - 1))); // - (2) -> shift right to determine the addtional bits (number of additional bits is zerocount - 1) " is 152.
Long Statement,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The length of the statement  "                streamCode <<= zeroCount - 1; // - shift all of the run bits out of the way so the first bit is points to the first bit of the level field. " is 139.
Long Statement,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The length of the statement  "            streamLength += zeroCount + 1; // - position bit pointer to keep track off how many bits to consume later on the stream. " is 120.
Long Statement,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The length of the statement  "                streamCode >>= (32 - zeroCount);// - (2) -> shift right to determine the addtional bits (number of additional bits is zerocount) " is 128.
Long Statement,ARDrone.Control.Workers,NetworkConnector,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NetworkConnector.cs,TryToConnectToAvailableDroneNetwork,The length of the statement  "            currentWifiInterface.Connect(Wlan.WlanConnectionMode.DiscoveryUnsecure' network.Value.dot11BssType' network.Value.dot11Ssid' 0); " is 128.
Long Statement,ARDrone.Control.Workers,NetworkConnector,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NetworkConnector.cs,InvokeConnectionStateChange,The length of the statement  "                ConnectionStateChanged.Invoke(this' new DroneNetworkConnectionStateChangedEventArgs(currentInterfaceName' state' currentPingRetries' maxPingRetries)); " is 150.
Long Statement,ARDrone.Control.Workers,CommandSender,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\CommandSender.cs,CheckForDataRetriever,The length of the statement  "                throw new InvalidOperationException("The initialization state can only be acquired when Data Retriever has been set and started"); " is 130.
Long Statement,NativeWifi,WlanClient,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetStringForReasonCode,The length of the statement  "			StringBuilder sb = new StringBuilder(1024); // the 1024 size here is arbitrary; the WlanReasonCodeToString docs fail to specify a recommended size " is 146.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetInterfaceInt,The length of the statement  "					Wlan.WlanQueryInterface(client.clientHandle' info.interfaceGuid' opCode' IntPtr.Zero' out valueSize' out valuePtr' out opcodeValueType)); " is 137.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,ConvertAvailableNetworkListPtr,The length of the statement  "				Wlan.WlanAvailableNetworkListHeader availNetListHeader = (Wlan.WlanAvailableNetworkListHeader)Marshal.PtrToStructure(availNetListPtr' typeof(Wlan.WlanAvailableNetworkListHeader)); " is 179.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,ConvertAvailableNetworkListPtr,The length of the statement  "					availNets[i] = (Wlan.WlanAvailableNetwork)Marshal.PtrToStructure(new IntPtr(availNetListIt)' typeof(Wlan.WlanAvailableNetwork)); " is 128.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,ConvertBssListPtr,The length of the statement  "				Wlan.WlanBssListHeader bssListHeader = (Wlan.WlanBssListHeader)Marshal.PtrToStructure(bssListPtr' typeof(Wlan.WlanBssListHeader)); " is 130.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetNetworkBssList,The length of the statement  "					Wlan.WlanGetNetworkBssList(client.clientHandle' info.interfaceGuid' IntPtr.Zero' Wlan.Dot11BssType.Any' false' IntPtr.Zero' out bssListPtr)); " is 141.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetNetworkBssList,The length of the statement  "						Wlan.WlanGetNetworkBssList(client.clientHandle' info.interfaceGuid' ssidPtr' bssType' securityEnabled' IntPtr.Zero' out bssListPtr)); " is 133.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,SetProfile,The length of the statement  "						Wlan.WlanSetProfile(client.clientHandle' info.interfaceGuid' flags' profileXml' null' overwrite' IntPtr.Zero' out reasonCode)); " is 127.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetProfiles,The length of the statement  "					Wlan.WlanProfileInfoListHeader header = (Wlan.WlanProfileInfoListHeader) Marshal.PtrToStructure(profileListPtr' typeof(Wlan.WlanProfileInfoListHeader)); " is 152.
Long Statement,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetProfiles,The length of the statement  "						Wlan.WlanProfileInfo profileInfo = (Wlan.WlanProfileInfo) Marshal.PtrToStructure(new IntPtr(profileListIterator)' typeof(Wlan.WlanProfileInfo)); " is 144.
Complex Conditional,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CheckFlightMoveCommand,The conditional expression  "Math.Abs(moveCommand.Roll - lastRollValue) >= thresholdBetweenSettingCommands ||                  Math.Abs(moveCommand.Pitch - lastPitchValue) >= thresholdBetweenSettingCommands ||                  Math.Abs(moveCommand.Yaw - lastYawValue) >= thresholdBetweenSettingCommands ||                  Math.Abs(moveCommand.Gaz - lastGazValue) >= thresholdBetweenSettingCommands"  is complex.
Complex Conditional,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,CheckFlightMoveCommand,The conditional expression  "moveCommand.Roll == 0.0f && moveCommand.Pitch == 0.0f &&                       moveCommand.Yaw == 0.0f && moveCommand.Gaz == 0.0f"  is complex.
Complex Conditional,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The conditional expression  "dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0"  is complex.
Empty Catch Block,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DetermineInternalConfiguration,The method has an empty catch block.
Empty Catch Block,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,Load,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Network,NetworkWorker,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Network\NetworkWorker.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Network,NetworkWorker,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Network\NetworkWorker.cs,ProcessWorkerThreadInternally,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Network,NetworkWorker,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Network\NetworkWorker.cs,CreateEndpoint,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Network,TcpWorker,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Network\TcpWorker.cs,DisconnectFromSocket,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Network,TcpWorker,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Network\TcpWorker.cs,SendMessage,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Utils,NetworkUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\NetworkUtils.cs,GetIpAddress,The method has an empty catch block.
Empty Catch Block,ARDrone.Control.Workers,NetworkConnector,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NetworkConnector.cs,IsAlreadyConnectedToDroneNetwork,The method has an empty catch block.
Magic Number,ARDrone.Control.Commands,FlightModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\FlightModeCommand.cs,GetFlightModeValue,The following statement contains a magic number: int flightModeValue = 290717696;
Magic Number,ARDrone.Control.Commands,FlightModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\FlightModeCommand.cs,GetFlightModeValue,The following statement contains a magic number: switch (flightMode)              {                  case DroneFlightMode.TakeOff:                      flightModeValue = 290718208;                      break;                  case DroneFlightMode.Emergency:                      flightModeValue = 290717952;                      break;                  default:                      flightModeValue = 290717696;                      break;              }
Magic Number,ARDrone.Control.Commands,FlightModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\FlightModeCommand.cs,GetFlightModeValue,The following statement contains a magic number: switch (flightMode)              {                  case DroneFlightMode.TakeOff:                      flightModeValue = 290718208;                      break;                  case DroneFlightMode.Emergency:                      flightModeValue = 290717952;                      break;                  default:                      flightModeValue = 290717696;                      break;              }
Magic Number,ARDrone.Control.Commands,FlightModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\FlightModeCommand.cs,GetFlightModeValue,The following statement contains a magic number: switch (flightMode)              {                  case DroneFlightMode.TakeOff:                      flightModeValue = 290718208;                      break;                  case DroneFlightMode.Emergency:                      flightModeValue = 290717952;                      break;                  default:                      flightModeValue = 290717696;                      break;              }
Magic Number,ARDrone.Control.Data,DroneFirmwareVersion,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\DroneFirmwareVersion.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < versionParts.Length; i++)              {                  hashValue = (hashValue + versionParts[i]) * 100;              }
Magic Number,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,GetInternalDroneConfigStates,The following statement contains a magic number: foreach (String configEntry in configEntries)              {                  char[] separators = new char[] { ':'' '=' };                  String[] configEntryValues = configEntry.Split(separators' 3);                    if (configEntryValues.Length != 3)                  {                      //Console.WriteLine ("Invalid config entry: " + configEntry);                      continue;                  }                    InternalDroneConfigurationState configState = new InternalDroneConfigurationState();                  configState.MainSection = configEntryValues[0].ToLower().Trim();                  configState.Key = configEntryValues[1].ToLower().Trim();                  configState.Value = configEntryValues[2].Trim();                    configStates.Add(configState);              }
Magic Number,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,GetInternalDroneConfigStates,The following statement contains a magic number: foreach (String configEntry in configEntries)              {                  char[] separators = new char[] { ':'' '=' };                  String[] configEntryValues = configEntry.Split(separators' 3);                    if (configEntryValues.Length != 3)                  {                      //Console.WriteLine ("Invalid config entry: " + configEntry);                      continue;                  }                    InternalDroneConfigurationState configState = new InternalDroneConfigurationState();                  configState.MainSection = configEntryValues[0].ToLower().Trim();                  configState.Key = configEntryValues[1].ToLower().Trim();                  configState.Value = configEntryValues[2].Trim();                    configStates.Add(configState);              }
Magic Number,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,GetInternalDroneConfigStates,The following statement contains a magic number: foreach (String configEntry in configEntries)              {                  char[] separators = new char[] { ':'' '=' };                  String[] configEntryValues = configEntry.Split(separators' 3);                    if (configEntryValues.Length != 3)                  {                      //Console.WriteLine ("Invalid config entry: " + configEntry);                      continue;                  }                    InternalDroneConfigurationState configState = new InternalDroneConfigurationState();                  configState.MainSection = configEntryValues[0].ToLower().Trim();                  configState.Key = configEntryValues[1].ToLower().Trim();                  configState.Value = configEntryValues[2].Trim();                    configStates.Add(configState);              }
Magic Number,ARDrone.Control.Data,DroneGeneralConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DroneGeneralConfiguration,The following statement contains a magic number: motorSoftwareVersions = new List<String>(4);
Magic Number,ARDrone.Control.Data,DroneGeneralConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DroneGeneralConfiguration,The following statement contains a magic number: motorHardwareVersions = new List<String>(4);
Magic Number,ARDrone.Control.Data,DroneGeneralConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DroneGeneralConfiguration,The following statement contains a magic number: motorSuppliers = new List<String>(4);
Magic Number,ARDrone.Control.Data,DroneData,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\NavigationData.cs,DroneData,The following statement contains a magic number: phi = navigationDataStruct.Phi / 1000.0;
Magic Number,ARDrone.Control.Data,DroneData,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\NavigationData.cs,DroneData,The following statement contains a magic number: psi = navigationDataStruct.Psi / 1000.0;
Magic Number,ARDrone.Control.Data,DroneData,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\NavigationData.cs,DroneData,The following statement contains a magic number: theta = navigationDataStruct.Theta / 1000.0;
Magic Number,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,DroneConfig,The following statement contains a magic number: videoPort = 5555;
Magic Number,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,DroneConfig,The following statement contains a magic number: navigationPort = 5554;
Magic Number,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,DroneConfig,The following statement contains a magic number: commandPort = 5556;
Magic Number,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,DroneConfig,The following statement contains a magic number: controlInfoPort = 5559;
Magic Number,ARDrone.Control,DroneConfig,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneConfig.cs,DroneConfig,The following statement contains a magic number: timeoutValue = 500;
Magic Number,ARDrone.Control.Network,NetworkWorker,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Network\NetworkWorker.cs,IsNormalDisconnectError,The following statement contains a magic number: return e.ErrorCode == 10004 && workerThreadEnded;
Magic Number,ARDrone.Control.Utils,BitmapUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\BitmapUtils.cs,BitmapSourceToBitmap,The following statement contains a magic number: int stride = width * ((imageSource.Format.BitsPerPixel + 7) / 8);
Magic Number,ARDrone.Control.Utils,BitmapUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\BitmapUtils.cs,BitmapSourceToBitmap,The following statement contains a magic number: int stride = width * ((imageSource.Format.BitsPerPixel + 7) / 8);
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: streamFieldBitIndex = 32;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: while (!pictureComplete && streamIndex < (imageStream.Length >> 2))              {                  ReadHeader();                    if (!pictureComplete)                  {                      for (int count = 0; count < blockCount; count++)                      {                          uint macroBlockEmpty = ReadStreamData(1);                            if (macroBlockEmpty == 0)                          {                              uint acCoefficients = ReadStreamData(8);                                blockY0HasAcComponents = (acCoefficients >> 0 & 1) == 1;                              blockY1HasAcComponents = (acCoefficients >> 1 & 1) == 1;                              blockY2HasAcComponents = (acCoefficients >> 2 & 1) == 1;                              blockY3HasAcComponents = (acCoefficients >> 3 & 1) == 1;                              blockCbHasAcComponents = (acCoefficients >> 4 & 1) == 1;                              blockCrHasAcComponents = (acCoefficients >> 5 & 1) == 1;                                if ((acCoefficients >> 6 & 1) == 1)                              {                                  uint quantizerMode = ReadStreamData(2);                                  this.quantizerMode = (int)((quantizerMode < 2) ? ~quantizerMode : quantizerMode);                              }                                GetBlockBytes(blockY0HasAcComponents);                              InverseTransform(count' 0);                                GetBlockBytes(blockY1HasAcComponents);                              InverseTransform(count' 1);                                GetBlockBytes(blockY2HasAcComponents);                              InverseTransform(count' 2);                                GetBlockBytes(blockY3HasAcComponents);                              InverseTransform(count' 3);                                GetBlockBytes(blockCbHasAcComponents);                              InverseTransform(count' 4);                                GetBlockBytes(blockCrHasAcComponents);                              InverseTransform(count' 5);                          }                      }                        ComposeImageSlice();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ProcessStream,The following statement contains a magic number: unsafe              {                  fixed (ushort* pixelData = this.pixelData)                  {                      IntPtr pixelDataPtr = (IntPtr)pixelData;                      internalImageSource.Lock();                      CopyMemory(internalImageSource.BackBuffer' pixelDataPtr' this.pixelData.Length * 2);                      internalImageSource.AddDirtyRect(rectangle);                      internalImageSource.Unlock();                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: code = ReadStreamData(22);
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadHeader,The following statement contains a magic number: if (startCode == 32)              {                  if (((code & 0x1F) == 0x1F))                  {                      pictureComplete = true;                  }                  else                  {                      if (sliceIndex++ == 0)                      {                          pictureFormat = (int)ReadStreamData(2);                          resolution = (int)ReadStreamData(3);                          pictureType = (int)ReadStreamData(3);                          quantizerMode = (int)ReadStreamData(5);                          frameIndex = (int)ReadStreamData(32);                            if (IsPictureFormatCif(pictureFormat))                          {                              width = widthCif << resolution - 1;                              height = heightCif << resolution - 1;                          }                          else if (IsPictureFormatVGA(pictureFormat))                          {                              width = widthVga << resolution - 1;                              height = heightVga << resolution - 1;                          }                            //We assume two bytes per pixel (RGB 565)                          pixelRowSize = width << 1;                            sliceCount = height >> 4;                          blockCount = width >> 4;                            if (imageSlice == null)                          {                              imageSlice = new ImageSlice(blockCount);                              pixelData = new ushort[width * height];                              internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                              rectangle = new Int32Rect(0' 0' width' height);                          }                          else                          {                              if (imageSlice.MacroBlocks.Count != blockCount)                              {                                  imageSlice = new ImageSlice(blockCount);                                  pixelData = new ushort[width * height];                                  internalImageSource = new WriteableBitmap(width' height' 96' 96' PixelFormats.Bgr565' null);                                  rectangle = new Int32Rect(0' 0' width' height);                              }                          }                      }                      else                      {                          quantizerMode = (int)ReadStreamData(5);                      }                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,IsPictureFormatVGA,The following statement contains a magic number: return pictureFormat == 2;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,GetBlockBytes,The following statement contains a magic number: uint dcCoefficient = ReadStreamData(10);
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ClearDataBuffer,The following statement contains a magic number: unsafe              {                  fixed (short* source = allZeros)                  fixed (short* destination = dataBlockBuffer)                  {                      IntPtr sourcePtr = (IntPtr)source;                      IntPtr destinationPtr = (IntPtr)destination;                      CopyMemory(destinationPtr' sourcePtr' dataBlockBuffer.Length * 2);                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The following statement contains a magic number: streamCode = PeekStreamData(imageStream' 32);
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The following statement contains a magic number: if (zeroCount > 1)              {                  temp = (int)(streamCode >> (32 - (zeroCount - 1))); // - (2) -> shift right to determine the addtional bits (number of additional bits is zerocount - 1)                  streamCode <<= zeroCount - 1; // - shift all of the run bits out of the way so the first bit is points to the first bit of the level field.                  streamLength += zeroCount - 1;// - position bit pointer to keep track off how many bits to consume later on the stream.                  run = temp + (1 << (zeroCount - 1)); // - (3) -> calculate run value              }              else              {                  run = zeroCount;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,DecodeFieldBytes,The following statement contains a magic number: if (zeroCount == 1)              {                  //If coarse value is 01 according to the Huffman dictionary this means EOB' so there is                  //no run and level and we indicate this by setting last to true;                  run = 0;                  last = true;              }              else              {                  if (zeroCount == 0)                  {                      zeroCount = 1;                      temp = 1;                  }                    streamLength += zeroCount;// - position bit pointer to keep track off how many bits to consume later on the stream.                  streamCode >>= (32 - zeroCount);// - (2) -> shift right to determine the addtional bits (number of additional bits is zerocount)                  //sign = (sbyte)(streamCode & 1); // determine sign' last bit is sign                   sign = (int)(streamCode & 1); // determine sign' last bit is sign                     if (zeroCount != 0)                  {                      //temp = (sbyte)(streamCode >> 1); // take into account that last bit is sign' so shift it out of the way                      //temp += (sbyte)(1 << (zeroCount - 1)); // - (3) -> calculate run value without sign                      temp = (int)(streamCode >> 1); // take into account that last bit is sign' so shift it out of the way                      temp += (int)(1 << (zeroCount - 1)); // - (3) -> calculate run value without sign                  }                    level = (sign == 1) ? -temp : temp; // - (3) -> calculate run value with sign                  last = false;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(imageStream' streamIndex * 4);                  streamFieldBitIndex = 0;                  streamIndex++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(imageStream' streamIndex * 4);                  streamFieldBitIndex = 0;                  streamIndex++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(imageStream' streamIndex * 4);                  streamFieldBitIndex = 0;                  streamIndex++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(imageStream' streamIndex * 4);                  streamFieldBitIndex = 0;                  streamIndex++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ReadStreamData,The following statement contains a magic number: if (count > 0)              {                  data = (data << count) | (streamField >> (32 - count));                    streamField <<= count;                  streamFieldBitIndex += count;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,PeekStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex) && streamIndex < (imageStream.Length >> 2))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(stream' streamIndex * 4);                  streamFieldBitIndex = 0;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,PeekStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex) && streamIndex < (imageStream.Length >> 2))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(stream' streamIndex * 4);                  streamFieldBitIndex = 0;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,PeekStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex) && streamIndex < (imageStream.Length >> 2))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(stream' streamIndex * 4);                  streamFieldBitIndex = 0;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,PeekStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex) && streamIndex < (imageStream.Length >> 2))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(stream' streamIndex * 4);                  streamFieldBitIndex = 0;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,PeekStreamData,The following statement contains a magic number: while (count > (32 - streamFieldBitIndex) && streamIndex < (imageStream.Length >> 2))              {                  data = (data << (int)(32 - streamFieldBitIndex)) | (streamField >> streamFieldBitIndex);                    count -= 32 - streamFieldBitIndex;                    streamField = BitConverter.ToUInt32(stream' streamIndex * 4);                  streamFieldBitIndex = 0;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,PeekStreamData,The following statement contains a magic number: if (count > 0)              {                  data = (data << count) | (streamField >> (32 - count));              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,AlignStreamData,The following statement contains a magic number: if (actualLength > 0)              {                  alignedLength = (actualLength & ~7);                  if (alignedLength != actualLength)                  {                      alignedLength += 0x08;                      streamField <<= (alignedLength - actualLength);                      streamFieldBitIndex = alignedLength;                  }              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: int[] cromaQuadrantOffsets = new[] { 0' 4' 32' 36 };
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: int[] cromaQuadrantOffsets = new[] { 0' 4' 32' 36 };
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: int[] cromaQuadrantOffsets = new[] { 0' 4' 32' 36 };
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: int imageDataOffset = (sliceIndex - 1) * width * 16;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,ComposeImageSlice,The following statement contains a magic number: foreach (MacroBlock macroBlock in imageSlice.MacroBlocks)              {                  for (int verticalStep = 0; verticalStep < blockWidth / 2; verticalStep++)                  {                      chromaOffset = verticalStep * blockWidth;                      lumaElementIndex1 = verticalStep * blockWidth * 2;                      lumaElementIndex2 = lumaElementIndex1 + blockWidth;                        dataIndex1 = imageDataOffset + (2 * verticalStep * width);                      dataIndex2 = dataIndex1 + width;                        for (int horizontalStep = 0; horizontalStep < blockWidth / 2; horizontalStep++)                      {                          for (int quadrant = 0; quadrant < 4; quadrant++)                          {                              int chromaIndex = chromaOffset + cromaQuadrantOffsets[quadrant] + horizontalStep;                              chromaBlueValue = macroBlock.DataBlocks[4][chromaIndex];                              chromaRedValue = macroBlock.DataBlocks[5][chromaIndex];                                u = chromaBlueValue - 128;                              ug = 88 * u;                              ub = 454 * u;                                v = chromaRedValue - 128;                              vg = 183 * v;                              vr = 359 * v;                                for (int pixel = 0; pixel < 2; pixel++)                              {                                  int deltaIndex = 2 * horizontalStep + pixel;                                  lumaElementValue1 = macroBlock.DataBlocks[quadrant][lumaElementIndex1 + deltaIndex] << 8;                                  lumaElementValue2 = macroBlock.DataBlocks[quadrant][lumaElementIndex2 + deltaIndex] << 8;                                    r = Saturate5(lumaElementValue1 + vr);                                  g = Saturate6(lumaElementValue1 - ug - vg);                                  b = Saturate5(lumaElementValue1 + ub);                                    pixelData[dataIndex1 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                                    r = Saturate5(lumaElementValue2 + vr);                                  g = Saturate6(lumaElementValue2 - ug - vg);                                  b = Saturate5(lumaElementValue2 + ub);                                    pixelData[dataIndex2 + pixelDataQuadrantOffsets[quadrant] + deltaIndex] = MakeRgb(r' g' b);                              }                          }                      }                  }                    imageDataOffset += 16;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,Saturate5,The following statement contains a magic number: x >>= 11;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,Saturate6,The following statement contains a magic number: x >>= 10;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,MakeRgb,The following statement contains a magic number: return (ushort)((r << 11) | (g << 5) | b);
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,MakeRgb,The following statement contains a magic number: return (ushort)((r << 11) | (g << 5) | b);
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,CountLeadingZeros,The following statement contains a magic number: accum += clzlut[value >> 24];
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,CountLeadingZeros,The following statement contains a magic number: accum += (accum == 8) ? clzlut[(value >> 16) & 0xFF] : 0;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,CountLeadingZeros,The following statement contains a magic number: accum += (accum == 8) ? clzlut[(value >> 16) & 0xFF] : 0;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,CountLeadingZeros,The following statement contains a magic number: accum += (accum == 16) ? clzlut[(value >> 8) & 0xFF] : 0;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,CountLeadingZeros,The following statement contains a magic number: accum += (accum == 16) ? clzlut[(value >> 8) & 0xFF] : 0;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,CountLeadingZeros,The following statement contains a magic number: accum += (accum == 24) ? clzlut[value & 0xFF] : 0;
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: int[] workSpace = new int[64];
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: short[] data = new short[64];
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 8; index > 0; index--)              {                  if (dataBlockBuffer[pointer + 8] == 0 &&                      dataBlockBuffer[pointer + 16] == 0 &&                      dataBlockBuffer[pointer + 24] == 0 &&                      dataBlockBuffer[pointer + 32] == 0 &&                      dataBlockBuffer[pointer + 40] == 0 &&                      dataBlockBuffer[pointer + 48] == 0 &&                      dataBlockBuffer[pointer + 56] == 0)                  {                      int dcValue = dataBlockBuffer[pointer] << passOneBits;                        workSpace[pointer + 0] = dcValue;                      workSpace[pointer + 8] = dcValue;                      workSpace[pointer + 16] = dcValue;                      workSpace[pointer + 24] = dcValue;                      workSpace[pointer + 32] = dcValue;                      workSpace[pointer + 40] = dcValue;                      workSpace[pointer + 48] = dcValue;                      workSpace[pointer + 56] = dcValue;                        pointer++;                      continue;                  }                    z2 = dataBlockBuffer[pointer + 16];                  z3 = dataBlockBuffer[pointer + 48];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    z2 = dataBlockBuffer[pointer];                  z3 = dataBlockBuffer[pointer + 32];                    tmp0 = (z2 + z3) << constBits;                  tmp1 = (z2 - z3) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = dataBlockBuffer[pointer + 56];                  tmp1 = dataBlockBuffer[pointer + 40];                  tmp2 = dataBlockBuffer[pointer + 24];                  tmp3 = dataBlockBuffer[pointer + 8];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                  z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    workSpace[pointer + 0] = ((tmp10 + tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 56] = ((tmp10 - tmp3 + (1 << f1)) >> f2);                  workSpace[pointer + 8] = ((tmp11 + tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 48] = ((tmp11 - tmp2 + (1 << f1)) >> f2);                  workSpace[pointer + 16] = ((tmp12 + tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 40] = ((tmp12 - tmp1 + (1 << f1)) >> f2);                  workSpace[pointer + 24] = ((tmp13 + tmp0 + (1 << f1)) >> f2);                  workSpace[pointer + 32] = ((tmp13 - tmp0 + (1 << f1)) >> f2);                    pointer++;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: for (int index = 0; index < 8; index++)              {                  z2 = workSpace[pointer + 2];                  z3 = workSpace[pointer + 6];                    z1 = (z2 + z3) * fix_0_541196100;                  tmp2 = z1 + z3 * -fix_1_847759065;                  tmp3 = z1 + z2 * fix_0_765366865;                    tmp0 = (workSpace[pointer + 0] + workSpace[pointer + 4]) << constBits;                  tmp1 = (workSpace[pointer + 0] - workSpace[pointer + 4]) << constBits;                    tmp10 = tmp0 + tmp3;                  tmp13 = tmp0 - tmp3;                  tmp11 = tmp1 + tmp2;                  tmp12 = tmp1 - tmp2;                    tmp0 = workSpace[pointer + 7];                  tmp1 = workSpace[pointer + 5];                  tmp2 = workSpace[pointer + 3];                  tmp3 = workSpace[pointer + 1];                    z1 = tmp0 + tmp3;                  z2 = tmp1 + tmp2;                  z3 = tmp0 + tmp2;                  z4 = tmp1 + tmp3;                    z5 = (z3 + z4) * fix_1_175875602;                    tmp0 = tmp0 * fix_0_298631336;                  tmp1 = tmp1 * fix_2_053119869;                  tmp2 = tmp2 * fix_3_072711026;                  tmp3 = tmp3 * fix_1_501321110;                  z1 = z1 * -fix_0_899976223;                  z2 = z2 * -fix_2_562915447;                  z3 = z3 * -fix_1_961570560;                  z4 = z4 * -fix_0_390180644;                    z3 += z5;                  z4 += z5;                    tmp0 += z1 + z3;                  tmp1 += z2 + z4;                  tmp2 += z2 + z3;                  tmp3 += z1 + z4;                    data[pointer + 0] = (short)((tmp10 + tmp3) >> f3);                  data[pointer + 7] = (short)((tmp10 - tmp3) >> f3);                  data[pointer + 1] = (short)((tmp11 + tmp2) >> f3);                  data[pointer + 6] = (short)((tmp11 - tmp2) >> f3);                  data[pointer + 2] = (short)((tmp12 + tmp1) >> f3);                  data[pointer + 5] = (short)((tmp12 - tmp1) >> f3);                  data[pointer + 3] = (short)((tmp13 + tmp0) >> f3);                  data[pointer + 4] = (short)((tmp13 - tmp0) >> f3);                    pointer += 8;              }
Magic Number,ARDrone.Control.Utils,VideoUtils,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,InverseTransform,The following statement contains a magic number: unsafe              {                  fixed (short* source = data)                  fixed (short* destination = imageSlice.MacroBlocks[macroBlockIndex].DataBlocks[dataBlockIndex])                  {                      IntPtr sourcePtr = (IntPtr)source;                      IntPtr destinationPtr = (IntPtr)destination;                      CopyMemory(destinationPtr' sourcePtr' data.Length * 2);                  }              }
Magic Number,ARDrone.Control.Utils,MacroBlock,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,MacroBlock,The following statement contains a magic number: for (int index = 0; index < 6; index++)              {                  DataBlocks.Add(new short[64]);              }
Magic Number,ARDrone.Control.Utils,MacroBlock,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Utils\VideoUtils.cs,MacroBlock,The following statement contains a magic number: for (int index = 0; index < 6; index++)              {                  DataBlocks.Add(new short[64]);              }
Magic Number,ARDrone.Control.Workers,NetworkConnector,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NetworkConnector.cs,StartWaitingForNetworkConnection,The following statement contains a magic number: waitForConnectionTimer = new Timer(new TimerCallback(StopWaitingForNetworkConnection)' null' connectionTimeout' 250);
Magic Number,ARDrone.Control.Workers,CommandSender,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\CommandSender.cs,Initialize,The following statement contains a magic number: int maxRetryCount = 10;
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,WaitForFirstMessageToArrive,The following statement contains a magic number: int maxRetries = 20;
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,WaitForFirstMessageToArrive,The following statement contains a magic number: while (currentRetries < maxRetries &&                     currentNavigationDataHeaderStruct.Status == 0)              {                  currentRetries++;                  Thread.Sleep(50);              }
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,ReceiveData,The following statement contains a magic number: try              {                  if (client != null)                      buffer = client.Receive(ref endpoint);              }              catch (SocketException e)              {                  if (e.ErrorCode == 10060) //Timeout                      SendMessage(1);                    if (client != null)                      buffer = client.Receive(ref endpoint);              }
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,UpdateNavigationData,The following statement contains a magic number: while (memoryStream.Position < memoryStream.Length)              {                  ushort tag = reader.ReadUInt16();                  ushort size = reader.ReadUInt16();                    if (IsNavigationData(tag))                  {                      DetermineNavigationData(buffer' (int)(memoryStream.Position - 4));                      memoryStream.Position += size - 4;                  }                  else if (IsNavigationDataCheckSum(tag))                  {                      checksum = reader.ReadUInt32();                  }                  else                  {                      memoryStream.Position += size - 4;                  }              }
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,UpdateNavigationData,The following statement contains a magic number: while (memoryStream.Position < memoryStream.Length)              {                  ushort tag = reader.ReadUInt16();                  ushort size = reader.ReadUInt16();                    if (IsNavigationData(tag))                  {                      DetermineNavigationData(buffer' (int)(memoryStream.Position - 4));                      memoryStream.Position += size - 4;                  }                  else if (IsNavigationDataCheckSum(tag))                  {                      checksum = reader.ReadUInt32();                  }                  else                  {                      memoryStream.Position += size - 4;                  }              }
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,UpdateNavigationData,The following statement contains a magic number: while (memoryStream.Position < memoryStream.Length)              {                  ushort tag = reader.ReadUInt16();                  ushort size = reader.ReadUInt16();                    if (IsNavigationData(tag))                  {                      DetermineNavigationData(buffer' (int)(memoryStream.Position - 4));                      memoryStream.Position += size - 4;                  }                  else if (IsNavigationDataCheckSum(tag))                  {                      checksum = reader.ReadUInt32();                  }                  else                  {                      memoryStream.Position += size - 4;                  }              }
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,CalculateChecksum,The following statement contains a magic number: for (uint index = 0; index < buffer.Length - 8; index++)              {                  checksum += buffer[index];              }
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,SetStatusFlags,The following statement contains a magic number: uint initializedState = state & 2048;
Magic Number,ARDrone.Control.Workers,NavigationDataRetriever,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Workers\NavigationDataRetriever.cs,SetStatusFlags,The following statement contains a magic number: uint commandModeState = state & 64;
Magic Number,NativeWifi,WlanRateSet,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WifiInterop.cs,GetRateInMbps,The following statement contains a magic number: return (rateSet[rate] & 0x7FFF) * 0.5;
Magic Number,NativeWifi,WlanClient,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,GetStringForReasonCode,The following statement contains a magic number: StringBuilder sb = new StringBuilder(1024);
Missing Default,ARDrone.Control.Commands,FlightModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\FlightModeCommand.cs,SetPrerequisitesAndOutcome,The following switch statement is missing a default case: switch (flightMode)              {                  case DroneFlightMode.TakeOff:                      prerequisites.Add(CommandStatusPrerequisite.NotFlying);                      prerequisites.Add(CommandStatusPrerequisite.NotEmergency);                      outcome.Add(CommandStatusOutcome.SetFlying);                      break;                  case DroneFlightMode.Land:                      prerequisites.Add(CommandStatusPrerequisite.Flying);                      prerequisites.Add(CommandStatusPrerequisite.NotEmergency);                      outcome.Add(CommandStatusOutcome.ClearFlying);                      outcome.Add(CommandStatusOutcome.ClearHovering);                      break;                  case DroneFlightMode.Emergency:                      outcome.Add(CommandStatusOutcome.ClearFlying);                      outcome.Add(CommandStatusOutcome.ClearHovering);                      outcome.Add(CommandStatusOutcome.SetEmergency);                      break;                  case DroneFlightMode.Reset:                      outcome.Add(CommandStatusOutcome.ClearEmergency);                      break;              }
Missing Default,ARDrone.Control.Commands,HoverModeCommand,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Commands\HoverModeCommand.cs,SetPrerequisitesAndOutcome,The following switch statement is missing a default case: switch (mode)              {                  case DroneHoverMode.Hover:                      prerequisites.Add(CommandStatusPrerequisite.Flying);                      prerequisites.Add(CommandStatusPrerequisite.NotEmergency);                      prerequisites.Add(CommandStatusPrerequisite.NotHovering);                      outcome.Add(CommandStatusOutcome.SetHovering);                      break;                  case DroneHoverMode.StopHovering:                      prerequisites.Add(CommandStatusPrerequisite.Flying);                      prerequisites.Add(CommandStatusPrerequisite.NotEmergency);                      prerequisites.Add(CommandStatusPrerequisite.Hovering);                      outcome.Add(CommandStatusOutcome.ClearHovering);                      break;              }
Missing Default,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DetermineInternalConfiguration,The following switch statement is missing a default case: switch (configState.MainSection)                      {                          case "general":                              DetermineGeneralConfiguration(configState);                              break;                          case "control":                              DetermineControlConfiguration(configState);                              break;                          case "network":                              DetermineNetworkConfiguration(configState);                              break;                          case "pic":                              DetermineOtherConfiguration(configState);                              break;                        }
Missing Default,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DetermineGeneralConfiguration,The following switch statement is missing a default case: switch (configState.Key)              {                  case "num_version_mb":                      generalConfiguration.MainboardVersionInt = configState.Value;                      break;                  case "num_version_soft":                      generalConfiguration.SoftwareVersionInt = configState.Value;                      break;                  case "soft_build_date":                      generalConfiguration.SoftwareCompilationDateInt = DateTime.ParseExact(configState.Value' "yyyy-MM-dd HH:mm"' null);                      break;                  // Assuming motor values come in in the ordered correctly                  case "motor1_soft":                  case "motor2_soft":                  case "motor3_soft":                  case "motor4_soft":                      generalConfiguration.MotorSoftwareVersionsInt.Add(configState.Value);                      break;                  case "motor1_hard":                  case "motor2_hard":                  case "motor3_hard":                  case "motor4_hard":                      generalConfiguration.MotorHardwareVersionsInt.Add(configState.Value);                      break;                  case "motor1_supplier":                  case "motor2_supplier":                  case "motor3_supplier":                  case "motor4_supplier":                      generalConfiguration.MotorSuppliersInt.Add(configState.Value);                      break;                  case "ardrone_name":                      generalConfiguration.DroneNameInt = configState.Value;                      break;                  case "flying_time":                      generalConfiguration.FlightTimeInt = new TimeSpan(0' 0' Int32.Parse(configState.Value));                      break;              }
Missing Default,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DetermineControlConfiguration,The following switch statement is missing a default case: switch (configState.Key)              {                  case "altitude_max":                      controlConfiguration.MaxAltitudeInt = Int32.Parse(configState.Value);                      break;                  case "altitude_min":                      controlConfiguration.MinAltitudeInt = Int32.Parse(configState.Value);                      break;              }
Missing Default,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DetermineNetworkConfiguration,The following switch statement is missing a default case: switch (configState.Key)              {                  case "ssid_single_player":                      networkConfiguration.SsidInt = configState.Value;                      break;                  case "passkey":                      networkConfiguration.NetworkPasswordInt = configState.Value;                      break;                  case "infrastructure":                      networkConfiguration.InfrastructureInt = Boolean.Parse(configState.Value);                      break;                  case "navdata_port":                      networkConfiguration.NavigationDataPortInt = Int32.Parse(configState.Value);                      break;                  case "video_port":                      networkConfiguration.VideoDataPortInt = Int32.Parse(configState.Value);                      break;                  case "at_port":                      networkConfiguration.CommandDataPortInt = Int32.Parse(configState.Value);                      break;              }
Missing Default,ARDrone.Control.Data,InternalDroneConfiguration,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Data\InternalDroneConfiguration.cs,DetermineOtherConfiguration,The following switch statement is missing a default case: switch (configState.Key)              {                  case "ultrasound_freq":                      otherConfiguration.UltraSoundFrequencyInt = Int32.Parse(configState.Value);                      break;              }
Missing Default,ARDrone.Control,DroneControl,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\DroneControl.cs,UpdateCurrentCamera,The following switch statement is missing a default case: switch (currentCameraMode)                      {                          case DroneCameraMode.FrontCamera:                              cameraMode = DroneCameraMode.BottomCamera;                              break;                          case DroneCameraMode.BottomCamera:                              cameraMode = DroneCameraMode.PictureInPictureFront;                              break;                          case DroneCameraMode.PictureInPictureFront:                              cameraMode = DroneCameraMode.PictureInPictureBottom;                              break;                          case DroneCameraMode.PictureInPictureBottom:                              cameraMode = DroneCameraMode.FrontCamera;                              break;                      }
Missing Default,NativeWifi,WlanClient,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,OnWlanNotification,The following switch statement is missing a default case: switch(notifyData.notificationSource)  			{  				case Wlan.WlanNotificationSource.ACM:  					switch((Wlan.WlanNotificationCodeAcm)notifyData.notificationCode)  					{  						case Wlan.WlanNotificationCodeAcm.ConnectionStart:  						case Wlan.WlanNotificationCodeAcm.ConnectionComplete:  						case Wlan.WlanNotificationCodeAcm.ConnectionAttemptFail:  						case Wlan.WlanNotificationCodeAcm.Disconnecting:  						case Wlan.WlanNotificationCodeAcm.Disconnected:  							Wlan.WlanConnectionNotificationData? connNotifyData = ParseWlanConnectionNotification(ref notifyData);  							if (connNotifyData.HasValue)  								if (wlanIface != null)  									wlanIface.OnWlanConnection(notifyData' connNotifyData.Value);  							break;  						case Wlan.WlanNotificationCodeAcm.ScanFail:  							{  								int expectedSize = Marshal.SizeOf(typeof (Wlan.WlanReasonCode));  								if (notifyData.dataSize >= expectedSize)  								{  									Wlan.WlanReasonCode reasonCode = (Wlan.WlanReasonCode) Marshal.ReadInt32(notifyData.dataPtr);  									if (wlanIface != null)  										wlanIface.OnWlanReason(notifyData' reasonCode);  								}  							}  							break;  					}  					break;  				case Wlan.WlanNotificationSource.MSM:  					switch((Wlan.WlanNotificationCodeMsm)notifyData.notificationCode)  					{  						case Wlan.WlanNotificationCodeMsm.Associating:  						case Wlan.WlanNotificationCodeMsm.Associated:  						case Wlan.WlanNotificationCodeMsm.Authenticating:  						case Wlan.WlanNotificationCodeMsm.Connected:  						case Wlan.WlanNotificationCodeMsm.RoamingStart:  						case Wlan.WlanNotificationCodeMsm.RoamingEnd:  						case Wlan.WlanNotificationCodeMsm.Disassociating:  						case Wlan.WlanNotificationCodeMsm.Disconnected:  						case Wlan.WlanNotificationCodeMsm.PeerJoin:  						case Wlan.WlanNotificationCodeMsm.PeerLeave:  						case Wlan.WlanNotificationCodeMsm.AdapterRemoval:  							Wlan.WlanConnectionNotificationData? connNotifyData = ParseWlanConnectionNotification(ref notifyData);  							if (connNotifyData.HasValue)  								if (wlanIface != null)  									wlanIface.OnWlanConnection(notifyData' connNotifyData.Value);  							break;  					}  					break;  			}
Missing Default,NativeWifi,WlanClient,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,OnWlanNotification,The following switch statement is missing a default case: switch((Wlan.WlanNotificationCodeAcm)notifyData.notificationCode)  					{  						case Wlan.WlanNotificationCodeAcm.ConnectionStart:  						case Wlan.WlanNotificationCodeAcm.ConnectionComplete:  						case Wlan.WlanNotificationCodeAcm.ConnectionAttemptFail:  						case Wlan.WlanNotificationCodeAcm.Disconnecting:  						case Wlan.WlanNotificationCodeAcm.Disconnected:  							Wlan.WlanConnectionNotificationData? connNotifyData = ParseWlanConnectionNotification(ref notifyData);  							if (connNotifyData.HasValue)  								if (wlanIface != null)  									wlanIface.OnWlanConnection(notifyData' connNotifyData.Value);  							break;  						case Wlan.WlanNotificationCodeAcm.ScanFail:  							{  								int expectedSize = Marshal.SizeOf(typeof (Wlan.WlanReasonCode));  								if (notifyData.dataSize >= expectedSize)  								{  									Wlan.WlanReasonCode reasonCode = (Wlan.WlanReasonCode) Marshal.ReadInt32(notifyData.dataPtr);  									if (wlanIface != null)  										wlanIface.OnWlanReason(notifyData' reasonCode);  								}  							}  							break;  					}
Missing Default,NativeWifi,WlanClient,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,OnWlanNotification,The following switch statement is missing a default case: switch((Wlan.WlanNotificationCodeMsm)notifyData.notificationCode)  					{  						case Wlan.WlanNotificationCodeMsm.Associating:  						case Wlan.WlanNotificationCodeMsm.Associated:  						case Wlan.WlanNotificationCodeMsm.Authenticating:  						case Wlan.WlanNotificationCodeMsm.Connected:  						case Wlan.WlanNotificationCodeMsm.RoamingStart:  						case Wlan.WlanNotificationCodeMsm.RoamingEnd:  						case Wlan.WlanNotificationCodeMsm.Disassociating:  						case Wlan.WlanNotificationCodeMsm.Disconnected:  						case Wlan.WlanNotificationCodeMsm.PeerJoin:  						case Wlan.WlanNotificationCodeMsm.PeerLeave:  						case Wlan.WlanNotificationCodeMsm.AdapterRemoval:  							Wlan.WlanConnectionNotificationData? connNotifyData = ParseWlanConnectionNotification(ref notifyData);  							if (connNotifyData.HasValue)  								if (wlanIface != null)  									wlanIface.OnWlanConnection(notifyData' connNotifyData.Value);  							break;  					}
Missing Default,NativeWifi,WlanInterface,C:\repos\shtejv_ARDrone-Control-.NET\ARDroneControlLibrary\Wifi\WlanApi.cs,ConnectSynchronously,The following switch statement is missing a default case: switch ((Wlan.WlanNotificationCodeAcm)wlanConnectionData.notifyData.notificationCode)                                          {                                              case Wlan.WlanNotificationCodeAcm.ConnectionComplete:                                                  if (wlanConnectionData.connNotifyData.dot11Ssid.SSID.ToString() == ssid.SSID.ToString())                                                      return true;                                                  break;                                          }
