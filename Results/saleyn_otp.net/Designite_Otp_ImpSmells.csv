Implementation smell,Namespace,Class,File,Method,Description
Long Method,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The method has 272 lines of code.
Long Method,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_publish,The method has 100 lines of code.
Complex Method,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,Cyclomatic complexity of the method is 9
Complex Method,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvName,Cyclomatic complexity of the method is 8
Complex Method,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_lookupPort,Cyclomatic complexity of the method is 9
Complex Method,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_publish,Cyclomatic complexity of the method is 9
Complex Method,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_publish,Cyclomatic complexity of the method is 9
Long Parameter List,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,encodeRPC,The method has 5 parameters. Parameters: from' mod' fun' args' gleader
Long Parameter List,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,encodeRPCcast,The method has 5 parameters. Parameters: from' mod' fun' args' gleader
Long Parameter List,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,encodeRPC,The method has 5 parameters. Parameters: from' mod' fun' args' gleader
Long Parameter List,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,encodeRPCcast,The method has 5 parameters. Parameters: from' mod' fun' args' gleader
Long Parameter List,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,rpcCall,The method has 5 parameters. Parameters: node' mod' fun' args' timeout
Long Parameter List,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,rpcCall,The method has 5 parameters. Parameters: node' mod' fun' args' timeout
Long Parameter List,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,sendRPC,The method has 5 parameters. Parameters: node' mod' fun' args' ioServer
Long Parameter List,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,sendRPC,The method has 5 parameters. Parameters: node' mod' fun' args' ioServer
Long Parameter List,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,sendRPCcast,The method has 5 parameters. Parameters: node' mod' fun' args' ioServer
Long Parameter List,Otp,OtpMsg,C:\repos\saleyn_otp.net\Otp\OtpMsg.cs,OtpMsg,The method has 5 parameters. Parameters: tag' from' to' eref' reason
Long Parameter List,Otp,OtpMsg,C:\repos\saleyn_otp.net\Otp\OtpMsg.cs,OtpMsg,The method has 5 parameters. Parameters: tag' from' toName' eref' reason
Long Parameter List,Otp,OtpMsg,C:\repos\saleyn_otp.net\Otp\OtpMsg.cs,OtpMsg,The method has 6 parameters. Parameters: tag' from' to' eref' reason' paybuf
Long Parameter List,Otp,OtpMsg,C:\repos\saleyn_otp.net\Otp\OtpMsg.cs,OtpMsg,The method has 6 parameters. Parameters: tag' from' to' eref' reason' paybuf
Long Parameter List,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,OtpNode,The method has 5 parameters. Parameters: node' acceptConnections' cookie' port' shortName
Long Parameter List,Otp.Erlang,Formatter,C:\repos\saleyn_otp.net\Otp\Erlang\Format.cs,ptuple,The method has 5 parameters. Parameters: fmt' pos' items' argc' args
Long Parameter List,Otp.Erlang,Formatter,C:\repos\saleyn_otp.net\Otp\Erlang\Format.cs,plist,The method has 5 parameters. Parameters: fmt' pos' items' argc' args
Long Parameter List,Otp.Erlang,Formatter,C:\repos\saleyn_otp.net\Otp\Erlang\Format.cs,pformat,The method has 5 parameters. Parameters: fmt' pos' items' argc' args
Long Statement,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendChallenge,The length of the statement  "                OtpTrace.TraceEvent("-> " + "HANDSHAKE sendChallenge" + " flags=" + flags + " dist=" + dist + " challenge=" + challenge + " local=" + self); " is 140.
Long Statement,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvChallenge,The length of the statement  "                OtpTrace.TraceEvent("<- " + "HANDSHAKE recvChallenge" + " from=" + peer._node + " challenge=" + challenge + " local=" + self); " is 126.
Long Statement,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendChallengeReply,The length of the statement  "                OtpTrace.TraceEvent("-> " + "HANDSHAKE sendChallengeReply" + " challenge=" + challenge + " digest=" + hex(digest) + " local=" + self); " is 134.
Long Statement,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvChallengeReply,The length of the statement  "                OtpTrace.TraceEvent("<- " + "HANDSHAKE recvChallengeReply" + " from=" + peer._node + " challenge=" + challenge + " digest=" + hex(her_digest) + " local=" + self); " is 162.
Long Statement,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvChallengeAck,The length of the statement  "                OtpTrace.TraceEvent("<- " + "HANDSHAKE recvChallengeAck" + " from=" + peer._node + " digest=" + hex(her_digest) + " local=" + self); " is 132.
Long Statement,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The length of the statement  "            return (int)((((int)b[0] << 24) & 0xff000000) + (((int)b[1] << 16) & 0xff0000) + (((int)b[2] << 8) & 0xff00) + (((int)b[3]) & 0xff)); " is 133.
Long Statement,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read_string,The length of the statement  "                    throw new Erlang.Exception("Wrong tag encountered' expected " + OtpExternal.stringTag + " or " + OtpExternal.listTag + "' got " + tag); " is 135.
Long Statement,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write_double,The length of the statement  "            //UPGRADE_TODO: The equivalent in .NETÂ for Class C#.math.BigDecimal.ROUND_HALF_EVEN will be considered in a future release.; " is 124.
Long Statement,Otp.Erlang,Pid,C:\repos\saleyn_otp.net\Otp\Erlang\Pid.cs,Equals,The length of the statement  "			return ((this._creation == pid._creation) && (this._serial == pid._serial) && (this._id == pid._id) && (_node.CompareTo(pid._node) == 0)); " is 138.
Long Statement,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Equals,The length of the statement  "				return (this._ids[0] == ref_Renamed._ids[0] && this._ids[1] == ref_Renamed._ids[1] && this._ids[2] == ref_Renamed._ids[2]); " is 123.
Virtual Method Call from Constructor,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,AbstractConnection,The constructor "AbstractConnection" calls a virtual method "recvName".
Virtual Method Call from Constructor,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,AbstractConnection,The constructor "AbstractConnection" calls a virtual method "close".
Virtual Method Call from Constructor,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,AbstractConnection,The constructor "AbstractConnection" calls a virtual method "doAccept".
Virtual Method Call from Constructor,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,AbstractConnection,The constructor "AbstractConnection" calls a virtual method "cookie".
Virtual Method Call from Constructor,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,AbstractConnection,The constructor "AbstractConnection" calls a virtual method "doConnect".
Virtual Method Call from Constructor,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The constructor "OtpCookedConnection" calls a virtual method "cookie".
Virtual Method Call from Constructor,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,OtpOutputStream,The constructor "OtpOutputStream" calls a virtual method "write4BE".
Virtual Method Call from Constructor,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,OtpOutputStream,The constructor "OtpOutputStream" calls a virtual method "poke4BE".
Virtual Method Call from Constructor,Otp,OtpSelf,C:\repos\saleyn_otp.net\Otp\OtpSelf.cs,OtpSelf,The constructor "OtpSelf" calls a virtual method "createPid".
Virtual Method Call from Constructor,Otp,OtpServer,C:\repos\saleyn_otp.net\Otp\OtpServer.cs,OtpServer,The constructor "OtpServer" calls a virtual method "cookie".
Virtual Method Call from Constructor,Otp.Erlang,Byte,C:\repos\saleyn_otp.net\Otp\Erlang\Byte.cs,Byte,The constructor "Byte" calls a virtual method "byteValue".
Virtual Method Call from Constructor,Otp.Erlang,Pid,C:\repos\saleyn_otp.net\Otp\Erlang\Pid.cs,Pid,The constructor "Pid" calls a virtual method "createPid".
Virtual Method Call from Constructor,Otp.Erlang,Pid,C:\repos\saleyn_otp.net\Otp\Erlang\Pid.cs,Pid,The constructor "Pid" calls a virtual method "node".
Virtual Method Call from Constructor,Otp.Erlang,Pid,C:\repos\saleyn_otp.net\Otp\Erlang\Pid.cs,Pid,The constructor "Pid" calls a virtual method "id".
Virtual Method Call from Constructor,Otp.Erlang,Pid,C:\repos\saleyn_otp.net\Otp\Erlang\Pid.cs,Pid,The constructor "Pid" calls a virtual method "serial".
Virtual Method Call from Constructor,Otp.Erlang,Pid,C:\repos\saleyn_otp.net\Otp\Erlang\Pid.cs,Pid,The constructor "Pid" calls a virtual method "creation".
Virtual Method Call from Constructor,Otp.Erlang,Port,C:\repos\saleyn_otp.net\Otp\Erlang\Port.cs,Port,The constructor "Port" calls a virtual method "createPort".
Virtual Method Call from Constructor,Otp.Erlang,Port,C:\repos\saleyn_otp.net\Otp\Erlang\Port.cs,Port,The constructor "Port" calls a virtual method "node".
Virtual Method Call from Constructor,Otp.Erlang,Port,C:\repos\saleyn_otp.net\Otp\Erlang\Port.cs,Port,The constructor "Port" calls a virtual method "id".
Virtual Method Call from Constructor,Otp.Erlang,Port,C:\repos\saleyn_otp.net\Otp\Erlang\Port.cs,Port,The constructor "Port" calls a virtual method "creation".
Virtual Method Call from Constructor,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The constructor "Ref" calls a virtual method "createRef".
Virtual Method Call from Constructor,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The constructor "Ref" calls a virtual method "node".
Virtual Method Call from Constructor,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The constructor "Ref" calls a virtual method "creation".
Virtual Method Call from Constructor,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The constructor "Ref" calls a virtual method "ids".
Virtual Method Call from Constructor,Otp.Erlang,UInt,C:\repos\saleyn_otp.net\Otp\Erlang\UInt.cs,UInt,The constructor "UInt" calls a virtual method "uIntValue".
Virtual Method Call from Constructor,Otp.Erlang,UInt,C:\repos\saleyn_otp.net\Otp\Erlang\UInt.cs,UInt,The constructor "UInt" calls a virtual method "uIntValue".
Virtual Method Call from Constructor,Otp.Erlang,UShort,C:\repos\saleyn_otp.net\Otp\Erlang\UShort.cs,UShort,The constructor "UShort" calls a virtual method "uShortValue".
Virtual Method Call from Constructor,Otp.Erlang,UShort,C:\repos\saleyn_otp.net\Otp\Erlang\UShort.cs,UShort,The constructor "UShort" calls a virtual method "uShortValue".
Empty Catch Block,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,cookieError,The method has an empty catch block.
Empty Catch Block,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,close,The method has an empty catch block.
Empty Catch Block,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,doConnect,The method has an empty catch block.
Empty Catch Block,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,hex,The method has an empty catch block.
Empty Catch Block,Otp,AbstractNode,C:\repos\saleyn_otp.net\Otp\AbstractNode.cs,AbstractNode,The method has an empty catch block.
Empty Catch Block,Otp,GenericQueue,C:\repos\saleyn_otp.net\Otp\GenericQueue.cs,close,The method has an empty catch block.
Empty Catch Block,Otp,GenericQueue,C:\repos\saleyn_otp.net\Otp\GenericQueue.cs,get,The method has an empty catch block.
Empty Catch Block,Otp,GenericQueue,C:\repos\saleyn_otp.net\Otp\GenericQueue.cs,get,The method has an empty catch block.
Empty Catch Block,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,deliver,The method has an empty catch block.
Empty Catch Block,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,deliver,The method has an empty catch block.
Empty Catch Block,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,exit,The method has an empty catch block.
Empty Catch Block,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,exit2,The method has an empty catch block.
Empty Catch Block,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,unlink,The method has an empty catch block.
Empty Catch Block,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,unPublishPort,The method has an empty catch block.
Empty Catch Block,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,unPublishPort,The method has an empty catch block.
Empty Catch Block,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_lookupPort,The method has an empty catch block.
Empty Catch Block,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_lookupPort,The method has an empty catch block.
Empty Catch Block,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,remoteStatus,The method has an empty catch block.
Empty Catch Block,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,localStatus,The method has an empty catch block.
Empty Catch Block,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,connAttempt,The method has an empty catch block.
Empty Catch Block,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,epmdFailedConnAttempt,The method has an empty catch block.
Empty Catch Block,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,receive,The method has an empty catch block.
Empty Catch Block,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,send,The method has an empty catch block.
Empty Catch Block,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,send,The method has an empty catch block.
Empty Catch Block,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,exit,The method has an empty catch block.
Empty Catch Block,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,link,The method has an empty catch block.
Empty Catch Block,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,unlink,The method has an empty catch block.
Empty Catch Block,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,ping,The method has an empty catch block.
Empty Catch Block,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,netKernel,The method has an empty catch block.
Empty Catch Block,Otp,Acceptor,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,closeSock,The method has an empty catch block.
Empty Catch Block,Otp,Acceptor,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,closeSock,The method has an empty catch block.
Empty Catch Block,Otp,OtpSelf,C:\repos\saleyn_otp.net\Otp\OtpSelf.cs,unPublishPort,The method has an empty catch block.
Empty Catch Block,Otp,OtpSelf,C:\repos\saleyn_otp.net\Otp\OtpSelf.cs,accept,The method has an empty catch block.
Empty Catch Block,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The method has an empty catch block.
Empty Catch Block,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The method has an empty catch block.
Empty Catch Block,Otp.Erlang,Binary,C:\repos\saleyn_otp.net\Otp\Erlang\Binary.cs,fromByteArray,The method has an empty catch block.
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendBuf,The following statement contains a magic number: header.write_tuple_head(4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendBuf,The following statement contains a magic number: header.poke4BE(0' header.count() + payload.count() - 4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendBuf,The following statement contains a magic number: header.write_tuple_head(3);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendBuf,The following statement contains a magic number: header.poke4BE(0' header.count() + payload.count() - 4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,cookieError,The following statement contains a magic number: try              {                  OtpOutputStream header = new OtpOutputStream(headerLen);                                    // preamble: 4 byte length + "passthrough" tag + version                  header.write4BE(0); // reserve space for length                  header.write1(passThrough);                  header.write1(OtpExternal.versionTag);                                    header.write_tuple_head(4);                  header.write_long((long)OtpMsg.Tag.regSendTag);                  header.write_any(local.createPid()); // disposable pid                  header.write_atom(cookie.atomValue()); // important: his cookie' not mine...                  header.write_atom("auth");                                    // version for payload                  header.write1(OtpExternal.versionTag);                                    // the payload                                    // the no_auth message (copied from Erlang) Don't change this (Erlang will crash)                  // {$gen_cast' {print' "~n** Unauthorized cookie ~w **~n"' [foo@aule]}}                  Erlang.Object[] msg = new Erlang.Object[2];                  Erlang.Object[] msgbody = new Erlang.Object[3];                                    msgbody[0] = new Erlang.Atom("print");                  msgbody[1] = new Erlang.String("~n** Bad cookie sent to " + local + " **~n");                  // Erlang will crash and burn if there is no third argument here...                  msgbody[2] = new Erlang.List(); // empty list                                    msg[0] = new Erlang.Atom("$gen_cast");                  msg[1] = new Erlang.Tuple(msgbody);                                    OtpOutputStream payload = new OtpOutputStream(new Erlang.Tuple(msg));                                    // fix up length in preamble                  header.poke4BE(0' header.count() + payload.count() - 4);                                    try                  {                      do_send(header' payload);                  }                  catch (System.IO.IOException)                  {                  } // ignore              }              finally              {                  close();                  throw new OtpAuthException("Remote cookie not authorized: " + cookie.atomValue());              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,cookieError,The following statement contains a magic number: try              {                  OtpOutputStream header = new OtpOutputStream(headerLen);                                    // preamble: 4 byte length + "passthrough" tag + version                  header.write4BE(0); // reserve space for length                  header.write1(passThrough);                  header.write1(OtpExternal.versionTag);                                    header.write_tuple_head(4);                  header.write_long((long)OtpMsg.Tag.regSendTag);                  header.write_any(local.createPid()); // disposable pid                  header.write_atom(cookie.atomValue()); // important: his cookie' not mine...                  header.write_atom("auth");                                    // version for payload                  header.write1(OtpExternal.versionTag);                                    // the payload                                    // the no_auth message (copied from Erlang) Don't change this (Erlang will crash)                  // {$gen_cast' {print' "~n** Unauthorized cookie ~w **~n"' [foo@aule]}}                  Erlang.Object[] msg = new Erlang.Object[2];                  Erlang.Object[] msgbody = new Erlang.Object[3];                                    msgbody[0] = new Erlang.Atom("print");                  msgbody[1] = new Erlang.String("~n** Bad cookie sent to " + local + " **~n");                  // Erlang will crash and burn if there is no third argument here...                  msgbody[2] = new Erlang.List(); // empty list                                    msg[0] = new Erlang.Atom("$gen_cast");                  msg[1] = new Erlang.Tuple(msgbody);                                    OtpOutputStream payload = new OtpOutputStream(new Erlang.Tuple(msg));                                    // fix up length in preamble                  header.poke4BE(0' header.count() + payload.count() - 4);                                    try                  {                      do_send(header' payload);                  }                  catch (System.IO.IOException)                  {                  } // ignore              }              finally              {                  close();                  throw new OtpAuthException("Remote cookie not authorized: " + cookie.atomValue());              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,cookieError,The following statement contains a magic number: try              {                  OtpOutputStream header = new OtpOutputStream(headerLen);                                    // preamble: 4 byte length + "passthrough" tag + version                  header.write4BE(0); // reserve space for length                  header.write1(passThrough);                  header.write1(OtpExternal.versionTag);                                    header.write_tuple_head(4);                  header.write_long((long)OtpMsg.Tag.regSendTag);                  header.write_any(local.createPid()); // disposable pid                  header.write_atom(cookie.atomValue()); // important: his cookie' not mine...                  header.write_atom("auth");                                    // version for payload                  header.write1(OtpExternal.versionTag);                                    // the payload                                    // the no_auth message (copied from Erlang) Don't change this (Erlang will crash)                  // {$gen_cast' {print' "~n** Unauthorized cookie ~w **~n"' [foo@aule]}}                  Erlang.Object[] msg = new Erlang.Object[2];                  Erlang.Object[] msgbody = new Erlang.Object[3];                                    msgbody[0] = new Erlang.Atom("print");                  msgbody[1] = new Erlang.String("~n** Bad cookie sent to " + local + " **~n");                  // Erlang will crash and burn if there is no third argument here...                  msgbody[2] = new Erlang.List(); // empty list                                    msg[0] = new Erlang.Atom("$gen_cast");                  msg[1] = new Erlang.Tuple(msgbody);                                    OtpOutputStream payload = new OtpOutputStream(new Erlang.Tuple(msg));                                    // fix up length in preamble                  header.poke4BE(0' header.count() + payload.count() - 4);                                    try                  {                      do_send(header' payload);                  }                  catch (System.IO.IOException)                  {                  } // ignore              }              finally              {                  close();                  throw new OtpAuthException("Remote cookie not authorized: " + cookie.atomValue());              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,cookieError,The following statement contains a magic number: try              {                  OtpOutputStream header = new OtpOutputStream(headerLen);                                    // preamble: 4 byte length + "passthrough" tag + version                  header.write4BE(0); // reserve space for length                  header.write1(passThrough);                  header.write1(OtpExternal.versionTag);                                    header.write_tuple_head(4);                  header.write_long((long)OtpMsg.Tag.regSendTag);                  header.write_any(local.createPid()); // disposable pid                  header.write_atom(cookie.atomValue()); // important: his cookie' not mine...                  header.write_atom("auth");                                    // version for payload                  header.write1(OtpExternal.versionTag);                                    // the payload                                    // the no_auth message (copied from Erlang) Don't change this (Erlang will crash)                  // {$gen_cast' {print' "~n** Unauthorized cookie ~w **~n"' [foo@aule]}}                  Erlang.Object[] msg = new Erlang.Object[2];                  Erlang.Object[] msgbody = new Erlang.Object[3];                                    msgbody[0] = new Erlang.Atom("print");                  msgbody[1] = new Erlang.String("~n** Bad cookie sent to " + local + " **~n");                  // Erlang will crash and burn if there is no third argument here...                  msgbody[2] = new Erlang.List(); // empty list                                    msg[0] = new Erlang.Atom("$gen_cast");                  msg[1] = new Erlang.Tuple(msgbody);                                    OtpOutputStream payload = new OtpOutputStream(new Erlang.Tuple(msg));                                    // fix up length in preamble                  header.poke4BE(0' header.count() + payload.count() - 4);                                    try                  {                      do_send(header' payload);                  }                  catch (System.IO.IOException)                  {                  } // ignore              }              finally              {                  close();                  throw new OtpAuthException("Remote cookie not authorized: " + cookie.atomValue());              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,cookieError,The following statement contains a magic number: try              {                  OtpOutputStream header = new OtpOutputStream(headerLen);                                    // preamble: 4 byte length + "passthrough" tag + version                  header.write4BE(0); // reserve space for length                  header.write1(passThrough);                  header.write1(OtpExternal.versionTag);                                    header.write_tuple_head(4);                  header.write_long((long)OtpMsg.Tag.regSendTag);                  header.write_any(local.createPid()); // disposable pid                  header.write_atom(cookie.atomValue()); // important: his cookie' not mine...                  header.write_atom("auth");                                    // version for payload                  header.write1(OtpExternal.versionTag);                                    // the payload                                    // the no_auth message (copied from Erlang) Don't change this (Erlang will crash)                  // {$gen_cast' {print' "~n** Unauthorized cookie ~w **~n"' [foo@aule]}}                  Erlang.Object[] msg = new Erlang.Object[2];                  Erlang.Object[] msgbody = new Erlang.Object[3];                                    msgbody[0] = new Erlang.Atom("print");                  msgbody[1] = new Erlang.String("~n** Bad cookie sent to " + local + " **~n");                  // Erlang will crash and burn if there is no third argument here...                  msgbody[2] = new Erlang.List(); // empty list                                    msg[0] = new Erlang.Atom("$gen_cast");                  msg[1] = new Erlang.Tuple(msgbody);                                    OtpOutputStream payload = new OtpOutputStream(new Erlang.Tuple(msg));                                    // fix up length in preamble                  header.poke4BE(0' header.count() + payload.count() - 4);                                    try                  {                      do_send(header' payload);                  }                  catch (System.IO.IOException)                  {                  } // ignore              }              finally              {                  close();                  throw new OtpAuthException("Remote cookie not authorized: " + cookie.atomValue());              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendLink,The following statement contains a magic number: header.write_tuple_head(3);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendLink,The following statement contains a magic number: header.poke4BE(0' header.count() - 4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendUnlink,The following statement contains a magic number: header.write_tuple_head(3);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendUnlink,The following statement contains a magic number: header.poke4BE(0' header.count() - 4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendExit,The following statement contains a magic number: header.write_tuple_head(4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendExit,The following statement contains a magic number: header.poke4BE(0' header.count() - 4);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: byte[] header = new byte[4];
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: byte[] payloadBuf = new byte[1024 * 1024];
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: byte[] payloadBuf = new byte[1024 * 1024];
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The following statement contains a magic number: try              {                  while (!done)                  {                      // don't return until we get a real message                      // or a failure of some kind (e.g. EXIT)                      // read length and read buffer must be atomic!                      do                      {                          // read 4 bytes - get length of incoming packet                          // socket.getInputStream().read(lbuf);                          int n;                          if ((n = readSock(socket' header' header.Length' false)) < header.Length)                              throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' n' header.Length));                            len = OtpInputStream.read4BE(header);                            //  received tick? send tock!                          if (len == 0)                              lock (this)                              {                                  System.Byte[] temp_bytearray;                                  temp_bytearray = tock;                                  if (socket != null)                                      ((System.IO.Stream)socket.GetStream()).Write(temp_bytearray' 0' temp_bytearray.Length);                              }                      }                      while (len == 0); // tick_loop                        if (len > maxPayloadLength)                          throw new System.Exception(                              String.Format("Message size too long (max={0}' got={1})"' maxPayloadLength' len));                        // got a real message (maybe) - read len bytes                      byte[] tmpbuf = new byte[len]; // len > payloadBuf.Length ? new byte[len] : payloadBuf;                      // i = socket.getInputStream().read(tmpbuf);                      int m = readSock(socket' tmpbuf' len' true);                      if (m != len)                          throw new System.Exception(String.Format("Read {0} out of {1} bytes!"' m' len));                        ibuf = new OtpInputStream(tmpbuf' 0' len);                        if (ibuf.read1() != passThrough)                      {                          goto receive_loop_brk;                      }                        // got a real message (really)                      Erlang.Atom reason = null;                      Erlang.Atom cookie = null;                      Erlang.Object tmp = null;                      Erlang.Tuple head = null;                      Erlang.Atom toName;                      Erlang.Pid to;                      Erlang.Pid from;                      Erlang.Ref eref;                        // decode the header                      tmp = ibuf.read_any();                      if (!(tmp is Erlang.Tuple))                          goto receive_loop_brk;                        head = (Erlang.Tuple)tmp;                      if (!(head.elementAt(0) is Erlang.Long))                      {                          goto receive_loop_brk;                      }                        // lets see what kind of message this is                      OtpMsg.Tag tag = (OtpMsg.Tag)head.elementAt(0).longValue();                        switch (tag)                      {                          case OtpMsg.Tag.sendTag:                          case OtpMsg.Tag.sendTTTag:                              // { SEND' Cookie' ToPid' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(1) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(1);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(to' ibuf));                              break;                            case OtpMsg.Tag.regSendTag:                          case OtpMsg.Tag.regSendTTTag:                              // { REG_SEND' FromPid' Cookie' ToName' TraceToken }                              if (!cookieOk)                              {                                  // we only check this once' he can send us bad cookies later if he likes                                  if (!(head.elementAt(2) is Erlang.Atom))                                  {                                      goto receive_loop_brk;                                  }                                  cookie = (Erlang.Atom)head.elementAt(2);                                  if (sendCookie)                                  {                                      if (!cookie.atomValue().Equals(auth_cookie))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  else                                  {                                      if (!cookie.atomValue().Equals(""))                                      {                                          cookieError(self' cookie);                                      }                                  }                                  cookieOk = true;                              }                                if (traceLevel >= OtpTrace.Type.sendThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                                    /*show received payload too */                                  long mark = ibuf.Position;                                  traceobj = ibuf.read_any();                                    if (traceobj != null)                                      OtpTrace.TraceEvent("   " + traceobj.ToString());                                  else                                      OtpTrace.TraceEvent("   (null)");                                  ibuf.Seek(mark' System.IO.SeekOrigin.Begin);                              }                                from = (Erlang.Pid)(head.elementAt(1));                              toName = (Erlang.Atom)(head.elementAt(3));                                deliver(new OtpMsg(from' toName.atomValue()' ibuf));                              break;                            case OtpMsg.Tag.exitTag:                          case OtpMsg.Tag.exit2Tag:                              // { EXIT2' FromPid' ToPid' Reason }                              if (!(head.elementAt(3) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(3);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.exitTTTag:                          case OtpMsg.Tag.exit2TTTag:                              // { EXIT2' FromPid' ToPid' TraceToken' Reason }                              // as above' but bifferent element number                              if (!(head.elementAt(4) is Erlang.Atom))                              {                                  goto receive_loop_brk;                              }                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              reason = (Erlang.Atom)head.elementAt(4);                                deliver(new OtpMsg(tag' from' to' reason));                              break;                            case OtpMsg.Tag.linkTag:                          case OtpMsg.Tag.unlinkTag:                              // { UNLINK' FromPid' ToPid}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                                from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                                deliver(new OtpMsg(tag' from' to));                              break;                            // absolutely no idea what to do with these' so we ignore them...                          case OtpMsg.Tag.groupLeaderTag:                          case OtpMsg.Tag.nodeLinkTag:                              // { NODELINK }                              // (just show trace)                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              break;                            case OtpMsg.Tag.monitorPTag:                          // {MONITOR_P' FromPid' ToProc' Ref}                          case OtpMsg.Tag.demonitorPTag:                              // {DEMONITOR_P' FromPid' ToProc' Ref}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                              deliver(new OtpMsg(tag' from' to' eref));                              break;                            case OtpMsg.Tag.monitorPexitTag:                              // {MONITOR_P_EXIT' FromPid' ToProc' Ref' Reason}                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- " + headerType(head) + " " + head.ToString());                              }                              from = (Erlang.Pid)(head.elementAt(1));                              to = (Erlang.Pid)(head.elementAt(2));                              eref = (Erlang.Ref)(head.elementAt(3));                                deliver(new OtpMsg(tag' from' to' eref' reason));                              break;                            default:                              // garbage?                              if (traceLevel >= OtpTrace.Type.ctrlThreshold)                              {                                  OtpTrace.TraceEvent("<- Unknown tag " + headerType(head) + " " + head.ToString());                              }                              goto receive_loop_brk;                      }                  }  receive_loop_brk: ;                   // end receive_loop                    // this section reachable only with break                  // we have received garbage from peer                  deliver(new Erlang.Exit("Remote is sending garbage"));                }              catch (OtpAuthException e)              {                  deliver(e);              }              catch (Erlang.Exception e)              {                  OtpTrace.TraceEvent(e.ToString());                  deliver(new Erlang.Exit("Remote is sending garbage: " + e.ToString()));              }              catch (System.Exception e)              {                  deliver(new Erlang.Exit("Remote has closed connection: " + e.ToString()));              }              finally              {                  close();                  OtpTrace.TraceEvent("exit connection "+System.Threading.Thread.CurrentThread.Name);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,decodeRPC,The following statement contains a magic number: if (msg is Erlang.Tuple)              {                  Erlang.Tuple t = (Erlang.Tuple)msg;                  if (t.arity() == 2)                  {                      Erlang.Atom rex = t[0] as Erlang.Atom;                      if (rex != null && rex.atomValue() == "rex")                          return t[1];                      // obs: second element                  }              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,decodeIO,The following statement contains a magic number: if (msg is Erlang.Tuple)              {                  Erlang.Tuple t = (Erlang.Tuple)msg;                  if (t.arity() == 4)                  {                      Erlang.Atom  ios = t[0] as Erlang.Atom;                      Erlang.Tuple data = t[3] as Erlang.Tuple;                      if (ios != null && ios.atomValue() == "io_request" && data != null)                      {                          if ((data[0] as Erlang.Atom).atomValue() == "put_chars")                          {                              if (data[1] is Erlang.String)                                  return (data[1] as Erlang.String).stringValue();                              else if (data[1] is Erlang.Binary)                              {                                  byte[] bin = (data[1] as Erlang.Binary).binaryValue();                                  char[] s = new char[bin.Length];                                  bin.CopyTo(s' 0);                                  return new string(s);                              }                              else                                  return data[1].ToString();                          }                      }                  }              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,decodeIO,The following statement contains a magic number: if (msg is Erlang.Tuple)              {                  Erlang.Tuple t = (Erlang.Tuple)msg;                  if (t.arity() == 4)                  {                      Erlang.Atom  ios = t[0] as Erlang.Atom;                      Erlang.Tuple data = t[3] as Erlang.Tuple;                      if (ios != null && ios.atomValue() == "io_request" && data != null)                      {                          if ((data[0] as Erlang.Atom).atomValue() == "put_chars")                          {                              if (data[1] is Erlang.String)                                  return (data[1] as Erlang.String).stringValue();                              else if (data[1] is Erlang.Binary)                              {                                  byte[] bin = (data[1] as Erlang.Binary).binaryValue();                                  char[] s = new char[bin.Length];                                  bin.CopyTo(s' 0);                                  return new string(s);                              }                              else                                  return data[1].ToString();                          }                      }                  }              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,do_send,The following statement contains a magic number: lock(this)              {                  try                  {                      if (traceLevel >= OtpTrace.Type.sendThreshold)                      {                          // Need to decode header and output buffer to show trace message!                          // First make OtpInputStream' then decode.                          try                          {                              if (traceLevel >= OtpTrace.Type.wireThreshold)                              {                                  Erlang.Object h = (header.getOtpInputStream(5)).read_any();                                  Erlang.Binary hb = header.ToBinary();                                  Erlang.Binary ob = payload.ToBinary();                                  System.Text.StringBuilder s = new System.Text.StringBuilder();                                  s.AppendFormat("-> {0} {1} (header_sz={2}' msg_sz={3})\n" +                                                 "   Header: {4}\n" +                                                 "   Msg:    {5}"' headerType(h)' h.ToString()' hb.size()' ob.size()'                                                                   hb.ToBinaryString()' ob.ToBinaryString());                                  OtpTrace.TraceEvent(s.ToString());                                  h  = null;                                  hb = null;                                  ob = null;                              }                              else                              {                                  Erlang.Object h = (header.getOtpInputStream(5)).read_any();                                  OtpTrace.TraceEvent("-> " + headerType(h) + " " + h.ToString());                                  Erlang.Object o = (payload.getOtpInputStream(0)).read_any();                                  OtpTrace.TraceEvent("   " + o.ToString());                                  h = null;                                  o = null;                              }                          }                          catch (Erlang.Exception e)                          {                              OtpTrace.TraceEvent("   " + "can't decode output buffer:" + e);                          }                      }                                            header.writeTo((System.IO.Stream) socket.GetStream());                      payload.writeTo((System.IO.Stream) socket.GetStream());                        long written = header.count() + payload.count();                      sentBytes += written;                      sentMsgs++;                      if (onReadWrite != null)                          onReadWrite(this' Operation.Write' written' sentBytes' sentMsgs);                  }                  catch (System.Exception e)                  {                      close();                      throw e;                  }              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,do_send,The following statement contains a magic number: lock(this)              {                  try                  {                      if (traceLevel >= OtpTrace.Type.sendThreshold)                      {                          // Need to decode header and output buffer to show trace message!                          // First make OtpInputStream' then decode.                          try                          {                              if (traceLevel >= OtpTrace.Type.wireThreshold)                              {                                  Erlang.Object h = (header.getOtpInputStream(5)).read_any();                                  Erlang.Binary hb = header.ToBinary();                                  Erlang.Binary ob = payload.ToBinary();                                  System.Text.StringBuilder s = new System.Text.StringBuilder();                                  s.AppendFormat("-> {0} {1} (header_sz={2}' msg_sz={3})\n" +                                                 "   Header: {4}\n" +                                                 "   Msg:    {5}"' headerType(h)' h.ToString()' hb.size()' ob.size()'                                                                   hb.ToBinaryString()' ob.ToBinaryString());                                  OtpTrace.TraceEvent(s.ToString());                                  h  = null;                                  hb = null;                                  ob = null;                              }                              else                              {                                  Erlang.Object h = (header.getOtpInputStream(5)).read_any();                                  OtpTrace.TraceEvent("-> " + headerType(h) + " " + h.ToString());                                  Erlang.Object o = (payload.getOtpInputStream(0)).read_any();                                  OtpTrace.TraceEvent("   " + o.ToString());                                  h = null;                                  o = null;                              }                          }                          catch (Erlang.Exception e)                          {                              OtpTrace.TraceEvent("   " + "can't decode output buffer:" + e);                          }                      }                                            header.writeTo((System.IO.Stream) socket.GetStream());                      payload.writeTo((System.IO.Stream) socket.GetStream());                        long written = header.count() + payload.count();                      sentBytes += written;                      sentMsgs++;                      if (onReadWrite != null)                          onReadWrite(this' Operation.Write' written' sentBytes' sentMsgs);                  }                  catch (System.Exception e)                  {                      close();                      throw e;                  }              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,do_send,The following statement contains a magic number: lock(this)              {                  try                  {                      if (traceLevel >= OtpTrace.Type.ctrlThreshold)                      {                          try                          {                              Erlang.Object h = (header.getOtpInputStream(5)).read_any();                              OtpTrace.TraceEvent("-> " + headerType(h) + " " + h);                          }                          catch (Erlang.Exception e)                          {                              OtpTrace.TraceEvent("   " + "can't decode output buffer: " + e);                          }                      }                      header.writeTo((System.IO.Stream) socket.GetStream());                  }                  catch (System.Exception e)                  {                      close();                      throw e;                  }              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,readSock,The following statement contains a magic number: if (readingPayload)              {                  receivedMsgs++;                  if (onReadWrite != null)                      onReadWrite(this' Operation.Read' got + 4 /* header len */' receivedBytes' receivedMsgs);              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,doConnect,The following statement contains a magic number: try              {                  socket = new System.Net.Sockets.TcpClient();                  socket.NoDelay = true;                  var connected = false;                  Thread thr = new Thread(                      () => {                          try                          {                              socket.Connect(peer.host()' port);                              connected = true;                          }                          catch (System.Exception)                          {                          }                      }                  ) { IsBackground = true' Name = "OtpSockConnectThread" };                    thr.Start();                    Debug.WriteLine("-> MD5 CONNECT TO " + peer.host() + ": " + port);                    var untilTime = DateTime.Now.AddMilliseconds(_connectTimeout);                    while (!connected && DateTime.Now < untilTime)                      Thread.Sleep(10);                    if (!connected) // Timeout                  {                      throw new OtpTimeoutException("Timeout waiting for connect to " + peer.host() + ':' + port);                  }                    if (traceLevel >= OtpTrace.Type.handshakeThreshold)                      OtpTrace.TraceEvent("-> MD5 CONNECT TO " + peer.host() + ":" + port);                  sendName(peer.distChoose' self.flags);                  recvStatus();                  int her_challenge = recvChallenge();                  byte[] our_digest = genDigest(her_challenge' auth_cookie);                  int our_challenge = genChallenge();                  sendChallengeReply(our_challenge' our_digest);                  recvChallengeAck(our_challenge);                  cookieOk = true;                  sendCookie = false;              }              catch (OtpAuthException ae)              {                  close();                  throw ae;              }              catch (System.Net.Sockets.SocketException e)              {                  close();                  throw new System.IO.IOException("Cannot connect to peer node: " + e.ToString());              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,hex0,The following statement contains a magic number: if (x < 0)              {                  uint_Renamed = x & 0x7F;                  uint_Renamed |= (1 << 7);              }              else              {                  uint_Renamed = (int) x;              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,hex0,The following statement contains a magic number: return "" + tab[SupportClass.URShift(uint_Renamed' 4)] + tab[uint_Renamed & 0xF];
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,genDigest,The following statement contains a magic number: if (challenge < 0)              {                  ch2 = 1L << 31;                  ch2 |= (long) (challenge & 0x7FFFFFFFL);              }              else              {                  ch2 = (long) challenge;              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendName,The following statement contains a magic number: obuf.write2BE(str.Length + 7);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendChallenge,The following statement contains a magic number: obuf.write2BE((short)str.Length + 11);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,read2BytePackage,The following statement contains a magic number: byte[] lbuf = new byte[2];
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvName,The following statement contains a magic number: try              {                  byte[] tmpbuf = read2BytePackage();                  OtpInputStream ibuf = new OtpInputStream(tmpbuf);                  byte[] tmpname;                  int len = (int) (tmpbuf.Length);                  peer.ntype = ibuf.read1();                  if (peer.ntype != AbstractNode.NTYPE_R6)                  {                      throw new System.IO.IOException("Unknown remote node type");                  }                  peer._distLow = (peer._distHigh = ibuf.read2BE());                  if (peer._distLow < 5)                  {                      throw new System.IO.IOException("Unknown remote node type");                  }                  peer.flags = ibuf.read4BE();                  tmpname = new byte[len - 7];                  ibuf.readN(tmpname);                  char[] tmpChar;                  tmpChar = new char[tmpname.Length];                  tmpname.CopyTo(tmpChar' 0);                  hisname = new System.String(tmpChar);                  // Set the old nodetype parameter to indicate hidden/normal status                  // When the old handshake is removed' the ntype should also be.                  if ((peer.flags & AbstractNode.dFlagPublished) != 0)                      peer.ntype = AbstractNode.NTYPE_R4_ERLANG;                  else                      peer.ntype = AbstractNode.NTYPE_R4_HIDDEN;                      if ((peer.flags & AbstractNode.dFlagExtendedReferences) == 0)                   {                      throw new System.IO.IOException("Handshake failed - peer cannot handle extended references");                  }                                      if (OtpSystem.useExtendedPidsPorts() && (peer.flags & AbstractNode.dFlagExtendedPidsPorts) == 0)                   if (true && (peer.flags & AbstractNode.dFlagExtendedPidsPorts) == 0)                   {                      throw new System.IO.IOException("Handshake failed - peer cannot handle extended pids and ports");                  }              }              catch (Erlang.Exception)              {                  throw new System.IO.IOException("Handshake failed - not enough data");              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvName,The following statement contains a magic number: try              {                  byte[] tmpbuf = read2BytePackage();                  OtpInputStream ibuf = new OtpInputStream(tmpbuf);                  byte[] tmpname;                  int len = (int) (tmpbuf.Length);                  peer.ntype = ibuf.read1();                  if (peer.ntype != AbstractNode.NTYPE_R6)                  {                      throw new System.IO.IOException("Unknown remote node type");                  }                  peer._distLow = (peer._distHigh = ibuf.read2BE());                  if (peer._distLow < 5)                  {                      throw new System.IO.IOException("Unknown remote node type");                  }                  peer.flags = ibuf.read4BE();                  tmpname = new byte[len - 7];                  ibuf.readN(tmpname);                  char[] tmpChar;                  tmpChar = new char[tmpname.Length];                  tmpname.CopyTo(tmpChar' 0);                  hisname = new System.String(tmpChar);                  // Set the old nodetype parameter to indicate hidden/normal status                  // When the old handshake is removed' the ntype should also be.                  if ((peer.flags & AbstractNode.dFlagPublished) != 0)                      peer.ntype = AbstractNode.NTYPE_R4_ERLANG;                  else                      peer.ntype = AbstractNode.NTYPE_R4_HIDDEN;                      if ((peer.flags & AbstractNode.dFlagExtendedReferences) == 0)                   {                      throw new System.IO.IOException("Handshake failed - peer cannot handle extended references");                  }                                      if (OtpSystem.useExtendedPidsPorts() && (peer.flags & AbstractNode.dFlagExtendedPidsPorts) == 0)                   if (true && (peer.flags & AbstractNode.dFlagExtendedPidsPorts) == 0)                   {                      throw new System.IO.IOException("Handshake failed - peer cannot handle extended pids and ports");                  }              }              catch (Erlang.Exception)              {                  throw new System.IO.IOException("Handshake failed - not enough data");              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvChallenge,The following statement contains a magic number: try              {                  byte[] buf = read2BytePackage();                  OtpInputStream ibuf = new OtpInputStream(buf);                  peer.ntype = ibuf.read1();                  if (peer.ntype != AbstractNode.NTYPE_R6)                  {                      throw new System.IO.IOException("Unexpected peer type");                  }                  peer._distLow = (peer._distHigh = ibuf.read2BE());                  peer.flags = ibuf.read4BE();                  challenge = ibuf.read4BE();                  byte[] tmpname = new byte[buf.Length - 11];                  ibuf.readN(tmpname);                  char[] tmpChar;                  tmpChar = new char[tmpname.Length];                  tmpname.CopyTo(tmpChar' 0);                  System.String hisname = new System.String(tmpChar);                  int i = hisname.IndexOf((System.Char) '@'' 0);                  peer._node = hisname;                  peer._alive = hisname.Substring(0' (i) - (0));                  peer._host = hisname.Substring(i + 1' (hisname.Length) - (i + 1));              }              catch (Erlang.Exception)              {                  throw new System.IO.IOException("Handshake failed - not enough data");              }
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendChallengeReply,The following statement contains a magic number: obuf.write2BE(21);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,digests_equals,The following statement contains a magic number: for (i = 0; i < 16; ++i)                  if (a[i] != b[i])                      return false;
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvChallengeReply,The following statement contains a magic number: byte[] her_digest = new byte[16];
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,sendChallengeAck,The following statement contains a magic number: obuf.write2BE(17);
Magic Number,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,recvChallengeAck,The following statement contains a magic number: byte[] her_digest = new byte[16];
Magic Number,Otp,AbstractNode,C:\repos\saleyn_otp.net\Otp\AbstractNode.cs,node,The following statement contains a magic number: if (_shortName)              {                  int i = _node.IndexOf('@');                  i = i < 0 ? 0 : i + 1;                  try                  {                      System.Net.IPAddress.Parse(_node.Substring(i));                      return _node;                  }                  catch (System.Exception)                  {                      int j = _node.IndexOf((System.Char)'.'' i);                      return (j < 0) ? _node : _node.Substring(0' i + j - 2);                  }              }              else              {                  return _node;              }
Magic Number,Otp,Links,C:\repos\saleyn_otp.net\Otp\Links.cs,addLink,The following statement contains a magic number: lock(this)  			{  				int i;  				  				if ((i = find(local' remote)) == - 1)  				{  					if (_count >= _links.Length)  					{  						Link[] tmp = new Link[_count * 2];  						Array.Copy(_links' 0' tmp' 0' _count);  						_links = tmp;  					}  					_links[_count++] = new Link(local' remote);  				}  			}
Magic Number,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The following statement contains a magic number: this.links = new Links(25);
Magic Number,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The following statement contains a magic number: this.monitors = new System.Collections.Hashtable(49' (float)0.95);
Magic Number,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The following statement contains a magic number: this.monitors = new System.Collections.Hashtable(49' (float)0.95);
Magic Number,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The following statement contains a magic number: this.links = new Links(25);
Magic Number,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The following statement contains a magic number: this.monitors = new System.Collections.Hashtable(49' (float)0.95);
Magic Number,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,OtpCookedConnection,The following statement contains a magic number: this.monitors = new System.Collections.Hashtable(49' (float)0.95);
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_lookupPort,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new System.Net.Sockets.TcpClient(node.host()' epmdPort);  				  				// build and send epmd request  				// length[2]' tag[1]' alivename[n] (length = n+1)  				obuf.write2BE(node.getAlive().Length + 1);  				obuf.write1(port3req);  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> LOOKUP (r3) " + node);  				  				// receive and decode reply  				byte[] tmpbuf = new byte[100];    				s.GetStream().Read(tmpbuf' 0' 100);  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				port = ibuf.read2BE();  			}  			catch (System.IO.IOException)  			{  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (no response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());  			}  			catch (Erlang.Exception)  			{  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (invalid response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());  			}  			finally  			{  				try  				{  					if (s != null)  						s.Close();  				}  				catch (System.IO.IOException)  				{  					/*ignore close errors */  				}  				s = null;  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_lookupPort,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new System.Net.Sockets.TcpClient(node.host()' epmdPort);  				  				// build and send epmd request  				// length[2]' tag[1]' alivename[n] (length = n+1)  				obuf.write2BE(node.getAlive().Length + 1);  				obuf.write1(port3req);  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> LOOKUP (r3) " + node);  				  				// receive and decode reply  				byte[] tmpbuf = new byte[100];    				s.GetStream().Read(tmpbuf' 0' 100);  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				port = ibuf.read2BE();  			}  			catch (System.IO.IOException)  			{  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (no response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());  			}  			catch (Erlang.Exception)  			{  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (invalid response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());  			}  			finally  			{  				try  				{  					if (s != null)  						s.Close();  				}  				catch (System.IO.IOException)  				{  					/*ignore close errors */  				}  				s = null;  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_lookupPort,The following statement contains a magic number: try              {                  OtpOutputStream obuf = new OtpOutputStream();                  s = new System.Net.Sockets.TcpClient(node.host()' epmdPort);                    // build and send epmd request                  // length[2]' tag[1]' alivename[n] (length = n+1)                  obuf.write2BE(node.getAlive().Length + 1);                  obuf.write1(port4req);                  //UPGRADE_NOTE: This code will be optimized in the future;                  byte[] tmpBytes;                  int i;                  string tmpStr;                  tmpStr = node.getAlive();                  tmpBytes = new byte[tmpStr.Length];                  i = 0;                  while (i < tmpStr.Length)                  {                      tmpBytes[i] = (byte)tmpStr[i];                      i++;                  }                  obuf.writeN(tmpBytes);                    // send request                  obuf.writeTo((System.IO.Stream)s.GetStream());                    if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("-> LOOKUP (r4) " + node);                    // receive and decode reply                  // resptag[1]' result[1]' port[2]' ntype[1]' proto[1]'                  // disthigh[2]' distlow[2]' nlen[2]' alivename[n]'                  // elen[2]' edata[m]                  byte[] tmpbuf = new byte[100];                    int n = s.GetStream().Read(tmpbuf' 0' 100);                    if (n < 0)                  {                      // this was an r3 node => not a failure (yet)                      if (s != null)                          s.Close();                      throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());                  }                    OtpInputStream ibuf = new OtpInputStream(tmpbuf);                    int response = ibuf.read1();                  if (response == port4resp)                  {                      int result = ibuf.read1();                      if (result == 0)                      {                          port = ibuf.read2BE();                            node.ntype = ibuf.read1();                          node._proto = ibuf.read1();                          node._distHigh = ibuf.read2BE();                          node._distLow = ibuf.read2BE();                          // ignore rest of fields                      }                  }              }              catch (System.IO.IOException)              {                  if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("<- (no response)");                  throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());              }              catch (Erlang.Exception)              {                  if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("<- (invalid response)");                  throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());              }              catch (System.Net.Sockets.SocketException)              {                  if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("<- (no epmd response)");                  throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());              }  			finally  			{  				try  				{  					if (s != null)  						s.Close();  				}  				catch (System.IO.IOException)  				{  					/*ignore close errors */  				}  				s = null;  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_lookupPort,The following statement contains a magic number: try              {                  OtpOutputStream obuf = new OtpOutputStream();                  s = new System.Net.Sockets.TcpClient(node.host()' epmdPort);                    // build and send epmd request                  // length[2]' tag[1]' alivename[n] (length = n+1)                  obuf.write2BE(node.getAlive().Length + 1);                  obuf.write1(port4req);                  //UPGRADE_NOTE: This code will be optimized in the future;                  byte[] tmpBytes;                  int i;                  string tmpStr;                  tmpStr = node.getAlive();                  tmpBytes = new byte[tmpStr.Length];                  i = 0;                  while (i < tmpStr.Length)                  {                      tmpBytes[i] = (byte)tmpStr[i];                      i++;                  }                  obuf.writeN(tmpBytes);                    // send request                  obuf.writeTo((System.IO.Stream)s.GetStream());                    if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("-> LOOKUP (r4) " + node);                    // receive and decode reply                  // resptag[1]' result[1]' port[2]' ntype[1]' proto[1]'                  // disthigh[2]' distlow[2]' nlen[2]' alivename[n]'                  // elen[2]' edata[m]                  byte[] tmpbuf = new byte[100];                    int n = s.GetStream().Read(tmpbuf' 0' 100);                    if (n < 0)                  {                      // this was an r3 node => not a failure (yet)                      if (s != null)                          s.Close();                      throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());                  }                    OtpInputStream ibuf = new OtpInputStream(tmpbuf);                    int response = ibuf.read1();                  if (response == port4resp)                  {                      int result = ibuf.read1();                      if (result == 0)                      {                          port = ibuf.read2BE();                            node.ntype = ibuf.read1();                          node._proto = ibuf.read1();                          node._distHigh = ibuf.read2BE();                          node._distLow = ibuf.read2BE();                          // ignore rest of fields                      }                  }              }              catch (System.IO.IOException)              {                  if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("<- (no response)");                  throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());              }              catch (Erlang.Exception)              {                  if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("<- (invalid response)");                  throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());              }              catch (System.Net.Sockets.SocketException)              {                  if (traceLevel >= traceThreshold)                      OtpTrace.TraceEvent("<- (no epmd response)");                  throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when looking up " + node.getAlive());              }  			finally  			{  				try  				{  					if (s != null)  						s.Close();  				}  				catch (System.IO.IOException)  				{  					/*ignore close errors */  				}  				s = null;  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_publish,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new System.Net.Sockets.TcpClient(System.Net.Dns.GetHostName()' epmdPort);  				  				obuf.write2BE(node.getAlive().Length + 3);  				  				obuf.write1(publish3req);  				obuf.write2BE(node.port());  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> PUBLISH (r3) " + node + " port=" + node.port());  				  				byte[] tmpbuf = new byte[100];    				int n = s.GetStream().Read(tmpbuf' 0' 100);  				  				if (n < 0)  				{  					if (s != null)  						s.Close();  					if (traceLevel >= traceThreshold)  						OtpTrace.TraceEvent("<- (no response)");  					return null;  				}  				  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				if (ibuf.read1() == publish3ok)  				{  					node._creation = ibuf.read2BE();  					if (traceLevel >= traceThreshold)  						OtpTrace.TraceEvent("<- OK");  					return s; // success - don't close socket  				}  			}  			catch (System.IO.IOException)  			{  				// epmd closed the connection = fail  				if (s != null)  					s.Close();  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (no response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  			}  			catch (Erlang.Exception)  			{  				if (s != null)  					s.Close();  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (invalid response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_publish,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new System.Net.Sockets.TcpClient(System.Net.Dns.GetHostName()' epmdPort);  				  				obuf.write2BE(node.getAlive().Length + 3);  				  				obuf.write1(publish3req);  				obuf.write2BE(node.port());  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> PUBLISH (r3) " + node + " port=" + node.port());  				  				byte[] tmpbuf = new byte[100];    				int n = s.GetStream().Read(tmpbuf' 0' 100);  				  				if (n < 0)  				{  					if (s != null)  						s.Close();  					if (traceLevel >= traceThreshold)  						OtpTrace.TraceEvent("<- (no response)");  					return null;  				}  				  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				if (ibuf.read1() == publish3ok)  				{  					node._creation = ibuf.read2BE();  					if (traceLevel >= traceThreshold)  						OtpTrace.TraceEvent("<- OK");  					return s; // success - don't close socket  				}  			}  			catch (System.IO.IOException)  			{  				// epmd closed the connection = fail  				if (s != null)  					s.Close();  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (no response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  			}  			catch (Erlang.Exception)  			{  				if (s != null)  					s.Close();  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (invalid response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r3_publish,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new System.Net.Sockets.TcpClient(System.Net.Dns.GetHostName()' epmdPort);  				  				obuf.write2BE(node.getAlive().Length + 3);  				  				obuf.write1(publish3req);  				obuf.write2BE(node.port());  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> PUBLISH (r3) " + node + " port=" + node.port());  				  				byte[] tmpbuf = new byte[100];    				int n = s.GetStream().Read(tmpbuf' 0' 100);  				  				if (n < 0)  				{  					if (s != null)  						s.Close();  					if (traceLevel >= traceThreshold)  						OtpTrace.TraceEvent("<- (no response)");  					return null;  				}  				  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				if (ibuf.read1() == publish3ok)  				{  					node._creation = ibuf.read2BE();  					if (traceLevel >= traceThreshold)  						OtpTrace.TraceEvent("<- OK");  					return s; // success - don't close socket  				}  			}  			catch (System.IO.IOException)  			{  				// epmd closed the connection = fail  				if (s != null)  					s.Close();  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (no response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  			}  			catch (Erlang.Exception)  			{  				if (s != null)  					s.Close();  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("<- (invalid response)");  				throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  			}
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_publish,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new TcpClient(System.Net.Dns.GetHostName()' epmdPort);  				  				obuf.write2BE(node.getAlive().Length + 13);  				  				obuf.write1(publish4req);  				obuf.write2BE(node.port());  				  				obuf.write1(node.type());  				  				obuf.write1(node.proto());  				obuf.write2BE(node.distHigh());  				obuf.write2BE(node.distLow());  				  				obuf.write2BE(node.getAlive().Length);  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				obuf.write2BE(0); // No extra  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> PUBLISH (r4) " + node + " port=" + node.port());  				  				// get reply  				byte[] tmpbuf = new byte[100];  				int n = s.GetStream().Read(tmpbuf' 0' 100);  				  				if (n < 0)  				{  					// this was an r3 node => not a failure (yet)  					if (s != null)  						s.Close();  					throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  				}  				  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				int response = ibuf.read1();  				if (response == publish4resp)  				{  					int result = ibuf.read1();  					if (result == 0)  					{  						node._creation = ibuf.read2BE();  						if (traceLevel >= traceThreshold)  							OtpTrace.TraceEvent("<- OK");  						return s; // success  					}  				}  			}              catch (System.IO.IOException e)              {                  error = e;              }              catch (Erlang.Exception e)              {                  error = e;              }              catch (System.Net.Sockets.SocketException e)              {                  error = e;              }
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_publish,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new TcpClient(System.Net.Dns.GetHostName()' epmdPort);  				  				obuf.write2BE(node.getAlive().Length + 13);  				  				obuf.write1(publish4req);  				obuf.write2BE(node.port());  				  				obuf.write1(node.type());  				  				obuf.write1(node.proto());  				obuf.write2BE(node.distHigh());  				obuf.write2BE(node.distLow());  				  				obuf.write2BE(node.getAlive().Length);  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				obuf.write2BE(0); // No extra  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> PUBLISH (r4) " + node + " port=" + node.port());  				  				// get reply  				byte[] tmpbuf = new byte[100];  				int n = s.GetStream().Read(tmpbuf' 0' 100);  				  				if (n < 0)  				{  					// this was an r3 node => not a failure (yet)  					if (s != null)  						s.Close();  					throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  				}  				  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				int response = ibuf.read1();  				if (response == publish4resp)  				{  					int result = ibuf.read1();  					if (result == 0)  					{  						node._creation = ibuf.read2BE();  						if (traceLevel >= traceThreshold)  							OtpTrace.TraceEvent("<- OK");  						return s; // success  					}  				}  			}              catch (System.IO.IOException e)              {                  error = e;              }              catch (Erlang.Exception e)              {                  error = e;              }              catch (System.Net.Sockets.SocketException e)              {                  error = e;              }
Magic Number,Otp,OtpEpmd,C:\repos\saleyn_otp.net\Otp\OtpEpmd.cs,r4_publish,The following statement contains a magic number: try  			{  				OtpOutputStream obuf = new OtpOutputStream();  				s = new TcpClient(System.Net.Dns.GetHostName()' epmdPort);  				  				obuf.write2BE(node.getAlive().Length + 13);  				  				obuf.write1(publish4req);  				obuf.write2BE(node.port());  				  				obuf.write1(node.type());  				  				obuf.write1(node.proto());  				obuf.write2BE(node.distHigh());  				obuf.write2BE(node.distLow());  				  				obuf.write2BE(node.getAlive().Length);  				//UPGRADE_NOTE: This code will be optimized in the future;  				byte[] tmpBytes;  				int i;  				string tmpStr;  				tmpStr = node.getAlive();  				tmpBytes = new byte[tmpStr.Length];  				i = 0;  				while (i < tmpStr.Length)  				{  					tmpBytes[i] = (byte) tmpStr[i];  					i++;  				}  				obuf.writeN(tmpBytes);  				obuf.write2BE(0); // No extra  				  				// send request  				obuf.writeTo((System.IO.Stream) s.GetStream());  				  				if (traceLevel >= traceThreshold)  					OtpTrace.TraceEvent("-> PUBLISH (r4) " + node + " port=" + node.port());  				  				// get reply  				byte[] tmpbuf = new byte[100];  				int n = s.GetStream().Read(tmpbuf' 0' 100);  				  				if (n < 0)  				{  					// this was an r3 node => not a failure (yet)  					if (s != null)  						s.Close();  					throw new System.IO.IOException("Nameserver not responding on " + node.host() + " when publishing " + node.getAlive());  				}  				  				OtpInputStream ibuf = new OtpInputStream(tmpbuf);  				  				int response = ibuf.read1();  				if (response == publish4resp)  				{  					int result = ibuf.read1();  					if (result == 0)  					{  						node._creation = ibuf.read2BE();  						if (traceLevel >= traceThreshold)  							OtpTrace.TraceEvent("<- OK");  						return s; // success  					}  				}  			}              catch (System.IO.IOException e)              {                  error = e;              }              catch (Erlang.Exception e)              {                  error = e;              }              catch (System.Net.Sockets.SocketException e)              {                  error = e;              }
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,OtpInputStream,The following statement contains a magic number: m_buf2 = new byte[2];
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,OtpInputStream,The following statement contains a magic number: m_buf4 = new byte[4];
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,OtpInputStream,The following statement contains a magic number: m_buf8 = new byte[8];
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,peek,The following statement contains a magic number: try              {                  i = base.ReadByte();                  base.Seek(-1' System.IO.SeekOrigin.Current);                  if (i < 0)                      i += 256;                    return i;              }              catch (System.Exception)              {                  throw new Erlang.Exception("Cannot read from input stream");              }
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read2BE,The following statement contains a magic number: return ((((int)m_buf2[0] << 8) & 0xff00) + (((int)m_buf2[1]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The following statement contains a magic number: System.Diagnostics.Debug.Assert(b.Length == 4);
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The following statement contains a magic number: return (int)((((int)b[0] << 24) & 0xff000000) + (((int)b[1] << 16) & 0xff0000) + (((int)b[2] << 8) & 0xff00) + (((int)b[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The following statement contains a magic number: return (int)((((int)b[0] << 24) & 0xff000000) + (((int)b[1] << 16) & 0xff0000) + (((int)b[2] << 8) & 0xff00) + (((int)b[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The following statement contains a magic number: return (int)((((int)b[0] << 24) & 0xff000000) + (((int)b[1] << 16) & 0xff0000) + (((int)b[2] << 8) & 0xff00) + (((int)b[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The following statement contains a magic number: return (int)((((int)b[0] << 24) & 0xff000000) + (((int)b[1] << 16) & 0xff0000) + (((int)b[2] << 8) & 0xff00) + (((int)b[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4BE,The following statement contains a magic number: return (int)((((int)b[0] << 24) & 0xff000000) + (((int)b[1] << 16) & 0xff0000) + (((int)b[2] << 8) & 0xff00) + (((int)b[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i1 = (System.UInt64)((((int)m_buf8[0] << 24) & 0xff000000)                               + (((int)m_buf8[1] << 16) & 0xff0000)                               + (((int)m_buf8[2] << 8) & 0xff00)                               + (((int)m_buf8[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i1 = (System.UInt64)((((int)m_buf8[0] << 24) & 0xff000000)                               + (((int)m_buf8[1] << 16) & 0xff0000)                               + (((int)m_buf8[2] << 8) & 0xff00)                               + (((int)m_buf8[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i1 = (System.UInt64)((((int)m_buf8[0] << 24) & 0xff000000)                               + (((int)m_buf8[1] << 16) & 0xff0000)                               + (((int)m_buf8[2] << 8) & 0xff00)                               + (((int)m_buf8[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i1 = (System.UInt64)((((int)m_buf8[0] << 24) & 0xff000000)                               + (((int)m_buf8[1] << 16) & 0xff0000)                               + (((int)m_buf8[2] << 8) & 0xff00)                               + (((int)m_buf8[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i1 = (System.UInt64)((((int)m_buf8[0] << 24) & 0xff000000)                               + (((int)m_buf8[1] << 16) & 0xff0000)                               + (((int)m_buf8[2] << 8) & 0xff00)                               + (((int)m_buf8[3]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read8BE,The following statement contains a magic number: System.UInt64 i2 = (i1 << 32) & 0xffffffff00000000                               + (System.UInt64)((((int)m_buf8[4] << 24) & 0xff000000)                               + (((int)m_buf8[5] << 16) & 0xff0000)                               + (((int)m_buf8[6] << 8) & 0xff00)                               + (((int)m_buf8[7]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read2LE,The following statement contains a magic number: return ((((int)m_buf2[1] << 8) & 0xff00) + (((int)m_buf2[0]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4LE,The following statement contains a magic number: return (int)((((int)m_buf4[3] << 24) & 0xff000000) + (((int)m_buf4[2] << 16) & 0xff0000)                  + (((int)m_buf4[1] << 8) & 0xff00) + (((int)m_buf4[0]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4LE,The following statement contains a magic number: return (int)((((int)m_buf4[3] << 24) & 0xff000000) + (((int)m_buf4[2] << 16) & 0xff0000)                  + (((int)m_buf4[1] << 8) & 0xff00) + (((int)m_buf4[0]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4LE,The following statement contains a magic number: return (int)((((int)m_buf4[3] << 24) & 0xff000000) + (((int)m_buf4[2] << 16) & 0xff0000)                  + (((int)m_buf4[1] << 8) & 0xff00) + (((int)m_buf4[0]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4LE,The following statement contains a magic number: return (int)((((int)m_buf4[3] << 24) & 0xff000000) + (((int)m_buf4[2] << 16) & 0xff0000)                  + (((int)m_buf4[1] << 8) & 0xff00) + (((int)m_buf4[0]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read4LE,The following statement contains a magic number: return (int)((((int)m_buf4[3] << 24) & 0xff000000) + (((int)m_buf4[2] << 16) & 0xff0000)                  + (((int)m_buf4[1] << 8) & 0xff00) + (((int)m_buf4[0]) & 0xff));
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read_float,The following statement contains a magic number: if (System.Math.Abs(d - f) >= 1.0E-20)                  throw new Erlang.Exception("Value cannot be represented as float: " + d);
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,getFloatOrDouble,The following statement contains a magic number: if (tag == OtpExternal.floatTag)              {                  // get the string                  strbuf = new byte[31];                  this.readN(strbuf);                    char[] tmpChar = new char[strbuf.Length];                  strbuf.CopyTo(tmpChar' 0);                  System.String str = new System.String(tmpChar);                  //System.Diagnostics.Debug.WriteLine("getFloatOrDouble: str = " + str);                    try                  {                      // Easier than the java version.                      parsedValue = System.Double.Parse(str);                      return parsedValue;                  }                  catch                  {                      throw new Erlang.Exception("Error parsing float format: '" + str + "'");                  }              }              else if (tag == OtpExternal.newFloatTag)              {                  this.readN(m_buf8);                  // IEEE 754 decoder                  if (BitConverter.IsLittleEndian)                  {                      Array.Reverse(m_buf8);                  }                  return BitConverter.ToDouble(m_buf8' 0);              }              else              {                  throw new Erlang.Exception("Wrong tag encountered' expected " + OtpExternal.floatTag + "' got " + tag);              }
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read_long,The following statement contains a magic number: switch (tag)              {                  case OtpExternal.smallIntTag:                      val = this.read1();                      break;                  case OtpExternal.intTag:                      val = this.read4BE();                      break;                  case OtpExternal.smallBigTag:                      {                          arity = this.read1();                          sign = this.read1();                            byte[] nb = new byte[arity];                          if (arity != this.readN(nb))                          {                              throw new Erlang.Exception("Cannot read from input stream. Expected smallBigTag arity " + arity);                          }                          if (arity > 8)                              throw new Erlang.Exception("Value too large for long type (arity=" + arity + ")");                            val = 0;                          for (int i = 0; i < arity; i++)                          {                              val |= (long)nb[i] << (i * 8);                          }                            val = (sign == 0 ? val : -val); // should deal with overflow                            if (sign == 1 && !signed)                              throw new Erlang.Exception("Requested unsigned' but read signed long value: " + val.ToString());                            break;                      }                  case OtpExternal.largeBigTag:                  default:                      throw new Erlang.Exception("Not valid integer tag: " + tag);              }
Magic Number,Otp,OtpInputStream,C:\repos\saleyn_otp.net\Otp\OtpInputStream.cs,read_long,The following statement contains a magic number: switch (tag)              {                  case OtpExternal.smallIntTag:                      val = this.read1();                      break;                  case OtpExternal.intTag:                      val = this.read4BE();                      break;                  case OtpExternal.smallBigTag:                      {                          arity = this.read1();                          sign = this.read1();                            byte[] nb = new byte[arity];                          if (arity != this.readN(nb))                          {                              throw new Erlang.Exception("Cannot read from input stream. Expected smallBigTag arity " + arity);                          }                          if (arity > 8)                              throw new Erlang.Exception("Value too large for long type (arity=" + arity + ")");                            val = 0;                          for (int i = 0; i < arity; i++)                          {                              val |= (long)nb[i] << (i * 8);                          }                            val = (sign == 0 ? val : -val); // should deal with overflow                            if (sign == 1 && !signed)                              throw new Erlang.Exception("Requested unsigned' but read signed long value: " + val.ToString());                            break;                      }                  case OtpExternal.largeBigTag:                  default:                      throw new Erlang.Exception("Not valid integer tag: " + tag);              }
Magic Number,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,init,The following statement contains a magic number: refId = new int[3];
Magic Number,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,init,The following statement contains a magic number: refId[2] = 0;
Magic Number,Otp,OtpLocalNode,C:\repos\saleyn_otp.net\Otp\OtpLocalNode.cs,createRef,The following statement contains a magic number: lock(this)  			{  				Erlang.Ref r = new Erlang.Ref(_node' refId' _creation);  				  				// increment ref ids (3 ints: 18 + 32 + 32 bits)  				refId[0]++;  				if (refId[0] > 0x3ffff)  				{  					refId[0] = 0;  					  					refId[1]++;  					if (refId[1] == 0)  					{  						refId[2]++;  					}  				}  				  				return r;  			}
Magic Number,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,OtpMbox,The following statement contains a magic number: this.links = new Links(10);
Magic Number,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,OtpMbox,The following statement contains a magic number: this.monitors = new System.Collections.Hashtable(49' (float)0.95);
Magic Number,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,OtpMbox,The following statement contains a magic number: this.monitors = new System.Collections.Hashtable(49' (float)0.95);
Magic Number,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,exit,The following statement contains a magic number: exit(2' to' reason);
Magic Number,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,exit,The following statement contains a magic number: try  			{  				System.String node = to.node();  				if (node.Equals(home.node()))  				{  					home.deliver(new OtpMsg(OtpMsg.Tag.exitTag' _self' to' reason));  				}  				else  				{  					OtpCookedConnection conn = home.connection(node);  					if (conn == null)  						return ;  					switch (arity)  					{  						case 1:   							conn.exit(_self' to' reason);  							break;  						  						case 2:   							conn.exit2(_self' to' reason);  							break;  						  					}  				}  			}  			catch (System.Exception)  			{  			}
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,init,The following statement contains a magic number: lock(this)  			{  				if (!initDone)  				{  					connections = new System.Collections.Hashtable(17' (float) 0.95);  					mboxes = new Mailboxes(this);                      if (acceptConnections)  					    acceptor = new Acceptor(this' port);                      listenPort = port;  					initDone = true;  				}  			}
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,init,The following statement contains a magic number: lock(this)  			{  				if (!initDone)  				{  					connections = new System.Collections.Hashtable(17' (float) 0.95);  					mboxes = new Mailboxes(this);                      if (acceptConnections)  					    acceptor = new Acceptor(this' port);                      listenPort = port;  					initDone = true;  				}  			}
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,getPingTuple,The following statement contains a magic number: Erlang.Object[] ping = new Erlang.Object[3];
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,getPingTuple,The following statement contains a magic number: Erlang.Object[] pid = new Erlang.Object[2];
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,getPingTuple,The following statement contains a magic number: Erlang.Object[] _node = new Erlang.Object[2];
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,getPingTuple,The following statement contains a magic number: ping[2] = new Erlang.Tuple(_node);
Magic Number,Otp,OtpNode,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,netKernel,The following statement contains a magic number: try  			{  				Erlang.Tuple t = (Erlang.Tuple) (m.getMsg());  				Erlang.Tuple req = (Erlang.Tuple) t.elementAt(1); // actual request  				  				Erlang.Pid pid = (Erlang.Pid) req.elementAt(0); // originating pid  				  				Erlang.Object[] pong = new Erlang.Object[2];  				pong[0] = req.elementAt(1); // his #Ref  				pong[1] = new Erlang.Atom("yes");  				  				mbox = createMbox();  				mbox.send(pid' new Erlang.Tuple(pong));  				return true;  			}  			catch (System.Exception)  			{  			}  			finally  			{  				closeMbox(mbox);  			}
Magic Number,Otp,Mailboxes,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,Mailboxes,The following statement contains a magic number: byPid = new System.Collections.Hashtable(17' (float) 0.95);
Magic Number,Otp,Mailboxes,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,Mailboxes,The following statement contains a magic number: byPid = new System.Collections.Hashtable(17' (float) 0.95);
Magic Number,Otp,Mailboxes,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,Mailboxes,The following statement contains a magic number: byName = new System.Collections.Hashtable(17' (float) 0.95);
Magic Number,Otp,Mailboxes,C:\repos\saleyn_otp.net\Otp\OtpNode.cs,Mailboxes,The following statement contains a magic number: byName = new System.Collections.Hashtable(17' (float) 0.95);
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,OtpOutputStream,The following statement contains a magic number: poke4BE(0' this._count - 4);
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write2BE,The following statement contains a magic number: write((byte) ((n & 0xff00) >> 8));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write4BE,The following statement contains a magic number: write((byte) ((n & 0xff000000) >> 24));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write4BE,The following statement contains a magic number: write((byte) ((n & 0xff0000) >> 16));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write4BE,The following statement contains a magic number: write((byte) ((n & 0xff00) >> 8));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write2LE,The following statement contains a magic number: write((byte) ((n & 0xff00) >> 8));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write4LE,The following statement contains a magic number: write((byte) ((n & 0xff00) >> 8));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write4LE,The following statement contains a magic number: write((byte) ((n & 0xff0000) >> 16));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write4LE,The following statement contains a magic number: write((byte) ((n & 0xff000000) >> 24));
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,poke4BE,The following statement contains a magic number: if (offset < _count)              {                  buf[offset + 0] = ((byte) ((n & 0xff000000) >> 24));                  buf[offset + 1] = ((byte) ((n & 0xff0000) >> 16));                  buf[offset + 2] = ((byte) ((n & 0xff00) >> 8));                  buf[offset + 3] = ((byte) (n & 0xff));              }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,poke4BE,The following statement contains a magic number: if (offset < _count)              {                  buf[offset + 0] = ((byte) ((n & 0xff000000) >> 24));                  buf[offset + 1] = ((byte) ((n & 0xff0000) >> 16));                  buf[offset + 2] = ((byte) ((n & 0xff00) >> 8));                  buf[offset + 3] = ((byte) (n & 0xff));              }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,poke4BE,The following statement contains a magic number: if (offset < _count)              {                  buf[offset + 0] = ((byte) ((n & 0xff000000) >> 24));                  buf[offset + 1] = ((byte) ((n & 0xff0000) >> 16));                  buf[offset + 2] = ((byte) ((n & 0xff00) >> 8));                  buf[offset + 3] = ((byte) (n & 0xff));              }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,poke4BE,The following statement contains a magic number: if (offset < _count)              {                  buf[offset + 0] = ((byte) ((n & 0xff000000) >> 24));                  buf[offset + 1] = ((byte) ((n & 0xff0000) >> 16));                  buf[offset + 2] = ((byte) ((n & 0xff00) >> 8));                  buf[offset + 3] = ((byte) (n & 0xff));              }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,poke4BE,The following statement contains a magic number: if (offset < _count)              {                  buf[offset + 0] = ((byte) ((n & 0xff000000) >> 24));                  buf[offset + 1] = ((byte) ((n & 0xff0000) >> 16));                  buf[offset + 2] = ((byte) ((n & 0xff00) >> 8));                  buf[offset + 3] = ((byte) (n & 0xff));              }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,encode_size,The following statement contains a magic number: if (o is Erlang.Atom) return 1 + 2 + o.atomValue().Length;              else if (o is Erlang.Boolean) return 1 + 2 + (o.boolValue()                                                        ? Erlang.Boolean.s_true.atomValue().Length                                                        : Erlang.Boolean.s_false.atomValue().Length);              else if (o is Erlang.Binary) return 5 + o.binaryValue().Length;              else if (o is Erlang.Long)              {                  long l = o.longValue();                  if ((l & 0xff) == l) return 2;                  else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin)) return 5;                  return long_arity(l);              }              else if (o is Erlang.Byte) return 1 + 1;              else if (o is Erlang.Double) return 9;              else if (o is Erlang.String)              {                  string l = o.stringValue();                  if (l.Length == 0) return 1;                  if (l.Length < 0xffff) return 2 + l.Length;                  return 1 + 4 + 2 * l.Length;                }              else if (o is Erlang.List)              {                  Erlang.List l = o.listValue();                  if (l.arity() == 0)                      return 1;                  int sz = 5;                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Tuple)              {                  Erlang.Tuple l = o.tupleValue();                  int sz = 1 + (l.arity() < 0xff ? 1 : 4);                  for (int i = 0; i < l.arity(); i++)                      sz += encode_size(l[i]);                  return sz;              }              else if (o is Erlang.Pid)              {                  Erlang.Pid p = o.pidValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 4 + 1;              }              else if (o is Erlang.Ref)              {                  Erlang.Ref p = o.refValue();                  int[] ids = p.ids();                  return 1 + (1 + 2 + p.node().Length) + 1 + 4 * ids.Length;              }              else if (o is Erlang.Port)              {                  Erlang.Port p = o.portValue();                  return 1 + (1 + 2 + p.node().Length) + 4 + 1;              }              else                  throw new Erlang.Exception("Unknown encode size for object: " + o.ToString());
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write_long,The following statement contains a magic number: if ((l & 0xff) == l)              {                  // will fit in one byte                  this.write1(OtpExternal.smallIntTag);                  this.write1(l);              }              else if ((l <= OtpExternal.erlMax) && (l >= OtpExternal.erlMin))              {                  this.write1(OtpExternal.intTag);                  this.write4BE(l);              }              else              {                  int  neg = isNegative ? 1 : 0;                  ulong v  = (ulong)(isNegative ? -l : l);                  byte arity = 0;                  this.write1(OtpExternal.smallBigTag);                  int arity_pos = _count;                  this.write1(0);  // Fill in later                  this.write1(neg); // sign                  while (v != 0) {                      this.write1((byte)(v & 0xff));  // write lowest byte                      v >>= 8;                // shift unsigned                      arity++;                  }                  buf[arity_pos] = arity;              }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,long_arity,The following statement contains a magic number: int sz = 3;
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,long_arity,The following statement contains a magic number: while (v != 0) { sz++; v >>= 8; }
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write_ref,The following statement contains a magic number: if (arity > 3)                  arity = 3;
Magic Number,Otp,OtpOutputStream,C:\repos\saleyn_otp.net\Otp\OtpOutputStream.cs,write_ref,The following statement contains a magic number: if (arity > 3)                  arity = 3;
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,OtpSystem,C:\repos\saleyn_otp.net\Otp\OtpSystem.cs,useExtendedPidsPorts,The following statement contains a magic number: try              {                  switch (Convert.ToInt32(rel))                  {                      case 1:                      case 2:                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                      case 8:                      case 9:                          xpidsports = false;                          break;                      case 0:                      default:                          break;                  }              }              //catch (NumberFormatException e)              catch (Exception)              {                  /* Ignore ... */              }
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: ok = node.ping(remote' 1000);
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: try  			{  				mbox = node.createMbox();    				Erlang.Object[] rpc = new Erlang.Object[2];  				Erlang.Object[] call = new Erlang.Object[5];    				call[0] = new Erlang.Atom("call");  				call[1] = new Erlang.Atom("lists");  				call[2] = new Erlang.Atom("reverse");  				call[3] = new Erlang.List(new Erlang.List("Hello Erlang world!"));  				call[4] = mbox.self();    				rpc[0] = mbox.self();  				rpc[1] = new Erlang.Tuple(call);    				Erlang.Tuple rpcTuple = new Erlang.Tuple(rpc);  				OtpTrace.TraceEvent("=> "+rpcTuple.ToString());    				mbox.send("rex"' remote' rpcTuple);  				Erlang.Object reply = mbox.receive(1000);    				OtpTrace.TraceEvent("<= "+reply.ToString());  			}  			catch (System.Exception)  			{  			}  			finally  			{  				node.closeMbox(mbox);  			}
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: try  			{  				mbox = node.createMbox();    				Erlang.Object[] rpc = new Erlang.Object[2];  				Erlang.Object[] call = new Erlang.Object[5];    				call[0] = new Erlang.Atom("call");  				call[1] = new Erlang.Atom("lists");  				call[2] = new Erlang.Atom("reverse");  				call[3] = new Erlang.List(new Erlang.List("Hello Erlang world!"));  				call[4] = mbox.self();    				rpc[0] = mbox.self();  				rpc[1] = new Erlang.Tuple(call);    				Erlang.Tuple rpcTuple = new Erlang.Tuple(rpc);  				OtpTrace.TraceEvent("=> "+rpcTuple.ToString());    				mbox.send("rex"' remote' rpcTuple);  				Erlang.Object reply = mbox.receive(1000);    				OtpTrace.TraceEvent("<= "+reply.ToString());  			}  			catch (System.Exception)  			{  			}  			finally  			{  				node.closeMbox(mbox);  			}
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: try  			{  				mbox = node.createMbox();    				Erlang.Object[] rpc = new Erlang.Object[2];  				Erlang.Object[] call = new Erlang.Object[5];    				call[0] = new Erlang.Atom("call");  				call[1] = new Erlang.Atom("lists");  				call[2] = new Erlang.Atom("reverse");  				call[3] = new Erlang.List(new Erlang.List("Hello Erlang world!"));  				call[4] = mbox.self();    				rpc[0] = mbox.self();  				rpc[1] = new Erlang.Tuple(call);    				Erlang.Tuple rpcTuple = new Erlang.Tuple(rpc);  				OtpTrace.TraceEvent("=> "+rpcTuple.ToString());    				mbox.send("rex"' remote' rpcTuple);  				Erlang.Object reply = mbox.receive(1000);    				OtpTrace.TraceEvent("<= "+reply.ToString());  			}  			catch (System.Exception)  			{  			}  			finally  			{  				node.closeMbox(mbox);  			}
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: try  			{  				mbox = node.createMbox();    				Erlang.Object[] rpc = new Erlang.Object[2];  				Erlang.Object[] call = new Erlang.Object[5];    				call[0] = new Erlang.Atom("call");  				call[1] = new Erlang.Atom("lists");  				call[2] = new Erlang.Atom("reverse");  				call[3] = new Erlang.List(new Erlang.List("Hello Erlang world!"));  				call[4] = mbox.self();    				rpc[0] = mbox.self();  				rpc[1] = new Erlang.Tuple(call);    				Erlang.Tuple rpcTuple = new Erlang.Tuple(rpc);  				OtpTrace.TraceEvent("=> "+rpcTuple.ToString());    				mbox.send("rex"' remote' rpcTuple);  				Erlang.Object reply = mbox.receive(1000);    				OtpTrace.TraceEvent("<= "+reply.ToString());  			}  			catch (System.Exception)  			{  			}  			finally  			{  				node.closeMbox(mbox);  			}
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: try  			{  				mbox = node.createMbox();    				Erlang.Object[] rpc = new Erlang.Object[2];  				Erlang.Object[] call = new Erlang.Object[5];    				call[0] = new Erlang.Atom("call");  				call[1] = new Erlang.Atom("lists");  				call[2] = new Erlang.Atom("reverse");  				call[3] = new Erlang.List(new Erlang.List("Hello Erlang world!"));  				call[4] = mbox.self();    				rpc[0] = mbox.self();  				rpc[1] = new Erlang.Tuple(call);    				Erlang.Tuple rpcTuple = new Erlang.Tuple(rpc);  				OtpTrace.TraceEvent("=> "+rpcTuple.ToString());    				mbox.send("rex"' remote' rpcTuple);  				Erlang.Object reply = mbox.receive(1000);    				OtpTrace.TraceEvent("<= "+reply.ToString());  			}  			catch (System.Exception)  			{  			}  			finally  			{  				node.closeMbox(mbox);  			}
Magic Number,Otp,Test,C:\repos\saleyn_otp.net\Otp\Test.cs,Main,The following statement contains a magic number: try  			{  				mbox = node.createMbox();    				Erlang.Object[] rpc = new Erlang.Object[2];  				Erlang.Object[] call = new Erlang.Object[5];    				call[0] = new Erlang.Atom("call");  				call[1] = new Erlang.Atom("lists");  				call[2] = new Erlang.Atom("reverse");  				call[3] = new Erlang.List(new Erlang.List("Hello Erlang world!"));  				call[4] = mbox.self();    				rpc[0] = mbox.self();  				rpc[1] = new Erlang.Tuple(call);    				Erlang.Tuple rpcTuple = new Erlang.Tuple(rpc);  				OtpTrace.TraceEvent("=> "+rpcTuple.ToString());    				mbox.send("rex"' remote' rpcTuple);  				Erlang.Object reply = mbox.receive(1000);    				OtpTrace.TraceEvent("<= "+reply.ToString());  			}  			catch (System.Exception)  			{  			}  			finally  			{  				node.closeMbox(mbox);  			}
Magic Number,Otp.Erlang,Atom,C:\repos\saleyn_otp.net\Otp\Erlang\Atom.cs,escapeSpecialChars,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				c = s[i];  				  				  				/*note that some of these escape sequences are unique to  				* Erlang' which is why the corresponding 'case' values use  				* octal. The resulting string is' of course' in Erlang format.  				*/  				  				switch (c)  				{  					case '\b':   						so.Append("\\b");  						break;    					case (char) (127):  						so.Append("\\d");  						break;    					case (char) (27):  						so.Append("\\e");  						break;    					case '\f':  						so.Append("\\f");  						break;    					case '\n':  						so.Append("\\n");  						break;    					case '\r':  						so.Append("\\r");  						break;    					case '\t':  						so.Append("\\t");  						break;    					case (char) (11):  						so.Append("\\v");  						break;    					case '\\':  						so.Append("\\\\");  						break;    					case '\'':  						so.Append("\\'");  						break;    					case '\"':  						so.Append("\\\"");  						break;    					default:  						// some other character classes  						if (c < 23)  						{  							// control chars show as "\^@"' "\^A" etc  							so.Append("\\^" + (char) (('A' - 1) + c));  						}  						else if (c > 126)  						{  							// 8-bit chars show as \345 \344 \366 etc  							so.Append("\\" + System.Convert.ToString(c' 8));  						}  						else  						{  							// character is printable without modification!  							so.Append(c);  						}  						break;    				}  			}
Magic Number,Otp.Erlang,Atom,C:\repos\saleyn_otp.net\Otp\Erlang\Atom.cs,escapeSpecialChars,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				c = s[i];  				  				  				/*note that some of these escape sequences are unique to  				* Erlang' which is why the corresponding 'case' values use  				* octal. The resulting string is' of course' in Erlang format.  				*/  				  				switch (c)  				{  					case '\b':   						so.Append("\\b");  						break;    					case (char) (127):  						so.Append("\\d");  						break;    					case (char) (27):  						so.Append("\\e");  						break;    					case '\f':  						so.Append("\\f");  						break;    					case '\n':  						so.Append("\\n");  						break;    					case '\r':  						so.Append("\\r");  						break;    					case '\t':  						so.Append("\\t");  						break;    					case (char) (11):  						so.Append("\\v");  						break;    					case '\\':  						so.Append("\\\\");  						break;    					case '\'':  						so.Append("\\'");  						break;    					case '\"':  						so.Append("\\\"");  						break;    					default:  						// some other character classes  						if (c < 23)  						{  							// control chars show as "\^@"' "\^A" etc  							so.Append("\\^" + (char) (('A' - 1) + c));  						}  						else if (c > 126)  						{  							// 8-bit chars show as \345 \344 \366 etc  							so.Append("\\" + System.Convert.ToString(c' 8));  						}  						else  						{  							// character is printable without modification!  							so.Append(c);  						}  						break;    				}  			}
Magic Number,Otp.Erlang,Atom,C:\repos\saleyn_otp.net\Otp\Erlang\Atom.cs,escapeSpecialChars,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				c = s[i];  				  				  				/*note that some of these escape sequences are unique to  				* Erlang' which is why the corresponding 'case' values use  				* octal. The resulting string is' of course' in Erlang format.  				*/  				  				switch (c)  				{  					case '\b':   						so.Append("\\b");  						break;    					case (char) (127):  						so.Append("\\d");  						break;    					case (char) (27):  						so.Append("\\e");  						break;    					case '\f':  						so.Append("\\f");  						break;    					case '\n':  						so.Append("\\n");  						break;    					case '\r':  						so.Append("\\r");  						break;    					case '\t':  						so.Append("\\t");  						break;    					case (char) (11):  						so.Append("\\v");  						break;    					case '\\':  						so.Append("\\\\");  						break;    					case '\'':  						so.Append("\\'");  						break;    					case '\"':  						so.Append("\\\"");  						break;    					default:  						// some other character classes  						if (c < 23)  						{  							// control chars show as "\^@"' "\^A" etc  							so.Append("\\^" + (char) (('A' - 1) + c));  						}  						else if (c > 126)  						{  							// 8-bit chars show as \345 \344 \366 etc  							so.Append("\\" + System.Convert.ToString(c' 8));  						}  						else  						{  							// character is printable without modification!  							so.Append(c);  						}  						break;    				}  			}
Magic Number,Otp.Erlang,Atom,C:\repos\saleyn_otp.net\Otp\Erlang\Atom.cs,escapeSpecialChars,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				c = s[i];  				  				  				/*note that some of these escape sequences are unique to  				* Erlang' which is why the corresponding 'case' values use  				* octal. The resulting string is' of course' in Erlang format.  				*/  				  				switch (c)  				{  					case '\b':   						so.Append("\\b");  						break;    					case (char) (127):  						so.Append("\\d");  						break;    					case (char) (27):  						so.Append("\\e");  						break;    					case '\f':  						so.Append("\\f");  						break;    					case '\n':  						so.Append("\\n");  						break;    					case '\r':  						so.Append("\\r");  						break;    					case '\t':  						so.Append("\\t");  						break;    					case (char) (11):  						so.Append("\\v");  						break;    					case '\\':  						so.Append("\\\\");  						break;    					case '\'':  						so.Append("\\'");  						break;    					case '\"':  						so.Append("\\\"");  						break;    					default:  						// some other character classes  						if (c < 23)  						{  							// control chars show as "\^@"' "\^A" etc  							so.Append("\\^" + (char) (('A' - 1) + c));  						}  						else if (c > 126)  						{  							// 8-bit chars show as \345 \344 \366 etc  							so.Append("\\" + System.Convert.ToString(c' 8));  						}  						else  						{  							// character is printable without modification!  							so.Append(c);  						}  						break;    				}  			}
Magic Number,Otp.Erlang,Atom,C:\repos\saleyn_otp.net\Otp\Erlang\Atom.cs,escapeSpecialChars,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				c = s[i];  				  				  				/*note that some of these escape sequences are unique to  				* Erlang' which is why the corresponding 'case' values use  				* octal. The resulting string is' of course' in Erlang format.  				*/  				  				switch (c)  				{  					case '\b':   						so.Append("\\b");  						break;    					case (char) (127):  						so.Append("\\d");  						break;    					case (char) (27):  						so.Append("\\e");  						break;    					case '\f':  						so.Append("\\f");  						break;    					case '\n':  						so.Append("\\n");  						break;    					case '\r':  						so.Append("\\r");  						break;    					case '\t':  						so.Append("\\t");  						break;    					case (char) (11):  						so.Append("\\v");  						break;    					case '\\':  						so.Append("\\\\");  						break;    					case '\'':  						so.Append("\\'");  						break;    					case '\"':  						so.Append("\\\"");  						break;    					default:  						// some other character classes  						if (c < 23)  						{  							// control chars show as "\^@"' "\^A" etc  							so.Append("\\^" + (char) (('A' - 1) + c));  						}  						else if (c > 126)  						{  							// 8-bit chars show as \345 \344 \366 etc  							so.Append("\\" + System.Convert.ToString(c' 8));  						}  						else  						{  							// character is printable without modification!  							so.Append(c);  						}  						break;    				}  			}
Magic Number,Otp.Erlang,Atom,C:\repos\saleyn_otp.net\Otp\Erlang\Atom.cs,escapeSpecialChars,The following statement contains a magic number: for (int i = 0; i < len; i++)  			{  				c = s[i];  				  				  				/*note that some of these escape sequences are unique to  				* Erlang' which is why the corresponding 'case' values use  				* octal. The resulting string is' of course' in Erlang format.  				*/  				  				switch (c)  				{  					case '\b':   						so.Append("\\b");  						break;    					case (char) (127):  						so.Append("\\d");  						break;    					case (char) (27):  						so.Append("\\e");  						break;    					case '\f':  						so.Append("\\f");  						break;    					case '\n':  						so.Append("\\n");  						break;    					case '\r':  						so.Append("\\r");  						break;    					case '\t':  						so.Append("\\t");  						break;    					case (char) (11):  						so.Append("\\v");  						break;    					case '\\':  						so.Append("\\\\");  						break;    					case '\'':  						so.Append("\\'");  						break;    					case '\"':  						so.Append("\\\"");  						break;    					default:  						// some other character classes  						if (c < 23)  						{  							// control chars show as "\^@"' "\^A" etc  							so.Append("\\^" + (char) (('A' - 1) + c));  						}  						else if (c > 126)  						{  							// 8-bit chars show as \345 \344 \366 etc  							so.Append("\\" + System.Convert.ToString(c' 8));  						}  						else  						{  							// character is printable without modification!  							so.Append(c);  						}  						break;    				}  			}
Magic Number,Otp.Erlang,Formatter,C:\repos\saleyn_otp.net\Otp\Erlang\Format.cs,pvariable,The following statement contains a magic number: if (fmt.Length > i + 1 && fmt[i] == ':' && fmt[i + 1] == ':')              {                  i = pos + 2;                  int tps = i;                    for (char c = fmt[i]; char.IsLetter(c) && i < fmt.Length - 1; c = fmt[++i]) ;                    if (fmt[i] == '(' && i < fmt.Length - 1 && fmt[i + 1] == ')')                  {                      pos = i + 2;                        string tp = new string(fmt' tps' i - tps);                        switch (tp)                      {                          case "int":                          case "integer":                              type = TermType.Int;                              break;                          case "str":                          case "string":                              type = TermType.String;                              break;                          case "atom":                              type = TermType.Atom;                              break;                          case "float":                          case "double":                              type = TermType.Double;                              break;                          case "binary":                              type = TermType.Binary;                              break;                          case "bool":                          case "boolean":                              type = TermType.Boolean;                              break;                          case "byte":                              type = TermType.Byte;                              break;                          case "char":                              type = TermType.Char;                              break;                          case "list":                              type = TermType.List;                              break;                          case "tuple":                              type = TermType.Tuple;                              break;                          case "pid":                              type = TermType.Pid;                              break;                          case "ref":                          case "reference":                              type = TermType.Ref;                              break;                          case "port":                              type = TermType.Port;                              break;                          default:                              throw new ArgumentException("Type '" + tps + "' is not supported!");                      }                  }                  else                      throw new ArgumentException("Invalid variable type specification: " +                          new string(fmt' start' pos - start));              }              else                  type = TermType.Object;
Magic Number,Otp.Erlang,Formatter,C:\repos\saleyn_otp.net\Otp\Erlang\Format.cs,pvariable,The following statement contains a magic number: if (fmt.Length > i + 1 && fmt[i] == ':' && fmt[i + 1] == ':')              {                  i = pos + 2;                  int tps = i;                    for (char c = fmt[i]; char.IsLetter(c) && i < fmt.Length - 1; c = fmt[++i]) ;                    if (fmt[i] == '(' && i < fmt.Length - 1 && fmt[i + 1] == ')')                  {                      pos = i + 2;                        string tp = new string(fmt' tps' i - tps);                        switch (tp)                      {                          case "int":                          case "integer":                              type = TermType.Int;                              break;                          case "str":                          case "string":                              type = TermType.String;                              break;                          case "atom":                              type = TermType.Atom;                              break;                          case "float":                          case "double":                              type = TermType.Double;                              break;                          case "binary":                              type = TermType.Binary;                              break;                          case "bool":                          case "boolean":                              type = TermType.Boolean;                              break;                          case "byte":                              type = TermType.Byte;                              break;                          case "char":                              type = TermType.Char;                              break;                          case "list":                              type = TermType.List;                              break;                          case "tuple":                              type = TermType.Tuple;                              break;                          case "pid":                              type = TermType.Pid;                              break;                          case "ref":                          case "reference":                              type = TermType.Ref;                              break;                          case "port":                              type = TermType.Port;                              break;                          default:                              throw new ArgumentException("Type '" + tps + "' is not supported!");                      }                  }                  else                      throw new ArgumentException("Invalid variable type specification: " +                          new string(fmt' start' pos - start));              }              else                  type = TermType.Object;
Magic Number,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The following statement contains a magic number: this._ids = new int[3];
Magic Number,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The following statement contains a magic number: this._ids[2] = 0;
Magic Number,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The following statement contains a magic number: if (len > 3)  				len = 3;
Magic Number,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Ref,The following statement contains a magic number: if (len > 3)  				len = 3;
Magic Number,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Equals,The following statement contains a magic number: if (this.isNewRef() && ref_Renamed.isNewRef())  			{  				return (this._ids[0] == ref_Renamed._ids[0] && this._ids[1] == ref_Renamed._ids[1] && this._ids[2] == ref_Renamed._ids[2]);  			}
Magic Number,Otp.Erlang,Ref,C:\repos\saleyn_otp.net\Otp\Erlang\Ref.cs,Equals,The following statement contains a magic number: if (this.isNewRef() && ref_Renamed.isNewRef())  			{  				return (this._ids[0] == ref_Renamed._ids[0] && this._ids[1] == ref_Renamed._ids[1] && this._ids[2] == ref_Renamed._ids[2]);  			}
Magic Number,Otp.Erlang,VarBind,C:\repos\saleyn_otp.net\Otp\Erlang\VarBind.cs,VarBind,The following statement contains a magic number: this.m_dict = new Dictionary<string' Erlang.Object>(23);
Duplicate Code,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,Start,The method contains a code clone-set at the following line numbers (starting from the method definition): ((99' 130)' (147' 178))
Missing Default,Otp,AbstractConnection,C:\repos\saleyn_otp.net\Otp\AbstractConnection.cs,headerType,The following switch statement is missing a default case: switch (tag)              {                  case OtpMsg.Tag.linkTag:                      return "LINK";                    case OtpMsg.Tag.sendTag:                      return "SEND";                    case OtpMsg.Tag.exitTag:                      return "EXIT";                    case OtpMsg.Tag.unlinkTag:                      return "UNLINK";                    case OtpMsg.Tag.nodeLinkTag:                      return "NODELINK";                    case OtpMsg.Tag.regSendTag:                      return "REG_SEND";                    case OtpMsg.Tag.groupLeaderTag:                      return "GROUP_LEADER";                    case OtpMsg.Tag.exit2Tag:                      return "EXIT2";                    case OtpMsg.Tag.sendTTTag:                      return "SEND_TT";                    case OtpMsg.Tag.exitTTTag:                      return "EXIT_TT";                    case OtpMsg.Tag.regSendTTTag:                      return "REG_SEND_TT";                    case OtpMsg.Tag.exit2TTTag:                      return "EXIT2_TT";                    case OtpMsg.Tag.monitorPTag:                      return "MONITOR_P";                    case OtpMsg.Tag.demonitorPTag:                      return "DEMONITOR_P";                    case OtpMsg.Tag.monitorPexitTag:                      return "MONITOR_P_EXIT";              }
Missing Default,Otp,OtpCookedConnection,C:\repos\saleyn_otp.net\Otp\OtpCookedConnection.cs,deliver,The following switch statement is missing a default case: switch (msg.type())  			{  				case OtpMsg.Tag.linkTag:  					if (delivered)  					{  						links.addLink(msg.getRecipientPid()' msg.getSenderPid());  					}  					else  						try  						{  							// no such pid - send exit to sender  							base.sendExit(msg.getRecipientPid()' msg.getSenderPid()' "noproc");  						}  						catch (System.IO.IOException)  						{  						}  					break;                    case OtpMsg.Tag.monitorPTag:                      if (delivered)                          monitors[msg.getSenderPid()] = msg.getMsg();                      else                          try                          {                              base.sendExit(msg.getRecipientPid()' msg.getSenderPid()' "noproc");                          }                          catch (System.IO.IOException)                          {                          }                      break;                    case OtpMsg.Tag.demonitorPTag:                  case OtpMsg.Tag.monitorPexitTag:                      monitors.Remove(msg.getSenderPid());                      break;                    case OtpMsg.Tag.unlinkTag:                  case OtpMsg.Tag.exitTag:  					links.removeLink(msg.getRecipientPid()' msg.getSenderPid());  					break;                    case OtpMsg.Tag.exit2Tag:  					break;  			}
Missing Default,Otp,OtpMbox,C:\repos\saleyn_otp.net\Otp\OtpMbox.cs,exit,The following switch statement is missing a default case: switch (arity)  					{  						case 1:   							conn.exit(_self' to' reason);  							break;  						  						case 2:   							conn.exit2(_self' to' reason);  							break;  						  					}
