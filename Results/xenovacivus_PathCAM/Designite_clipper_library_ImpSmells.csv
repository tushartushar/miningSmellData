Implementation smell,Namespace,Class,File,Method,Description
Long Method,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessBound,The method has 108 lines of code.
Long Method,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The method has 149 lines of code.
Long Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,The method has 208 lines of code.
Long Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessHorizontal,The method has 114 lines of code.
Long Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,JoinPoints,The method has 147 lines of code.
Long Method,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The method has 162 lines of code.
Complex Method,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,FindNextLocMin,Cyclomatic complexity of the method is 8
Complex Method,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessBound,Cyclomatic complexity of the method is 20
Complex Method,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,Cyclomatic complexity of the method is 28
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ExecuteInternal,Cyclomatic complexity of the method is 8
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,InsertLocalMinimaIntoAEL,Cyclomatic complexity of the method is 15
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AppendPolygon,Cyclomatic complexity of the method is 8
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,Cyclomatic complexity of the method is 12
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessHorizontal,Cyclomatic complexity of the method is 18
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,BuildIntersectList,Cyclomatic complexity of the method is 10
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessEdgesAtTopOfScanbeam,Cyclomatic complexity of the method is 9
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,JoinHorz,Cyclomatic complexity of the method is 11
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,PointInPolygon,Cyclomatic complexity of the method is 8
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,JoinCommonEdges,Cyclomatic complexity of the method is 13
Complex Method,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,CleanPolygon,Cyclomatic complexity of the method is 8
Complex Method,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,Cyclomatic complexity of the method is 10
Complex Method,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,Cyclomatic complexity of the method is 16
Long Parameter List,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,SlopesEqual,The method has 5 parameters. Parameters: pt1' pt2' pt3' pt4' UseFullRange
Long Parameter List,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,GetOverlap,The method has 6 parameters. Parameters: a1' a2' b1' b2' Left' Right
Long Parameter List,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,JoinHorz,The method has 6 parameters. Parameters: op1' op1b' op2' op2b' Pt' DiscardLeft
Long Parameter List,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,OffsetPaths,The method has 5 parameters. Parameters: polys' delta' jointype' endtype' MiterLimit
Complex Conditional,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,RangeTest,The conditional expression  "Pt.X > hiRange || Pt.Y > hiRange || -Pt.X > hiRange || -Pt.Y > hiRange"  is complex.
Complex Conditional,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,RangeTest,The conditional expression  "Pt.X > loRange || Pt.Y > loRange || -Pt.X > loRange || -Pt.Y > loRange"  is complex.
Complex Conditional,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The conditional expression  "(Closed && highI < 2) || (!Closed && highI < 1)"  is complex.
Complex Conditional,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The conditional expression  "Closed &&              SlopesEqual(E.Prev.Curr' E.Curr' E.Next.Curr' m_UseFullRange) &&               (!PreserveCollinear ||              !Pt2IsBetweenPt1AndPt3(E.Prev.Curr' E.Curr' E.Next.Curr))"  is complex.
Complex Conditional,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The conditional expression  "(!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next))"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "Op1 != null && IsHorizontal(rb) &&               m_GhostJoins.Count > 0 && rb.WindDelta != 0"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "lb.OutIdx >= 0 && lb.PrevInAEL != null &&              lb.PrevInAEL.Curr.X == lb.Bot.X &&              lb.PrevInAEL.OutIdx >= 0 &&              SlopesEqual(lb.PrevInAEL' lb' m_UseFullRange) &&              lb.WindDelta != 0 && lb.PrevInAEL.WindDelta != 0"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,InsertLocalMinimaIntoAEL,The conditional expression  "rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&                SlopesEqual(rb.PrevInAEL' rb' m_UseFullRange) &&                rb.WindDelta != 0 && rb.PrevInAEL.WindDelta != 0"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddLocalMinPoly,The conditional expression  "prevE != null && prevE.OutIdx >= 0 &&              (TopX(prevE' pt.Y) == TopX(e' pt.Y)) &&              SlopesEqual(e' prevE' m_UseFullRange) &&              (e.WindDelta != 0) && (prevE.WindDelta != 0)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,The conditional expression  "e1stops || e2stops ||                   (e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||                  (e1.PolyTyp != e2.PolyTyp && m_ClipType != ClipType.ctXor)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,The conditional expression  "(e1Wc == 0 || e1Wc == 1) &&                 (e2Wc == 0 || e2Wc == 1) && !e1stops && !e2stops"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,The conditional expression  "((e1.PolyTyp == PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||                                ((e1.PolyTyp == PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,The conditional expression  "(e1stops != e2stops) &&              ((e1stops && (e1.OutIdx >= 0)) || (e2stops && (e2.OutIdx >= 0)))"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessHorizontal,The conditional expression  "(dir == Direction.dLeftToRight && e.Curr.X <= horzRight) ||                (dir == Direction.dRightToLeft && e.Curr.X >= horzLeft)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessHorizontal,The conditional expression  "(dir == Direction.dLeftToRight && e.Curr.X >= horzRight) ||                (dir == Direction.dRightToLeft && e.Curr.X <= horzLeft)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessHorizontal,The conditional expression  "ePrev != null && ePrev.Curr.X == horzEdge.Bot.X &&                ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta != 0 &&                (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&                SlopesEqual(horzEdge' ePrev' m_UseFullRange))"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessHorizontal,The conditional expression  "eNext != null && eNext.Curr.X == horzEdge.Bot.X &&                eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta != 0 &&                eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&                SlopesEqual(horzEdge' eNext' m_UseFullRange)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,GetMaximaPair,The conditional expression  "result != null && (result.OutIdx == Skip ||            (result.NextInAEL == result.PrevInAEL && !IsHorizontal(result)))"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "(e.OutIdx >= 0) && (e.WindDelta != 0) && ePrev != null &&                  (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&                  (ePrev.WindDelta != 0)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "ePrev != null && ePrev.Curr.X == e.Bot.X &&                ePrev.Curr.Y == e.Bot.Y && op != null &&                ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&                SlopesEqual(e' ePrev' m_UseFullRange) &&                (e.WindDelta != 0) && (ePrev.WindDelta != 0)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ProcessEdgesAtTopOfScanbeam,The conditional expression  "eNext != null && eNext.Curr.X == e.Bot.X &&                eNext.Curr.Y == e.Bot.Y && op != null &&                eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&                SlopesEqual(e' eNext' m_UseFullRange) &&                (e.WindDelta != 0) && (eNext.WindDelta != 0)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,BuildResult2,The conditional expression  "(outRec.IsOpen && cnt < 2) ||                   (!outRec.IsOpen && cnt < 3)"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,FixupOutPolygon,The conditional expression  "(pp.Pt == pp.Next.Pt) || (pp.Pt == pp.Prev.Pt) ||                  (SlopesEqual(pp.Prev.Pt' pp.Pt' pp.Next.Pt' m_UseFullRange) &&                  (!PreserveCollinear || !Pt2IsBetweenPt1AndPt3(pp.Prev.Pt' pp.Pt' pp.Next.Pt)))"  is complex.
Complex Conditional,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,JoinPoints,The conditional expression  "(op1b == op1) || (op2b == op2) || (op1b == op2b) ||              ((outRec1 == outRec2) && (Reverse1 == Reverse2))"  is complex.
Complex Conditional,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The conditional expression  "(endType == EndType.etClosedPolygon && j < 2) ||          (endType != EndType.etClosedPolygon && j < 0)"  is complex.
Complex Conditional,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The conditional expression  "len == 0 || (delta <= 0 && (len < 3 ||             node.m_endtype != EndType.etClosedPolygon))"  is complex.
Magic Number,ClipperLib,Int128,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Int128Mul,The following statement contains a magic number: UInt64 int1Hi = (UInt64)lhs >> 32;
Magic Number,ClipperLib,Int128,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Int128Mul,The following statement contains a magic number: UInt64 int2Hi = (UInt64)rhs >> 32;
Magic Number,ClipperLib,Int128,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Int128Mul,The following statement contains a magic number: hi = (Int64)(a + (c >> 32));
Magic Number,ClipperLib,Int128,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Int128Mul,The following statement contains a magic number: unchecked { lo = (c << 32) + b; }
Magic Number,ClipperLib,Int128,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,ToDouble,The following statement contains a magic number: const double shift64 = 18446744073709551616.0;
Magic Number,ClipperLib,ClipperBase,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The following statement contains a magic number: if ((Closed && highI < 2) || (!Closed && highI < 1)) return false;
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,BuildResult,The following statement contains a magic number: for (int i = 0; i < m_PolyOuts.Count; i++)            {                OutRec outRec = m_PolyOuts[i];                if (outRec.Pts == null) continue;                OutPt p = outRec.Pts.Prev;                int cnt = PointCount(p);                if (cnt < 2) continue;                Path pg = new Path(cnt);                for (int j = 0; j < cnt; j++)                {                    pg.Add(p.Pt);                    p = p.Prev;                }                polyg.Add(pg);            }
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,BuildResult2,The following statement contains a magic number: for (int i = 0; i < m_PolyOuts.Count; i++)            {                OutRec outRec = m_PolyOuts[i];                int cnt = PointCount(outRec.Pts);                if ((outRec.IsOpen && cnt < 2) ||                   (!outRec.IsOpen && cnt < 3)) continue;                FixHoleLinkage(outRec);                PolyNode pn = new PolyNode();                polytree.m_AllPolys.Add(pn);                outRec.PolyNode = pn;                pn.m_polygon.Capacity = cnt;                OutPt op = outRec.Pts.Prev;                for (int j = 0; j < cnt; j++)                {                    pn.m_polygon.Add(op.Pt);                    op = op.Prev;                }            }
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,BuildResult2,The following statement contains a magic number: for (int i = 0; i < m_PolyOuts.Count; i++)            {                OutRec outRec = m_PolyOuts[i];                int cnt = PointCount(outRec.Pts);                if ((outRec.IsOpen && cnt < 2) ||                   (!outRec.IsOpen && cnt < 3)) continue;                FixHoleLinkage(outRec);                PolyNode pn = new PolyNode();                polytree.m_AllPolys.Add(pn);                outRec.PolyNode = pn;                pn.m_polygon.Capacity = cnt;                OutPt op = outRec.Pts.Prev;                for (int j = 0; j < cnt; j++)                {                    pn.m_polygon.Add(op.Pt);                    op = op.Prev;                }            }
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Area,The following statement contains a magic number: if (cnt < 3) return 0;
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Area,The following statement contains a magic number: return -a * 0.5;
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Area,The following statement contains a magic number: return a * 0.5;
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,CleanPolygon,The following statement contains a magic number: while (op.Idx == 0 && op.Next != op.Prev)          {            if (PointsAreClose(op.Pt' op.Prev.Pt' distSqrd))            {              op = ExcludeOp(op);              cnt--;            }            else if (PointsAreClose(op.Prev.Pt' op.Next.Pt' distSqrd))            {              ExcludeOp(op.Next);              op = ExcludeOp(op);              cnt -= 2;            }            else if (SlopesNearCollinear(op.Prev.Pt' op.Pt' op.Next.Pt' distSqrd))            {              op = ExcludeOp(op);              cnt--;            }            else            {              op.Idx = 1;              op = op.Next;            }          }
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,CleanPolygon,The following statement contains a magic number: if (cnt < 3) cnt = 0;
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Minkowski,The following statement contains a magic number: for (int i = 0; i <= pathCnt - 2 + delta; i++)            for (int j = 0; j <= polyCnt - 1; j++)            {              Path quad = new Path(4);              quad.Add(result[i % pathCnt][j % polyCnt]);              quad.Add(result[(i + 1) % pathCnt][j % polyCnt]);              quad.Add(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);              quad.Add(result[i % pathCnt][(j + 1) % polyCnt]);              if (!Orientation(quad)) quad.Reverse();              quads.Add(quad);            }
Magic Number,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Minkowski,The following statement contains a magic number: for (int i = 0; i <= pathCnt - 2 + delta; i++)            for (int j = 0; j <= polyCnt - 1; j++)            {              Path quad = new Path(4);              quad.Add(result[i % pathCnt][j % polyCnt]);              quad.Add(result[(i + 1) % pathCnt][j % polyCnt]);              quad.Add(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);              quad.Add(result[i % pathCnt][(j + 1) % polyCnt]);              if (!Orientation(quad)) quad.Reverse();              quads.Add(quad);            }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Round,The following statement contains a magic number: return value < 0 ? (cInt)(value - 0.5) : (cInt)(value + 0.5);
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,AddPath,The following statement contains a magic number: if ((endType == EndType.etClosedPolygon && j < 2) ||          (endType != EndType.etClosedPolygon && j < 0)) return;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: if (MiterLimit > 2) m_miterLim = 2 / (MiterLimit * MiterLimit);        else m_miterLim = 0.5;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: if (MiterLimit > 2) m_miterLim = 2 / (MiterLimit * MiterLimit);        else m_miterLim = 0.5;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: if (MiterLimit > 2) m_miterLim = 2 / (MiterLimit * MiterLimit);        else m_miterLim = 0.5;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: m_destPolys.Capacity = m_polyNodes.ChildCount * 2;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)        {          PolyNode node = m_polyNodes.Childs[i];          m_srcPoly = node.m_polygon;            int len = m_srcPoly.Count;            if (len == 0 || (delta <= 0 && (len < 3 ||             node.m_endtype != EndType.etClosedPolygon)))              continue;            m_destPoly = new Path();            if (len == 1)          {            if (node.m_jointype == JoinType.jtRound)            {              double X = 1.0' Y = 0.0;              for (int j = 1; j <= steps; j++)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                double X2 = X;                X = X * m_cos - m_sin * Y;                Y = X2 * m_sin + Y * m_cos;              }            }            else            {              double X = -1.0' Y = -1.0;              for (int j = 0; j < 4; ++j)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                if (X < 0) X = 1;                else if (Y < 0) Y = 1;                else X = -1;              }            }            m_destPolys.Add(m_destPoly);            continue;          }            //build m_normals ...          m_normals.Clear();          m_normals.Capacity = len;          for (int j = 0; j < len - 1; j++)            m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));          if (node.m_endtype == EndType.etClosedLine ||             node.m_endtype == EndType.etClosedPolygon)            m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));          else            m_normals.Add(new DoublePoint(m_normals[len - 2]));            if (node.m_endtype == EndType.etClosedPolygon)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else if (node.m_endtype == EndType.etClosedLine)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);            m_destPoly = new Path();            //re-build m_normals ...            DoublePoint n = m_normals[len - 1];            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);            m_normals[0] = new DoublePoint(-n.X' -n.Y);            k = 0;            for (int j = len - 1; j >= 0; j--)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else          {            int k = 0;            for (int j = 1; j < len - 1; ++j)              OffsetPoint(j' ref k' node.m_jointype);              IntPoint pt1;            if (node.m_endtype == EndType.etOpenButt)            {              int j = len - 1;              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));              m_destPoly.Add(pt1);            }            else            {              int j = len - 1;              k = len - 2;              m_sinA = 0;              m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(j' k);              else                DoRound(j' k);            }              //re-build m_normals ...            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);              m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);              k = len - 1;            for (int j = k - 1; j > 0; --j)              OffsetPoint(j' ref k' node.m_jointype);              if (node.m_endtype == EndType.etOpenButt)            {              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));              m_destPoly.Add(pt1);            }            else            {              k = 1;              m_sinA = 0;              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(0' 1);              else                DoRound(0' 1);            }            m_destPolys.Add(m_destPoly);          }        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)        {          PolyNode node = m_polyNodes.Childs[i];          m_srcPoly = node.m_polygon;            int len = m_srcPoly.Count;            if (len == 0 || (delta <= 0 && (len < 3 ||             node.m_endtype != EndType.etClosedPolygon)))              continue;            m_destPoly = new Path();            if (len == 1)          {            if (node.m_jointype == JoinType.jtRound)            {              double X = 1.0' Y = 0.0;              for (int j = 1; j <= steps; j++)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                double X2 = X;                X = X * m_cos - m_sin * Y;                Y = X2 * m_sin + Y * m_cos;              }            }            else            {              double X = -1.0' Y = -1.0;              for (int j = 0; j < 4; ++j)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                if (X < 0) X = 1;                else if (Y < 0) Y = 1;                else X = -1;              }            }            m_destPolys.Add(m_destPoly);            continue;          }            //build m_normals ...          m_normals.Clear();          m_normals.Capacity = len;          for (int j = 0; j < len - 1; j++)            m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));          if (node.m_endtype == EndType.etClosedLine ||             node.m_endtype == EndType.etClosedPolygon)            m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));          else            m_normals.Add(new DoublePoint(m_normals[len - 2]));            if (node.m_endtype == EndType.etClosedPolygon)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else if (node.m_endtype == EndType.etClosedLine)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);            m_destPoly = new Path();            //re-build m_normals ...            DoublePoint n = m_normals[len - 1];            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);            m_normals[0] = new DoublePoint(-n.X' -n.Y);            k = 0;            for (int j = len - 1; j >= 0; j--)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else          {            int k = 0;            for (int j = 1; j < len - 1; ++j)              OffsetPoint(j' ref k' node.m_jointype);              IntPoint pt1;            if (node.m_endtype == EndType.etOpenButt)            {              int j = len - 1;              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));              m_destPoly.Add(pt1);            }            else            {              int j = len - 1;              k = len - 2;              m_sinA = 0;              m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(j' k);              else                DoRound(j' k);            }              //re-build m_normals ...            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);              m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);              k = len - 1;            for (int j = k - 1; j > 0; --j)              OffsetPoint(j' ref k' node.m_jointype);              if (node.m_endtype == EndType.etOpenButt)            {              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));              m_destPoly.Add(pt1);            }            else            {              k = 1;              m_sinA = 0;              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(0' 1);              else                DoRound(0' 1);            }            m_destPolys.Add(m_destPoly);          }        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)        {          PolyNode node = m_polyNodes.Childs[i];          m_srcPoly = node.m_polygon;            int len = m_srcPoly.Count;            if (len == 0 || (delta <= 0 && (len < 3 ||             node.m_endtype != EndType.etClosedPolygon)))              continue;            m_destPoly = new Path();            if (len == 1)          {            if (node.m_jointype == JoinType.jtRound)            {              double X = 1.0' Y = 0.0;              for (int j = 1; j <= steps; j++)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                double X2 = X;                X = X * m_cos - m_sin * Y;                Y = X2 * m_sin + Y * m_cos;              }            }            else            {              double X = -1.0' Y = -1.0;              for (int j = 0; j < 4; ++j)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                if (X < 0) X = 1;                else if (Y < 0) Y = 1;                else X = -1;              }            }            m_destPolys.Add(m_destPoly);            continue;          }            //build m_normals ...          m_normals.Clear();          m_normals.Capacity = len;          for (int j = 0; j < len - 1; j++)            m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));          if (node.m_endtype == EndType.etClosedLine ||             node.m_endtype == EndType.etClosedPolygon)            m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));          else            m_normals.Add(new DoublePoint(m_normals[len - 2]));            if (node.m_endtype == EndType.etClosedPolygon)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else if (node.m_endtype == EndType.etClosedLine)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);            m_destPoly = new Path();            //re-build m_normals ...            DoublePoint n = m_normals[len - 1];            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);            m_normals[0] = new DoublePoint(-n.X' -n.Y);            k = 0;            for (int j = len - 1; j >= 0; j--)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else          {            int k = 0;            for (int j = 1; j < len - 1; ++j)              OffsetPoint(j' ref k' node.m_jointype);              IntPoint pt1;            if (node.m_endtype == EndType.etOpenButt)            {              int j = len - 1;              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));              m_destPoly.Add(pt1);            }            else            {              int j = len - 1;              k = len - 2;              m_sinA = 0;              m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(j' k);              else                DoRound(j' k);            }              //re-build m_normals ...            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);              m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);              k = len - 1;            for (int j = k - 1; j > 0; --j)              OffsetPoint(j' ref k' node.m_jointype);              if (node.m_endtype == EndType.etOpenButt)            {              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));              m_destPoly.Add(pt1);            }            else            {              k = 1;              m_sinA = 0;              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(0' 1);              else                DoRound(0' 1);            }            m_destPolys.Add(m_destPoly);          }        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoOffset,The following statement contains a magic number: for (int i = 0; i < m_polyNodes.ChildCount; i++)        {          PolyNode node = m_polyNodes.Childs[i];          m_srcPoly = node.m_polygon;            int len = m_srcPoly.Count;            if (len == 0 || (delta <= 0 && (len < 3 ||             node.m_endtype != EndType.etClosedPolygon)))              continue;            m_destPoly = new Path();            if (len == 1)          {            if (node.m_jointype == JoinType.jtRound)            {              double X = 1.0' Y = 0.0;              for (int j = 1; j <= steps; j++)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                double X2 = X;                X = X * m_cos - m_sin * Y;                Y = X2 * m_sin + Y * m_cos;              }            }            else            {              double X = -1.0' Y = -1.0;              for (int j = 0; j < 4; ++j)              {                m_destPoly.Add(new IntPoint(                  Round(m_srcPoly[0].X + X * delta)'                  Round(m_srcPoly[0].Y + Y * delta)));                if (X < 0) X = 1;                else if (Y < 0) Y = 1;                else X = -1;              }            }            m_destPolys.Add(m_destPoly);            continue;          }            //build m_normals ...          m_normals.Clear();          m_normals.Capacity = len;          for (int j = 0; j < len - 1; j++)            m_normals.Add(GetUnitNormal(m_srcPoly[j]' m_srcPoly[j + 1]));          if (node.m_endtype == EndType.etClosedLine ||             node.m_endtype == EndType.etClosedPolygon)            m_normals.Add(GetUnitNormal(m_srcPoly[len - 1]' m_srcPoly[0]));          else            m_normals.Add(new DoublePoint(m_normals[len - 2]));            if (node.m_endtype == EndType.etClosedPolygon)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else if (node.m_endtype == EndType.etClosedLine)          {            int k = len - 1;            for (int j = 0; j < len; j++)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);            m_destPoly = new Path();            //re-build m_normals ...            DoublePoint n = m_normals[len - 1];            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);            m_normals[0] = new DoublePoint(-n.X' -n.Y);            k = 0;            for (int j = len - 1; j >= 0; j--)              OffsetPoint(j' ref k' node.m_jointype);            m_destPolys.Add(m_destPoly);          }          else          {            int k = 0;            for (int j = 1; j < len - 1; ++j)              OffsetPoint(j' ref k' node.m_jointype);              IntPoint pt1;            if (node.m_endtype == EndType.etOpenButt)            {              int j = len - 1;              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X + m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y + m_normals[j].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[j].X - m_normals[j].X *                delta)' (cInt)Round(m_srcPoly[j].Y - m_normals[j].Y * delta));              m_destPoly.Add(pt1);            }            else            {              int j = len - 1;              k = len - 2;              m_sinA = 0;              m_normals[j] = new DoublePoint(-m_normals[j].X' -m_normals[j].Y);              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(j' k);              else                DoRound(j' k);            }              //re-build m_normals ...            for (int j = len - 1; j > 0; j--)              m_normals[j] = new DoublePoint(-m_normals[j - 1].X' -m_normals[j - 1].Y);              m_normals[0] = new DoublePoint(-m_normals[1].X' -m_normals[1].Y);              k = len - 1;            for (int j = k - 1; j > 0; --j)              OffsetPoint(j' ref k' node.m_jointype);              if (node.m_endtype == EndType.etOpenButt)            {              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X - m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y - m_normals[0].Y * delta));              m_destPoly.Add(pt1);              pt1 = new IntPoint((cInt)Round(m_srcPoly[0].X + m_normals[0].X * delta)'                (cInt)Round(m_srcPoly[0].Y + m_normals[0].Y * delta));              m_destPoly.Add(pt1);            }            else            {              k = 1;              m_sinA = 0;              if (node.m_endtype == EndType.etOpenSquare)                DoSquare(0' 1);              else                DoRound(0' 1);            }            m_destPolys.Add(m_destPoly);          }        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          if (solution.Count > 0) solution.RemoveAt(0);        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,Execute,The following statement contains a magic number: if (delta > 0)        {          clpr.Execute(ClipType.ctUnion' solution'            PolyFillType.pftPositive' PolyFillType.pftPositive);        }        else        {          IntRect r = Clipper.GetBounds(m_destPolys);          Path outer = new Path(4);            outer.Add(new IntPoint(r.left - 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.bottom + 10));          outer.Add(new IntPoint(r.right + 10' r.top - 10));          outer.Add(new IntPoint(r.left - 10' r.top - 10));            clpr.AddPath(outer' PolyType.ptSubject' true);          clpr.ReverseSolution = true;          clpr.Execute(ClipType.ctUnion' solution' PolyFillType.pftNegative' PolyFillType.pftNegative);          //remove the outer PolyNode rectangle ...          if (solution.ChildCount == 1 && solution.Childs[0].ChildCount > 0)          {            PolyNode outerNode = solution.Childs[0];            solution.Childs.Capacity = outerNode.ChildCount;            solution.Childs[0] = outerNode.Childs[0];            for (int i = 1; i < outerNode.ChildCount; i++)              solution.AddChild(outerNode.Childs[i]);          }          else            solution.Clear();        }
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,OffsetPoint,The following statement contains a magic number: if (m_sinA < 0.00005 && m_sinA > -0.00005) return;        else if (m_sinA > 1.0) m_sinA = 1.0;        else if (m_sinA < -1.0) m_sinA = -1.0;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,OffsetPoint,The following statement contains a magic number: if (m_sinA < 0.00005 && m_sinA > -0.00005) return;        else if (m_sinA > 1.0) m_sinA = 1.0;        else if (m_sinA < -1.0) m_sinA = -1.0;
Magic Number,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,DoSquare,The following statement contains a magic number: double dx = Math.Tan(Math.Atan2(m_sinA'            m_normals[k].X * m_normals[j].X + m_normals[k].Y * m_normals[j].Y) / 4);
Duplicate Code,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,JoinPoints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((27' 49)' (132' 154))
Missing Default,ClipperLib,Clipper,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,IntersectEdges,The following switch statement is missing a default case: switch (m_ClipType)                    {                        case ClipType.ctIntersection:                            if (e1Wc2 > 0 && e2Wc2 > 0)                                AddLocalMinPoly(e1' e2' pt);                            break;                        case ClipType.ctUnion:                            if (e1Wc2 <= 0 && e2Wc2 <= 0)                                AddLocalMinPoly(e1' e2' pt);                            break;                        case ClipType.ctDifference:                            if (((e1.PolyTyp == PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||                                ((e1.PolyTyp == PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))                                    AddLocalMinPoly(e1' e2' pt);                            break;                        case ClipType.ctXor:                            AddLocalMinPoly(e1' e2' pt);                            break;                    }
Missing Default,ClipperLib,ClipperOffset,C:\repos\xenovacivus_PathCAM\ThirdParty\clipper_library\clipper.cs,OffsetPoint,The following switch statement is missing a default case: switch (jointype)          {            case JoinType.jtMiter:              {                double r = 1 + (m_normals[j].X * m_normals[k].X +                  m_normals[j].Y * m_normals[k].Y);                if (r >= m_miterLim) DoMiter(j' k' r); else DoSquare(j' k);                break;              }            case JoinType.jtSquare: DoSquare(j' k); break;            case JoinType.jtRound: DoRound(j' k); break;          }
