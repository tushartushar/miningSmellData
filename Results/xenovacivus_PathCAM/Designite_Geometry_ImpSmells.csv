Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,Cyclomatic complexity of the method is 10
Complex Method,Geometry,Polygon,C:\repos\xenovacivus_PathCAM\Geometry\Polygon.cs,ToTriangles,Cyclomatic complexity of the method is 8
Complex Method,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,Triangles,Cyclomatic complexity of the method is 12
Long Statement,Geometry,AnalyzedTriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\AnalyzedTriangleMesh.cs,Analyze,The length of the statement  "            Func<Triangle' bool> TopTriangleCriteria = triangle => Vector3.Dot(triangle.Plane.Normal' Vector3.UnitZ) == 1 && triangle.A.Z == MaxPoint.Z; " is 140.
Long Statement,Geometry,AnalyzedTriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\AnalyzedTriangleMesh.cs,Analyze,The length of the statement  "            Func<Triangle' bool> BottomTriangleCriteria = triangle => Vector3.Dot(triangle.Plane.Normal' Vector3.UnitZ) == -1 && triangle.A.Z == MinPoint.Z; " is 144.
Long Statement,Geometry,AnalyzedTriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\AnalyzedTriangleMesh.cs,Analyze,The length of the statement  "            Func<Triangle' bool> PocketCriteria1 = triangle => !TopTriangleCriteria(triangle) && Vector3.Dot(triangle.Plane.Normal' Vector3.UnitZ) > 0; " is 139.
Long Statement,Geometry,AnalyzedTriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\AnalyzedTriangleMesh.cs,Analyze,The length of the statement  "            Func<Triangle' bool> PocketCriteria2 = triangle => !TopTriangleCriteria(triangle) && Vector3.Dot(triangle.Plane.Normal' Vector3.UnitZ) >= 0; " is 140.
Long Statement,Geometry,OBJ_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\OBJ_Loader.cs,Load,The length of the statement  "            // Lines starting with f are a face.  The indices are <vertex>/<texture>/<normal>' where texture and normal are optional. " is 121.
Long Statement,Geometry,OBJ_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\OBJ_Loader.cs,Load,The length of the statement  "            Regex faceRegex = new Regex(@"^f(?<face_data>\s+(?<vertex>\d+)/?(?<texture_coordinate>\d+)?/?(?<vertex_normal>\d+)?)+"' RegexOptions.IgnoreCase); " is 145.
Long Statement,Geometry,Plane,C:\repos\xenovacivus_PathCAM\Geometry\Plane.cs,Distance,The length of the statement  "            Vector3 target = ray.Start + alongRay * ray.Direction; // This should be on the plane - if not' the distance has the wrong sign. " is 128.
Long Statement,Geometry,Plane,C:\repos\xenovacivus_PathCAM\Geometry\Plane.cs,Distance,The length of the statement  "            Vector3 target2 = ray.Start - alongRay * ray.Direction; // Rather than compare with zero' which is not deterministic' compare with the possible result if the plane were behind the ray. " is 184.
Complex Conditional,Geometry,Polygon,C:\repos\xenovacivus_PathCAM\Geometry\Polygon.cs,ToTriangles,The conditional expression  "otherPoint != v1 && otherPoint != v2 && otherPoint != v3 && tri.IsPointInTriangle(otherPoint)"  is complex.
Complex Conditional,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,GetLines,The conditional expression  "type == LineType.All || (hole && type == LineType.Hole) || (!hole && type == LineType.Outside)"  is complex.
Complex Conditional,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,GetPairs,The conditional expression  "(outside && test < 2) || (!outside && test >= 2)"  is complex.
Magic Number,Geometry,LineSegmentCircleIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,LineSegmentCircleIntersect,The following statement contains a magic number: float along = (float)Math.Sqrt(Math.Pow(circleRadius' 2) - Math.Pow(distanceToLine' 2));
Magic Number,Geometry,LineSegmentCircleIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,LineSegmentCircleIntersect,The following statement contains a magic number: float along = (float)Math.Sqrt(Math.Pow(circleRadius' 2) - Math.Pow(distanceToLine' 2));
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: List<Vector3> vertices = new List<Vector3>(3);
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: List<float> distances = new List<float>(3);
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  float d1 = distances[i];                  float d2 = distances[(i + 1) % 3];                  float d3 = distances[(i + 2) % 3];                  Vector3 v1 = vertices[i];                  Vector3 v2 = vertices[(i + 1) % 3];                  Vector3 v3 = vertices[(i + 2) % 3];                    if (d1 * d2 < 0)                  {                      // One point on the edge from D1 to D2                      Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                      onPlane.Add(intersect);                      if (d3 == 0)                      {                          // Other point is on D3                          onPlane.Add(v3);                          break;                      }                      else                      {                          if (d1 * d3 < 0)                          {                              // Intersect with v1 to v3                              onPlane.Add(new Vector3(v3 * d1 - v1 * d3) / (d1 - d3));                              break;                          }                          else if (d2 * d3 < 0)                          {                              // Intersect with v2 to v3                              onPlane.Add(new Vector3(v3 * d2 - v2 * d3) / (d2 - d3));                              break;                          }                          else                          {                              // how the heck would we get here?                          }                      }                  }                  if (d1 == 0 && d2 == 0)                  {                      if (d3 == 0)                      {                          // Triangle intersects perfectly with the plane - need to return all 3 edges here?                          all_intersect = true;                          break;                      }                      else                      {                          onPlane.Add(v1);                          onPlane.Add(v2);                          break;                      }                  }                    //if (d1 * d2 < 0)                  //{                  //    // Edge of the triangle crosses the plane' interpolate to get the intersection point                  //    Vector3 intersect = new Vector3(v2 * d1 - v1 * d2) / (d1 - d2);                  //    onPlane.Add(intersect);                  //}              }
Magic Number,Geometry,TrianglePlaneIntersect,C:\repos\xenovacivus_PathCAM\Geometry\Intersect.cs,TrianglePlaneIntersect,The following statement contains a magic number: if (onPlane.Count == 2)              {                  pointA = onPlane[0];                  pointB = onPlane[1];                  intersects = true;              }
Magic Number,Geometry,DAE_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\DAE_Loader.cs,Load,The following statement contains a magic number: using (System.IO.TextReader reader = File.OpenText(filepath))              {                  XmlSerializer ser = new XmlSerializer(typeof(Collada));                  Collada c = (Collada)ser.Deserialize(reader);                  foreach (Geometry g in c.library_geometries)                  {                      float[] floats = g.mesh.PositionFloats();                      int[] indices = g.mesh.TrianglePositionIndices();                        List<Vector3> vertices = new List<Vector3>();                        for (int i = 0; i < floats.Count(); i += 3)                      {                          Vector3 v = new Vector3(floats[i]' floats[i + 1]' floats[i + 2]);                          vertices.Add(v * scale);                      }                        for (int i = 0; i < indices.Count(); i += 3)                      {                          triMesh.AddTriangle(vertices[indices[i]]' vertices[indices[i + 1]]' vertices[indices[i + 2]]);                      }                  }              }
Magic Number,Geometry,DAE_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\DAE_Loader.cs,Load,The following statement contains a magic number: using (System.IO.TextReader reader = File.OpenText(filepath))              {                  XmlSerializer ser = new XmlSerializer(typeof(Collada));                  Collada c = (Collada)ser.Deserialize(reader);                  foreach (Geometry g in c.library_geometries)                  {                      float[] floats = g.mesh.PositionFloats();                      int[] indices = g.mesh.TrianglePositionIndices();                        List<Vector3> vertices = new List<Vector3>();                        for (int i = 0; i < floats.Count(); i += 3)                      {                          Vector3 v = new Vector3(floats[i]' floats[i + 1]' floats[i + 2]);                          vertices.Add(v * scale);                      }                        for (int i = 0; i < indices.Count(); i += 3)                      {                          triMesh.AddTriangle(vertices[indices[i]]' vertices[indices[i + 1]]' vertices[indices[i + 2]]);                      }                  }              }
Magic Number,Geometry,DAE_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\DAE_Loader.cs,Load,The following statement contains a magic number: using (System.IO.TextReader reader = File.OpenText(filepath))              {                  XmlSerializer ser = new XmlSerializer(typeof(Collada));                  Collada c = (Collada)ser.Deserialize(reader);                  foreach (Geometry g in c.library_geometries)                  {                      float[] floats = g.mesh.PositionFloats();                      int[] indices = g.mesh.TrianglePositionIndices();                        List<Vector3> vertices = new List<Vector3>();                        for (int i = 0; i < floats.Count(); i += 3)                      {                          Vector3 v = new Vector3(floats[i]' floats[i + 1]' floats[i + 2]);                          vertices.Add(v * scale);                      }                        for (int i = 0; i < indices.Count(); i += 3)                      {                          triMesh.AddTriangle(vertices[indices[i]]' vertices[indices[i + 1]]' vertices[indices[i + 2]]);                      }                  }              }
Magic Number,Geometry,DAE_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\DAE_Loader.cs,Load,The following statement contains a magic number: using (System.IO.TextReader reader = File.OpenText(filepath))              {                  XmlSerializer ser = new XmlSerializer(typeof(Collada));                  Collada c = (Collada)ser.Deserialize(reader);                  foreach (Geometry g in c.library_geometries)                  {                      float[] floats = g.mesh.PositionFloats();                      int[] indices = g.mesh.TrianglePositionIndices();                        List<Vector3> vertices = new List<Vector3>();                        for (int i = 0; i < floats.Count(); i += 3)                      {                          Vector3 v = new Vector3(floats[i]' floats[i + 1]' floats[i + 2]);                          vertices.Add(v * scale);                      }                        for (int i = 0; i < indices.Count(); i += 3)                      {                          triMesh.AddTriangle(vertices[indices[i]]' vertices[indices[i + 1]]' vertices[indices[i + 2]]);                      }                  }              }
Magic Number,Geometry,OBJ_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\OBJ_Loader.cs,Load,The following statement contains a magic number: foreach (string s in strings)              {                  if (vertexRegex.IsMatch(s))                  {                      Match m = vertexRegex.Match(s);                      float x = float.Parse(m.Groups["x"].Value);                      float y = float.Parse(m.Groups["y"].Value);                      float z = float.Parse(m.Groups["z"].Value);                      // Rotate 90 degrees about the X axis - for some reason .obj files saved from sketchup have this issue...                      Vector3 v = new Vector3(x' -z' y);                      vertices.Add(v * scale);                  }                  else if (faceRegex.IsMatch(s))                  {                      Match m = faceRegex.Match(s);                        //Console.WriteLine(m.Groups["face_data"].Captures.Count);                      //Console.WriteLine(m.Groups["vertex"].Captures.Count);                      //Console.WriteLine(m.Groups["texture_coordinate"].Captures.Count);                      //Console.WriteLine(m.Groups["vertex_normal"].Captures.Count);                        //Face face = new Face();                      Polygon polygon = new Polygon();                        CaptureCollection vert_captures = m.Groups["vertex"].Captures;                      CaptureCollection texcoord_captures = m.Groups["texture_coordinate"].Captures;                      CaptureCollection norm_captures = m.Groups["vertex_normal"].Captures;                        var vertexIndices = vert_captures.Cast<Capture>().Select(capture => int.Parse(capture.Value) - 1);                        foreach (var vertexIndex in vertexIndices)                      {                          if (vertexIndex < 0 || vertexIndex > vertices.Count)                          {                              Console.WriteLine("Bad vertex index {0}' only {1} vertices loaded"' vertexIndex' vertices.Count);                          }                          else                          {                              polygon.Add(vertices[vertexIndex]);                          }                      }                      //for (int i = 0; i < vert_captures.Count; i++)                      //{                      //    int vert_index = int.Parse(vert_captures[i].Value) - 1;                      //                          //}                      if (texcoord_captures.Count == vert_captures.Count)                      {                          // TODO: Add texture coordinates to the face                      }                      if (norm_captures.Count == vert_captures.Count)                      {                          // TODO: Add vertex normals to the face                      }                        if (polygon.Vertices.Count() < 3)                      {                          Console.WriteLine("Bad face defined' less than 3 vertices");                      }                      else                      {                          foreach (var triangle in polygon.ToTriangles())                          {                              triMesh.AddTriangle(triangle);                          }                      }                  }              }
Magic Number,Geometry,STL_Loader,C:\repos\xenovacivus_PathCAM\Geometry\Loaders\STL_Loader.cs,Load,The following statement contains a magic number: foreach (var facet in stl.Facets)              {                  List<Vector3> vertices = new List<Vector3>();                  foreach (var vertex in facet.Vertices)                  {                      Vector3 v = new Vector3((float)vertex.X' (float)vertex.Y' (float)vertex.Z);                      vertices.Add(v * scale);                  }                  triMesh.AddTriangle(new Triangle(vertices[0]' vertices[1]' vertices[2]));              }
Magic Number,Geometry,Plane,C:\repos\xenovacivus_PathCAM\Geometry\Plane.cs,CreateMatrix,The following statement contains a magic number: if (Math.Abs(Normal.Z) > 0.8)              {                  up = new Vector3(1' 0' 0);              }
Magic Number,Geometry,Polygon,C:\repos\xenovacivus_PathCAM\Geometry\Polygon.cs,ToTriangles,The following statement contains a magic number: if (vertices.Count == 3)              {              }
Magic Number,Geometry,Polygon,C:\repos\xenovacivus_PathCAM\Geometry\Polygon.cs,ToTriangles,The following statement contains a magic number: while (vertices.Count >= 3)              {                  int verts = vertices.Count;                  int i = 0;                  // Find an ear on the face' remove it                  for (i = 0; i < verts; i++)                  {                      Vector3 v1 = vertices[i];                      Vector3 v2 = vertices[(i + 1) % verts];                      Vector3 v3 = vertices[(i + 2) % verts];                      var tri = new Triangle(v1' v2' v3);                        bool anyPointInPolygon = false;                      foreach (var otherPoint in vertices)                      {                          if (otherPoint != v1 && otherPoint != v2 && otherPoint != v3 && tri.IsPointInTriangle(otherPoint))                          {                              anyPointInPolygon = true;                              break;                          }                      }                        // First check: see if any point in the original polygon is inside the new triangle                      if (anyPointInPolygon)                      {                          // Can't use this triangle' move onto the next one                      }                      else                      {                          // Make sure the triangle points the right way.                          if (Vector3.Dot(tri.Plane.Normal' p.Normal) > 0.9f)                          {                              yield return tri;                              this.vertices.RemoveAt((i + 1) % verts);                              break;                          }                          else                          {                          }                      }                  }                  if (i == verts)                  {                      // Got a bad face                      break;                  }              }
Magic Number,Geometry,Polygon,C:\repos\xenovacivus_PathCAM\Geometry\Polygon.cs,ToTriangles,The following statement contains a magic number: while (vertices.Count >= 3)              {                  int verts = vertices.Count;                  int i = 0;                  // Find an ear on the face' remove it                  for (i = 0; i < verts; i++)                  {                      Vector3 v1 = vertices[i];                      Vector3 v2 = vertices[(i + 1) % verts];                      Vector3 v3 = vertices[(i + 2) % verts];                      var tri = new Triangle(v1' v2' v3);                        bool anyPointInPolygon = false;                      foreach (var otherPoint in vertices)                      {                          if (otherPoint != v1 && otherPoint != v2 && otherPoint != v3 && tri.IsPointInTriangle(otherPoint))                          {                              anyPointInPolygon = true;                              break;                          }                      }                        // First check: see if any point in the original polygon is inside the new triangle                      if (anyPointInPolygon)                      {                          // Can't use this triangle' move onto the next one                      }                      else                      {                          // Make sure the triangle points the right way.                          if (Vector3.Dot(tri.Plane.Normal' p.Normal) > 0.9f)                          {                              yield return tri;                              this.vertices.RemoveAt((i + 1) % verts);                              break;                          }                          else                          {                          }                      }                  }                  if (i == verts)                  {                      // Got a bad face                      break;                  }              }
Magic Number,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,Slice,The following statement contains a magic number: for (int i = -1; i <= 1; i++)              {                  Vector3 offset = plane.Normal * 0.0001f * (float)i;                  LineHandler lineHandler = new LineHandler(0.0f);                  Plane testPlane = new Plane(plane.Normal' plane.Point + offset);                  foreach (Triangle t in mesh.Triangles)                  {                      var intersect = new TrianglePlaneIntersect(t' testPlane);                      if (intersect.Intersects)                      {                          lineHandler.AddSegment(intersect.PointA' intersect.PointB);                          //GL.Color3(Color.Blue);                          //GL.Vertex3(intersect.PointA + new Vector3(0' 0' height + .01f));                          //GL.Color3(Color.Red);                          //GL.Vertex3(intersect.PointB + new Vector3(0' 0' height + .01f));                      }                      else if (intersect.all_intersect && Vector3.Dot(t.Plane.Normal' testPlane.Normal) > 0.5f)                      {                          // Entire triangle intersects                          // Add all the triangle edges (TODO: clean this up...)                          List<Vector3> vertices = new List<Vector3>(t.Vertices);                          for (int a = 0; a < 3; a++)                          {                              Vector3 v1 = vertices[a];                              Vector3 v2 = vertices[(a + 1) % 3];                              lineHandler.AddSegment(v1' v2);                          }                      }                  }                  if (this.polyTree == null)                  {                      Init(lineHandler.GetOuterLoops()' plane);                  }                  else                  {                      Slice s = new Slice(lineHandler.GetOuterLoops()' plane);                      this.Union(s);                  }              }
Magic Number,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,Slice,The following statement contains a magic number: for (int i = -1; i <= 1; i++)              {                  Vector3 offset = plane.Normal * 0.0001f * (float)i;                  LineHandler lineHandler = new LineHandler(0.0f);                  Plane testPlane = new Plane(plane.Normal' plane.Point + offset);                  foreach (Triangle t in mesh.Triangles)                  {                      var intersect = new TrianglePlaneIntersect(t' testPlane);                      if (intersect.Intersects)                      {                          lineHandler.AddSegment(intersect.PointA' intersect.PointB);                          //GL.Color3(Color.Blue);                          //GL.Vertex3(intersect.PointA + new Vector3(0' 0' height + .01f));                          //GL.Color3(Color.Red);                          //GL.Vertex3(intersect.PointB + new Vector3(0' 0' height + .01f));                      }                      else if (intersect.all_intersect && Vector3.Dot(t.Plane.Normal' testPlane.Normal) > 0.5f)                      {                          // Entire triangle intersects                          // Add all the triangle edges (TODO: clean this up...)                          List<Vector3> vertices = new List<Vector3>(t.Vertices);                          for (int a = 0; a < 3; a++)                          {                              Vector3 v1 = vertices[a];                              Vector3 v2 = vertices[(a + 1) % 3];                              lineHandler.AddSegment(v1' v2);                          }                      }                  }                  if (this.polyTree == null)                  {                      Init(lineHandler.GetOuterLoops()' plane);                  }                  else                  {                      Slice s = new Slice(lineHandler.GetOuterLoops()' plane);                      this.Union(s);                  }              }
Magic Number,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,GetPairs,The following statement contains a magic number: while (null != n)              {                  int depth = 0;                  PolyNode parent = n.Parent;                  while (parent != null)                  {                      depth++;                      parent = parent.Parent;                  }                  int test = (depth - 1) % 4;                  if ((outside && test < 2) || (!outside && test >= 2))                  {                      polygons.Add(n.Contour);                  }                  n = n.GetNext();              }
Magic Number,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,GetPairs,The following statement contains a magic number: while (null != n)              {                  int depth = 0;                  PolyNode parent = n.Parent;                  while (parent != null)                  {                      depth++;                      parent = parent.Parent;                  }                  int test = (depth - 1) % 4;                  if ((outside && test < 2) || (!outside && test >= 2))                  {                      polygons.Add(n.Contour);                  }                  n = n.GetNext();              }
Magic Number,Geometry,Slice,C:\repos\xenovacivus_PathCAM\Geometry\Slice.cs,GetPairs,The following statement contains a magic number: while (null != n)              {                  int depth = 0;                  PolyNode parent = n.Parent;                  while (parent != null)                  {                      depth++;                      parent = parent.Parent;                  }                  int test = (depth - 1) % 4;                  if ((outside && test < 2) || (!outside && test >= 2))                  {                      polygons.Add(n.Contour);                  }                  n = n.GetNext();              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: foreach (Edge e in Edges)              {                  if (e.Vertices.Count() != 2)                  {                      return false;                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,Clean,The following statement contains a magic number: for (int i = 0; i < triangles.Count; i++)              {                  var tri1 = triangles[i];                  int longestEdgeIndex = tri1.LongestEdgeIndex();                  var edge = tri1.edges[longestEdgeIndex];                    int[] vertexIndices1 = new int[] { tri1.a' tri1.b' tri1.c };                  Vector3 oppositePoint = vertices[vertexIndices1[(longestEdgeIndex + 2) % 3]];                    // Is the triangle really small' basically a line?                  // Note: use a test value of half epsilon to guarentee                   if (edge.LineSegment.Distance(oppositePoint) < (epsilon / 2.0f))                  {                      // If so' find the quad formed by the two attached triangles and flip the dividing line.                      var tri2 = edge.triangles.First(t => t != tri1);                        int splitEdgeIndex = tri2.edges.FindIndex(e => e == edge);                        int[] vertexIndices2 = new int[] { tri2.a' tri2.b' tri2.c };                          int a = vertexIndices2[(splitEdgeIndex + 1) % 3];                      int b = vertexIndices2[(splitEdgeIndex + 2) % 3];                      int c = vertexIndices2[(splitEdgeIndex + 3) % 3];                      int d = vertexIndices1[(longestEdgeIndex + 2) % 3];                        edge.a = b;                      edge.b = d;                        tri2.a = b;                      tri2.b = c;                      tri2.c = d;                        tri1.a = d;                      tri1.b = a;                      tri1.c = b;                        SetTriangleEdgePointers(tri2);                      SetTriangleEdgePointers(tri1);                  }              }
Magic Number,Geometry,TriangleMesh,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,SetTriangleEdgePointers,The following statement contains a magic number: tri.edges[2].triangles.Add(tri);
Magic Number,Geometry,TriangleIndices,C:\repos\xenovacivus_PathCAM\Geometry\TriangleMesh.cs,LongestEdgeIndex,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  {                      float length = edges[i].Length();                      if (length > longest || index < 0)                      {                          index = i;                          longest = length;                      }                  }
