Implementation smell,Namespace,Class,File,Method,Description
Long Method,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The method has 130 lines of code.
Long Method,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The method has 227 lines of code.
Complex Method,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,Cyclomatic complexity of the method is 13
Long Statement,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,UpdatePalette,The length of the statement  "                    CurrentPalette[palIndex++] = Color.FromArgb(smackerMap[t]' smackerMap[(int)Util.ReadByte(s) & 0x3F]' smackerMap[(int)Util.ReadByte(s) & 0x3F]); " is 143.
Long Statement,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,GetVideoDataBitmap,The length of the statement  "            BitmapData data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format8bppIndexed); " is 177.
Magic Number,SCSharp.Smk,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\BitStream.cs,ReadBits,The following statement contains a magic number: if (BitCount > 16)                  throw new ArgumentOutOfRangeException("BitCount"' "Maximum BitCount is 16");
Magic Number,SCSharp.Smk,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\BitStream.cs,ReadBits,The following statement contains a magic number: while (BitCount > 0)              {                  if (mCurrentByte >= nbBytes)                  {                      if (mStream.Position >= mStream.Length)                          throw new EndOfStreamException();                      nbBytes = mStream.Read(bytes' 0' MAX_BYTES);                      mCurrentByte = 0;                      mCurrentBit = 0;                  }                                    if (mCurrentBit + BitCount < 8)  //Everything fits in this byte                  {                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - BitCount))) << bitsRead;                      mCurrentBit = BitCount + mCurrentBit;                      BitCount = 0;                  }                  else //Read all bits left in this byte                  {                      int bitsToRead = 8 - mCurrentBit;                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - bitsToRead))) << bitsRead;                      bitsRead += bitsToRead;                      mCurrentByte++;                      mCurrentBit = 0;                      BitCount -= bitsToRead;                  }              }
Magic Number,SCSharp.Smk,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\BitStream.cs,ReadBits,The following statement contains a magic number: while (BitCount > 0)              {                  if (mCurrentByte >= nbBytes)                  {                      if (mStream.Position >= mStream.Length)                          throw new EndOfStreamException();                      nbBytes = mStream.Read(bytes' 0' MAX_BYTES);                      mCurrentByte = 0;                      mCurrentBit = 0;                  }                                    if (mCurrentBit + BitCount < 8)  //Everything fits in this byte                  {                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - BitCount))) << bitsRead;                      mCurrentBit = BitCount + mCurrentBit;                      BitCount = 0;                  }                  else //Read all bits left in this byte                  {                      int bitsToRead = 8 - mCurrentBit;                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - bitsToRead))) << bitsRead;                      bitsRead += bitsToRead;                      mCurrentByte++;                      mCurrentBit = 0;                      BitCount -= bitsToRead;                  }              }
Magic Number,SCSharp.Smk,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\BitStream.cs,ReadBits,The following statement contains a magic number: while (BitCount > 0)              {                  if (mCurrentByte >= nbBytes)                  {                      if (mStream.Position >= mStream.Length)                          throw new EndOfStreamException();                      nbBytes = mStream.Read(bytes' 0' MAX_BYTES);                      mCurrentByte = 0;                      mCurrentBit = 0;                  }                                    if (mCurrentBit + BitCount < 8)  //Everything fits in this byte                  {                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - BitCount))) << bitsRead;                      mCurrentBit = BitCount + mCurrentBit;                      BitCount = 0;                  }                  else //Read all bits left in this byte                  {                      int bitsToRead = 8 - mCurrentBit;                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - bitsToRead))) << bitsRead;                      bitsRead += bitsToRead;                      mCurrentByte++;                      mCurrentBit = 0;                      BitCount -= bitsToRead;                  }              }
Magic Number,SCSharp.Smk,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\BitStream.cs,ReadBits,The following statement contains a magic number: while (BitCount > 0)              {                  if (mCurrentByte >= nbBytes)                  {                      if (mStream.Position >= mStream.Length)                          throw new EndOfStreamException();                      nbBytes = mStream.Read(bytes' 0' MAX_BYTES);                      mCurrentByte = 0;                      mCurrentBit = 0;                  }                                    if (mCurrentBit + BitCount < 8)  //Everything fits in this byte                  {                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - BitCount))) << bitsRead;                      mCurrentBit = BitCount + mCurrentBit;                      BitCount = 0;                  }                  else //Read all bits left in this byte                  {                      int bitsToRead = 8 - mCurrentBit;                      result |= (((int)bytes[mCurrentByte] >> mCurrentBit) & (0xffff >> (16 - bitsToRead))) << bitsRead;                      bitsRead += bitsToRead;                      mCurrentByte++;                      mCurrentBit = 0;                      BitCount -= bitsToRead;                  }              }
Magic Number,SCSharp.Smk,Huffmantree,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Huffmantree.cs,BuildTree,The following statement contains a magic number: if (flag != 0)              {                  //Advance to "0"-branch                  Node left = new Node();                  //Recursive call                  BuildTree(m' left);                    //The first left-node is actually the root                  if (current == null)                  {                      rootNode = left;                      return;                  }                  else                      current.Left = left;              }              else //If flag is zero              {                  if (current == null)                  {                      current = new Node();                      rootNode = current;                                       }                  //Read 8 bit leaf                  int leaf = m.ReadBits(8);                  //Console.WriteLine("Decoded :" + leaf);                  current.IsLeaf = true;                  current.Value = leaf;                  return;              }
Magic Number,SCSharp.Smk,BigHuffmanTree,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Huffmantree.cs,BuildTree,The following statement contains a magic number: iMarker1 = m.ReadBits(16);
Magic Number,SCSharp.Smk,BigHuffmanTree,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Huffmantree.cs,BuildTree,The following statement contains a magic number: iMarker2 = m.ReadBits(16);
Magic Number,SCSharp.Smk,BigHuffmanTree,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Huffmantree.cs,BuildTree,The following statement contains a magic number: iMarker3 = m.ReadBits(16);
Magic Number,SCSharp.Smk,BigHuffmanTree,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Huffmantree.cs,BuildTree,The following statement contains a magic number: if (flag != 0)              {                  //Advance to "0"-branch                  Node left = new Node();                  //Recursive call                  BuildTree(m' left);                    //The first left-node is actually the root                  if (current == null)                  {                      RootNode = left;                      return;                  }                  else                      current.Left = left;              }              else //If flag is zero              {                  if (current == null)                  {                      current = new Node();                      RootNode = current;                  }                  //Read 16 bit leaf by decoding the low byte' then the high byte                  int lower = lowByteTree.Decode(m);                  int higher = highByteTree.Decode(m);                  int leaf = lower | (higher << 8);                  //System.Console.WriteLine("Decoded: " + leaf);                  //If we found one of the markers' store pointers to those nodes.                  if (leaf == iMarker1)                  {                      leaf = 0;                      marker1 = current;                  }                  if (leaf == iMarker2)                  {                      leaf = 0;                      marker2 = current;                  }                  if (leaf == iMarker3)                  {                      leaf = 0;                      marker3 = current;                  }                    current.IsLeaf = true;                  current.Value = leaf;                  return;              }
Magic Number,SCSharp.Smk,SmackerFile,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,ReadHeader,The following statement contains a magic number: for (i = 0; i < 7; i++)                  smk.AudioSize[i] = Util.ReadDWord(s);
Magic Number,SCSharp.Smk,SmackerFile,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,ReadHeader,The following statement contains a magic number: for (i = 0; i < 7; i++)                  smk.AudioRate[i] = Util.ReadDWord(s);
Magic Number,SCSharp.Smk,SmackerFile,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,CalcFps,The following statement contains a magic number: if ((int)smk.Pts_Inc > 0)                  return 1000.0 / (int)smk.Pts_Inc;              else if ((int)smk.Pts_Inc < 0)                  return 100000.0 / (-(int)smk.Pts_Inc);              else                  return 10.0;
Magic Number,SCSharp.Smk,SmackerFile,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,CalcFps,The following statement contains a magic number: if ((int)smk.Pts_Inc > 0)                  return 1000.0 / (int)smk.Pts_Inc;              else if ((int)smk.Pts_Inc < 0)                  return 100000.0 / (-(int)smk.Pts_Inc);              else                  return 10.0;
Magic Number,SCSharp.Smk,SmackerFile,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,CalcFps,The following statement contains a magic number: if ((int)smk.Pts_Inc > 0)                  return 1000.0 / (int)smk.Pts_Inc;              else if ((int)smk.Pts_Inc < 0)                  return 100000.0 / (-(int)smk.Pts_Inc);              else                  return 10.0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,IsStereoTrack,The following statement contains a magic number: return ((AudioRate[i] >> 24) & 16) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,IsStereoTrack,The following statement contains a magic number: return ((AudioRate[i] >> 24) & 16) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,Is16BitTrack,The following statement contains a magic number: return ((AudioRate[i] >> 24) & 32) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,Is16BitTrack,The following statement contains a magic number: return ((AudioRate[i] >> 24) & 32) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,IsCompressedTrack,The following statement contains a magic number: return ((AudioRate[i] >> 24) & 128) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,IsCompressedTrack,The following statement contains a magic number: return ((AudioRate[i] >> 24) & 128) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,IsYInterlaced,The following statement contains a magic number: return (Flags & 2) > 0;
Magic Number,SCSharp.Smk,SmackerHeader,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\Smk.cs,IsYDoubled,The following statement contains a magic number: return (Flags & 4) > 0;
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,SmackerDecoder,The following statement contains a magic number: lastAudioData = new byte[7][];
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,UpdatePalette,The following statement contains a magic number: long frameSize = File.FrameSizes[CurrentFrame] & (~3);
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,UpdatePalette,The following statement contains a magic number: size = size * 4 - 1;
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,UpdatePalette,The following statement contains a magic number: while (sz < 256)              {                  int t = (int)Util.ReadByte(s);                  if ((t & 0x80) != 0)                  {                      /* skip palette entries */                      sz += (t & 0x7F) + 1;                      for (int i = 0; i < (t & 0x7F) + 1; i++)                      {                          CurrentPalette[palIndex++] = Color.FromArgb(255' 0' 0' 0);                      }                      //palIndex += ((t & 0x7F) + 1) ;                  }                  else if ((t & 0x40) != 0)                  {                      /* copy with offset */                      int off = ((int)Util.ReadByte(s));                      j = (t & 0x3F) + 1;                      while ((j-- != 0) && sz < 256)                      {                          CurrentPalette[palIndex++] = OldPallette[off];                          sz++;                          off++;                      }                  }                  else                  {                      /* new entries */                      CurrentPalette[palIndex++] = Color.FromArgb(smackerMap[t]' smackerMap[(int)Util.ReadByte(s) & 0x3F]' smackerMap[(int)Util.ReadByte(s) & 0x3F]);                      sz++;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,UpdatePalette,The following statement contains a magic number: while (sz < 256)              {                  int t = (int)Util.ReadByte(s);                  if ((t & 0x80) != 0)                  {                      /* skip palette entries */                      sz += (t & 0x7F) + 1;                      for (int i = 0; i < (t & 0x7F) + 1; i++)                      {                          CurrentPalette[palIndex++] = Color.FromArgb(255' 0' 0' 0);                      }                      //palIndex += ((t & 0x7F) + 1) ;                  }                  else if ((t & 0x40) != 0)                  {                      /* copy with offset */                      int off = ((int)Util.ReadByte(s));                      j = (t & 0x3F) + 1;                      while ((j-- != 0) && sz < 256)                      {                          CurrentPalette[palIndex++] = OldPallette[off];                          sz++;                          off++;                      }                  }                  else                  {                      /* new entries */                      CurrentPalette[palIndex++] = Color.FromArgb(smackerMap[t]' smackerMap[(int)Util.ReadByte(s) & 0x3F]' smackerMap[(int)Util.ReadByte(s) & 0x3F]);                      sz++;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,UpdatePalette,The following statement contains a magic number: while (sz < 256)              {                  int t = (int)Util.ReadByte(s);                  if ((t & 0x80) != 0)                  {                      /* skip palette entries */                      sz += (t & 0x7F) + 1;                      for (int i = 0; i < (t & 0x7F) + 1; i++)                      {                          CurrentPalette[palIndex++] = Color.FromArgb(255' 0' 0' 0);                      }                      //palIndex += ((t & 0x7F) + 1) ;                  }                  else if ((t & 0x40) != 0)                  {                      /* copy with offset */                      int off = ((int)Util.ReadByte(s));                      j = (t & 0x3F) + 1;                      while ((j-- != 0) && sz < 256)                      {                          CurrentPalette[palIndex++] = OldPallette[off];                          sz++;                          off++;                      }                  }                  else                  {                      /* new entries */                      CurrentPalette[palIndex++] = Color.FromArgb(smackerMap[t]' smackerMap[(int)Util.ReadByte(s) & 0x3F]' smackerMap[(int)Util.ReadByte(s) & 0x3F]);                      sz++;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,ReadNextFrame,The following statement contains a magic number: for (int i = 0; i < 7; i++' mask <<= 1)              {                  if ((file.FrameTypes[CurrentFrame] & mask) > 0)                  {                      long pos = File.Stream.Position;                      uint length = Util.ReadDWord(File.Stream);                        //We assume compression' if not' well too bad                      uint unpackedLength = Util.ReadDWord(File.Stream);                      BitStream m = new BitStream(File.Stream);                      if (m.ReadBits(1) != 0) //Audio present                      {                          bool stereo = m.ReadBits(1) > 0;                          bool is16Bit = m.ReadBits(1) > 0;                            //Next are some trees                          uint nbTrees = 1;                          if (stereo)                              nbTrees <<= 1;                          if (is16Bit)                              nbTrees <<= 1;                          Huffmantree[] tree = new Huffmantree[nbTrees];                          byte[] audioData = new byte[unpackedLength + 4];                          uint audioDataIndex = 0;                          for (int k = 0; k < nbTrees; k++)                          {                              tree[k] = new Huffmantree();                              tree[k].BuildTree(m);                          }                            int res;                          if (is16Bit)                          {                              Int16 rightBaseMSB = 0' rightBaseLSB = 0' leftBaseMSB = 0' leftBaseLSB = 0;                              rightBaseMSB = (Int16)(m.ReadBits(8));                              rightBaseLSB = (Int16)(m.ReadBits(8));                              //Add sample (little endian)                              audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                              audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                              if (stereo)                              {                                  leftBaseMSB = (Int16)(m.ReadBits(8));                                  leftBaseLSB = (Int16)(m.ReadBits(8));                                  //Add sample (little endian)                                  audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                  audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                              }                                for (int l = 0; l < unpackedLength / 2; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      res = tree[2].Decode(m);                                      leftBaseLSB += (Int16)res;                                      res = tree[3].Decode(m);                                      leftBaseMSB += (Int16)res;                                      leftBaseMSB += (Int16)(leftBaseLSB >> 8);                                      leftBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)leftBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)leftBaseMSB; //Higher byte                                  }                                  else                                  {                                      res = tree[0].Decode(m);                                      rightBaseLSB += (Int16)res;                                      res = tree[1].Decode(m);                                      rightBaseMSB += (Int16)res;                                      rightBaseMSB += (Int16)(rightBaseLSB >> 8);                                      rightBaseLSB &= 0xFF;                                        //Add sample (little endian)                                      audioData[audioDataIndex++] = (byte)rightBaseLSB; //Lower byte                                      audioData[audioDataIndex++] = (byte)rightBaseMSB; //Higher byte                                  }                              }                          }                          else                          {                              byte rightBase = (byte)m.ReadBits(8)' leftBase = 0;                                //Add sample                               audioData[audioDataIndex++] = rightBase;                                if (stereo)                              {                                  leftBase = (byte)m.ReadBits(8);                                  //Add sample                                   audioData[audioDataIndex++] = leftBase;                              }                                for (int l = 0; l < unpackedLength; l++)                              {                                  if ((l & ((stereo) ? 1 : 0)) > 0)                                  {                                      leftBase += (byte)tree[1].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = leftBase;                                  }                                  else                                  {                                      rightBase += (byte)tree[0].Decode(m);                                      //Add sample                                       audioData[audioDataIndex++] = rightBase;                                  }                              }                          }                          lastAudioData[i] = audioData;                      }                        File.Stream.Seek(pos + (long)length' SeekOrigin.Begin);                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: uint nbBlocksX = File.Header.Width / 4;
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: uint nbBlocksY = File.Header.Height / 4;
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,DecodeVideo,The following statement contains a magic number: while (currentBlock < nbBlocks)              {                  blockHeader = (uint)File.Type.Decode(m);                  runLength = sizetable[(blockHeader >> 2) & 0x3F];                    blockType = blockHeader & 3;                  //   System.Console.Write("BLOCK " + currentBlock + " " + runLength + " ");                    switch (blockType)                  {                      case 2: //VOID BLOCK                          //  System.Console.WriteLine("VOID - ");                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              index = 0;                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      index = GetIndex(posX + x' posY + y);                                      currentFrameData[index] = lastFrameData[index];                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 3: //SOLID BLOCK                          //     System.Console.WriteLine("SOLID - ");                          color = (byte)(blockHeader >> 8);                            //Get block address                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              //Get current block coordinates                              posX = 4 * (currentBlock % nbBlocksX);                              posY = 4 * (currentBlock / nbBlocksX);                              for (x = 0; x < 4; x++)                              {                                  for (y = 0; y < 4; y++)                                  {                                      currentFrameData[GetIndex(posX + x' posY + y)] = color;                                  }                              }                                currentBlock++;                          }                          runLengthNotComplete = runLength - i;                          break;                      case 0: //MONO BLOCK                          //    System.Console.WriteLine("MONO - ");                          for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                          {                              colors = (uint)File.MClr.Decode(m);                              color1 = (byte)(colors >> 8);                              color2 = (byte)(colors & 0xFF);                                mask = (uint)File.MMap.Decode(m);                              posX = (currentBlock % nbBlocksX) * 4;                              posY = (currentBlock / nbBlocksX) * 4;                              for (y = 0; y < 4; y++)                              {                                  if ((mask & 1) > 0)                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX' posY + y)] = color2;                                  }                                  if ((mask & 2) > 0)                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 1' posY + y)] = color2;                                  }                                  if ((mask & 4) > 0)                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                  }                                  if ((mask & 8) > 0)                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                  }                                  else                                  {                                      currentFrameData[GetIndex(posX + 3' posY + y)] = color2;                                  }                                    mask >>= 4;                              }                              currentBlock++;                          }                          //  runLengthNotComplete = runLength - i;                          break;                      case 1:                          //    System.Console.WriteLine("FULL - ");                          int mode = 0;                          if (File.IsV4)                          {                              int type = m.ReadBits(1);                                if (type == 0)                              {                                  int abit = m.ReadBits(1);                                  if (abit == 1)                                      mode = 2;                                }                              else                                  mode = 1;                          }                            switch (mode)                          {                              case 0://v2 Full block                                    for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      for (y = 0; y < 4; y++)                                      {                                          colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                            currentFrameData[GetIndex(posX + 3' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + y)] = color2;                                              colors = (uint)File.Full.Decode(m);                                          color1 = (byte)(colors >> 8);                                          color2 = (byte)(colors & 0xFF);                                          currentFrameData[GetIndex(posX + 1' posY + y)] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + y)] = color2;                                        }                                      currentBlock++;                                  }                                  break;                              case 1:                                  for (i = 0; i < runLength && currentBlock < nbBlocks; i++)                                  {                                      posX = (currentBlock % nbBlocksX) * 4;                                      posY = (currentBlock / nbBlocksX) * 4;                                      pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 0)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 0)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 1)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 1)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 1)] = color1;                                        pix = (uint)File.Full.Decode(m);                                        color1 = (byte)(pix >> 8);                                      color2 = (byte)(pix & 0xFF);                                        currentFrameData[GetIndex(posX + 0' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 2)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 2)] = color1;                                      currentFrameData[GetIndex(posX + 0' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 1' posY + 3)] = color2;                                      currentFrameData[GetIndex(posX + 2' posY + 3)] = color1;                                      currentFrameData[GetIndex(posX + 3' posY + 3)] = color1;                                        currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - i;                                  break;                              case 2:                                  for (j = 0; j < runLength && currentBlock < nbBlocks; j++)                                  {                                      posX = (currentBlock % nbBlocksX) << 2;                                      posY = (currentBlock / nbBlocksX) << 2;                                      for (i = 0; i < 2; i++)                                      {                                            pix1 = (uint)File.Full.Decode(m);                                          pix2 = (uint)File.Full.Decode(m);                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                            currentFrameData[GetIndex(posX + 2' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 2' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 3' posY + (i << 1) + 1)] = color1;                                              color1 = (byte)(pix1 >> 8);                                          color2 = (byte)(pix1 & 0xFF);                                              currentFrameData[GetIndex(posX + 0' posY + (i << 1))] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1))] = color1;                                          currentFrameData[GetIndex(posX + 0' posY + (i << 1) + 1)] = color2;                                          currentFrameData[GetIndex(posX + 1' posY + (i << 1) + 1)] = color1;                                          }                                      currentBlock++;                                  }                                  //          runLengthNotComplete = runLength - j;                                  break;                              default:                                  break;                          }                            break;                  }              }
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,GetVideoDataBitmap,The following statement contains a magic number: ColorPalette pal = GetColorPalette(256);
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,GetVideoDataBitmap,The following statement contains a magic number: Array.Copy(CurrentPalette' pal.Entries' 256);
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,GetColorPalette,The following statement contains a magic number: if (nColors > 2)                  bitscolordepth = PixelFormat.Format4bppIndexed;
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,GetColorPalette,The following statement contains a magic number: if (nColors > 16)                  bitscolordepth = PixelFormat.Format8bppIndexed;
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,Reset,The following statement contains a magic number: int pos = (int)(104 + 5 * nbFrames + file.Header.TreesSize);
Magic Number,SCSharp.Smk,SmackerDecoder,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq.Smk\SmkDecoder.cs,Reset,The following statement contains a magic number: int pos = (int)(104 + 5 * nbFrames + file.Header.TreesSize);
