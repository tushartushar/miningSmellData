Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SCSharp,Fnt,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Fnt.cs,GetGlyph,Cyclomatic complexity of the method is 8
Complex Method,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,AdjustTree,Cyclomatic complexity of the method is 10
Complex Method,MpqReader,MpqStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqStream.cs,DecompressMulti,Cyclomatic complexity of the method is 9
Long Parameter List,SCSharp,Glyph,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Fnt.cs,Glyph,The method has 5 parameters. Parameters: width' height' xoffset' yoffset' bitmap
Long Parameter List,SCSharp,Grp,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Grp.cs,DecodeLine,The method has 5 parameters. Parameters: grid' line' xOffset' line_length' width
Long Statement,SCSharp,Grp,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Grp.cs,GetFrame,The length of the statement  "				DecodeLine (grid' height - i - entries[frame].yOffset' entries[frame].xOffset' (ushort)(line_offsets[i + 1] - line_offsets[i])' width); " is 135.
Long Statement,SCSharp,Grp,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Grp.cs,DecodeLine,The length of the statement  "			} catch (Exception e) { Console.WriteLine ("EXCEPTION on line {0}' x = {2}' i = {3}' line length = {2} (line data length = {4}): {5}"' line' x' line_length' i' line_data.Length' e); } " is 183.
Long Statement,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The length of the statement  "			return ((uint)((uint)buf[position] | (uint)buf[position+1] << 8 | (uint)buf[position+2] << 16 | (uint)buf[position+3] << 24)); " is 126.
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: x1 = Util.ReadWord (buf' position + 4);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: y1 = Util.ReadWord (buf' position + 6);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: x2 = Util.ReadWord (buf' position + 8);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: y2 = Util.ReadWord (buf' position + 10);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: width = Util.ReadWord (buf' position + 12);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: height = Util.ReadWord (buf' position + 14);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: text_offset = Util.ReadDWord (buf' position + 20);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: flags = (ElementFlags)Util.ReadDWord (buf' position + 24);
Magic Number,SCSharp,BinElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,BinElement,The following statement contains a magic number: type = (ElementType)buf[position + 34];
Magic Number,SCSharp,Bin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Bin.cs,ReadElements,The following statement contains a magic number: do {  				BinElement element = new BinElement (buf' position' (uint)stream.Length);    				elements.Add (element);    				position += 86;  			} while (position < ((BinElement)elements[0]).text_offset);
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ReadFromStream,The following statement contains a magic number: byte[] section_name_buf = new byte[4];
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ReadFromStream,The following statement contains a magic number: while (true) {  				stream.Read (section_name_buf' 0' 4);    				SectionData sec_data = new SectionData();    				sec_data.data_length = Util.ReadDWord (stream);  				sec_data.data_position = stream.Position;    				section_name = Encoding.ASCII.GetString (section_name_buf' 0' 4);    				sections.Add (section_name' sec_data);    				if (stream.Position + sec_data.data_length >= stream.Length)  					break;    				stream.Position += sec_data.data_length;  			}
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ReadFromStream,The following statement contains a magic number: while (true) {  				stream.Read (section_name_buf' 0' 4);    				SectionData sec_data = new SectionData();    				sec_data.data_length = Util.ReadDWord (stream);  				sec_data.data_position = stream.Position;    				section_name = Encoding.ASCII.GetString (section_name_buf' 0' 4);    				sections.Add (section_name' sec_data);    				if (stream.Position + sec_data.data_length >= stream.Length)  					break;    				stream.Position += sec_data.data_length;  			}
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ParseSection,The following statement contains a magic number: if (section_name == "TYPE") {  				scenarioType = Util.ReadWord (section_data' 0);  			}  			else if (section_name == "ERA ")  				tileSet = (Tileset)Util.ReadWord (section_data' 0);  			else if (section_name == "DIM ") {  				width = Util.ReadWord (section_data' 0);  				height = Util.ReadWord (section_data' 2);  			}  			else if (section_name == "MTXM") {  				mapTiles = new ushort[width'height];  				int y' x;  				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapTiles[x'y] = Util.ReadWord (section_data' (y*width + x)*2);  			}  			else if (section_name == "MASK") {  				mapMask = new byte[width'height];  				int y' x;  				int i = 0;    				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapMask[x'y] = section_data [i++];  			}  			else if (section_name == "SPRP") {  				int nameStringIndex = Util.ReadWord (section_data' 0);  				int descriptionStringIndex = Util.ReadWord (section_data' 2);    				Console.WriteLine ("mapName = {0}"' nameStringIndex);  				Console.WriteLine ("mapDescription = {0}"' descriptionStringIndex);  				mapName = GetMapString (nameStringIndex);  				mapDescription = GetMapString (descriptionStringIndex);  			}  			else if (section_name == "STR ") {  				ReadStrings (section_data);  			}  			else if (section_name == "OWNR") {  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					/*   					   00 - Unused  					   03 - Rescuable  					   05 - Computer  					   06 - Human  					   07 - Neutral  					*/  					if (section_data[i] == 0x05)  						numComputerSlots ++;  					else if (section_data[i] == 0x06)  						numHumanSlots ++;  				}  			}  			else if (section_name == "SIDE") {  				/*  				  00 - Zerg  				  01 - Terran  				  02 - Protoss  				  03 - Independent  				  04 - Neutral  				  05 - User Select  				  07 - Inactive  				  10 - Human  				*/  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					if (section_data[i] == 0x05) /* user select */  						numPlayers++;  				}  			}  			else if (section_name == "UNIT") {  				ReadUnits (section_data);  			}  			else if (section_name == "MBRF") {  				briefingData = new TriggerData();  				briefingData.Parse (section_data' true);  			}  			else  				Console.WriteLine ("Unhandled Chk section type {0}' length {1}"' section_name' section_data.Length);
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ParseSection,The following statement contains a magic number: if (section_name == "TYPE") {  				scenarioType = Util.ReadWord (section_data' 0);  			}  			else if (section_name == "ERA ")  				tileSet = (Tileset)Util.ReadWord (section_data' 0);  			else if (section_name == "DIM ") {  				width = Util.ReadWord (section_data' 0);  				height = Util.ReadWord (section_data' 2);  			}  			else if (section_name == "MTXM") {  				mapTiles = new ushort[width'height];  				int y' x;  				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapTiles[x'y] = Util.ReadWord (section_data' (y*width + x)*2);  			}  			else if (section_name == "MASK") {  				mapMask = new byte[width'height];  				int y' x;  				int i = 0;    				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapMask[x'y] = section_data [i++];  			}  			else if (section_name == "SPRP") {  				int nameStringIndex = Util.ReadWord (section_data' 0);  				int descriptionStringIndex = Util.ReadWord (section_data' 2);    				Console.WriteLine ("mapName = {0}"' nameStringIndex);  				Console.WriteLine ("mapDescription = {0}"' descriptionStringIndex);  				mapName = GetMapString (nameStringIndex);  				mapDescription = GetMapString (descriptionStringIndex);  			}  			else if (section_name == "STR ") {  				ReadStrings (section_data);  			}  			else if (section_name == "OWNR") {  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					/*   					   00 - Unused  					   03 - Rescuable  					   05 - Computer  					   06 - Human  					   07 - Neutral  					*/  					if (section_data[i] == 0x05)  						numComputerSlots ++;  					else if (section_data[i] == 0x06)  						numHumanSlots ++;  				}  			}  			else if (section_name == "SIDE") {  				/*  				  00 - Zerg  				  01 - Terran  				  02 - Protoss  				  03 - Independent  				  04 - Neutral  				  05 - User Select  				  07 - Inactive  				  10 - Human  				*/  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					if (section_data[i] == 0x05) /* user select */  						numPlayers++;  				}  			}  			else if (section_name == "UNIT") {  				ReadUnits (section_data);  			}  			else if (section_name == "MBRF") {  				briefingData = new TriggerData();  				briefingData.Parse (section_data' true);  			}  			else  				Console.WriteLine ("Unhandled Chk section type {0}' length {1}"' section_name' section_data.Length);
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ParseSection,The following statement contains a magic number: if (section_name == "TYPE") {  				scenarioType = Util.ReadWord (section_data' 0);  			}  			else if (section_name == "ERA ")  				tileSet = (Tileset)Util.ReadWord (section_data' 0);  			else if (section_name == "DIM ") {  				width = Util.ReadWord (section_data' 0);  				height = Util.ReadWord (section_data' 2);  			}  			else if (section_name == "MTXM") {  				mapTiles = new ushort[width'height];  				int y' x;  				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapTiles[x'y] = Util.ReadWord (section_data' (y*width + x)*2);  			}  			else if (section_name == "MASK") {  				mapMask = new byte[width'height];  				int y' x;  				int i = 0;    				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapMask[x'y] = section_data [i++];  			}  			else if (section_name == "SPRP") {  				int nameStringIndex = Util.ReadWord (section_data' 0);  				int descriptionStringIndex = Util.ReadWord (section_data' 2);    				Console.WriteLine ("mapName = {0}"' nameStringIndex);  				Console.WriteLine ("mapDescription = {0}"' descriptionStringIndex);  				mapName = GetMapString (nameStringIndex);  				mapDescription = GetMapString (descriptionStringIndex);  			}  			else if (section_name == "STR ") {  				ReadStrings (section_data);  			}  			else if (section_name == "OWNR") {  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					/*   					   00 - Unused  					   03 - Rescuable  					   05 - Computer  					   06 - Human  					   07 - Neutral  					*/  					if (section_data[i] == 0x05)  						numComputerSlots ++;  					else if (section_data[i] == 0x06)  						numHumanSlots ++;  				}  			}  			else if (section_name == "SIDE") {  				/*  				  00 - Zerg  				  01 - Terran  				  02 - Protoss  				  03 - Independent  				  04 - Neutral  				  05 - User Select  				  07 - Inactive  				  10 - Human  				*/  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					if (section_data[i] == 0x05) /* user select */  						numPlayers++;  				}  			}  			else if (section_name == "UNIT") {  				ReadUnits (section_data);  			}  			else if (section_name == "MBRF") {  				briefingData = new TriggerData();  				briefingData.Parse (section_data' true);  			}  			else  				Console.WriteLine ("Unhandled Chk section type {0}' length {1}"' section_name' section_data.Length);
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ParseSection,The following statement contains a magic number: if (section_name == "TYPE") {  				scenarioType = Util.ReadWord (section_data' 0);  			}  			else if (section_name == "ERA ")  				tileSet = (Tileset)Util.ReadWord (section_data' 0);  			else if (section_name == "DIM ") {  				width = Util.ReadWord (section_data' 0);  				height = Util.ReadWord (section_data' 2);  			}  			else if (section_name == "MTXM") {  				mapTiles = new ushort[width'height];  				int y' x;  				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapTiles[x'y] = Util.ReadWord (section_data' (y*width + x)*2);  			}  			else if (section_name == "MASK") {  				mapMask = new byte[width'height];  				int y' x;  				int i = 0;    				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapMask[x'y] = section_data [i++];  			}  			else if (section_name == "SPRP") {  				int nameStringIndex = Util.ReadWord (section_data' 0);  				int descriptionStringIndex = Util.ReadWord (section_data' 2);    				Console.WriteLine ("mapName = {0}"' nameStringIndex);  				Console.WriteLine ("mapDescription = {0}"' descriptionStringIndex);  				mapName = GetMapString (nameStringIndex);  				mapDescription = GetMapString (descriptionStringIndex);  			}  			else if (section_name == "STR ") {  				ReadStrings (section_data);  			}  			else if (section_name == "OWNR") {  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					/*   					   00 - Unused  					   03 - Rescuable  					   05 - Computer  					   06 - Human  					   07 - Neutral  					*/  					if (section_data[i] == 0x05)  						numComputerSlots ++;  					else if (section_data[i] == 0x06)  						numHumanSlots ++;  				}  			}  			else if (section_name == "SIDE") {  				/*  				  00 - Zerg  				  01 - Terran  				  02 - Protoss  				  03 - Independent  				  04 - Neutral  				  05 - User Select  				  07 - Inactive  				  10 - Human  				*/  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					if (section_data[i] == 0x05) /* user select */  						numPlayers++;  				}  			}  			else if (section_name == "UNIT") {  				ReadUnits (section_data);  			}  			else if (section_name == "MBRF") {  				briefingData = new TriggerData();  				briefingData.Parse (section_data' true);  			}  			else  				Console.WriteLine ("Unhandled Chk section type {0}' length {1}"' section_name' section_data.Length);
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ParseSection,The following statement contains a magic number: if (section_name == "TYPE") {  				scenarioType = Util.ReadWord (section_data' 0);  			}  			else if (section_name == "ERA ")  				tileSet = (Tileset)Util.ReadWord (section_data' 0);  			else if (section_name == "DIM ") {  				width = Util.ReadWord (section_data' 0);  				height = Util.ReadWord (section_data' 2);  			}  			else if (section_name == "MTXM") {  				mapTiles = new ushort[width'height];  				int y' x;  				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapTiles[x'y] = Util.ReadWord (section_data' (y*width + x)*2);  			}  			else if (section_name == "MASK") {  				mapMask = new byte[width'height];  				int y' x;  				int i = 0;    				for (y = 0; y < height; y ++)  					for (x = 0; x < width; x ++)  						mapMask[x'y] = section_data [i++];  			}  			else if (section_name == "SPRP") {  				int nameStringIndex = Util.ReadWord (section_data' 0);  				int descriptionStringIndex = Util.ReadWord (section_data' 2);    				Console.WriteLine ("mapName = {0}"' nameStringIndex);  				Console.WriteLine ("mapDescription = {0}"' descriptionStringIndex);  				mapName = GetMapString (nameStringIndex);  				mapDescription = GetMapString (descriptionStringIndex);  			}  			else if (section_name == "STR ") {  				ReadStrings (section_data);  			}  			else if (section_name == "OWNR") {  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					/*   					   00 - Unused  					   03 - Rescuable  					   05 - Computer  					   06 - Human  					   07 - Neutral  					*/  					if (section_data[i] == 0x05)  						numComputerSlots ++;  					else if (section_data[i] == 0x06)  						numHumanSlots ++;  				}  			}  			else if (section_name == "SIDE") {  				/*  				  00 - Zerg  				  01 - Terran  				  02 - Protoss  				  03 - Independent  				  04 - Neutral  				  05 - User Select  				  07 - Inactive  				  10 - Human  				*/  				numPlayers = 0;  				for (int i = 0; i < 12; i ++) {  					if (section_data[i] == 0x05) /* user select */  						numPlayers++;  				}  			}  			else if (section_name == "UNIT") {  				ReadUnits (section_data);  			}  			else if (section_name == "MBRF") {  				briefingData = new TriggerData();  				briefingData.Parse (section_data' true);  			}  			else  				Console.WriteLine ("Unhandled Chk section type {0}' length {1}"' section_name' section_data.Length);
Magic Number,SCSharp,Chk,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,ReadUnits,The following statement contains a magic number: while (i <= data.Length / 36) {  				/*uint serial =*/ Util.ReadDWord (stream);  				ushort x = Util.ReadWord (stream);  				ushort y = Util.ReadWord (stream);  				ushort type = Util.ReadWord (stream);  				Util.ReadWord (stream);  				Util.ReadWord (stream);  				Util.ReadWord (stream);  				byte player = Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadDWord (stream);  				Util.ReadWord (stream);  				Util.ReadWord (stream);    				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				Util.ReadByte (stream);  				i++;    				UnitInfo info = new UnitInfo ();  				info.unit_id = type;  				info.x = x;  				info.y = y;  				info.player = player;    				units.Add (info);  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < conditions.Length; i ++) {  				TriggerCondition c = new TriggerCondition ();  				c.Number = Util.ReadDWord (data' offset); offset += 4;  				c.Group = Util.ReadDWord (data' offset); offset += 4;  				c.Amount = Util.ReadDWord (data' offset); offset += 4;  				c.UnitType = Util.ReadWord (data' offset); offset += 2;  				c.ComparisonSwitch = data[offset++];  				c.Condition = data[offset++];  				c.Resource = data[offset++];  				c.Flags = data[offset++];    				// padding  				offset += 2;    				conditions[i] = c;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < conditions.Length; i ++) {  				TriggerCondition c = new TriggerCondition ();  				c.Number = Util.ReadDWord (data' offset); offset += 4;  				c.Group = Util.ReadDWord (data' offset); offset += 4;  				c.Amount = Util.ReadDWord (data' offset); offset += 4;  				c.UnitType = Util.ReadWord (data' offset); offset += 2;  				c.ComparisonSwitch = data[offset++];  				c.Condition = data[offset++];  				c.Resource = data[offset++];  				c.Flags = data[offset++];    				// padding  				offset += 2;    				conditions[i] = c;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < conditions.Length; i ++) {  				TriggerCondition c = new TriggerCondition ();  				c.Number = Util.ReadDWord (data' offset); offset += 4;  				c.Group = Util.ReadDWord (data' offset); offset += 4;  				c.Amount = Util.ReadDWord (data' offset); offset += 4;  				c.UnitType = Util.ReadWord (data' offset); offset += 2;  				c.ComparisonSwitch = data[offset++];  				c.Condition = data[offset++];  				c.Resource = data[offset++];  				c.Flags = data[offset++];    				// padding  				offset += 2;    				conditions[i] = c;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < conditions.Length; i ++) {  				TriggerCondition c = new TriggerCondition ();  				c.Number = Util.ReadDWord (data' offset); offset += 4;  				c.Group = Util.ReadDWord (data' offset); offset += 4;  				c.Amount = Util.ReadDWord (data' offset); offset += 4;  				c.UnitType = Util.ReadWord (data' offset); offset += 2;  				c.ComparisonSwitch = data[offset++];  				c.Condition = data[offset++];  				c.Resource = data[offset++];  				c.Flags = data[offset++];    				// padding  				offset += 2;    				conditions[i] = c;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < conditions.Length; i ++) {  				TriggerCondition c = new TriggerCondition ();  				c.Number = Util.ReadDWord (data' offset); offset += 4;  				c.Group = Util.ReadDWord (data' offset); offset += 4;  				c.Amount = Util.ReadDWord (data' offset); offset += 4;  				c.UnitType = Util.ReadWord (data' offset); offset += 2;  				c.ComparisonSwitch = data[offset++];  				c.Condition = data[offset++];  				c.Resource = data[offset++];  				c.Flags = data[offset++];    				// padding  				offset += 2;    				conditions[i] = c;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: for (i = 0; i < actions.Length; i ++) {  				TriggerAction a = new TriggerAction ();  				  				a.Location = Util.ReadDWord (data' offset); offset += 4;  				a.TextIndex = Util.ReadDWord (data' offset); offset += 4;  				a.WavIndex = Util.ReadWord (data' offset); offset += 4;  				a.Delay = Util.ReadDWord (data' offset); offset += 4;  				a.Group1 = Util.ReadDWord (data' offset); offset += 4;  				a.Group2 = Util.ReadDWord (data' offset); offset += 4;  				a.UnitType = Util.ReadWord (data' offset); offset += 2;  				a.Action = data[offset++];  				a.Switch = data[offset++];  				a.Flags = data[offset++];    				// padding  				offset += 3;    				actions[i] = a;  			}
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: offset += 4;
Magic Number,SCSharp,Trigger,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Chk.cs,Parse,The following statement contains a magic number: offset += 28;
Magic Number,SCSharp,DatVariable,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Dat.cs,BlockSize,The following statement contains a magic number: switch (type) {  			case DatVariableType.Byte:  				return num_entries;  			case DatVariableType.Word:  				return num_entries * 2;  			case DatVariableType.DWord:  				return num_entries * 4;  			default:  				return 0;  			}
Magic Number,SCSharp,DatVariable,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Dat.cs,BlockSize,The following statement contains a magic number: switch (type) {  			case DatVariableType.Byte:  				return num_entries;  			case DatVariableType.Word:  				return num_entries * 2;  			case DatVariableType.DWord:  				return num_entries * 4;  			default:  				return 0;  			}
Magic Number,SCSharp,Fnt,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Fnt.cs,GetGlyph,The following statement contains a magic number: while (true) {  				byte b = Util.ReadByte (stream);  				int count = (b & 0xF8) >> 3;  				byte cmap_entry = (byte)(b & 0x07);    				for (int i = 0; i < count; i ++) {  					bitmap[y'x] = 0;  					x--;  					if (x < 0) {  						x = letterWidth - 1;  						y--;  						if (y < 0)  							goto done;  					}  				}    				bitmap[y'x] = (byte)cmap_entry;  				x--;  				if (x < 0) {  					x = letterWidth - 1;  					y--;  					if (y < 0)  						goto done;  				}  			}
Magic Number,SCSharp,Grp,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Grp.cs,GetFrame,The following statement contains a magic number: line_offsets = new ushort[old/2+1];
Magic Number,SCSharp,Grp,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Grp.cs,GetFrame,The following statement contains a magic number: for (i = 1; i < old / 2; i ++)  				line_offsets[i] = Util.ReadWord(stream);
Magic Number,SCSharp,Grp,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\Grp.cs,GetFrame,The following statement contains a magic number: for (i = 0; i < line_offsets.Length - 2; i ++) {  				DecodeLine (grid' height - i - entries[frame].yOffset' entries[frame].xOffset' (ushort)(line_offsets[i + 1] - line_offsets[i])' width);  			}
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,PointsToSCPE,The following statement contains a magic number: return (buf[p] == 0x53  				&& buf[p+1] == 0x43  				&& buf[p+2] == 0x50  				&& buf[p+3] == 0x45);
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,PointsToSCPE,The following statement contains a magic number: return (buf[p] == 0x53  				&& buf[p+1] == 0x43  				&& buf[p+2] == 0x50  				&& buf[p+3] == 0x45);
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: int p = buf.Length - 8;
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: int o = Util.ReadWord (buf' p + 2);
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: while (PointsToSCPE (Util.ReadWord (buf' p + 2)))  				p -= 4;
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: while (PointsToSCPE (Util.ReadWord (buf' p + 2)))  				p -= 4;
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: Console.WriteLine ("iscript.bin contains {0} entries"'  					   (buf.Length - p) / 4 - 2);
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: Console.WriteLine ("iscript.bin contains {0} entries"'  					   (buf.Length - p) / 4 - 2);
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: while (p < buf.Length - 4) {  				ushort images_id = Util.ReadWord (buf' p);  				ushort offset = Util.ReadWord (buf' p+2);  				entries[images_id] = offset;    				Console.WriteLine ("id: {0}   offset: {1:X}"' images_id' offset);    				p += 4;  			}
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: while (p < buf.Length - 4) {  				ushort images_id = Util.ReadWord (buf' p);  				ushort offset = Util.ReadWord (buf' p+2);  				entries[images_id] = offset;    				Console.WriteLine ("id: {0}   offset: {1:X}"' images_id' offset);    				p += 4;  			}
Magic Number,SCSharp,IScriptBin,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\IScriptBin.cs,ReadFromStream,The following statement contains a magic number: while (p < buf.Length - 4) {  				ushort images_id = Util.ReadWord (buf' p);  				ushort offset = Util.ReadWord (buf' p+2);  				entries[images_id] = offset;    				Console.WriteLine ("id: {0}   offset: {1:X}"' images_id' offset);    				p += 4;  			}
Magic Number,SCSharp,MapDataDat,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MapDataDat.cs,MapDataDat,The following statement contains a magic number: indexBlockId = AddVariableBlock (32' DatVariableType.DWord);
Magic Number,SCSharp,PortDataDat,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PortDataDat.cs,PortDataDat,The following statement contains a magic number: portraitIndexBlock = AddVariableBlock (360' DatVariableType.DWord);
Magic Number,SCSharp,SpritesDat,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\SpritesDat.cs,SpritesDat,The following statement contains a magic number: imageIndexBlockId = AddVariableBlock (386' DatVariableType.Word);
Magic Number,SCSharp,UnitsDat,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\UnitsDat.cs,UnitsDat,The following statement contains a magic number: yesSoundStartBlockId = AddPlacedVariableBlock (yessoundstart_offset' 105/*Is this right?*/' DatVariableType.Word);
Magic Number,SCSharp,UnitsDat,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\UnitsDat.cs,UnitsDat,The following statement contains a magic number: yesSoundEndBlockId = AddPlacedVariableBlock (yessoundend_offset' 105/*Is this right?*/' DatVariableType.Word);
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadWord,The following statement contains a magic number: return ((ushort)(fs.ReadByte () | (fs.ReadByte() << 8)));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadWord,The following statement contains a magic number: return ((ushort)((int)buf[position] | (int)buf[position+1] << 8));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return (uint)(fs.ReadByte () | (fs.ReadByte() << 8) | (fs.ReadByte() << 16) | (fs.ReadByte() << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return (uint)(fs.ReadByte () | (fs.ReadByte() << 8) | (fs.ReadByte() << 16) | (fs.ReadByte() << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return (uint)(fs.ReadByte () | (fs.ReadByte() << 8) | (fs.ReadByte() << 16) | (fs.ReadByte() << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return ((uint)((uint)buf[position] | (uint)buf[position+1] << 8 | (uint)buf[position+2] << 16 | (uint)buf[position+3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return ((uint)((uint)buf[position] | (uint)buf[position+1] << 8 | (uint)buf[position+2] << 16 | (uint)buf[position+3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return ((uint)((uint)buf[position] | (uint)buf[position+1] << 8 | (uint)buf[position+2] << 16 | (uint)buf[position+3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return ((uint)((uint)buf[position] | (uint)buf[position+1] << 8 | (uint)buf[position+2] << 16 | (uint)buf[position+3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,ReadDWord,The following statement contains a magic number: return ((uint)((uint)buf[position] | (uint)buf[position+1] << 8 | (uint)buf[position+2] << 16 | (uint)buf[position+3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,WriteWord,The following statement contains a magic number: fs.WriteByte ((byte)((word >> 8) & 0xff));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,WriteDWord,The following statement contains a magic number: fs.WriteByte ((byte)((dword >> 8) & 0xff));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,WriteDWord,The following statement contains a magic number: fs.WriteByte ((byte)((dword >> 16) & 0xff));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,WriteDWord,The following statement contains a magic number: fs.WriteByte ((byte)((dword >> 24) & 0xff));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,MakeTag,The following statement contains a magic number: if (chars.Length != 4)  				throw new ArgumentException("We need 4 chars");
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,MakeTag,The following statement contains a magic number: return (uint)(chars[0] | (chars[1] << 8) | (chars[2] << 16) | (chars[3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,MakeTag,The following statement contains a magic number: return (uint)(chars[0] | (chars[1] << 8) | (chars[2] << 16) | (chars[3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,MakeTag,The following statement contains a magic number: return (uint)(chars[0] | (chars[1] << 8) | (chars[2] << 16) | (chars[3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,MakeTag,The following statement contains a magic number: return (uint)(chars[0] | (chars[1] << 8) | (chars[2] << 16) | (chars[3] << 24));
Magic Number,SCSharp,Util,C:\repos\toshok_scsharp\SCSharp\SCSharp.Util\Util.cs,MakeTag,The following statement contains a magic number: return (uint)(chars[0] | (chars[1] << 8) | (chars[2] << 16) | (chars[3] << 24));
Magic Number,MpqReader,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\BitStream.cs,ReadBits,The following statement contains a magic number: if (BitCount > 16)  				throw new ArgumentOutOfRangeException("BitCount"' "Maximum BitCount is 16");
Magic Number,MpqReader,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\BitStream.cs,ReadBits,The following statement contains a magic number: int result = mCurrent & (0xffff >> (16 - BitCount));
Magic Number,MpqReader,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\BitStream.cs,PeekByte,The following statement contains a magic number: if (EnsureBits(8) == false) return -1;
Magic Number,MpqReader,BitStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\BitStream.cs,EnsureBits,The following statement contains a magic number: mBitCount += 8;
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,HashString,The following statement contains a magic number: foreach(char c in Input)  			{  				int val = (int)char.ToUpper(c);  				seed1 = sStormBuffer[Offset + val] ^ (seed1 + seed2);  				seed2 = (uint)val + seed1 + seed2 + (seed2 << 5) + 3;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,HashString,The following statement contains a magic number: foreach(char c in Input)  			{  				int val = (int)char.ToUpper(c);  				seed1 = sStormBuffer[Offset + val] ^ (seed1 + seed2);  				seed2 = (uint)val + seed1 + seed2 + (seed2 << 5) + 3;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian) {  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else {  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;  				  				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;  				  				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;  				  				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;  				  				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted) continue;    				uint saveseed1 = seed1;  				  				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				  				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);  				  				if ((result & 0xffff0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted) continue;    				uint saveseed1 = seed1;  				  				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				  				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);  				  				if ((result & 0xffff0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted) continue;    				uint saveseed1 = seed1;  				  				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				  				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);  				  				if ((result & 0xffff0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted) continue;    				uint saveseed1 = seed1;  				  				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				  				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);  				  				if ((result & 0xffff0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for(uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for(int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2]  = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for(uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for(int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2]  = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for(uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for(int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2]  = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for(uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for(int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2]  = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for(uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for(int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2]  = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for(uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for(int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2]  = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,BuildList,The following statement contains a magic number: root = new LinkedNode(256' 1);
Magic Number,MpqReader,MpqHuffman,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqHuffman.cs,BuildList,The following statement contains a magic number: root = root.Insert(new LinkedNode(257' 1));
Magic Number,MpqReader,MpqStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqStream.cs,LoadBlockPositions,The following statement contains a magic number: uint blockpossize = (uint)blockposcount * 4;
Magic Number,MpqReader,MpqStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqStream.cs,LoadBlock,The following statement contains a magic number: if (mBlock.IsEncrypted && mBlock.FileSize > 3)  			{  				if (mSeed1 == 0)  					throw new Exception("Unable to determine encryption key");  				MpqArchive.DecryptBlock(data' (uint)(mSeed1 + BlockIndex));  			}
Magic Number,MpqReader,MpqStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqStream.cs,DecompressMulti,The following statement contains a magic number: if ((comptype & 8) != 0)  			{  				byte[] result = PKDecompress(sinput' OutputLength);  				comptype &= 0xF7;  				if (comptype == 0) return result;  				sinput = new MemoryStream(result);  			}
Magic Number,MpqReader,MpqStream,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqStream.cs,DecompressMulti,The following statement contains a magic number: if ((comptype & 0x80) != 0)  			{  				byte[] result = MpqWavCompression.Decompress(sinput' 2);  				comptype &= 0x7f;  				if (comptype == 0) return result;  				sinput = new MemoryStream(result);  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,PKLibDecompress,The following statement contains a magic number: if(4 > mDSizeBits || mDSizeBits > 6)  				throw new Exception("Invalid dictionary size: " + mDSizeBits);
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,PKLibDecompress,The following statement contains a magic number: if(4 > mDSizeBits || mDSizeBits > 6)  				throw new Exception("Invalid dictionary size: " + mDSizeBits);
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,DecodeLit,The following statement contains a magic number: switch(mStream.ReadBits(1))  			{  				case -1:  					return -1;  					  				case 1:  					// The next bits are position in buffers  					int pos = sPosition2[mStream.PeekByte()];    					// Skip the bits we just used  					if (mStream.ReadBits(sLenBits[pos]) == -1) return -1;  	  					int nbits = sExLenBits[pos];  					if(nbits != 0)  					{  						// TODO: Verify this conversion  						int val2 = mStream.ReadBits(nbits);  						if (val2 == -1 && (pos + val2 != 0x10e)) return -1;    						pos = sLenBase[pos] + val2;  					}  					return pos + 0x100; // Return number of bytes to repeat    				case 0:  					if (mCType == CompressionType.Binary)  						return mStream.ReadBits(8);    					// TODO: Text mode  					throw new NotImplementedException("Text mode is not yet implemented");  				default:  					return 0;  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if (mStream.EnsureBits(8) == false) return 0;
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\toshok_scsharp\SCSharp\SCSharp.Mpq\PKLibDecompress.cs,GenerateDecodeTable,The following statement contains a magic number: byte[] result = new byte[256];
