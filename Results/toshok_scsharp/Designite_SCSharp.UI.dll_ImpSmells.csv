Implementation smell,Namespace,Class,File,Method,Description
Long Method,SCSharp.UI,Game,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Game.cs,Game,The method has 143 lines of code.
Long Method,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The method has 121 lines of code.
Long Method,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The method has 103 lines of code.
Long Method,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The method has 359 lines of code.
Complex Method,SCSharp.UI,AStarSolver,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\AStar.cs,FindPath,Cyclomatic complexity of the method is 8
Complex Method,SCSharp.UI,Game,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Game.cs,Game,Cyclomatic complexity of the method is 21
Complex Method,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,Cyclomatic complexity of the method is 8
Complex Method,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,Cyclomatic complexity of the method is 10
Complex Method,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,ComposeText,Cyclomatic complexity of the method is 14
Complex Method,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,Cyclomatic complexity of the method is 10
Complex Method,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,Cyclomatic complexity of the method is 8
Complex Method,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,Cyclomatic complexity of the method is 9
Complex Method,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,Cyclomatic complexity of the method is 9
Complex Method,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,PopulateFileList,Cyclomatic complexity of the method is 9
Complex Method,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,UpdatePlayersDisplay,Cyclomatic complexity of the method is 8
Complex Method,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,ResourceLoader,Cyclomatic complexity of the method is 12
Long Parameter List,SCSharp.UI,DialogBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\DialogBoxElement.cs,TileRow,The method has 7 parameters. Parameters: surf' grp' pal' l' c' r' y
Long Parameter List,SCSharp.UI,GrpButtonElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GrpButtonElement.cs,GrpButtonElement,The method has 5 parameters. Parameters: screen' grp' palette' x' y
Long Parameter List,SCSharp.UI,GrpElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GrpElement.cs,GrpElement,The method has 5 parameters. Parameters: screen' grp' palette' x' y
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,ComposeText,The method has 6 parameters. Parameters: text' font' palette' width' height' offset
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurface,The method has 9 parameters. Parameters: data' width' height' depth' stride' rmask' gmask' bmask' amask
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromRGBAData,The method has 5 parameters. Parameters: data' width' height' depth' stride
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromRGBData,The method has 5 parameters. Parameters: data' width' height' depth' stride
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The method has 5 parameters. Parameters: grid' width' height' palette' with_alpha
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The method has 6 parameters. Parameters: grid' width' height' palette' translucent_index' transparent_index
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The method has 5 parameters. Parameters: grid' width' height' palette' with_alpha
Long Parameter List,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The method has 6 parameters. Parameters: grid' width' height' palette' translucent_index' transparent_index
Long Parameter List,SCSharp.UI,ImageElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ImageElement.cs,ImageElement,The method has 6 parameters. Parameters: screen' x1' y1' width' height' translucent_index
Long Parameter List,SCSharp.UI,LabelElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LabelElement.cs,LabelElement,The method has 5 parameters. Parameters: screen' palette' font' x' y
Long Parameter List,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,AddMovieElements,The method has 6 parameters. Parameters: elementIndex' normalMovie' onMovie' off_x' off_y' on_movie_on_top
Long Parameter List,SCSharp.UI,MovieElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MovieElement.cs,MovieElement,The method has 5 parameters. Parameters: screen' el' palette' resource' scale
Long Parameter List,SCSharp.UI,MovieElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MovieElement.cs,MovieElement,The method has 6 parameters. Parameters: screen' x' y' width' height' scale
Long Parameter List,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ReadyRoomScreen,The method has 9 parameters. Parameters: mpq' scenario_prefix' start_element_index' cancel_element_index' skiptutorial_element_index' replay_element_index' transmission_element_index' objectives_element_index' first_portrait_element_index
Long Parameter List,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Sprite,The method has 5 parameters. Parameters: mpq' sprite_entry' palette' x' y
Long Parameter List,SCSharp.UI,SpriteManager,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\SpriteManager.cs,CreateSprite,The method has 5 parameters. Parameters: mpq' sprite_number' palette' x' y
Long Parameter List,SCSharp.UI,UIElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIElement.cs,UIElement,The method has 5 parameters. Parameters: screen' x1' y1' width' height
Long Identifier,SCSharp.UI,GameMenuDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameMenuDialog.cs,,The length of the parameter MISSIONOBJECTIVES_ELEMENT_INDEX is 31.
Long Identifier,SCSharp.UI,LoadSavedScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LoadSavedScreen.cs,,The length of the parameter SAVEDGAME_LISTBOX_ELEMENT_INDEX is 31.
Long Identifier,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,,The length of the parameter GAMESUBTYPE_LABEL_ELEMENT_INDEX is 31.
Long Identifier,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,,The length of the parameter GAMESUBTYPE_COMBO_ELEMENT_INDEX is 31.
Long Identifier,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,,The length of the parameter SECOND_BUT_FIRST_INCOMPLETE_INDEX is 33.
Long Identifier,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,,The length of the parameter THIRD_BUT_FIRST_INCOMPLETE_INDEX is 32.
Long Identifier,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,,The length of the parameter THIRD_BUT_SECOND_INCOMPLETE_INDEX is 33.
Long Statement,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintMinimap,The length of the statement  "			Rectangle rect = new Rectangle (new Point ((int)((float)topleft_x / (float)mapRenderer.MapWidth * MINIMAP_WIDTH + MINIMAP_X)' " is 125.
Long Statement,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The length of the statement  "			AddMovieElements (SINGLEPLAYER_ELEMENT_INDEX' "glue\\mainmenu\\Single.smk"' "glue\\mainmenu\\SingleOn.smk"' 50' 70' false); " is 123.
Long Statement,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The length of the statement  "			AddMovieElements (CAMPAIGNEDITOR_ELEMENT_INDEX' "glue\\mainmenu\\Editor.smk"' "glue\\mainmenu\\EditorOn.smk"' 20' 18' true); " is 124.
Long Statement,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToSurface,The length of the statement  "			return GuiUtil.CreateSurfaceFromRGBAData (bitmap' (ushort)pixel_width' (ushort)pixel_height' 32' (ushort)(pixel_width * 4)); " is 124.
Long Statement,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,SelectCampaign,The length of the statement  "			mapdata_index = GlobalResources.Instance.MapDataDat.FileIndexes [(Game.Instance.PlayingBroodWar ? BroodwarCampaigns : StarcraftCampaigns)[campaign].mapDataStart]; " is 162.
Long Statement,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The length of the statement  "				diskPlayer = new SmackerPlayer ((Stream)Mpq.GetResource (Game.Instance.PlayingBroodWar ? "glue\\Expcampaign\\disk.smk" : "glue\\campaign\\disk.smk")' 1); " is 153.
Long Statement,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The length of the statement  "			diskElement.X1 = (ushort)(Elements[elementIndex].X1 + ((Elements[elementIndex].Width - diskElement.MovieSize.Width) / 2)); " is 122.
Long Statement,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The length of the statement  "			normalElement.X1 = (ushort)(Elements[elementIndex].X1 + ((Elements[elementIndex].Width - normalElement.MovieSize.Width) / 2) + off_x); " is 134.
Long Statement,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The length of the statement  "			normalElement.Y1 = (ushort)(((ButtonElement)Elements[elementIndex]).TextPosition.Y - normalElement.MovieSize.Height + off_y); " is 125.
Long Statement,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The length of the statement  "					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"' " is 167.
Long Statement,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The length of the statement  "				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X) " is 128.
Long Statement,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The length of the statement  "				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]); " is 147.
Complex Conditional,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,UpdateCursor,The conditional expression  "cursor_x < sx + half_width && cursor_x > sx - half_width  					    && cursor_y < sy + half_height && cursor_y > sy - half_height"  is complex.
Complex Conditional,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The conditional expression  "args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT"  is complex.
Complex Conditional,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The conditional expression  "(megatile_x >= chk.Width || megatile_x < 0) ||  			    (megatile_y >= chk.Height || megatile_y < 0)"  is complex.
Complex Conditional,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Invalidate,The conditional expression  "r.X >= Painter.SCREEN_RES_X  			    || r.Y >= Painter.SCREEN_RES_Y  			    || r.X + r.Width <= 0  			    || r.Y + r.Height <= 0"  is complex.
Complex Conditional,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The conditional expression  "(x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)"  is complex.
Complex Conditional,SCSharp.UI,TitleScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\TitleScreen.cs,LoadingFlasher,The conditional expression  "(Elements[LOADING_ELEMENT_INDEX].Visible && (totalElapsed < FLASH_ON_DURATION)) ||  			    (!Elements[LOADING_ELEMENT_INDEX].Visible && (totalElapsed < FLASH_OFF_DURATION))"  is complex.
Complex Conditional,SCSharp.UI,UIElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIElement.cs,PointInside,The conditional expression  "x >= X1 && x < X1 + Width &&  			    y >= Y1 && y < Y1 + Height"  is complex.
Complex Conditional,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,KeyboardDown,The conditional expression  "(args.Key == e.Hotkey)  					     ||  					     (args.Key == Key.Return  					      && (e.Flags & ElementFlags.DefaultButton) == ElementFlags.DefaultButton)  					     ||  					     (args.Key == Key.Escape  					      && (e.Flags & ElementFlags.CancelButton) == ElementFlags.CancelButton)"  is complex.
Magic Number,SCSharp.UI,MapPoint,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\AStar.cs,GetHashCode,The following statement contains a magic number: return (33 * X) ^ (91 * Y);
Magic Number,SCSharp.UI,MapPoint,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\AStar.cs,GetHashCode,The following statement contains a magic number: return (33 * X) ^ (91 * Y);
Magic Number,SCSharp.UI,AStarSolver,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\AStar.cs,NeighborNodes,The following statement contains a magic number: for (int x = -1; x <= 1; x ++) {  				for (int y = -1; y <= 1; y ++) {  					MapPoint p = new MapPoint (x+point.X' y+point.Y);  					// Console.WriteLine ("checking neighbor {0}"' p);  					if (x == 0 && y == 0) { // disallow non-moves  						// Console.WriteLine ("no (1)");  						continue;  					}    					if (p.X < 0 || p.X >= (map.Chk.Width << 3)) {  						// Console.WriteLine ("no (2)");  						continue;  					}    					if (p.Y < 0 || p.Y >= (map.Chk.Height << 3)) {  						// Console.WriteLine ("no (3)");  						continue;  					}    					// don't move into walls  					if (!map.Navigable (p)) {  						// Console.WriteLine ("no (4)");  						continue;  					}    					// Console.WriteLine ("adding neighbor of {0}"' p);    					neighbors.Add (p);  				}  			}
Magic Number,SCSharp.UI,AStarSolver,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\AStar.cs,NeighborNodes,The following statement contains a magic number: for (int x = -1; x <= 1; x ++) {  				for (int y = -1; y <= 1; y ++) {  					MapPoint p = new MapPoint (x+point.X' y+point.Y);  					// Console.WriteLine ("checking neighbor {0}"' p);  					if (x == 0 && y == 0) { // disallow non-moves  						// Console.WriteLine ("no (1)");  						continue;  					}    					if (p.X < 0 || p.X >= (map.Chk.Width << 3)) {  						// Console.WriteLine ("no (2)");  						continue;  					}    					if (p.Y < 0 || p.Y >= (map.Chk.Height << 3)) {  						// Console.WriteLine ("no (3)");  						continue;  					}    					// don't move into walls  					if (!map.Navigable (p)) {  						// Console.WriteLine ("no (4)");  						continue;  					}    					// Console.WriteLine ("adding neighbor of {0}"' p);    					neighbors.Add (p);  				}  			}
Magic Number,SCSharp.UI,ButtonElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ButtonElement.cs,CalculateTextPosition,The following statement contains a magic number: if (text_surf == null)  				text_surf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  								 Sensitive ? 4 : 24);
Magic Number,SCSharp.UI,ButtonElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ButtonElement.cs,CalculateTextPosition,The following statement contains a magic number: if (text_surf == null)  				text_surf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  								 Sensitive ? 4 : 24);
Magic Number,SCSharp.UI,ButtonElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ButtonElement.cs,CalculateTextPosition,The following statement contains a magic number: if ((Flags & ElementFlags.CenterTextHoriz) == ElementFlags.CenterTextHoriz)  				text_x = (Width - text_surf.Width) / 2;  			else if ((Flags & ElementFlags.RightAlignText) == ElementFlags.RightAlignText)  				text_x = (Width - text_surf.Width);  			else  				text_x = 0;
Magic Number,SCSharp.UI,ButtonElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ButtonElement.cs,CalculateTextPosition,The following statement contains a magic number: if ((Flags & ElementFlags.CenterTextVert) == ElementFlags.CenterTextVert)  				text_y = (Height - text_surf.Height) / 2;  			else if ((Flags & ElementFlags.BottomAlignText) == ElementFlags.BottomAlignText)  				text_y = (Height - text_surf.Height);  			else  				text_y = 0;
Magic Number,SCSharp.UI,Cinematic,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Cinematic.cs,VideoPainter,The following statement contains a magic number: if (surf != null)  				Painter.Blit (surf'  					      new Point ((Painter.Width - surf.Width) / 2'  							 (Painter.Height - surf.Height) / 2));
Magic Number,SCSharp.UI,Cinematic,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Cinematic.cs,VideoPainter,The following statement contains a magic number: if (surf != null)  				Painter.Blit (surf'  					      new Point ((Painter.Width - surf.Width) / 2'  							 (Painter.Height - surf.Height) / 2));
Magic Number,SCSharp.UI,ComboBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ComboBoxElement.cs,CreateSurface,The following statement contains a magic number: if (cursor != -1) {  				Surface item_surface = GuiUtil.ComposeText (items[cursor]' Font' Palette' 4);    				item_surface.TransparentColor = Color.Black;  				surf.Blit (item_surface' new Point (0' 0));  			}
Magic Number,SCSharp.UI,ComboBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ComboBoxElement.cs,CreateDropdownSurface,The following statement contains a magic number: for (int i = 0; i < items.Count; i ++) {  				Surface item_surface = GuiUtil.ComposeText (items[i]' Font' Palette'  									    i == selected_item ? 4 : 24);    				item_surface.TransparentColor = Color.Black;    				dropdownSurface.Blit (item_surface' new Point (0' y));  				y += item_surface.Height;  			}
Magic Number,SCSharp.UI,ComboBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ComboBoxElement.cs,CreateDropdownSurface,The following statement contains a magic number: for (int i = 0; i < items.Count; i ++) {  				Surface item_surface = GuiUtil.ComposeText (items[i]' Font' Palette'  									    i == selected_item ? 4 : 24);    				item_surface.TransparentColor = Color.Black;    				dropdownSurface.Blit (item_surface' new Point (0' y));  				y += item_surface.Height;  			}
Magic Number,SCSharp.UI,CursorAnimator,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\CursorAnimator.cs,CursorAnimator,The following statement contains a magic number: this.x = 100;
Magic Number,SCSharp.UI,CursorAnimator,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\CursorAnimator.cs,CursorAnimator,The following statement contains a magic number: this.y = 100;
Magic Number,SCSharp.UI,DialogBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\DialogBoxElement.cs,TileRow,The following statement contains a magic number: Surface lsurf = GuiUtil.CreateSurfaceFromBitmap (grp.GetFrame (l)'  									 grp.Width' grp.Height'  									 pal'  									 41' 0);
Magic Number,SCSharp.UI,DialogBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\DialogBoxElement.cs,TileRow,The following statement contains a magic number: Surface csurf = GuiUtil.CreateSurfaceFromBitmap (grp.GetFrame (c)'  									 grp.Width' grp.Height'  									 pal'  									 41' 0);
Magic Number,SCSharp.UI,DialogBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\DialogBoxElement.cs,TileRow,The following statement contains a magic number: Surface rsurf = GuiUtil.CreateSurfaceFromBitmap (grp.GetFrame (r)'  									 grp.Width' grp.Height'  									 pal'  									 41' 0);
Magic Number,SCSharp.UI,DialogBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\DialogBoxElement.cs,CreateSurface,The following statement contains a magic number: if (ParentScreen.Background == null && ParentScreen.UseTiles) {  				Surface surf = new Surface (Width' Height);  				surf.Fill (new Rectangle (new Point (0'0)' new Size (Width' Height))'  					   Color.FromArgb (0'0'0'0));  				surf.TransparentColor = Color.Black; /* XXX */    				Pcx pal = new Pcx ();  				pal.ReadFromStream ((Stream)Mpq.GetResource ("unit\\cmdbtns\\ticon.pcx")'  						    -1' -1);    				/* tile the top border */  				TileRow (surf' tileGrp' pal.Palette' TILE_TL' TILE_T' TILE_TR' 0);    				/* tile everything down to the bottom border */  				for (int y = tileGrp.Height - 2; y < surf.Height - tileGrp.Height; y += tileGrp.Height - 2)  					TileRow (surf' tileGrp' pal.Palette' TILE_L' TILE_C' TILE_R' y);    				/* tile the bottom row */  				TileRow (surf' tileGrp' pal.Palette' TILE_BL' TILE_B' TILE_BR' surf.Height - tileGrp.Height);  				return surf;  			}  			else  				return null;
Magic Number,SCSharp.UI,DialogBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\DialogBoxElement.cs,CreateSurface,The following statement contains a magic number: if (ParentScreen.Background == null && ParentScreen.UseTiles) {  				Surface surf = new Surface (Width' Height);  				surf.Fill (new Rectangle (new Point (0'0)' new Size (Width' Height))'  					   Color.FromArgb (0'0'0'0));  				surf.TransparentColor = Color.Black; /* XXX */    				Pcx pal = new Pcx ();  				pal.ReadFromStream ((Stream)Mpq.GetResource ("unit\\cmdbtns\\ticon.pcx")'  						    -1' -1);    				/* tile the top border */  				TileRow (surf' tileGrp' pal.Palette' TILE_TL' TILE_T' TILE_TR' 0);    				/* tile everything down to the bottom border */  				for (int y = tileGrp.Height - 2; y < surf.Height - tileGrp.Height; y += tileGrp.Height - 2)  					TileRow (surf' tileGrp' pal.Palette' TILE_L' TILE_C' TILE_R' y);    				/* tile the bottom row */  				TileRow (surf' tileGrp' pal.Palette' TILE_BL' TILE_B' TILE_BR' surf.Height - tileGrp.Height);  				return surf;  			}  			else  				return null;
Magic Number,SCSharp.UI,GameModeDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameModeDialog.cs,GameModeDialog,The following statement contains a magic number: background_translucent = 42;
Magic Number,SCSharp.UI,GameModeDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameModeDialog.cs,ResourceLoader,The following statement contains a magic number: Elements[TITLE_ELEMENT_INDEX].Text = GlobalResources.Instance.BrooDat.GluAllTbl.Strings[172];
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,GameScreen,The following statement contains a magic number: ScrollCursors = new CursorAnimator[8];
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,GameScreen,The following statement contains a magic number: ScrollCursors = new CursorAnimator[8];
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PaintStarfield,The following statement contains a magic number: for (int i = starfield_layers.Length - 1; i >= 0; i --) {  				int scroll_x = (int)(topleft_x * factors[i]);  				int scroll_y = (int)(topleft_y * factors[i]);    				if (scroll_x > Painter.SCREEN_RES_X) scroll_x %= Painter.SCREEN_RES_X;  				if (scroll_y > 375) scroll_y %= 375;    				  				dest = new Rectangle (new Point (0'0)'  						      new Size (Painter.SCREEN_RES_X - scroll_x'  								375 - scroll_y));  				source = dest;  				source.X += scroll_x;  				source.Y += scroll_y;    				Painter.Blit (starfield_layers[i]'  					      dest' source);    				if (scroll_x != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 0)'  							      new Size (scroll_x' 375 - scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y += scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_y != 0) {  					dest = new Rectangle (new Point (0' 375 - scroll_y)'  							      new Size (Painter.SCREEN_RES_X - scroll_x' scroll_y));  					source = dest;  					source.X += scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}    				if (scroll_x != 0 || scroll_y != 0) {  					dest = new Rectangle (new Point (Painter.SCREEN_RES_X - scroll_x' 375 - scroll_y)'  							      new Size (scroll_x' scroll_y));  					source = dest;  					source.X -= Painter.SCREEN_RES_X - scroll_x;  					source.Y -= 375 - scroll_y;    					Painter.Blit (starfield_layers[i]'  						      dest' source);  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: hudElement = new ImageElement (this' 0' 0' 640' 480' TranslucentIndex);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: hudElement = new ImageElement (this' 0' 0' 640' 480' TranslucentIndex);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: portraitElement = new MovieElement (this' 415' 415' 48' 48' false);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: portraitElement = new MovieElement (this' 415' 415' 48' 48' false);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: portraitElement = new MovieElement (this' 415' 415' 48' 48' false);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: portraitElement = new MovieElement (this' 415' 415' 48' 48' false);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: if (scenario.Tileset == Tileset.Platform) {  				Spk starfield = (Spk)mpq.GetResource ("parallax\\star.spk");    				starfield_layers = new Surface [starfield.Layers.Length];  				for (int i = 0; i < starfield_layers.Length; i ++) {  					starfield_layers[i] = new Surface (Painter.SCREEN_RES_X' Painter.SCREEN_RES_Y);    					starfield_layers[i].TransparentColor = Color.Black;    					for (int o = 0; o < starfield.Layers[i].Objects.Length; o ++) {  						ParallaxObject obj = starfield.Layers[i].Objects[o];    						starfield_layers[i].Fill (new Rectangle (new Point (obj.X' obj.Y)' new Size (2'2))'  									  Color.White);  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: if (scenario.Tileset == Tileset.Platform) {  				Spk starfield = (Spk)mpq.GetResource ("parallax\\star.spk");    				starfield_layers = new Surface [starfield.Layers.Length];  				for (int i = 0; i < starfield_layers.Length; i ++) {  					starfield_layers[i] = new Surface (Painter.SCREEN_RES_X' Painter.SCREEN_RES_Y);    					starfield_layers[i].TransparentColor = Color.Black;    					for (int o = 0; o < starfield.Layers[i].Objects.Length; o ++) {  						ParallaxObject obj = starfield.Layers[i].Objects[o];    						starfield_layers[i].Fill (new Rectangle (new Point (obj.X' obj.Y)' new Size (2'2))'  									  Color.White);  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < cursornames.Length; i ++) {  				ScrollCursors[i] = new CursorAnimator ((Grp)mpq.GetResource (cursornames[i])'  								       effectpal.Palette);  				ScrollCursors[i].SetHotSpot (60' 60);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < cursornames.Length; i ++) {  				ScrollCursors[i] = new CursorAnimator ((Grp)mpq.GetResource (cursornames[i])'  								       effectpal.Palette);  				ScrollCursors[i].SetHotSpot (60' 60);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < magcursornames.Length; i ++) {  				MagCursors[i] = new CursorAnimator ((Grp)mpq.GetResource (magcursornames[i])'  								    effectpal.Palette);  				MagCursors[i].SetHotSpot (60' 60);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < magcursornames.Length; i ++) {  				MagCursors[i] = new CursorAnimator ((Grp)mpq.GetResource (magcursornames[i])'  								    effectpal.Palette);  				MagCursors[i].SetHotSpot (60' 60);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < targetcursornames.Length; i ++) {  				TargetCursors[i] = new CursorAnimator ((Grp)mpq.GetResource (targetcursornames[i])'  								       effectpal.Palette);  				TargetCursors[i].SetHotSpot (60' 60);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < targetcursornames.Length; i ++) {  				TargetCursors[i] = new CursorAnimator ((Grp)mpq.GetResource (targetcursornames[i])'  								       effectpal.Palette);  				TargetCursors[i].SetHotSpot (60' 60);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: wireframeElement = new GrpElement (this' wireframe' cmdicon_palette' 170' 390);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: wireframeElement = new GrpElement (this' wireframe' cmdicon_palette' 170' 390);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.UnitName] = new LabelElement (this' fontpal.Palette'  										   GuiUtil.GetFonts (Mpq)[1]'  										   254' 390);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.UnitName] = new LabelElement (this' fontpal.Palette'  										   GuiUtil.GetFonts (Mpq)[1]'  										   254' 390);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceUsed] = new LabelElement (this' fontpal.Palette'  										       GuiUtil.GetFonts (Mpq)[0]'  										       292' 420);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceUsed] = new LabelElement (this' fontpal.Palette'  										       GuiUtil.GetFonts (Mpq)[0]'  										       292' 420);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceProvided] = new LabelElement (this' fontpal.Palette'  											   GuiUtil.GetFonts (Mpq)[0]'  											   292' 434);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceProvided] = new LabelElement (this' fontpal.Palette'  											   GuiUtil.GetFonts (Mpq)[0]'  											   292' 434);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceTotal] = new LabelElement (this' fontpal.Palette'  											GuiUtil.GetFonts (Mpq)[0]'  											292' 448);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceTotal] = new LabelElement (this' fontpal.Palette'  											GuiUtil.GetFonts (Mpq)[0]'  											292' 448);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceMax] = new LabelElement (this' fontpal.Palette'  										      GuiUtil.GetFonts (Mpq)[0]'  										      292' 462);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: labelElements[(int)HudLabels.ResourceMax] = new LabelElement (this' fontpal.Palette'  										      GuiUtil.GetFonts (Mpq)[0]'  										      292' 462);
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: cmdButtonElements = new GrpButtonElement[9];
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < cmdButtonElements.Length; i ++) {  				cmdButtonElements[i] = new GrpButtonElement (this' cmdicons' cmdicon_palette' button_xs[x]' button_ys[y]);  				x++;  				if (x == 3) {  					x = 0;  					y++;  				}  				cmdButtonElements[i].Visible = false;  				Elements.Add (cmdButtonElements[i]);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,UpdateCursor,The following statement contains a magic number: if (mouseOverElement == null) {  				/* are we over a unit?  if so' display the mag cursor */  				unitUnderCursor = null;  				for (int i = 0; i < units.Count; i ++) {  					Unit u = units[i];  					Sprite s = u.Sprite;    					int sx' sy;    					s.GetPosition (out sx' out sy);    					int cursor_x = Game.Instance.Cursor.X + topleft_x;  					int cursor_y = Game.Instance.Cursor.Y + topleft_y;    					int half_width = u.Width / 2;  					int half_height = u.Height / 2;    					if (cursor_x < sx + half_width && cursor_x > sx - half_width  					    && cursor_y < sy + half_height && cursor_y > sy - half_height) {  						Game.Instance.Cursor = MagCursors[MAG_CURSOR_G];  						unitUnderCursor = u;  						break;  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,UpdateCursor,The following statement contains a magic number: if (mouseOverElement == null) {  				/* are we over a unit?  if so' display the mag cursor */  				unitUnderCursor = null;  				for (int i = 0; i < units.Count; i ++) {  					Unit u = units[i];  					Sprite s = u.Sprite;    					int sx' sy;    					s.GetPosition (out sx' out sy);    					int cursor_x = Game.Instance.Cursor.X + topleft_x;  					int cursor_y = Game.Instance.Cursor.Y + topleft_y;    					int half_width = u.Width / 2;  					int half_height = u.Height / 2;    					if (cursor_x < sx + half_width && cursor_x > sx - half_width  					    && cursor_y < sy + half_height && cursor_y > sy - half_height) {  						Game.Instance.Cursor = MagCursors[MAG_CURSOR_G];  						unitUnderCursor = u;  						break;  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ScrollTick,The following statement contains a magic number: if (scroll_elapsed < 20)  				return;
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,ScrollTick,The following statement contains a magic number: Painter.Invalidate (new Rectangle (new Point (0'0)'  							   new Size (Painter.SCREEN_RES_X' 375)));
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,Recenter,The following statement contains a magic number: topleft_x = x - Painter.SCREEN_RES_X / 2;
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,Recenter,The following statement contains a magic number: topleft_y = y - Painter.SCREEN_RES_Y / 2;
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,MouseButtonDown,The following statement contains a magic number: if (mouseOverElement != null) {  				base.MouseButtonDown (args);  			}  			else if (args.X > MINIMAP_X && args.X < MINIMAP_X + MINIMAP_WIDTH &&  				 args.Y > MINIMAP_Y && args.Y < MINIMAP_Y + MINIMAP_HEIGHT) {  				RecenterFromMinimap (args.X' args.Y);  				buttonDownInMinimap = true;  			}  			else {  				if (selectedUnit != unitUnderCursor) {    					Console.WriteLine ("hey there' keyboard.modifierkeystate = {0}"' Keyboard.ModifierKeyState);    					// if we have a selected unit and we  					// right click (or ctrl-click?)' try  					// to move there  					if (selectedUnit != null && (Keyboard.ModifierKeyState & ModifierKeys.ShiftKeys) != 0) {  						Console.WriteLine ("And... we're walking");    						int pixel_x = args.X + topleft_x;  						int pixel_y = args.Y + topleft_y;    						// calculate the megatile  						int megatile_x = pixel_x >> 5;  						int megatile_y = pixel_y >> 5;    						Console.WriteLine ("megatile {0}'{1}"' megatile_x' megatile_y);    						// the mini tile  						int minitile_x = pixel_x >> 2;  						int minitile_y = pixel_y >> 2;    						Console.WriteLine ("minitile {0}'{1} ({2}'{3} in the megatile)"'  								   minitile_x' minitile_y'  								   minitile_x - megatile_x * 8'  								   minitile_y - megatile_y * 8);    						if (selectedUnit.YesSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.YesSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						selectedUnit.Move (mapRenderer' minitile_x' minitile_y);    						return;  					}  					  					portraitElement.Stop ();  					  					selectedUnit = unitUnderCursor;    					if (selectedUnit == null) {  						portraitElement.Visible = false;  						wireframeElement.Visible = false;  						for (int i = 0; i < (int)HudLabels.Count; i ++)  							labelElements[i].Visible = false;  					}  					else {  						Console.WriteLine ("selected unit: {0}"' selectedUnit);  						Console.WriteLine ("selectioncircle = {0}"' selectedUnit.SelectionCircleOffset);    						if (selectedUnit.Portrait == null) {  							portraitElement.Visible = false;  						}  						else {  							string portrait_resource = String.Format ("portrait\\{0}0.smk"'  												  selectedUnit.Portrait);    							portraitElement.Player = new SmackerPlayer ((Stream)mpq.GetResource (portrait_resource)' 1);  							portraitElement.Play ();  							portraitElement.Visible = true;  						}    						if (selectedUnit.WhatSound != null) {  							string sound_resource = String.Format ("sound\\{0}"' selectedUnit.WhatSound);  							Console.WriteLine ("sound_resource = {0}"' sound_resource);  							GuiUtil.PlaySound (mpq' sound_resource);  						}    						/* set up the wireframe */  						wireframeElement.Frame = selectedUnit.UnitId;  						wireframeElement.Visible = true;    						/* then display info about the selected unit */  						labelElements[(int)HudLabels.UnitName].Text = statTxt[selectedUnit.UnitId];  						if (true /* XXX unit is a building */) {  							labelElements[(int)HudLabels.ResourceUsed].Text = statTxt[820+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceProvided].Text = statTxt[814+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceTotal].Text = statTxt[817+(int)Game.Instance.Race];  							labelElements[(int)HudLabels.ResourceMax].Text = statTxt[823+(int)Game.Instance.Race];    							for (int i = 0; i < (int)HudLabels.Count; i ++)  								labelElements[i].Visible = true;  						}    						/* then fill in the command buttons */  						int[] cmd_indices;    						switch (selectedUnit.UnitId) {  						case 106:  							cmd_indices = new int[] { 7' -1' -1' -1' -1' 286' -1' -1' 282 };  							break;  						default:  							Console.WriteLine ("cmd_indices == -1");  							cmd_indices = new int[] { -1' -1' -1' -1' -1' -1' -1' -1' -1 };  							break;  						}    						for (int i = 0; i < cmd_indices.Length; i ++) {  							if (cmd_indices[i] == -1) {  								cmdButtonElements[i].Visible = false;  							}  							else {  								cmdButtonElements[i].Visible = true;  								cmdButtonElements[i].Frame = cmd_indices[i];  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PointerMotion,The following statement contains a magic number: if (buttonDownInMinimap) {  				RecenterFromMinimap (args.X' args.Y);  			}  			else {  				base.PointerMotion (args);    				// if the mouse is over one of the  				// normal UIElements in the HUD' deal  				// with it  				if (mouseOverElement != null) {  					// XXX for now' just return.  					return;  				}    				// if the mouse is over the hud area' return  				int hudIndex = (args.X + args.Y * hudElement.Pcx.Width) * 4;  				if (hudElement.Pcx.RgbaData [hudIndex] == 0xff) {  					Game.Instance.Cursor = Cursor;  					return;  				}    				if (args.X < MOUSE_MOVE_BORDER) {  					horiz_delta = -SCROLL_DELTA;  				}  				else if (args.X + MOUSE_MOVE_BORDER > Painter.SCREEN_RES_X) {  					horiz_delta = SCROLL_DELTA;  				}  				else {  					horiz_delta = 0;  				}    				if (args.Y < MOUSE_MOVE_BORDER) {  					vert_delta = -SCROLL_DELTA;  				}  				else if (args.Y + MOUSE_MOVE_BORDER > Painter.SCREEN_RES_Y) {  					vert_delta = SCROLL_DELTA;  				}  				else {  					vert_delta = 0;  				}    				// we update the cursor to show the  				// scrolling animations here' since it  				// only happens on pointer motion.  				if (horiz_delta < 0)  					if (vert_delta < 0)  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_UL];  					else if (vert_delta > 0)  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_DL];  					else  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_L];  				else if (horiz_delta > 0)  					if (vert_delta < 0)  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_UR];  					else if (vert_delta > 0)  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_DR];  					else  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_R];  				else  					if (vert_delta < 0)  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_U];  					else if (vert_delta > 0)  						Game.Instance.Cursor = ScrollCursors[SCROLL_CURSOR_D];  					else  						Game.Instance.Cursor = Cursor;      				UpdateCursor ();  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PlaceInitialUnits,The following statement contains a magic number: foreach (UnitInfo unitinfo in unit_infos) {  				if (unitinfo.unit_id == 0xffff)  					break;    				Unit unit = new Unit (unitinfo);    				/* we handle start locations in a special way' below */  				if (unit.FlingyId == 140) {  					startLocations.Add (unit);  					continue;  				}    				//players[unitinfo.player].AddUnit (unit);    				unit.CreateSprite (mpq' tileset_palette);  				units.Add (unit);  			}
Magic Number,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,PlaceInitialUnits,The following statement contains a magic number: if (template != null && (template.InitialUnits != InitialUnits.UseMapSettings)) {  				foreach (Unit sl in startLocations) {  					/* terran command center = 106'  					   zerg hatchery = 131'  					   protoss nexus = 154 */    					Unit unit = new Unit (154);  					unit.X = sl.X;  					unit.Y = sl.Y;    					unit.CreateSprite (mpq' tileset_palette);  					units.Add (unit);  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: byte[] buf = new byte[g.Width * g.Height * 4];
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: for (int y = g.Height - 1; y >= 0; y--) {  				for (int x = g.Width - 1; x >= 0; x--) {  					if (g.Bitmap[y'x] == 0)  						buf [i + 0] = 0;  					else if (g.Bitmap[y'x] == 1)  						buf [i + 0] = 255;  					else  						buf [i + 0] = 128;    					buf[i + 1] = palette[ (g.Bitmap[y'x] + offset) * 3 + 2];  					buf[i + 2] = palette[ (g.Bitmap[y'x] + offset) * 3 + 1];  					buf[i + 3] = palette[ (g.Bitmap[y'x] + offset) * 3 ];    					if (buf[i+1] == 252 && buf[i+2] == 0 && buf[i+3] == 252)  						buf[i + 0] = 0;    					i += 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' (ushort)g.Width' (ushort)g.Height' 32' g.Width * 4);
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,RenderGlyph,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' (ushort)g.Width' (ushort)g.Height' 32' g.Width * 4);
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,ComposeText,The following statement contains a magic number: return ComposeText (text' font' palette' -1' -1' 4);
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: byte[] buf = new byte[width * height * (3 + (with_alpha ? 1 : 0))];
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (with_alpha)  						i++;  					buf[i++] = palette[ grid[y'x] * 3 + 2];  					buf[i++] = palette[ grid[y'x] * 3 + 1];  					buf[i++] = palette[ grid[y'x] * 3 ];  					if (with_alpha) {  						if (buf[i - 3] == 0  						    && buf[i - 2] == 0  						    && buf[i - 1] == 0) {  							buf[i-4] = 0x00;  						}  						else if (buf[i - 3] == 59  							 && buf[i - 2] == 39  							 && buf[i - 1] == 39) {  							buf[i - 3] = buf[i - 2] = buf[i - 1] = 0;  							//							Console.WriteLine ("translucent shadow pixel' palette index = {0}"' palette [grid[y'x]] * 3);  							buf[i - 4] = 0xaa;  						}  						else {  							//							Console.WriteLine ("pixel data RGB = {0}'{1}'{2}' palette index = {3}"'  							//									   buf[i-3]'buf[i-2]'buf[i-1]' palette [grid[y'x]] * 3);  							buf[i-4] = 0xff;  						}  					}  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: byte[] buf = new byte[width * height * 4];
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,GetBitmapData,The following statement contains a magic number: for (y = height - 1; y >= 0; y --) {  				for (x = width - 1; x >= 0; x--) {  					if (grid[y'x] == translucent_index)  						buf[i+0] = 0x05; /* keep this in sync with Pcx.cs */  					else if (grid[y'x] == transparent_index)  						buf[i+0] = 0x00;  					else  						buf[i+0] = 0xff;  					buf[i+1] = palette[ grid[y'x] * 3 + 2];  					buf[i+2] = palette[ grid[y'x] * 3 + 1];  					buf[i+3] = palette[ grid[y'x] * 3 + 0];  					i+= 4;  				}  			}
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' width' height' with_alpha ? 32 : 24' width * (3 + (with_alpha ? 1 : 0)));
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' width' height' with_alpha ? 32 : 24' width * (3 + (with_alpha ? 1 : 0)));
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' width' height' with_alpha ? 32 : 24' width * (3 + (with_alpha ? 1 : 0)));
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' width' height' 32' width * 4);
Magic Number,SCSharp.UI,GuiUtil,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GuiUtil.cs,CreateSurfaceFromBitmap,The following statement contains a magic number: return CreateSurfaceFromRGBAData (buf' width' height' 32' width * 4);
Magic Number,SCSharp.UI,LabelElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LabelElement.cs,CreateSurface,The following statement contains a magic number: if (calc_width) {  				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  									Sensitive ? 4 : 24);  				Width = (ushort)textSurf.Width;  				Height = (ushort)textSurf.Height;    				return textSurf;  			}  			else {  				/* this is wrong */  				Surface surf = new Surface (Width' Height);    				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  									Sensitive ? 4 : 24);    				int x = 0;  				if (Type == ElementType.LabelRightAlign)  					x += Width - textSurf.Width;  				else if (Type == ElementType.LabelCenterAlign)  					x += (Width - textSurf.Width) / 2;    				surf.Blit (textSurf' new Point (x' 0));    				surf.TransparentColor = Color.Black /* XXX */;  				return surf;  			}
Magic Number,SCSharp.UI,LabelElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LabelElement.cs,CreateSurface,The following statement contains a magic number: if (calc_width) {  				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  									Sensitive ? 4 : 24);  				Width = (ushort)textSurf.Width;  				Height = (ushort)textSurf.Height;    				return textSurf;  			}  			else {  				/* this is wrong */  				Surface surf = new Surface (Width' Height);    				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  									Sensitive ? 4 : 24);    				int x = 0;  				if (Type == ElementType.LabelRightAlign)  					x += Width - textSurf.Width;  				else if (Type == ElementType.LabelCenterAlign)  					x += (Width - textSurf.Width) / 2;    				surf.Blit (textSurf' new Point (x' 0));    				surf.TransparentColor = Color.Black /* XXX */;  				return surf;  			}
Magic Number,SCSharp.UI,LabelElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LabelElement.cs,CreateSurface,The following statement contains a magic number: if (calc_width) {  				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  									Sensitive ? 4 : 24);  				Width = (ushort)textSurf.Width;  				Height = (ushort)textSurf.Height;    				return textSurf;  			}  			else {  				/* this is wrong */  				Surface surf = new Surface (Width' Height);    				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  									Sensitive ? 4 : 24);    				int x = 0;  				if (Type == ElementType.LabelRightAlign)  					x += Width - textSurf.Width;  				else if (Type == ElementType.LabelCenterAlign)  					x += (Width - textSurf.Width) / 2;    				surf.Blit (textSurf' new Point (x' 0));    				surf.TransparentColor = Color.Black /* XXX */;  				return surf;  			}
Magic Number,SCSharp.UI,LabelElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LabelElement.cs,CreateSurface,The following statement contains a magic number: if (calc_width) {  				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  									Sensitive ? 4 : 24);  				Width = (ushort)textSurf.Width;  				Height = (ushort)textSurf.Height;    				return textSurf;  			}  			else {  				/* this is wrong */  				Surface surf = new Surface (Width' Height);    				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  									Sensitive ? 4 : 24);    				int x = 0;  				if (Type == ElementType.LabelRightAlign)  					x += Width - textSurf.Width;  				else if (Type == ElementType.LabelCenterAlign)  					x += (Width - textSurf.Width) / 2;    				surf.Blit (textSurf' new Point (x' 0));    				surf.TransparentColor = Color.Black /* XXX */;  				return surf;  			}
Magic Number,SCSharp.UI,LabelElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LabelElement.cs,CreateSurface,The following statement contains a magic number: if (calc_width) {  				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' -1' -1'  									Sensitive ? 4 : 24);  				Width = (ushort)textSurf.Width;  				Height = (ushort)textSurf.Height;    				return textSurf;  			}  			else {  				/* this is wrong */  				Surface surf = new Surface (Width' Height);    				Surface textSurf = GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  									Sensitive ? 4 : 24);    				int x = 0;  				if (Type == ElementType.LabelRightAlign)  					x += Width - textSurf.Width;  				else if (Type == ElementType.LabelCenterAlign)  					x += (Width - textSurf.Width) / 2;    				surf.Blit (textSurf' new Point (x' 0));    				surf.TransparentColor = Color.Black /* XXX */;  				return surf;  			}
Magic Number,SCSharp.UI,ListBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ListBoxElement.cs,CreateSurface,The following statement contains a magic number: for (int i = first_visible; i < first_visible + num_visible; i ++) {  				if (i >= items.Count)  					break;  				Surface item_surface = GuiUtil.ComposeText (items[i]' Font' Palette'  									    (!selectable ||  									     (!selecting && cursor == i) ||  									     (selecting && selectionIndex == i)) ? 4 : 24);    				surf.Blit (item_surface' new Point (0' y));  				y += item_surface.Height;  			}
Magic Number,SCSharp.UI,ListBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ListBoxElement.cs,CreateSurface,The following statement contains a magic number: for (int i = first_visible; i < first_visible + num_visible; i ++) {  				if (i >= items.Count)  					break;  				Surface item_surface = GuiUtil.ComposeText (items[i]' Font' Palette'  									    (!selectable ||  									     (!selecting && cursor == i) ||  									     (selecting && selectionIndex == i)) ? 4 : 24);    				surf.Blit (item_surface' new Point (0' y));  				y += item_surface.Height;  			}
Magic Number,SCSharp.UI,LoginScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LoginScreen.cs,ResourceLoader,The following statement contains a magic number: Elements[NEW_ELEMENT_INDEX].Activate +=  				delegate () {  					EntryDialog d = new EntryDialog (this' mpq'  									 GlobalResources.Instance.GluAllTbl.Strings[22]);  					d.Cancel += delegate () { DismissDialog (); };  					d.Ok += delegate () {  						if (listbox.Contains (d.Value)) {  							NameAlreadyExists (d);  						}  						else {  							DismissDialog ();  							listbox.AddItem (d.Value);  						}  					};  					ShowDialog (d);  				};
Magic Number,SCSharp.UI,LoginScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LoginScreen.cs,ResourceLoader,The following statement contains a magic number: Elements[DELETE_ELEMENT_INDEX].Activate +=  				delegate () {  					OkCancelDialog okd = new OkCancelDialog (this' mpq'  										 GlobalResources.Instance.GluAllTbl.Strings[23]);  					okd.Cancel += delegate () { DismissDialog (); };  					okd.Ok += delegate () {  						DismissDialog ();  						/* actually delete the file */  						listbox.RemoveAt (listbox.SelectedIndex);  					};  					ShowDialog (okd);  				};
Magic Number,SCSharp.UI,LoginScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\LoginScreen.cs,NameAlreadyExists,The following statement contains a magic number: OkDialog okd = new OkDialog (d' mpq'  						     GlobalResources.Instance.GluAllTbl.Strings[24]);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (SINGLEPLAYER_ELEMENT_INDEX' "glue\\mainmenu\\Single.smk"' "glue\\mainmenu\\SingleOn.smk"' 50' 70' false);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (SINGLEPLAYER_ELEMENT_INDEX' "glue\\mainmenu\\Single.smk"' "glue\\mainmenu\\SingleOn.smk"' 50' 70' false);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (MULTIPLAYER_ELEMENT_INDEX' "glue\\mainmenu\\Multi.smk"' "glue\\mainmenu\\MultiOn.smk"' 20' 12' true);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (MULTIPLAYER_ELEMENT_INDEX' "glue\\mainmenu\\Multi.smk"' "glue\\mainmenu\\MultiOn.smk"' 20' 12' true);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (CAMPAIGNEDITOR_ELEMENT_INDEX' "glue\\mainmenu\\Editor.smk"' "glue\\mainmenu\\EditorOn.smk"' 20' 18' true);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (CAMPAIGNEDITOR_ELEMENT_INDEX' "glue\\mainmenu\\Editor.smk"' "glue\\mainmenu\\EditorOn.smk"' 20' 18' true);
Magic Number,SCSharp.UI,MainMenu,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MainMenu.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (EXIT_ELEMENT_INDEX' "glue\\mainmenu\\Exit.smk"' "glue\\mainmenu\\ExitOn.smk"' 15' 0' true);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,MapRenderer,The following statement contains a magic number: pixel_width = (ushort)(chk.Width * 32);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,MapRenderer,The following statement contains a magic number: pixel_height = (ushort)(chk.Height * 32);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,SetUpperLeft,The following statement contains a magic number: int tl_x = x / 32;
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,SetUpperLeft,The following statement contains a magic number: int tl_y = y / 32;
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,SetUpperLeft,The following statement contains a magic number: for (int map_y = tl_y; map_y <= tl_y + width / 32 && map_y < chk.Height; map_y ++) {  				for (int map_x = tl_x; map_x <= tl_x + width / 32 && map_x < chk.Width; map_x ++) {  					Surface tile = GetTile(chk.MapTiles[map_x'map_y]);  					mapSurface.Blit (tile' new Point (map_x * 32 - x' map_y * 32 - y));  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,SetUpperLeft,The following statement contains a magic number: for (int map_y = tl_y; map_y <= tl_y + width / 32 && map_y < chk.Height; map_y ++) {  				for (int map_x = tl_x; map_x <= tl_x + width / 32 && map_x < chk.Width; map_x ++) {  					Surface tile = GetTile(chk.MapTiles[map_x'map_y]);  					mapSurface.Blit (tile' new Point (map_x * 32 - x' map_y * 32 - y));  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,SetUpperLeft,The following statement contains a magic number: for (int map_y = tl_y; map_y <= tl_y + width / 32 && map_y < chk.Height; map_y ++) {  				for (int map_x = tl_x; map_x <= tl_x + width / 32 && map_x < chk.Width; map_x ++) {  					Surface tile = GetTile(chk.MapTiles[map_x'map_y]);  					mapSurface.Blit (tile' new Point (map_x * 32 - x' map_y * 32 - y));  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,SetUpperLeft,The following statement contains a magic number: for (int map_y = tl_y; map_y <= tl_y + width / 32 && map_y < chk.Height; map_y ++) {  				for (int map_x = tl_x; map_x <= tl_x + width / 32 && map_x < chk.Width; map_x ++) {  					Surface tile = GetTile(chk.MapTiles[map_x'map_y]);  					mapSurface.Blit (tile' new Point (map_x * 32 - x' map_y * 32 - y));  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: int tile_group = mapTile >> 4;
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: if (image == null)  				image = new byte[32 * 32 * 4];
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: if (image == null)  				image = new byte[32 * 32 * 4];
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: if (image == null)  				image = new byte[32 * 32 * 4];
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  				for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  					ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  					bool flipped = (minitile_id & 0x01) == 0x01;  					minitile_id >>= 1;    					int pixel_x' pixel_y;  					if (flipped) {  						for (pixel_y = 0; pixel_y < 8; pixel_y++)  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = (minitile_x + 1) * 8 - pixel_x - 1;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  					}  					else {  						for (pixel_y = 0; pixel_y < 8; pixel_y++) {  							for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  								int x = minitile_x * 8 + pixel_x;  								int y = (minitile_y * 8) * 32 + pixel_y * 32;    								if (show_flag && (minitile_flags & flag) == flag && (pixel_x == pixel_y)) {  									image[0 + 4 * (x + y)] = 255;  									image[1 + 4 * (x + y)] = 255;  									image[2 + 4 * (x + y)] = 0;  									image[3 + 4 * (x + y)] = 0;  								}  								else {  									byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    									image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  									image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  									image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  									image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: Surface surf = GuiUtil.CreateSurfaceFromRGBAData (image' 32' 32' 32' 32 * 4);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: Surface surf = GuiUtil.CreateSurfaceFromRGBAData (image' 32' 32' 32' 32 * 4);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: Surface surf = GuiUtil.CreateSurfaceFromRGBAData (image' 32' 32' 32' 32 * 4);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: Surface surf = GuiUtil.CreateSurfaceFromRGBAData (image' 32' 32' 32' 32 * 4);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,GetTile,The following statement contains a magic number: Surface surf = GuiUtil.CreateSurfaceFromRGBAData (image' 32' 32' 32' 32 * 4);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: megatile_x = point.X >> 3;
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: megatile_y = point.Y >> 3;
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: int tile_group = mapTile >> 4;
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + point.Y * 8 + point.X * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + point.Y * 8 + point.X * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,Navigable,The following statement contains a magic number: ushort minitile_flags = Util.ReadWord (vf4' megatile_id * 32 + point.Y * 8 + point.X * 2);
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToSurface,The following statement contains a magic number: return GuiUtil.CreateSurfaceFromRGBAData (bitmap' (ushort)pixel_width' (ushort)pixel_height' 32' (ushort)(pixel_width * 4));
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToSurface,The following statement contains a magic number: return GuiUtil.CreateSurfaceFromRGBAData (bitmap' (ushort)pixel_width' (ushort)pixel_height' 32' (ushort)(pixel_width * 4));
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: byte[] image = new byte[pixel_width * pixel_height * 4];
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MapRenderer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MapRenderer.cs,RenderToBitmap,The following statement contains a magic number: for (int map_y = 0; map_y < chk.Height; map_y++) {  				for (int map_x = 0; map_x < chk.Width; map_x ++) {  					int mapTile = mapTiles[map_x'map_y];    					//					bool odd = (mapTile & 0x10) == 0x10;    					int tile_group = mapTile >> 4; /* the tile's group in the cv5 file */  					int tile_number = mapTile & 0x0F;    /* the megatile within the tile group */    					int megatile_id = Util.ReadWord (cv5' (tile_group * 26 + 10 + tile_number) * 2);    					int minitile_x' minitile_y;    					for (minitile_y = 0; minitile_y < 4; minitile_y ++) {  						for (minitile_x = 0; minitile_x < 4; minitile_x ++) {  							ushort minitile_id = Util.ReadWord (vx4' megatile_id * 32 + minitile_y * 8 + minitile_x * 2);  							bool flipped = (minitile_id & 0x01) == 0x01;  							minitile_id >>= 1;    							int pixel_x' pixel_y;  							if (flipped) {  								for (pixel_y = 0; pixel_y < 8; pixel_y++)  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + (minitile_x + 1) * 8 - pixel_x - 1;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  							}  							else {  								for (pixel_y = 0; pixel_y < 8; pixel_y++) {  									for (pixel_x = 0; pixel_x < 8; pixel_x ++) {  										int x = map_x * 32 + minitile_x * 8 + pixel_x;  										int y = (map_y * 32 + minitile_y * 8) * pixel_width + pixel_y * pixel_width;    										byte palette_entry = vr4[minitile_id * 64 + pixel_y * 8 + pixel_x];    										image[0 + 4 * (x + y)] = (byte)(255 - wpe[palette_entry * 4 + 3]);  										image[1 + 4 * (x + y)] = wpe[palette_entry * 4 + 2];  										image[2 + 4 * (x + y)] = wpe[palette_entry * 4 + 1];  										image[3 + 4 * (x + y)] = wpe[palette_entry * 4 + 0];  									}  								}  							}  						}  					}  				}  			}
Magic Number,SCSharp.UI,MarkupScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,ResourceLoader,The following statement contains a magic number: fnt = GuiUtil.GetFonts(mpq)[3];
Magic Number,SCSharp.UI,MarkupScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,ResourceLoader,The following statement contains a magic number: millisDelay = 4000;
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,MarkupPage,The following statement contains a magic number: newBackground = GuiUtil.SurfaceFromStream (background' 254' 0);
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Layout,The following statement contains a magic number: foreach (string l in lines) {  					if (l.Trim() == "")  						lineSurfaces.Add (null);  					else  						lineSurfaces.Add (GuiUtil.ComposeText (l' fnt' pal' Painter.SCREEN_RES_X - X_OFFSET * 2' -1' 4));  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Layout,The following statement contains a magic number: foreach (string l in lines) {  					if (l.Trim() == "")  						lineSurfaces.Add (null);  					else  						lineSurfaces.Add (GuiUtil.ComposeText (l' fnt' pal' Painter.SCREEN_RES_X - X_OFFSET * 2' -1' 4));  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following statement contains a magic number: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following statement contains a magic number: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following statement contains a magic number: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following statement contains a magic number: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following statement contains a magic number: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
Magic Number,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following statement contains a magic number: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				fps_rect = new Rectangle (new Point (10' 10)' new Size (80' 30));  				frame_count ++;  				if (frame_count == 50) {    					DateTime after = DateTime.Now;    					fps = 1.0 / (after - last_time).TotalSeconds * 50;  					last_time = after;  					frame_count = 0;    					/* make sure we invalidate the region where we're going to draw the fps/related info */  					Invalidate (fps_rect);  				}  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				fps_rect = new Rectangle (new Point (10' 10)' new Size (80' 30));  				frame_count ++;  				if (frame_count == 50) {    					DateTime after = DateTime.Now;    					fps = 1.0 / (after - last_time).TotalSeconds * 50;  					last_time = after;  					frame_count = 0;    					/* make sure we invalidate the region where we're going to draw the fps/related info */  					Invalidate (fps_rect);  				}  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				fps_rect = new Rectangle (new Point (10' 10)' new Size (80' 30));  				frame_count ++;  				if (frame_count == 50) {    					DateTime after = DateTime.Now;    					fps = 1.0 / (after - last_time).TotalSeconds * 50;  					last_time = after;  					frame_count = 0;    					/* make sure we invalidate the region where we're going to draw the fps/related info */  					Invalidate (fps_rect);  				}  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				fps_rect = new Rectangle (new Point (10' 10)' new Size (80' 30));  				frame_count ++;  				if (frame_count == 50) {    					DateTime after = DateTime.Now;    					fps = 1.0 / (after - last_time).TotalSeconds * 50;  					last_time = after;  					frame_count = 0;    					/* make sure we invalidate the region where we're going to draw the fps/related info */  					Invalidate (fps_rect);  				}  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				fps_rect = new Rectangle (new Point (10' 10)' new Size (80' 30));  				frame_count ++;  				if (frame_count == 50) {    					DateTime after = DateTime.Now;    					fps = 1.0 / (after - last_time).TotalSeconds * 50;  					last_time = after;  					frame_count = 0;    					/* make sure we invalidate the region where we're going to draw the fps/related info */  					Invalidate (fps_rect);  				}  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				fps_rect = new Rectangle (new Point (10' 10)' new Size (80' 30));  				frame_count ++;  				if (frame_count == 50) {    					DateTime after = DateTime.Now;    					fps = 1.0 / (after - last_time).TotalSeconds * 50;  					last_time = after;  					frame_count = 0;    					/* make sure we invalidate the region where we're going to draw the fps/related info */  					Invalidate (fps_rect);  				}  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				if (fps_surface != null)  					fps_surface.Dispose ();    				fps_surface = GuiUtil.ComposeText (String.Format ("fps: {0'0:F}"' fps)'  								   GuiUtil.GetFonts (Game.Instance.PlayingMpq)[1]'  								   fontpal);    				paintingSurface.Blit (fps_surface' new Point (10'10));  			}
Magic Number,SCSharp.UI,Painter,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Painter.cs,Redraw,The following statement contains a magic number: if (show_fps) {  				if (fps_surface != null)  					fps_surface.Dispose ();    				fps_surface = GuiUtil.ComposeText (String.Format ("fps: {0'0:F}"' fps)'  								   GuiUtil.GetFonts (Game.Instance.PlayingMpq)[1]'  								   fontpal);    				paintingSurface.Blit (fps_surface' new Point (10'10));  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: stream.Position += 48;
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: stream.Position += 54;
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: if (bpp != 8 || numplanes != 1)  				throw new Exception ("unsupported .pcx image type");
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: stream.Position = stream.Length - 256 * 3;
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: stream.Position = stream.Length - 256 * 3;
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: palette = new byte[256 * 3];
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: palette = new byte[256 * 3];
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: stream.Read (palette' 0' 256 * 3);
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: stream.Read (palette' 0' 256 * 3);
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: data = new byte[width * height * 4];
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,Pcx,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Pcx.cs,ReadFromStream,The following statement contains a magic number: while (idx < data.Length) {  				byte b = Util.ReadByte (stream);  				byte count;  				byte value;    				if ((b & 0xC0) == 0xC0) {  					/* it's a count byte */  					count = (byte)(b & 0x3F);  					value = Util.ReadByte (stream);  				}  				else {  					count = 1;  					value = b;  				}    				for (int i = 0; i < count; i ++) {  					if (idx + 4 > data.Length)  						return;    					/* this stuff is endian  					 * dependent... for big endian  					 * we need the "idx +"'s  					 * reversed */  					data[idx + 3] = palette [value * 3 + 0];  					data[idx + 2] = palette [value * 3 + 1];  					data[idx + 1] = palette [value * 3 + 2];  					if (with_alpha) {  						if (value == translucentIndex)  							data[idx + 0] = 0xd0;  						else if (value == transparentIndex)  							data[idx + 0] = 0x00;  						else  							data[idx + 0] = 0xff;  					}    					idx += 4;  				}  			}
Magic Number,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,InitializePlayerCombo,The following statement contains a magic number: combo.AddItem (GlobalResources.Instance.GluAllTbl.Strings[130]);
Magic Number,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,InitializePlayerCombo,The following statement contains a magic number: combo.AddItem (GlobalResources.Instance.GluAllTbl.Strings[128]' true);
Magic Number,SCSharp.UI,PlayCustomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\PlayCustomScreen.cs,UpdatePlayersDisplay,The following statement contains a magic number: if (selectedChk != null) {  				for (i = 0; i < max_players; i ++) {  					if (selectedGot.UseMapSettings) {  						if (i >= selectedChk.NumComputerSlots + 1) break;  					}  					else {  						if (i >= selectedChk.NumPlayers) break;  					}    					if (i > 0)  						((ComboBoxElement)Elements[PLAYER1_COMBOBOX_PLAYER + i]).SelectedIndex = 1;  					((ComboBoxElement)Elements[PLAYER1_COMBOBOX_RACE + i]).SelectedIndex = 3;  					Elements[PLAYER1_COMBOBOX_PLAYER + i].Visible = true;  					Elements[PLAYER1_COMBOBOX_RACE + i].Visible = true;  				}  			}
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,ResourceLoader,The following statement contains a magic number: Elements[THIRD_CAMPAIGN_ELEMENT_INDEX].Activate +=  				delegate () {  					SelectCampaign (2);  				};
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (FIRST_CAMPAIGN_ELEMENT_INDEX' 0' -40' 0);
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,ResourceLoader,The following statement contains a magic number: AddMovieElements (THIRD_CAMPAIGN_ELEMENT_INDEX' 2' 0' 0);
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,SelectCampaign,The following statement contains a magic number: markup = String.Format ("rez\\Est{0}{1}{2}.txt"'  						Util.RaceChar[(int)Game.Instance.Race]'  						prefix.EndsWith ("tutorial") ? "0t" : prefix.Substring (prefix.Length - 2)'  						Game.Instance.PlayingBroodWar ? "x" : "");
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The following statement contains a magic number: diskElement.X1 = (ushort)(Elements[elementIndex].X1 + ((Elements[elementIndex].Width - diskElement.MovieSize.Width) / 2));
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The following statement contains a magic number: normalElement.X1 = (ushort)(Elements[elementIndex].X1 + ((Elements[elementIndex].Width - normalElement.MovieSize.Width) / 2) + off_x);
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The following statement contains a magic number: onElement.X1 = (ushort)(Elements[elementIndex].X1 + ((Elements[elementIndex].Width - onElement.MovieSize.Width) / 2));
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The following statement contains a magic number: normalElement.Dim (100);
Magic Number,SCSharp.UI,RaceSelectionScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\RaceSelectionScreen.cs,AddMovieElements,The following statement contains a magic number: Elements[elementIndex].MouseLeaveEvent +=   				delegate () {  					normalElement.Dim (100);  					onElement.Visible = false;  				};
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ResourceLoader,The following statement contains a magic number: TranslucentIndex = 138;
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < 4; i ++) {  				MovieElement m = new MovieElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   true);    				m.X1 += 3;  				m.Y1 += 3;  				m.Width -= 6;  				m.Height -= 6;    				ImageElement f = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				f.Text = String.Format ("glue\\Ready{0}\\{0}Frame{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				ImageElement h = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				h.Text = String.Format ("glue\\Ready{0}\\{0}FrameH{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				f.Visible = false;  				h.Visible = false;  				m.Visible = false;  				  				portraits.Add (m);  				hframes.Add (h);  				frames.Add (f);    				Elements.Add (m);  				Elements.Add (h);  				Elements.Add (f);  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < 4; i ++) {  				MovieElement m = new MovieElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   true);    				m.X1 += 3;  				m.Y1 += 3;  				m.Width -= 6;  				m.Height -= 6;    				ImageElement f = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				f.Text = String.Format ("glue\\Ready{0}\\{0}Frame{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				ImageElement h = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				h.Text = String.Format ("glue\\Ready{0}\\{0}FrameH{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				f.Visible = false;  				h.Visible = false;  				m.Visible = false;  				  				portraits.Add (m);  				hframes.Add (h);  				frames.Add (f);    				Elements.Add (m);  				Elements.Add (h);  				Elements.Add (f);  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < 4; i ++) {  				MovieElement m = new MovieElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   true);    				m.X1 += 3;  				m.Y1 += 3;  				m.Width -= 6;  				m.Height -= 6;    				ImageElement f = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				f.Text = String.Format ("glue\\Ready{0}\\{0}Frame{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				ImageElement h = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				h.Text = String.Format ("glue\\Ready{0}\\{0}FrameH{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				f.Visible = false;  				h.Visible = false;  				m.Visible = false;  				  				portraits.Add (m);  				hframes.Add (h);  				frames.Add (f);    				Elements.Add (m);  				Elements.Add (h);  				Elements.Add (f);  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < 4; i ++) {  				MovieElement m = new MovieElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   true);    				m.X1 += 3;  				m.Y1 += 3;  				m.Width -= 6;  				m.Height -= 6;    				ImageElement f = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				f.Text = String.Format ("glue\\Ready{0}\\{0}Frame{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				ImageElement h = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				h.Text = String.Format ("glue\\Ready{0}\\{0}FrameH{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				f.Visible = false;  				h.Visible = false;  				m.Visible = false;  				  				portraits.Add (m);  				hframes.Add (h);  				frames.Add (f);    				Elements.Add (m);  				Elements.Add (h);  				Elements.Add (f);  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ResourceLoader,The following statement contains a magic number: for (int i = 0; i < 4; i ++) {  				MovieElement m = new MovieElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   true);    				m.X1 += 3;  				m.Y1 += 3;  				m.Width -= 6;  				m.Height -= 6;    				ImageElement f = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				f.Text = String.Format ("glue\\Ready{0}\\{0}Frame{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				ImageElement h = new ImageElement (this'  								   Elements[first_portrait_element_index + i].BinElement'  								   Elements[first_portrait_element_index + i].Palette'  								   TranslucentIndex);  				h.Text = String.Format ("glue\\Ready{0}\\{0}FrameH{1}.pcx"'  							Util.RaceChar[(int)Game.Instance.Race]'  							i + 1);    				f.Visible = false;  				h.Visible = false;  				m.Visible = false;  				  				portraits.Add (m);  				hframes.Add (h);  				frames.Add (f);    				Elements.Add (m);  				Elements.Add (h);  				Elements.Add (f);  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,StopBriefing,The following statement contains a magic number: for (int i = 0; i < 4; i ++) {  				Elements[first_portrait_element_index + i].Visible = false;  				portraits[i].Visible = false;  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,UnhighlightPortrait,The following statement contains a magic number: if (portraits[slot].Visible) {  				hframes[slot].Visible = false;  				frames[slot].Visible = true;  				portraits[highlightedPortrait].Dim (100);  			}
Magic Number,SCSharp.UI,ReadyRoomScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,ShowPortrait,The following statement contains a magic number: portraits[slot].Dim (100);
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,BriefingRunner,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\ReadyRoomScreen.cs,Tick,The following statement contains a magic number: while (current_action < actions.Length) {  				TriggerAction action = actions[current_action];    				current_action ++;    				switch (action.Action) {  				case 0: /* no action */  					break;  				case 1:  					sleepUntil = (int)action.Delay;  					return;  				case 2:  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				case 3:  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 4:  					screen.SetObjectives (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 5:  					Console.WriteLine ("show portrait:");  					Console.WriteLine ("location = {0}' textindex = {1}' wavindex = {2}' delay = {3}' group1 = {4}' group2 = {5}' unittype = {6}' action = {7}' switch = {8}' flags = {9}"'  							   action.Location'  							   action.TextIndex'  							   action.WavIndex'  							   action.Delay'  							   action.Group1'  							   action.Group2'  							   action.UnitType'  							   action.Action'  							   action.Switch'  							   action.Flags);  					screen.ShowPortrait ((int)action.UnitType' (int)action.Group1);  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 6:  					screen.HidePortrait ((int)action.Group1);  					break;  				case 7:  					Console.WriteLine ("Display Speaking Portrait(Slot' Time)");  					Console.WriteLine (scenario.GetMapString ((int)action.TextIndex));  					break;  				case 8:  					Console.WriteLine ("Transmission(Text' Slot' Time' Modifier' Wave' WavTime)");  					screen.SetTransmissionText (scenario.GetMapString ((int)action.TextIndex));  					screen.HighlightPortrait ((int)action.Group1);  					GuiUtil.PlaySound (screen.Mpq' prefix + "\\" + scenario.GetMapString ((int)action.WavIndex));  					sleepUntil = (int)action.Delay;  					return;  				default:  					break;  				}  			}
Magic Number,SCSharp.UI,SmackerPlayer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\SmackerPlayer.cs,Events_Tick,The following statement contains a magic number: while (timeElapsed > 1.0 / file.Header.Fps && frameQueue.Count > 0)  			{  				timeElapsed -= (float)(1.0f / file.Header.Fps);  				byte[] rgbData = frameQueue.Dequeue();    				if (surf == null) {  					surf = GuiUtil.CreateSurface (rgbData' (ushort)file.Header.Width' (ushort)file.Header.Height'  								      32' (int)file.Header.Width * 4'  								      (int)0x00ff0000'  								      (int)0x0000ff00'  								      (int)0x000000ff'  								      unchecked ((int)0xff000000));  				}  				else {  					surf.Lock();  					Marshal.Copy(rgbData' 0' surf.Pixels' rgbData.Length);  					surf.Unlock();  					surf.Update();  				}    				EmitFrameReady ();    				if (frameQueue.Count < (buffered_frames / 2) + 1)  					waitEvent.Set ();  			}
Magic Number,SCSharp.UI,SmackerPlayer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\SmackerPlayer.cs,Events_Tick,The following statement contains a magic number: while (timeElapsed > 1.0 / file.Header.Fps && frameQueue.Count > 0)  			{  				timeElapsed -= (float)(1.0f / file.Header.Fps);  				byte[] rgbData = frameQueue.Dequeue();    				if (surf == null) {  					surf = GuiUtil.CreateSurface (rgbData' (ushort)file.Header.Width' (ushort)file.Header.Height'  								      32' (int)file.Header.Width * 4'  								      (int)0x00ff0000'  								      (int)0x0000ff00'  								      (int)0x000000ff'  								      unchecked ((int)0xff000000));  				}  				else {  					surf.Lock();  					Marshal.Copy(rgbData' 0' surf.Pixels' rgbData.Length);  					surf.Unlock();  					surf.Update();  				}    				EmitFrameReady ();    				if (frameQueue.Count < (buffered_frames / 2) + 1)  					waitEvent.Set ();  			}
Magic Number,SCSharp.UI,SmackerPlayer,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\SmackerPlayer.cs,Events_Tick,The following statement contains a magic number: while (timeElapsed > 1.0 / file.Header.Fps && frameQueue.Count > 0)  			{  				timeElapsed -= (float)(1.0f / file.Header.Fps);  				byte[] rgbData = frameQueue.Dequeue();    				if (surf == null) {  					surf = GuiUtil.CreateSurface (rgbData' (ushort)file.Header.Width' (ushort)file.Header.Height'  								      32' (int)file.Header.Width * 4'  								      (int)0x00ff0000'  								      (int)0x0000ff00'  								      (int)0x000000ff'  								      unchecked ((int)0xff000000));  				}  				else {  					surf.Lock();  					Marshal.Copy(rgbData' 0' surf.Pixels' rgbData.Length);  					surf.Unlock();  					surf.Update();  				}    				EmitFrameReady ();    				if (frameQueue.Count < (buffered_frames / 2) + 1)  					waitEvent.Set ();  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,GetTopLeftPosition,The following statement contains a magic number: if (sprite_surface != null) {  				xo -= sprite_surface.Width / 2;  				yo -= sprite_surface.Height / 2;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,GetTopLeftPosition,The following statement contains a magic number: if (sprite_surface != null) {  				xo -= sprite_surface.Width / 2;  				yo -= sprite_surface.Height / 2;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,RunScript,The following statement contains a magic number: int offset_to_script_type = (4 /* "SCEP" */ + 1 /* the script entry "type" */ + 3 /* the spacers */ +  						     (int)animationType * 2);
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,RunScript,The following statement contains a magic number: int offset_to_script_type = (4 /* "SCEP" */ + 1 /* the script entry "type" */ + 3 /* the spacers */ +  						     (int)animationType * 2);
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,RunScript,The following statement contains a magic number: int offset_to_script_type = (4 /* "SCEP" */ + 1 /* the script entry "type" */ + 3 /* the spacers */ +  						     (int)animationType * 2);
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,ReadWord,The following statement contains a magic number: pc += 2;
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,PaintSprite,The following statement contains a magic number: if (sprite_surface != null) {  				if ((x > SpriteManager.X - sprite_surface.Width / 2) && (x - sprite_surface.Width / 2 <= SpriteManager.X + Painter.SCREEN_RES_X)  				    && (y > SpriteManager.Y - sprite_surface.Height / 2) && (y - sprite_surface.Height / 2 <= SpriteManager.Y + 375)) {  					Painter.Blit (sprite_surface'  						      new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								 y - SpriteManager.Y - sprite_surface.Height / 2));    					if (show_sprite_borders) {  						Painter.DrawBox (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  											   y - SpriteManager.Y - sprite_surface.Height / 2)'  										new Size (sprite_surface.Width - 1'  											  sprite_surface.Height - 1))'  								 Color.Green);  					}  				}  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Invalidate,The following statement contains a magic number: Painter.Invalidate (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								      y - SpriteManager.Y - sprite_surface.Height / 2)'  							   sprite_surface.Size));
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Invalidate,The following statement contains a magic number: Painter.Invalidate (new Rectangle (new Point (x - SpriteManager.X - sprite_surface.Width / 2'  								      y - SpriteManager.Y - sprite_surface.Height / 2)'  							   sprite_surface.Size));
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,Sprite,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Sprite.cs,Tick,The following statement contains a magic number: switch ((IScriptOpcode)buf[pc++]) {  			case IScriptOpcode.playfram:  				warg1 = ReadWord (ref pc);  				TraceLine ("playfram: {0}"' warg1);  				DoPlayFrame (warg1 + facing % 16);  				break;  			case IScriptOpcode.playframtile:  				warg1 = ReadWord (ref pc);  				TraceLine ("playframetile: {0}"' warg1);  				break;  			case IScriptOpcode.sethorpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("sethorpos: {0}"' barg1);  				break;  			case IScriptOpcode.setpos:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("setpos: {0} {1}"' barg1' barg2);  				break;  			case IScriptOpcode.setvertpos:  				barg1 = ReadByte (ref pc);  				TraceLine ("setvertpos: {0}"' barg1);  				break;  			case IScriptOpcode.wait:  				barg1 = ReadByte (ref pc);  				TraceLine ("wait: {0}"' barg1);  				waiting = barg1;  				break;  			case IScriptOpcode.waitrand:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("waitrand: {0} {1}"' barg1' barg2);  				waiting = rng.Next(255) > 127 ? barg1 : barg2;  				break;  			case IScriptOpcode._goto:  				warg1 = ReadWord (ref pc);  				TraceLine ("goto: {0}"' warg1);  				pc = warg1;  				break;  			case IScriptOpcode.imgol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imgul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgul: {0} {1} {2}"' warg1' barg1' barg2);  				Sprite dependent_sprite = SpriteManager.CreateSprite (this' warg1' palette);  				dependent_sprite.RunScript (AnimationType.Init);  				break;  			case IScriptOpcode.imgolorig:  				warg1 = ReadWord (ref pc);  				TraceLine ("imgolorig: {0}"' warg1);  				break;  			case IScriptOpcode.switchul:  				warg1 = ReadWord (ref pc);  				TraceLine ("switchul: {0}"' warg1);  				break;  			// __0c unknown  			case IScriptOpcode.imgoluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgoluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.imguluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imguluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.highsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("highsprol: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.lowsprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} ({1}'{2})"' warg1' barg1' barg2);   				Sprite s = SpriteManager.CreateSprite (warg1' palette' x' y);   				s.RunScript (AnimationType.Init);  				dependentSprite = s;  				break;    				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("lowsprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.uflunstable:  				warg1 = ReadWord (ref pc);  				TraceLine ("uflunstable: {0}"' warg1);  				break;  			case IScriptOpcode.spruluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("spruluselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sprul:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sprul: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.sproluselo:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("sproleuselo: {0} {1} {2}"' warg1' barg1' barg2);  				break;  			case IScriptOpcode.end:  				TraceLine ("end");  				return false;  			case IScriptOpcode.setflipstate:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflipstate: {0}"' barg1);  				break;  			case IScriptOpcode.playsnd:  				warg1 = ReadWord (ref pc);  				TraceLine ("playsnd: {0} ({1})"' warg1 - 1' GlobalResources.Instance.SfxDataTbl[(int)GlobalResources.Instance.SfxDataDat.FileIndexes [warg1 - 1]]);  				break;  			case IScriptOpcode.playsndrand: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("playsndrand: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.playsndbtwn:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("playsndbtwn: {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.domissiledmg:  				TraceLine ("domissiledmg: unknown args");  				break;  			case IScriptOpcode.attackmelee: {  				barg1 = ReadByte (ref pc);  				ushort[] wargs = new ushort[barg1];  				for (byte b = 0; b < barg1; b ++) {  					wargs[b] = ReadWord (ref pc);  				}  				Trace ("attackmelee: {0} (");  				for (int i = 0; i < wargs.Length; i ++) {  					Trace ("{0}"' wargs[i]);  					if (i < wargs.Length - 1)  						Trace ("' ");  				}  				TraceLine (")");  				break;  			}  			case IScriptOpcode.followmaingraphic:  				TraceLine ("followmaingraphic:");  				if (parent_sprite != null)  					DoPlayFrame (parent_sprite.CurrentFrame);  				break;  			case IScriptOpcode.randcondjmp:  				barg1 = ReadByte (ref pc);  				warg1 = ReadWord (ref pc);  				TraceLine ("randcondjmp: {0} {1}"' barg1' warg1);  				int rand = rng.Next(255);  				if (rand > barg1) {  					TraceLine ("+ choosing goto branch");  					pc = warg1;  				}  				break;  			case IScriptOpcode.turnccwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turnccwise: {0}"' barg1);  				if (facing - barg1 < 0)  					facing = 15 - barg1;  				else  					facing -= barg1;  				break;  			case IScriptOpcode.turncwise:  				barg1 = ReadByte (ref pc);  				TraceLine ("turncwise: {0}"' barg1);  				if (facing + barg1 > 15)  					facing = facing + barg1 - 15;  				else  					facing += barg1;  				break;  			case IScriptOpcode.turnlcwise:  				TraceLine ("turnlcwise: unknown args");  				break;  			case IScriptOpcode.turnrand:  				TraceLine ("turnrand:");  				if (rng.Next(255) > 127)  					goto case IScriptOpcode.turnccwise;  				else  					goto case IScriptOpcode.turncwise;  				break;  			case IScriptOpcode.setspawnframe:  				barg1 = ReadByte (ref pc);  				TraceLine ("setspawnframe {0}"' barg1);  				break;  			case IScriptOpcode.sigorder:  				barg1 = ReadByte (ref pc);  				TraceLine ("sigorder {0}"' barg1);  				break;  			case IScriptOpcode.attackwith:  				barg1 = ReadByte (ref pc);  				TraceLine ("attackwith {0}"' barg1);  				break;  			case IScriptOpcode.attack:  				TraceLine ("attack:");  				break;  			case IScriptOpcode.castspell:  				TraceLine ("castspell:");  				break;  			case IScriptOpcode.useweapon:  				barg1 = ReadByte (ref pc);  				TraceLine ("useweapon: {0}"' barg1);  				break;  			case IScriptOpcode.move:  				barg1 = ReadByte (ref pc);  				TraceLine ("move: {0}"' barg1);  				break;  			case IScriptOpcode.gotorepeatattk:  				TraceLine ("gotorepeatattk");  				break;  			case IScriptOpcode.engframe:  				warg1 = ReadWord (ref pc);  				TraceLine ("engframe: {0}"' warg1);  				break;  			case IScriptOpcode.engset:  				warg1 = ReadWord (ref pc);  				TraceLine ("engset: {0}"' warg1);  				break;  			// __2d unknown  			case IScriptOpcode.nobrkcodestart:  				TraceLine ("nobrkcodestart:");  				break;  			case IScriptOpcode.nobrkcodeend:  				TraceLine ("nobrkcodeend:");  				break;  			case IScriptOpcode.ignorerest:  				TraceLine ("ignorerest");  				break;  			case IScriptOpcode.attkshiftproj:  				barg1 = ReadByte (ref pc);  				TraceLine ("attkshiftproj: {0}"' barg1);  				break;  			case IScriptOpcode.tmprmgraphicstart:  				TraceLine ("tmprmgraphicstart:");  				break;  			case IScriptOpcode.tmprmgraphicend:  				TraceLine ("tmprmgraphicend:");  				break;  			case IScriptOpcode.setfldirect:  				barg1 = ReadByte (ref pc);  				TraceLine ("setfldirect: {0}"' barg1);  				DoPlayFrame (barg1);  				break;  			case IScriptOpcode.call:  				warg1 = ReadWord (ref pc);  				TraceLine ("call: {0}"' warg1);  				break;  			case IScriptOpcode._return:  				TraceLine ("return:");  				break;  			case IScriptOpcode.setflspeed:  				barg1 = ReadByte (ref pc);  				TraceLine ("setflspeed: {0}"' barg1);  				break;  			case IScriptOpcode.creategasoverlays:  				barg1 = ReadByte (ref pc);  				TraceLine ("creategasoverlays: {0}"' barg1);  				break;  			case IScriptOpcode.pwrupcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("pwrupcondjmp: {0}"' warg1);  				break;  			case IScriptOpcode.trgtrangecondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				TraceLine ("trgtrangecondjmp {0} {1}"' warg1' warg2);  				break;  			case IScriptOpcode.trgtarccondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("trgtarccondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.curdirectcondjmp:  				warg1 = ReadWord (ref pc);  				warg2 = ReadWord (ref pc);  				warg3 = ReadWord (ref pc);  				TraceLine ("curdirectcondjmp {0} {1} {2}"' warg1' warg2' warg3);  				break;  			case IScriptOpcode.imgulnextid:  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("imgulnextid {0} {1}"' barg1' barg2);  				break;  			// __3e unknown  			case IScriptOpcode.liftoffcondjmp:  				warg1 = ReadWord (ref pc);  				TraceLine ("liftoffcondjmp {0}"' warg1);  				break;  			case IScriptOpcode.warpoverlay:  				warg1 = ReadWord (ref pc);  				TraceLine ("warpoverlay {0}"' warg1);  				break;  			case IScriptOpcode.orderdone:  				barg1 = ReadByte (ref pc);  				TraceLine ("orderdone {0}"' barg1);  				break;  			case IScriptOpcode.grdsprol:  				warg1 = ReadWord (ref pc);  				barg1 = ReadByte (ref pc);  				barg2 = ReadByte (ref pc);  				TraceLine ("grdsprol {0} {1} {2}"' warg1' barg1' barg2);  				break;  			// __43 unknown  			case IScriptOpcode.dogrddamage:  				TraceLine ("dogrddamage");  				break;  			default:  				Console.WriteLine ("Unknown iscript opcode: 0x{0:x}"' buf[pc-1]);  				break;  			}
Magic Number,SCSharp.UI,TextBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\TextBoxElement.cs,CreateSurface,The following statement contains a magic number: return GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  						    Sensitive ? 4 : 24);
Magic Number,SCSharp.UI,TextBoxElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\TextBoxElement.cs,CreateSurface,The following statement contains a magic number: return GuiUtil.ComposeText (Text' Font' Palette' Width' Height'  						    Sensitive ? 4 : 24);
Magic Number,SCSharp.UI,UIDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIDialog.cs,UIDialog,The following statement contains a magic number: background_translucent = 254;
Magic Number,SCSharp.UI,UIDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIDialog.cs,UIDialog,The following statement contains a magic number: dimScreenSurface.Alpha = 100;
Magic Number,SCSharp.UI,UIDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIDialog.cs,ResourceLoader,The following statement contains a magic number: if (Background != null) {  				baseX = (Painter.SCREEN_RES_X - Background.Width) / 2;  				baseY = (Painter.SCREEN_RES_Y - Background.Height) / 2;  				si = 0;  			}  			else {  				baseX = Elements[0].X1;  				baseY = Elements[0].Y1;  				si = 1;  			}
Magic Number,SCSharp.UI,UIDialog,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIDialog.cs,ResourceLoader,The following statement contains a magic number: if (Background != null) {  				baseX = (Painter.SCREEN_RES_X - Background.Width) / 2;  				baseY = (Painter.SCREEN_RES_Y - Background.Height) / 2;  				si = 0;  			}  			else {  				baseX = Elements[0].X1;  				baseY = Elements[0].Y1;  				si = 1;  			}
Magic Number,SCSharp.UI,UIElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIElement.cs,CreateSurface,The following statement contains a magic number: switch (Type) {  			case ElementType.DefaultButton:  			case ElementType.Button:  			case ElementType.ButtonWithoutBorder:  				return GuiUtil.ComposeText (Text' Font' palette' Width' Height'  							    sensitive ? 4 : 24);  			default:  				return null;  			}
Magic Number,SCSharp.UI,UIElement,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIElement.cs,CreateSurface,The following statement contains a magic number: switch (Type) {  			case ElementType.DefaultButton:  			case ElementType.Button:  			case ElementType.ButtonWithoutBorder:  				return GuiUtil.ComposeText (Text' Font' palette' Width' Height'  							    sensitive ? 4 : 24);  			default:  				return null;  			}
Magic Number,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,UIScreen,The following statement contains a magic number: background_translucent = 254;
Magic Number,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,BackgroundPainter,The following statement contains a magic number: int background_x = (Painter.Width - background.Width) / 2;
Magic Number,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,BackgroundPainter,The following statement contains a magic number: int background_y = (Painter.Height - background.Height) / 2;
Magic Number,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,ResourceLoader,The following statement contains a magic number: if (effectpal_path != null) {  				Console.WriteLine ("loading cursor palette");  				s = (Stream)mpq.GetResource (effectpal_path);  				if (s != null) {  					effectpal = new Pcx ();  					effectpal.ReadFromStream (s' -1' -1);  				}  				if (effectpal != null && arrowgrp_path != null) {  					Console.WriteLine ("loading arrow cursor");  					Grp arrowgrp = (Grp)mpq.GetResource (arrowgrp_path);  					if (arrowgrp != null) {  						Cursor = new CursorAnimator (arrowgrp' effectpal.Palette);  						Cursor.SetHotSpot (64' 64);  					}  				}  			}
Magic Number,SCSharp.UI,UIScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\UIScreen.cs,ResourceLoader,The following statement contains a magic number: if (effectpal_path != null) {  				Console.WriteLine ("loading cursor palette");  				s = (Stream)mpq.GetResource (effectpal_path);  				if (s != null) {  					effectpal = new Pcx ();  					effectpal.ReadFromStream (s' -1' -1);  				}  				if (effectpal != null && arrowgrp_path != null) {  					Console.WriteLine ("loading arrow cursor");  					Grp arrowgrp = (Grp)mpq.GetResource (arrowgrp_path);  					if (arrowgrp != null) {  						Cursor = new CursorAnimator (arrowgrp' effectpal.Palette);  						Cursor.SetHotSpot (64' 64);  					}  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,Move,The following statement contains a magic number: if (false /*flying unit*/) {  				// easier case' take the direct route  			}  			else {  				// Console.WriteLine ("FindPath from {0}'{1} -> {2}'{3}"'  				// 		   x >> 2' y >> 2'  				// 		   goal_minitile_x' goal_minitile_y);    				navigateDestination = new MapPoint (goal_minitile_x' goal_minitile_y);    				AStarSolver astar = new AStarSolver (mapRenderer);    				navigatePath = astar.FindPath (new MapPoint (x >> 2' y >> 2)'  							       navigateDestination);    				sprite.Debug = true;    				if (navigatePath != null)  					NavigateAlongPath ();  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,Move,The following statement contains a magic number: if (false /*flying unit*/) {  				// easier case' take the direct route  			}  			else {  				// Console.WriteLine ("FindPath from {0}'{1} -> {2}'{3}"'  				// 		   x >> 2' y >> 2'  				// 		   goal_minitile_x' goal_minitile_y);    				navigateDestination = new MapPoint (goal_minitile_x' goal_minitile_y);    				AStarSolver astar = new AStarSolver (mapRenderer);    				navigatePath = astar.FindPath (new MapPoint (x >> 2' y >> 2)'  							       navigateDestination);    				sprite.Debug = true;    				if (navigatePath != null)  					NavigateAlongPath ();  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,ClassifyDirection,The following statement contains a magic number: if (startCurrentSegment.X < endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("1 startCurrentSegment.Y < endCurrentSegment.Y");  					return 5;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 12");  					return 12;  				}  				else {  					Console.WriteLine ("1 startCurrentSegment.Y > endCurrentSegment.Y");  					return 2;  				}  			}  			else if (startCurrentSegment.X == endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y < endCurrentSegment.Y");  					return 7;  				}  				else if (startCurrentSegment.Y > endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  				else {  					Console.WriteLine ("@#(*@!#&( shouldn't happen");  					return 0;  				}  			}  			else {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("3 startCurrentSegment.Y < endCurrentSegment.Y");  					return 9;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 4");  					return 4;  				}  				else {  					Console.WriteLine ("3 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,ClassifyDirection,The following statement contains a magic number: if (startCurrentSegment.X < endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("1 startCurrentSegment.Y < endCurrentSegment.Y");  					return 5;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 12");  					return 12;  				}  				else {  					Console.WriteLine ("1 startCurrentSegment.Y > endCurrentSegment.Y");  					return 2;  				}  			}  			else if (startCurrentSegment.X == endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y < endCurrentSegment.Y");  					return 7;  				}  				else if (startCurrentSegment.Y > endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  				else {  					Console.WriteLine ("@#(*@!#&( shouldn't happen");  					return 0;  				}  			}  			else {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("3 startCurrentSegment.Y < endCurrentSegment.Y");  					return 9;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 4");  					return 4;  				}  				else {  					Console.WriteLine ("3 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,ClassifyDirection,The following statement contains a magic number: if (startCurrentSegment.X < endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("1 startCurrentSegment.Y < endCurrentSegment.Y");  					return 5;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 12");  					return 12;  				}  				else {  					Console.WriteLine ("1 startCurrentSegment.Y > endCurrentSegment.Y");  					return 2;  				}  			}  			else if (startCurrentSegment.X == endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y < endCurrentSegment.Y");  					return 7;  				}  				else if (startCurrentSegment.Y > endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  				else {  					Console.WriteLine ("@#(*@!#&( shouldn't happen");  					return 0;  				}  			}  			else {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("3 startCurrentSegment.Y < endCurrentSegment.Y");  					return 9;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 4");  					return 4;  				}  				else {  					Console.WriteLine ("3 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,ClassifyDirection,The following statement contains a magic number: if (startCurrentSegment.X < endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("1 startCurrentSegment.Y < endCurrentSegment.Y");  					return 5;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 12");  					return 12;  				}  				else {  					Console.WriteLine ("1 startCurrentSegment.Y > endCurrentSegment.Y");  					return 2;  				}  			}  			else if (startCurrentSegment.X == endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y < endCurrentSegment.Y");  					return 7;  				}  				else if (startCurrentSegment.Y > endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  				else {  					Console.WriteLine ("@#(*@!#&( shouldn't happen");  					return 0;  				}  			}  			else {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("3 startCurrentSegment.Y < endCurrentSegment.Y");  					return 9;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 4");  					return 4;  				}  				else {  					Console.WriteLine ("3 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,ClassifyDirection,The following statement contains a magic number: if (startCurrentSegment.X < endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("1 startCurrentSegment.Y < endCurrentSegment.Y");  					return 5;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 12");  					return 12;  				}  				else {  					Console.WriteLine ("1 startCurrentSegment.Y > endCurrentSegment.Y");  					return 2;  				}  			}  			else if (startCurrentSegment.X == endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y < endCurrentSegment.Y");  					return 7;  				}  				else if (startCurrentSegment.Y > endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  				else {  					Console.WriteLine ("@#(*@!#&( shouldn't happen");  					return 0;  				}  			}  			else {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("3 startCurrentSegment.Y < endCurrentSegment.Y");  					return 9;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 4");  					return 4;  				}  				else {  					Console.WriteLine ("3 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,ClassifyDirection,The following statement contains a magic number: if (startCurrentSegment.X < endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("1 startCurrentSegment.Y < endCurrentSegment.Y");  					return 5;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 12");  					return 12;  				}  				else {  					Console.WriteLine ("1 startCurrentSegment.Y > endCurrentSegment.Y");  					return 2;  				}  			}  			else if (startCurrentSegment.X == endCurrentSegment.X) {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y < endCurrentSegment.Y");  					return 7;  				}  				else if (startCurrentSegment.Y > endCurrentSegment.Y) {  					Console.WriteLine ("2 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  				else {  					Console.WriteLine ("@#(*@!#&( shouldn't happen");  					return 0;  				}  			}  			else {  				if (startCurrentSegment.Y < endCurrentSegment.Y) {  					Console.WriteLine ("3 startCurrentSegment.Y < endCurrentSegment.Y");  					return 9;  				}  				else if (startCurrentSegment.Y == endCurrentSegment.Y) {  					Console.WriteLine ("face = 4");  					return 4;  				}  				else {  					Console.WriteLine ("3 startCurrentSegment.Y > endCurrentSegment.Y");  					return 0;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: if (dest_pixel_x - pixel_x < 2)  				pixel_x = dest_pixel_x;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: if (dest_pixel_y - pixel_y < 2)  				pixel_y = dest_pixel_y;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: x = pixel_x << 2;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: y = pixel_y << 2;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: if (pixel_x == dest_pixel_x && pixel_y == dest_pixel_y) {  				startCurrentSegment = endCurrentSegment;  				navigatePath.RemoveAt (0);    				// if we're at the destination' remove the tick handler  				if (navigatePath.Count == 0) {  					sprite.RunScript (AnimationType.WalkingToIdle);  					Events.Tick -= NavigateTick;  				}  				else {  					endCurrentSegment = navigatePath[0];    					sprite.Face (ClassifyDirection (startCurrentSegment' endCurrentSegment));    					dest_pixel_x = endCurrentSegment.X * 4 + 4;  					dest_pixel_y = endCurrentSegment.Y * 4 + 4;    					delta_x = dest_pixel_x - pixel_x;  					delta_y = dest_pixel_y - pixel_y;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: if (pixel_x == dest_pixel_x && pixel_y == dest_pixel_y) {  				startCurrentSegment = endCurrentSegment;  				navigatePath.RemoveAt (0);    				// if we're at the destination' remove the tick handler  				if (navigatePath.Count == 0) {  					sprite.RunScript (AnimationType.WalkingToIdle);  					Events.Tick -= NavigateTick;  				}  				else {  					endCurrentSegment = navigatePath[0];    					sprite.Face (ClassifyDirection (startCurrentSegment' endCurrentSegment));    					dest_pixel_x = endCurrentSegment.X * 4 + 4;  					dest_pixel_y = endCurrentSegment.Y * 4 + 4;    					delta_x = dest_pixel_x - pixel_x;  					delta_y = dest_pixel_y - pixel_y;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: if (pixel_x == dest_pixel_x && pixel_y == dest_pixel_y) {  				startCurrentSegment = endCurrentSegment;  				navigatePath.RemoveAt (0);    				// if we're at the destination' remove the tick handler  				if (navigatePath.Count == 0) {  					sprite.RunScript (AnimationType.WalkingToIdle);  					Events.Tick -= NavigateTick;  				}  				else {  					endCurrentSegment = navigatePath[0];    					sprite.Face (ClassifyDirection (startCurrentSegment' endCurrentSegment));    					dest_pixel_x = endCurrentSegment.X * 4 + 4;  					dest_pixel_y = endCurrentSegment.Y * 4 + 4;    					delta_x = dest_pixel_x - pixel_x;  					delta_y = dest_pixel_y - pixel_y;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateTick,The following statement contains a magic number: if (pixel_x == dest_pixel_x && pixel_y == dest_pixel_y) {  				startCurrentSegment = endCurrentSegment;  				navigatePath.RemoveAt (0);    				// if we're at the destination' remove the tick handler  				if (navigatePath.Count == 0) {  					sprite.RunScript (AnimationType.WalkingToIdle);  					Events.Tick -= NavigateTick;  				}  				else {  					endCurrentSegment = navigatePath[0];    					sprite.Face (ClassifyDirection (startCurrentSegment' endCurrentSegment));    					dest_pixel_x = endCurrentSegment.X * 4 + 4;  					dest_pixel_y = endCurrentSegment.Y * 4 + 4;    					delta_x = dest_pixel_x - pixel_x;  					delta_y = dest_pixel_y - pixel_y;  				}  			}
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: int start_pixel_x = X * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: int start_pixel_x = X * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: int start_pixel_y = X * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: int start_pixel_y = X * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: dest_pixel_x = endCurrentSegment.X * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: dest_pixel_x = endCurrentSegment.X * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: dest_pixel_y = endCurrentSegment.Y * 4 + 4;
Magic Number,SCSharp.UI,Unit,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\Unit.cs,NavigateAlongPath,The following statement contains a magic number: dest_pixel_y = endCurrentSegment.Y * 4 + 4;
Missing Default,SCSharp.UI,GameScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\GameScreen.cs,KeyboardDown,The following switch statement is missing a default case: switch (args.Key) {  			case Key.F10:  				GameMenuDialog d = new GameMenuDialog (this' mpq);    				d.ReturnToGame += delegate () { DismissDialog (); };  				ShowDialog (d);  				break;    			case Key.RightArrow:  				horiz_delta = SCROLL_DELTA;  				break;  			case Key.LeftArrow:  				horiz_delta = -SCROLL_DELTA;  				break;  			case Key.DownArrow:  				vert_delta = SCROLL_DELTA;  				break;  			case Key.UpArrow:  				vert_delta = -SCROLL_DELTA;  				break;  			}
Missing Default,SCSharp.UI,MarkupScreen,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,KeyboardDown,The following switch statement is missing a default case: switch (args.Key)  			{  			case Key.Escape:  				Events.Tick -= FlipPage;  				MarkupFinished ();  				break;  			case Key.Space:  			case Key.Return:  				totalElapsed = 0;  				AdvanceToNextPage ();  				break;  			}
Missing Default,SCSharp.UI,MarkupPage,C:\repos\toshok_scsharp\SCSharp\SCSharp.UI\MarkupScreen.cs,Paint,The following switch statement is missing a default case: switch (location) {  				case PageLocation.Top:  					y = Y_OFFSET;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.Bottom:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Left:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else   							y += fnt.LineSize;  					}  					break;  				case PageLocation.LowerLeft:  					y = Painter.Height - Y_OFFSET - fnt.LineSize * lines.Count;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Right:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point (Painter.Width - s.Width - X_OFFSET' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				case PageLocation.Center:  					y = (Painter.Height - fnt.LineSize * lines.Count) / 2;  					foreach (Surface s in lineSurfaces) {  						if (s != null) {  							Painter.Blit (s' new Point ((Painter.Width - s.Width) / 2' y));  							y += s.Height;  						}  						else  							y += fnt.LineSize;  					}  					break;  				}
