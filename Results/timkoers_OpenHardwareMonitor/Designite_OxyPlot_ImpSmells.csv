Implementation smell,Namespace,Class,File,Method,Description
Long Method,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The method has 131 lines of code.
Long Method,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The method has 135 lines of code.
Long Method,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The method has 232 lines of code.
Long Method,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The method has 100 lines of code.
Complex Method,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,GetPoint,Cyclomatic complexity of the method is 18
Complex Method,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,GetVector,Cyclomatic complexity of the method is 23
Complex Method,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,Cyclomatic complexity of the method is 23
Complex Method,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,Cyclomatic complexity of the method is 39
Complex Method,OxyPlot,CodeGenerator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,SetProperties,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot,CodeGeneratorStringExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CodeGenerator\CodeGeneratorStringExtensions.cs,ToCode,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot,ListFiller,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\ListFiller.cs,Fill,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,Cyclomatic complexity of the method is 11
Complex Method,OxyPlot,SutherlandHodgmanClipping,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\SutherlandHodgmanClipping.cs,LineIntercept,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,CohenSutherlandClipping,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CohenSutherlandClipping.cs,ClipLine,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,Cyclomatic complexity of the method is 16
Complex Method,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,Cyclomatic complexity of the method is 14
Complex Method,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLine,Cyclomatic complexity of the method is 12
Complex Method,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawMarkers,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,Cyclomatic complexity of the method is 15
Complex Method,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,ClipRect,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,Render,Cyclomatic complexity of the method is 19
Complex Method,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetAxisTitlePositionAndAlignment,Cyclomatic complexity of the method is 14
Complex Method,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,Cyclomatic complexity of the method is 38
Complex Method,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMinorItems,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,Cyclomatic complexity of the method is 11
Complex Method,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,Cyclomatic complexity of the method is 66
Complex Method,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,Cyclomatic complexity of the method is 12
Complex Method,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteText,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,Cyclomatic complexity of the method is 32
Complex Method,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,Cyclomatic complexity of the method is 17
Complex Method,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,Cyclomatic complexity of the method is 22
Complex Method,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,Cyclomatic complexity of the method is 42
Complex Method,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,Cyclomatic complexity of the method is 30
Complex Method,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CreateDateTickValues,Cyclomatic complexity of the method is 19
Complex Method,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Reporting,HtmlReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\HtmlReportWriter.cs,WriteRows,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ErrorColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,UpdateMaxMin,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,Cyclomatic complexity of the method is 16
Complex Method,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,Cyclomatic complexity of the method is 16
Complex Method,OxyPlot.Series,DataPointSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\DataPointSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,InternalUpdateMaxMin,Cyclomatic complexity of the method is 8
Complex Method,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,GetNearestPoint,Cyclomatic complexity of the method is 10
Complex Method,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,Render,Cyclomatic complexity of the method is 11
Complex Method,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,Render,Cyclomatic complexity of the method is 9
Complex Method,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,Cyclomatic complexity of the method is 9
Long Parameter List,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,ImageAnnotation,The method has 5 parameters.
Long Parameter List,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The method has 5 parameters.
Long Parameter List,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The method has 5 parameters.
Long Parameter List,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The method has 6 parameters.
Long Parameter List,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The method has 7 parameters.
Long Parameter List,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,GetPointAtRelativeDistance,The method has 5 parameters.
Long Parameter List,OxyPlot,StringHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\StringHelper.cs,Format,The method has 5 parameters.
Long Parameter List,OxyPlot,FractionHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\FractionHelper.cs,ConvertToFractionString,The method has 5 parameters.
Long Parameter List,OxyPlot,TrackerHitResult,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\TrackerHitResult.cs,TrackerHitResult,The method has 6 parameters.
Long Parameter List,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,FromIndexed8,The method has 5 parameters.
Long Parameter List,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapInfoHeader,The method has 7 parameters.
Long Parameter List,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapV4Header,The method has 7 parameters.
Long Parameter List,OxyPlot,SvgExporter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgExporter.cs,Export,The method has 6 parameters.
Long Parameter List,OxyPlot,SvgExporter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgExporter.cs,ExportToString,The method has 5 parameters.
Long Parameter List,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The method has 6 parameters.
Long Parameter List,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The method has 5 parameters.
Long Parameter List,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,Segment,The method has 8 parameters.
Long Parameter List,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,The method has 6 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The method has 12 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The method has 11 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,MeasureMathText,The method has 5 parameters.
Long Parameter List,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The method has 13 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawLineSegments,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawPolygons,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLine,The method has 10 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLineSegments,The method has 8 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawImage,The method has 8 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedImage,The method has 9 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedPolygon,The method has 10 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedRectangle,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedRectangleAsPolygon,The method has 6 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedEllipse,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedText,The method has 12 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawLine,The method has 7 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawMarker,The method has 9 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawMarkers,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawMarkers,The method has 11 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawRectangleAsPolygon,The method has 5 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawRectangleAsPolygon,The method has 5 parameters.
Long Parameter List,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The method has 9 parameters.
Long Parameter List,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetAxisTitlePositionAndAlignment,The method has 5 parameters.
Long Parameter List,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The method has 5 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\IRenderContext.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\IRenderContext.cs,DrawLineSegments,The method has 6 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\IRenderContext.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\IRenderContext.cs,DrawPolygons,The method has 7 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\IRenderContext.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,IRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\IRenderContext.cs,DrawImage,The method has 11 parameters.
Long Parameter List,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The method has 9 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,SvgRenderContext,The method has 6 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawLine,The method has 6 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawPolygon,The method has 7 parameters.
Long Parameter List,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The method has 10 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteRectangle,The method has 5 parameters.
Long Parameter List,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteText,The method has 9 parameters.
Long Parameter List,OxyPlot.Axes,AngleAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\AngleAxis.cs,AngleAxis,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The method has 12 parameters.
Long Parameter List,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,The method has 7 parameters.
Long Parameter List,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,DateTimeAxis,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,DateTimeAxis,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,LinearAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LinearAxis.cs,LinearAxis,The method has 6 parameters.
Long Parameter List,OxyPlot.Axes,MagnitudeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\MagnitudeAxis.cs,MagnitudeAxis,The method has 5 parameters.
Long Parameter List,OxyPlot.Axes,TimeSpanAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\TimeSpanAxis.cs,TimeSpanAxis,The method has 5 parameters.
Long Parameter List,LinqBridge,OrderedEnumerable,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\LinqBridge.cs,OrderedEnumerable,The method has 6 parameters.
Long Parameter List,LinqBridge,OrderedEnumerable,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\LinqBridge.cs,OrderedEnumerable,The method has 9 parameters.
Long Parameter List,OxyPlot.Series,ErrorColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,UpdateMaxMin,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,ErrorColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,RenderItem,The method has 7 parameters.
Long Parameter List,OxyPlot.Series,BoxPlotItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotItem.cs,BoxPlotItem,The method has 8 parameters.
Long Parameter List,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,RectangleBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarItem.cs,RectangleBarItem,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,TornadoBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarItem.cs,TornadoBarItem,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,HighLowItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowItem.cs,HighLowItem,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,GetNearestPoint,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,UpdateData,The method has 10 parameters.
Long Parameter List,OxyPlot.Series,ScatterPoint,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterPoint.cs,ScatterPoint,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,UpdateData,The method has 10 parameters.
Long Parameter List,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,AddScatterPoints,The method has 17 parameters.
Long Parameter List,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,UpdateData,The method has 8 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 5 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 6 parameters.
Long Parameter List,OxyPlot.Series,FunctionSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The method has 6 parameters.
Long Statement,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,Render,The length of the statement  "	}' clippingRect' MinimumSegmentLength * MinimumSegmentLength' this.GetSelectableColor (this.Color)' this.StrokeThickness' this.LineStyle' this.LineJoin' false); " is 160.
Long Statement,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clippingRect' textPoint' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' ha' va); " is 150.
Long Statement,OxyPlot.Annotations,EllipseAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The length of the statement  "	this.screenRectangle = OxyRect.Create (this.Transform (this.X - (Width / 2)' Y - (Height / 2))' this.Transform (X + (Width / 2)' Y + (Height / 2))); " is 148.
Long Statement,OxyPlot.Annotations,EllipseAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clipping' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 211.
Long Statement,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The length of the statement  "	rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColors.White.ChangeAlpha (200)' null); " is 167.
Long Statement,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The length of the statement  "	rc.DrawText (p' this.CopyrightNotice' OxyColors.Black' null' 12' 500' 0' HorizontalAlignment.Right' VerticalAlignment.Bottom); " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double x0 = double.IsNaN (this.MinimumX) || this.MinimumX.Equals (double.MinValue) ? this.XAxis.ActualMinimum : this.MinimumX; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double x1 = double.IsNaN (this.MaximumX) || this.MaximumX.Equals (double.MaxValue) ? this.XAxis.ActualMaximum : this.MaximumX; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double y0 = double.IsNaN (this.MinimumY) || this.MinimumY.Equals (double.MinValue) ? this.YAxis.ActualMinimum : this.MinimumY; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "	double y1 = double.IsNaN (this.MaximumY) || this.MaximumY.Equals (double.MaxValue) ? this.YAxis.ActualMaximum : this.MaximumY; " is 126.
Long Statement,OxyPlot.Annotations,RectangleAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\RectangleAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clipping' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.TextRotation' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 211.
Long Statement,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,Render,The length of the statement  "	this.actualBounds = GetTextBounds (position' textSize' this.Padding' this.Rotation' this.HorizontalAlignment' this.VerticalAlignment); " is 134.
Long Statement,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedPolygon (this.actualBounds' clippingRect' MinDistSquared' this.Background' this.Stroke' this.StrokeThickness); " is 124.
Long Statement,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedText (clippingRect' position' this.Text' this.GetSelectableFillColor (this.ActualTextColor)' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' this.Rotation' this.HorizontalAlignment' this.VerticalAlignment); " is 233.
Long Statement,OxyPlot.Annotations,PolygonAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\PolygonAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedPolygon (this.screenPoints' clipping' MinimumSegmentLength * MinimumSegmentLength' this.GetSelectableFillColor (this.Fill)' this.GetSelectableColor (this.Color)' this.StrokeThickness' this.LineStyle' this.LineJoin); " is 229.
Long Statement,OxyPlot.Annotations,PolygonAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\PolygonAnnotation.cs,Render,The length of the statement  "		rc.DrawClippedText (clipping' textPosition' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 195.
Long Statement,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The length of the statement  "	bool isCurvedLine = !(this.XAxis is LinearAxis) || !(this.YAxis is LinearAxis) || this.Type == LineAnnotationType.EquationY; " is 124.
Long Statement,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The length of the statement  "	var clippingRectangle = OxyRect.Create (this.ClipByXAxis ? this.XAxis.ScreenMin.X : PlotModel.PlotArea.Left' this.ClipByYAxis ? this.YAxis.ScreenMin.Y : PlotModel.PlotArea.Top' this.ClipByXAxis ? this.XAxis.ScreenMax.X : PlotModel.PlotArea.Right' this.ClipByYAxis ? this.YAxis.ScreenMax.Y : PlotModel.PlotArea.Bottom); " is 318.
Long Statement,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The length of the statement  "	rc.DrawClippedLine (this.screenPoints' clippingRectangle' MinimumSegmentLength * MinimumSegmentLength' this.GetSelectableColor (this.Color)' this.StrokeThickness' this.LineStyle' this.LineJoin' aliased' pts => clippedPoints = pts); " is 231.
Long Statement,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The length of the statement  "	if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) { " is 126.
Long Statement,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment); " is 208.
Long Statement,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White); " is 177.
Long Statement,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hue,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Red' OxyColors.Yellow' OxyColors.Green' OxyColors.Cyan' OxyColors.Blue' OxyColors.Magenta' OxyColors.Red); " is 163.
Long Statement,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Jet,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.DarkBlue' OxyColors.Cyan' OxyColors.Yellow' OxyColors.Orange' OxyColors.DarkRed); " is 138.
Long Statement,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Rainbow,The length of the statement  "	return OxyPalette.Interpolate (numberOfColors' OxyColors.Violet' OxyColors.Indigo' OxyColors.Blue' OxyColors.Green' OxyColors.Yellow' OxyColors.Orange' OxyColors.Red); " is 167.
Long Statement,OxyPlot,ScreenPointHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\ScreenPointHelper.cs,IsPointInPolygon,The length of the statement  "		if (((pts [i].Y > p.Y) != (pts [j].Y > p.Y)) && (p.X < ((pts [j].X - pts [i].X) * ((p.Y - pts [i].Y) / (pts [j].Y - pts [i].Y))) + pts [i].X)) { " is 144.
Long Statement,OxyPlot,TrackerHitResult,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\TrackerHitResult.cs,ToString,The length of the statement  "	return StringHelper.Format (this.Series.ActualCulture' formatString' this.Item' this.Series.Title' xaxisTitle' xvalue' yaxisTitle' yvalue' this.Item).Trim (); " is 158.
Long Statement,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The length of the statement  "				Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance); " is 120.
Long Statement,OxyPlot,OxyThickness,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyThickness.cs,ToCode,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "new OxyThickness({0}'{1}'{2}'{3})"' this.Left' this.Top' this.Right' this.Bottom); " is 135.
Long Statement,OxyPlot,OxyThickness,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyThickness.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3})"' this.left' this.top' this.right' this.bottom); " is 122.
Long Statement,OxyPlot,OxyRect,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyRect.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3})"' this.left' this.top' this.width' this.height); " is 122.
Long Statement,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The length of the statement  "		this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va); " is 130.
Long Statement,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The length of the statement  "			for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) { " is 136.
Long Statement,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The length of the statement  "		for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) { " is 136.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLine,The length of the statement  "	var clipping = new CohenSutherlandClipping (clippingRectangle.Left' clippingRectangle.Right' clippingRectangle.Top' clippingRectangle.Bottom); " is 142.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLineSegments,The length of the statement  "	var clipping = new CohenSutherlandClipping (clippingRectangle.Left' clippingRectangle.Right' clippingRectangle.Top' clippingRectangle.Bottom); " is 142.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedImage,The length of the statement  "	rc.DrawImage (source' (uint)srcx' (uint)srcy' (uint)srcw' (uint)srch' destx' desty' destw' desth' opacity' interpolate); " is 120.
Long Statement,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawRectangleAsPolygon,The length of the statement  "	if (thickness.Left.Equals (thickness.Right) && thickness.Left.Equals (thickness.Top) && thickness.Left.Equals (thickness.Bottom)) { " is 131.
Long Statement,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetAxisTitlePositionAndAlignment,The length of the statement  "	double middle = axis.IsHorizontal () ? Lerp (axis.ScreenMin.X' axis.ScreenMax.X' axis.TitlePosition) : Lerp (axis.ScreenMax.Y' axis.ScreenMin.Y' axis.TitlePosition); " is 165.
Long Statement,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderAxisTitle,The length of the statement  "		double screenLength = isHorizontal ? Math.Abs (axis.ScreenMax.X - axis.ScreenMin.X) : Math.Abs (axis.ScreenMax.Y - axis.ScreenMin.Y); " is 133.
Long Statement,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderAxisTitle,The length of the statement  "	this.rc.DrawMathText (lpt' axis.ActualTitle' axis.ActualTitleColor' axis.ActualTitleFont' axis.ActualTitleFontSize' axis.ActualTitleFontWeight' angle' halign' valign' maxSize); " is 176.
Long Statement,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The length of the statement  "		this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' axis.Angle' ha' va); " is 135.
Long Statement,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The length of the statement  "		this.rc.DrawLine (axis.Transform (actualMinimum)' axisPosition' axis.Transform (actualMaximum)' axisPosition' this.AxislinePen); " is 128.
Long Statement,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The length of the statement  "		this.rc.DrawLine (axisPosition' axis.Transform (actualMinimum)' axisPosition' axis.Transform (actualMaximum)' this.AxislinePen); " is 128.
Long Statement,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,IsValidValue,The length of the statement  "	return !double.IsNaN (value) && !double.IsInfinity (value) && value < this.FilterMaxValue && value > this.FilterMinValue && (this.FilterFunction == null || this.FilterFunction (value)); " is 185.
Long Statement,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0}({1}' {2}' {3}' {4})"' this.GetType ().Name' this.Position' this.ActualMinimum' this.ActualMaximum' this.ActualMajorStep); " is 178.
Long Statement,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateIntervals,The length of the statement  "	this.ActualMajorStep = !double.IsNaN (this.MajorStep) ? this.MajorStep : this.CalculateActualInterval (length' labelSize); " is 122.
Long Statement,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateIntervals,The length of the statement  "	this.ActualMinorStep = !double.IsNaN (this.MinorStep) ? this.MinorStep : this.CalculateMinorInterval (this.ActualMajorStep); " is 124.
Long Statement,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The length of the statement  "	// double maxIntervals = Orientation == AxisOrientation.x ? MaximumAxisIntervalsPer200Pixels * 0.8 : MaximumAxisIntervalsPer200Pixels; " is 134.
Long Statement,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateMinorInterval,The length of the statement  "	// The following obsolete code divided major intervals into 4 minor intervals' unless the major interval's mantissa was 5. " is 122.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "		var maxBarWidth = stackedSeries.Where (s => s.StackGroup == stackIndices [j]).Select (s => ((CategorizedSeries)s).GetBarWidth ()).Concat (new[] { " is 145.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "			if (stackedSeries.SelectMany (s => ((CategorizedSeries)s).GetItems ()).Any (item => item.GetCategoryIndex (k++) == i)) { " is 120.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "	var unstackedBarSeries = categorizedSeries.Where (s => !(s is IStackableSeries) || !((IStackableSeries)s).IsStacked).ToList (); " is 127.
Long Statement,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The length of the statement  "			if (stackedSeries.SelectMany (s => ((CategorizedSeries)s).GetItems ()).All (item => item.GetCategoryIndex (k++) != i)) { " is 120.
Long Statement,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,GetPaletteIndex,The length of the statement  "	int index = 1 + (int)((value - this.ActualMinimum) / (this.ActualMaximum - this.ActualMinimum) * this.Palette.Colors.Count); " is 124.
Long Statement,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,The length of the statement  "			rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' null); " is 147.
Long Statement,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,GetLowValue,The length of the statement  "	return ((double)paletteIndex / this.Palette.Colors.Count * (this.ActualMaximum - this.ActualMinimum)) + this.ActualMinimum; " is 123.
Long Statement,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,GetTickValues,The length of the statement  "	minorTickValues = this.CreateDateTimeTickValues (this.ActualMinimum' this.ActualMaximum' this.ActualMinorStep' this.actualMinorIntervalType); " is 141.
Long Statement,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,GetTickValues,The length of the statement  "	majorTickValues = this.CreateDateTimeTickValues (this.ActualMinimum' this.ActualMaximum' this.ActualMajorStep' this.actualIntervalType); " is 136.
Long Statement,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CreateDateTimeTickValues,The length of the statement  "	// If the step size is more than 7 days (e.g. months or years) we use a specialized tick generation method that adds tick values with uneven spacing... " is 151.
Long Statement,OxyPlot.Axes,LinearAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LinearAxis.cs,FormatValue,The length of the statement  "		return FractionHelper.ConvertToFractionString (x' this.FractionUnit' this.FractionUnitSymbol' 1e-6' this.ActualCulture); " is 120.
Long Statement,OxyPlot.Series,BarItemBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarItemBase.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}"' this.Value' this.CategoryIndex' this.Color.ToCode ()); " is 126.
Long Statement,OxyPlot.Series,ErrorColumnItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ErrorColumnItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}"' this.Value' this.Error' this.CategoryIndex' this.Color.ToCode ()); " is 142.
Long Statement,OxyPlot.Series,BoxPlotItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotItem.cs,ToString,The length of the statement  "	return string.Format ("{0} {1} {2} {3} {4} {5} "' this.X' this.LowerWhisker' this.BoxBottom' this.Median' this.BoxTop' this.UpperWhisker); " is 138.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,The length of the statement  "				result.Text = StringHelper.Format (this.ActualCulture' this.OutlierTrackerFormatString' item' this.Title' this.XAxis.GetValue (result.DataPoint.X)' outlier); " is 157.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,The length of the statement  "			result.Text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Title' this.XAxis.GetValue (result.DataPoint.X)' item.UpperWhisker' item.BoxTop' item.Median' item.BoxBottom' item.LowerWhisker); " is 221.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,GetNearestPoint,The length of the statement  "			result.Text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Title' this.XAxis.GetValue (result.DataPoint.X)' item.UpperWhisker' item.BoxTop' item.Median' item.BoxBottom' item.LowerWhisker); " is 221.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,IsValidPoint,The length of the statement  "	return !double.IsNaN (item.X) && !double.IsInfinity (item.X) && !item.Values.Any (double.IsNaN) && !item.Values.Any (double.IsInfinity) && (xaxis != null && xaxis.IsValidValue (item.X)) && (yaxis != null && item.Values.All (yaxis.IsValidValue)); " is 245.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The length of the statement  "			}' clippingRect' 0' strokeColor' this.StrokeThickness * this.MedianThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true); " is 123.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The length of the statement  "				var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2); " is 141.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The length of the statement  "	rc.DrawMarkers (outlierScreenPoints' clippingRect' this.OutlierType' null' markerSizes' fillColor' strokeColor' this.StrokeThickness); " is 134.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The length of the statement  "		rc.DrawRectangleAsPolygon (new OxyRect (xmid - halfBoxWidth' ytop' 2 * halfBoxWidth' ybottom - ytop)' fillColor' strokeColor' LegendStrokeThickness); " is 149.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The length of the statement  "		}' strokeColor' LegendStrokeThickness * this.MedianThickness' LineStyle.Solid.GetDashArray ()' OxyPenLineJoin.Miter' true); " is 123.
Long Statement,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The length of the statement  "		var ellipseRect = new OxyRect (xmid - this.MedianPointSize' ymid - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2); " is 141.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawClippedLine (pts0' clippingRect' minDistSquared' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle' this.LineJoin' false); " is 166.
Long Statement,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The length of the statement  "	rc.DrawClippedLine (pts1' clippingRect' minDistSquared' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle' this.LineJoin' false); " is 166.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The length of the statement  "				}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false); " is 124.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The length of the statement  "				}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true); " is 123.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The length of the statement  "				}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true); " is 123.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The length of the statement  "				rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness); " is 194.
Long Statement,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (this.CandleWidth * 0.5)' yclose' this.CandleWidth' yopen - yclose)' this.GetSelectableFillColor (this.ActualColor)' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness); " is 230.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The length of the statement  "	Conrec.RendererDelegate renderer = (startX' startY' endX' endY' contourLevel) => this.segments.Add (new ContourSegment (new DataPoint (startX' startY)' new DataPoint (endX' endY)' contourLevel)); " is 195.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,GetNearestPoint,The length of the statement  "		var r = interpolate ? this.GetNearestInterpolatedPointInternal (c.Points' point) : this.GetNearestPointInternal (c.Points' point); " is 130.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,GetNearestPoint,The length of the statement  "				result.Text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' null' this.Title' xaxisTitle' r.DataPoint.X' yaxisTitle' r.DataPoint.Y' zaxisTitle' c.ContourLevel); " is 181.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The length of the statement  "			rc.DrawClippedLine (pts' clippingRect' 4' this.GetSelectableColor (contour.Color ?? this.ActualColor)' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' false); " is 170.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The length of the statement  "			segment2 = this.FindConnectedSegment ((DataPoint)contourPoints [contourPointsCount - 1]' firstSegment.ContourLevel' eps' out reverse); " is 134.
Long Statement,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,RenderLabel,The length of the statement  "		rc.DrawText (cl.Position' cl.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' cl.Angle' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 182.
Long Statement,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,GetCategoryAxis,The length of the statement  "		throw new Exception ("A ColumnSeries requires a CategoryAxis on the x-axis. Use a BarSeries if you want horizontal bars."); " is 123.
Long Statement,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The length of the statement  "	var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' value); " is 130.
Long Statement,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The length of the statement  "	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' va); " is 159.
Long Statement,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,GetCategoryAxis,The length of the statement  "		throw new Exception ("A BarSeries requires a CategoryAxis on the y-axis. Use a ColumnSeries if you want vertical bars."); " is 121.
Long Statement,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The length of the statement  "	var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' value); " is 130.
Long Statement,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The length of the statement  "	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' ha' VerticalAlignment.Middle); " is 157.
Long Statement,OxyPlot.Series,IntervalBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}"' this.Start' this.End' this.Title' this.Color.ToCode ()); " is 132.
Long Statement,OxyPlot.Series,RectangleBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}'{4}'{5}"' this.X0' this.Y0' this.X1' this.Y1' this.Title' this.Color.ToCode ()); " is 154.
Long Statement,OxyPlot.Series,RectangleBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}'{4}"' this.X0' this.Y0' this.X1' this.Y1' this.Title); " is 128.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,GetNearestPoint,The length of the statement  "			var text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Items [i].X0' this.Items [i].X1' this.Items [i].Y0' this.Items [i].Y1' this.Items [i].Title); " is 182.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (rectangle' clippingRect' this.GetSelectableFillColor (item.Color ?? this.ActualFillColor)' this.StrokeColor' this.StrokeThickness); " is 165.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The length of the statement  "			var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title); " is 139.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 181.
Long Statement,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness); " is 193.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,GetNearestPoint,The length of the statement  "			var text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Items [i].Start' this.Items [i].End' this.Items [i].Title); " is 148.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (rectangle' clippingRect' this.GetSelectableFillColor (item.Color ?? this.ActualFillColor)' this.StrokeColor' this.StrokeThickness); " is 165.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The length of the statement  "			var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title); " is 125.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 181.
Long Statement,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness); " is 193.
Long Statement,OxyPlot.Series,TornadoBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}'{4}"' this.Minimum' this.Maximum' this.BaseValue' this.MinimumColor.ToCode ()' this.MaximumColor.ToCode ()); " is 182.
Long Statement,OxyPlot.Series,TornadoBarItem,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarItem.cs,ToCode,The length of the statement  "		return CodeGenerator.FormatConstructor (this.GetType ()' "{0}'{1}'{2}'{3}"' this.Minimum' this.Maximum' this.BaseValue' this.MinimumColor.ToCode ()); " is 149.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (minimumRectangle' clippingRect' item.MinimumColor ?? this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness); " is 156.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "		rc.DrawClippedRectangleAsPolygon (maximumRectangle' clippingRect' item.MaximumColor ?? this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness); " is 156.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum); " is 144.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2); " is 122.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle); " is 180.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum); " is 144.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2); " is 123.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The length of the statement  "			rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle); " is 179.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness); " is 176.
Long Statement,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The length of the statement  "	rc.DrawRectangleAsPolygon (new OxyRect (xmid' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness); " is 160.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,GetNearestPoint,The length of the statement  "				result.Text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Title' this.XAxis.GetValue (p.X)' item.High' item.Low' item.Open' item.Close); " is 170.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,IsValidItem,The length of the statement  "	return !double.IsNaN (pt.X) && !double.IsInfinity (pt.X) && !double.IsNaN (pt.High) && !double.IsInfinity (pt.High) && !double.IsNaN (pt.Low) && !double.IsInfinity (pt.Low); " is 173.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,Render,The length of the statement  "			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true); " is 123.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,Render,The length of the statement  "				}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true); " is 123.
Long Statement,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,Render,The length of the statement  "				}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true); " is 123.
Long Statement,OxyPlot.Series,StemSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StemSeries.cs,Render,The length of the statement  "			}' clippingRect' minDistSquared' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle' this.LineJoin' false); " is 143.
Long Statement,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The length of the statement  "			var verticalStrokeThickness = double.IsNaN (this.VerticalStrokeThickness) ? this.StrokeThickness : this.VerticalStrokeThickness; " is 128.
Long Statement,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The length of the statement  "				rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false); " is 148.
Long Statement,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The length of the statement  "				rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false); " is 164.
Long Statement,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The length of the statement  "				rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false); " is 142.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,GetNearestPoint,The length of the statement  "		if (p.X < this.XAxis.ActualMinimum || p.X > this.XAxis.ActualMaximum || p.Y < this.YAxis.ActualMinimum || p.Y > this.YAxis.ActualMaximum) { " is 139.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,GetNearestPoint,The length of the statement  "			var text = StringHelper.Format (this.ActualCulture' formatString' item' this.Title' xaxisTitle' xvalue' yaxisTitle' yvalue' colorAxisTitle' zvalue); " is 148.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,IsValidPoint,The length of the statement  "	return !double.IsNaN (pt.X) && !double.IsInfinity (pt.X) && !double.IsNaN (pt.Y) && !double.IsInfinity (pt.Y) && (xaxis != null && xaxis.IsValidValue (pt.X)) && (yaxis != null && yaxis.IsValidValue (pt.Y)); " is 206.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,Render,The length of the statement  "		var markerIsStrokedOnly = this.MarkerType == MarkerType.Plus || this.MarkerType == MarkerType.Star || this.MarkerType == MarkerType.Cross; " is 138.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,Render,The length of the statement  "			rc.DrawMarkers (group.Value' clippingRect' this.MarkerType' this.MarkerOutline' groupSizes [group.Key]' color' markerIsStrokedOnly ? color : this.MarkerStroke' this.MarkerStrokeThickness' this.BinSize' binOffset); " is 213.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,Render,The length of the statement  "		rc.DrawMarkers (allPoints' clippingRect' this.MarkerType' this.MarkerOutline' markerSizes' this.ActualMarkerFillColor' this.MarkerStroke' this.MarkerStrokeThickness' this.BinSize' binOffset); " is 191.
Long Statement,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,RenderLegend,The length of the statement  "	rc.DrawMarker (midpt' legendBox' this.MarkerType' this.MarkerOutline' this.MarkerSize' this.ActualMarkerFillColor' this.MarkerStroke' this.MarkerStrokeThickness); " is 162.
Long Statement,OxyPlot.Series,TwoColorLineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\TwoColorLineSeries.cs,RenderSmoothedLine,The length of the statement  "	rc.DrawClippedLine (pointsToRender' clippingRect' this.MinimumSegmentLength * this.MinimumSegmentLength' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle' this.LineJoin' false); " is 215.
Long Statement,OxyPlot.Series,TwoColorLineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\TwoColorLineSeries.cs,RenderSmoothedLine,The length of the statement  "	rc.DrawClippedLine (pointsToRender' clippingRect' this.MinimumSegmentLength * this.MinimumSegmentLength' this.GetSelectableColor (this.ActualColor2)' this.StrokeThickness' this.ActualLineStyle2' this.LineJoin' false); " is 217.
Long Statement,OxyPlot.Series,XYAxisSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\XYAxisSeries.cs,IsValidPoint,The length of the statement  "	return !double.IsNaN (pt.X) && !double.IsInfinity (pt.X) && !double.IsNaN (pt.Y) && !double.IsInfinity (pt.Y) && (xaxis != null && xaxis.IsValidValue (pt.X)) && (yaxis != null && yaxis.IsValidValue (pt.Y)); " is 206.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "	var midPoint = new ScreenPoint ((model.PlotArea.Left + model.PlotArea.Right) * 0.5' (model.PlotArea.Top + model.PlotArea.Bottom) * 0.5); " is 136.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "		var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians))); " is 146.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians))); " is 173.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians))); " is 151.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle); " is 212.
Long Statement,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The length of the statement  "			rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle); " is 183.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,Render,The length of the statement  "		rc.DrawClippedLineSegments (lineBreakSegments' clippingRect' this.BrokenLineColor' this.BrokenLineThickness' this.BrokenLineStyle' this.LineJoin' false); " is 153.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,Render,The length of the statement  "	if (this.LineLegendPosition != LineLegendPosition.None && this.Points.Count > 0 && !string.IsNullOrEmpty (this.Title)) { " is 120.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegend,The length of the statement  "	rc.DrawLine (pts' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle.GetDashArray ()); " is 122.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegend,The length of the statement  "	rc.DrawMarker (midpt' legendBox' this.MarkerType' this.MarkerOutline' this.MarkerSize' this.MarkerFill' this.MarkerStroke' this.MarkerStrokeThickness); " is 151.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderPointLabels,The length of the statement  "		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Bottom); " is 181.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The length of the statement  "	rc.DrawClippedText (clippingRect' pt' this.Title' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' ha' VerticalAlignment.Middle); " is 166.
Long Statement,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderSmoothedLine,The length of the statement  "	rc.DrawClippedLine (pointsToRender' clippingRect' this.MinimumSegmentLength * this.MinimumSegmentLength' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.ActualLineStyle' this.LineJoin' false); " is 215.
Complex Conditional,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedImage,The conditional expression  "x > clippingRect.Right || x + w < clippingRect.Left || y > clippingRect.Bottom || y + h < clippingRect.Top"  is complex.
Complex Conditional,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The conditional expression  "!this.IsValid (item.X0) || !this.IsValid (item.X1) || !this.IsValid (item.Y0) || !this.IsValid (item.Y1)"  is complex.
Complex Conditional,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,GetNearestPoint,The conditional expression  "p.X < this.XAxis.ActualMinimum || p.X > this.XAxis.ActualMaximum || p.Y < this.YAxis.ActualMinimum || p.Y > this.YAxis.ActualMaximum"  is complex.
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,ArrowAnnotation,The following statement contains a magic number: this.HeadLength = 10;  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,ArrowAnnotation,The following statement contains a magic number: this.HeadWidth = 3;  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,ArrowAnnotation,The following statement contains a magic number: this.StrokeThickness = 2;  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,HitTest,The following statement contains a magic number: if ((point - this.screenEndPoint).Length < tolerance) {  	return new HitTestResult (this.screenEndPoint' null' 2);  }  
Magic Number,OxyPlot.Annotations,ArrowAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ArrowAnnotation.cs,HitTest,The following statement contains a magic number: return new HitTestResult (this.screenEndPoint' null' 2);  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = OxyRect.Create (this.Transform (this.X - (Width / 2)' Y - (Height / 2))' this.Transform (X + (Width / 2)' Y + (Height / 2)));  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = OxyRect.Create (this.Transform (this.X - (Width / 2)' Y - (Height / 2))' this.Transform (X + (Width / 2)' Y + (Height / 2)));  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = OxyRect.Create (this.Transform (this.X - (Width / 2)' Y - (Height / 2))' this.Transform (X + (Width / 2)' Y + (Height / 2)));  
Magic Number,OxyPlot.Annotations,EllipseAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\EllipseAnnotation.cs,Render,The following statement contains a magic number: this.screenRectangle = OxyRect.Create (this.Transform (this.X - (Width / 2)' Y - (Height / 2))' this.Transform (X + (Width / 2)' Y + (Height / 2)));  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,ImageAnnotation,The following statement contains a magic number: this.X = new PlotLength (0.5' PlotLengthUnit.RelativeToPlotArea);  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,ImageAnnotation,The following statement contains a magic number: this.Y = new PlotLength (0.5' PlotLengthUnit.RelativeToPlotArea);  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: if (this.HorizontalAlignment == HorizontalAlignment.Center) {  	x -= width * 0.5;  }  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: x -= width * 0.5;  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: if (this.VerticalAlignment == VerticalAlignment.Middle) {  	y -= height * 0.5;  }  
Magic Number,OxyPlot.Annotations,ImageAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\ImageAnnotation.cs,Render,The following statement contains a magic number: y -= height * 0.5;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileMapAnnotation,The following statement contains a magic number: this.TileSize = 256;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileMapAnnotation,The following statement contains a magic number: this.MaxZoomLevel = 20;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileMapAnnotation,The following statement contains a magic number: this.MaxNumberOfDownloads = 8;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColors.White.ChangeAlpha (200)' null);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColors.White.ChangeAlpha (200)' null);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColors.White.ChangeAlpha (200)' null);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColors.White.ChangeAlpha (200)' null);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawRectangle (new OxyRect (p.X - textSize.Width - 2' p.Y - textSize.Height - 2' textSize.Width + 4' textSize.Height + 4)' OxyColors.White.ChangeAlpha (200)' null);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawText (p' this.CopyrightNotice' OxyColors.Black' null' 12' 500' 0' HorizontalAlignment.Right' VerticalAlignment.Bottom);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,Render,The following statement contains a magic number: rc.DrawText (p' this.CopyrightNotice' OxyColors.Black' null' 12' 500' 0' HorizontalAlignment.Right' VerticalAlignment.Bottom);  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The following statement contains a magic number: x = (longitude + 180.0) / 360.0 * n;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The following statement contains a magic number: x = (longitude + 180.0) / 360.0 * n;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,LatLonToTile,The following statement contains a magic number: y = (1.0 - Math.Log (Math.Tan (lat) + 1.0 / Math.Cos (lat)) / Math.PI) / 2.0 * n;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The following statement contains a magic number: longitude = (x / n * 360.0) - 180.0;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The following statement contains a magic number: longitude = (x / n * 360.0) - 180.0;  
Magic Number,OxyPlot.Annotations,TileMapAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TileMapAnnotation.cs,TileToLatLon,The following statement contains a magic number: latitude = lat * 180.0 / Math.PI;  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,TextAnnotation,The following statement contains a magic number: this.Padding = new OxyThickness (4);  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: switch (horizontalAlignment) {  case HorizontalAlignment.Center:  	left = -size.Width * 0.5;  	right = -left;  	break;  case HorizontalAlignment.Right:  	left = -size.Width;  	right = 0;  	break;  default:  	left = 0;  	right = size.Width;  	break;  }  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: left = -size.Width * 0.5;  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: switch (verticalAlignment) {  case VerticalAlignment.Middle:  	top = -size.Height * 0.5;  	bottom = -top;  	break;  case VerticalAlignment.Bottom:  	top = -size.Height;  	bottom = 0;  	break;  default:  	top = 0;  	bottom = size.Height;  	break;  }  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: top = -size.Height * 0.5;  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: polygon [2] = position + (u * (right + padding.Right)) + (v * (bottom + padding.Bottom));  
Magic Number,OxyPlot.Annotations,TextAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\TextAnnotation.cs,GetTextBounds,The following statement contains a magic number: polygon [3] = position + (u * (left - padding.Left)) + (v * (bottom + padding.Bottom));  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,LineAnnotation,The following statement contains a magic number: this.TextMargin = 12;  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (!isCurvedLine) {  	// we only need to calculate two points if it is a straight line  	if (fx != null) {  		points.Add (new DataPoint (actualMinimumX' fx (actualMinimumX)));  		points.Add (new DataPoint (actualMaximumX' fx (actualMaximumX)));  	}  	else if (fy != null) {  		points.Add (new DataPoint (fy (actualMinimumY)' actualMinimumY));  		points.Add (new DataPoint (fy (actualMaximumY)' actualMaximumY));  	}  	if (this.Type == LineAnnotationType.Horizontal || this.Type == LineAnnotationType.Vertical) {  		// use aliased line drawing for horizontal and vertical lines  		aliased = true;  	}  }  else {  	if (fx != null) {  		double x = actualMinimumX;  		// todo: the step size should be adaptive  		double dx = (actualMaximumX - actualMinimumX) / 100;  		while (true) {  			points.Add (new DataPoint (x' fx (x)));  			if (x > actualMaximumX) {  				break;  			}  			x += dx;  		}  	}  	else if (fy != null) {  		double y = actualMinimumY;  		// todo: the step size should be adaptive  		double dy = (actualMaximumY - actualMinimumY) / 100;  		while (true) {  			points.Add (new DataPoint (fy (y)' y));  			if (y > actualMaximumY) {  				break;  			}  			y += dy;  		}  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (!isCurvedLine) {  	// we only need to calculate two points if it is a straight line  	if (fx != null) {  		points.Add (new DataPoint (actualMinimumX' fx (actualMinimumX)));  		points.Add (new DataPoint (actualMaximumX' fx (actualMaximumX)));  	}  	else if (fy != null) {  		points.Add (new DataPoint (fy (actualMinimumY)' actualMinimumY));  		points.Add (new DataPoint (fy (actualMaximumY)' actualMaximumY));  	}  	if (this.Type == LineAnnotationType.Horizontal || this.Type == LineAnnotationType.Vertical) {  		// use aliased line drawing for horizontal and vertical lines  		aliased = true;  	}  }  else {  	if (fx != null) {  		double x = actualMinimumX;  		// todo: the step size should be adaptive  		double dx = (actualMaximumX - actualMinimumX) / 100;  		while (true) {  			points.Add (new DataPoint (x' fx (x)));  			if (x > actualMaximumX) {  				break;  			}  			x += dx;  		}  	}  	else if (fy != null) {  		double y = actualMinimumY;  		// todo: the step size should be adaptive  		double dy = (actualMaximumY - actualMinimumY) / 100;  		while (true) {  			points.Add (new DataPoint (fy (y)' y));  			if (y > actualMaximumY) {  				break;  			}  			y += dy;  		}  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (fx != null) {  	double x = actualMinimumX;  	// todo: the step size should be adaptive  	double dx = (actualMaximumX - actualMinimumX) / 100;  	while (true) {  		points.Add (new DataPoint (x' fx (x)));  		if (x > actualMaximumX) {  			break;  		}  		x += dx;  	}  }  else if (fy != null) {  	double y = actualMinimumY;  	// todo: the step size should be adaptive  	double dy = (actualMaximumY - actualMinimumY) / 100;  	while (true) {  		points.Add (new DataPoint (fy (y)' y));  		if (y > actualMaximumY) {  			break;  		}  		y += dy;  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (fx != null) {  	double x = actualMinimumX;  	// todo: the step size should be adaptive  	double dx = (actualMaximumX - actualMinimumX) / 100;  	while (true) {  		points.Add (new DataPoint (x' fx (x)));  		if (x > actualMaximumX) {  			break;  		}  		x += dx;  	}  }  else if (fy != null) {  	double y = actualMinimumY;  	// todo: the step size should be adaptive  	double dy = (actualMaximumY - actualMinimumY) / 100;  	while (true) {  		points.Add (new DataPoint (fy (y)' y));  		if (y > actualMaximumY) {  			break;  		}  		y += dy;  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (fy != null) {  	double y = actualMinimumY;  	// todo: the step size should be adaptive  	double dy = (actualMaximumY - actualMinimumY) / 100;  	while (true) {  		points.Add (new DataPoint (fy (y)' y));  		if (y > actualMaximumY) {  			break;  		}  		y += dy;  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  	margin = 0;  }  else {  	margin *= this.TextPosition < 0.5 ? 1 : -1;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: margin *= this.TextPosition < 0.5 ? 1 : -1;  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position.X += f * this.TextPadding * Math.Cos (angleInRadians);  	position.Y += f * this.TextPadding * Math.Sin (angleInRadians);  	var cs = new CohenSutherlandClipping (clippingRectangle);  	if (!string.IsNullOrEmpty (this.Text) && cs.IsInside (position)) {  		rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position.X += f * this.TextPadding * Math.Cos (angleInRadians);  	position.Y += f * this.TextPadding * Math.Sin (angleInRadians);  	var cs = new CohenSutherlandClipping (clippingRectangle);  	if (!string.IsNullOrEmpty (this.Text) && cs.IsInside (position)) {  		rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position.X += f * this.TextPadding * Math.Cos (angleInRadians);  	position.Y += f * this.TextPadding * Math.Sin (angleInRadians);  	var cs = new CohenSutherlandClipping (clippingRectangle);  	if (!string.IsNullOrEmpty (this.Text) && cs.IsInside (position)) {  		rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position.X += f * this.TextPadding * Math.Cos (angleInRadians);  	position.Y += f * this.TextPadding * Math.Sin (angleInRadians);  	var cs = new CohenSutherlandClipping (clippingRectangle);  	if (!string.IsNullOrEmpty (this.Text) && cs.IsInside (position)) {  		rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position.X += f * this.TextPadding * Math.Cos (angleInRadians);  	position.Y += f * this.TextPadding * Math.Sin (angleInRadians);  	var cs = new CohenSutherlandClipping (clippingRectangle);  	if (!string.IsNullOrEmpty (this.Text) && cs.IsInside (position)) {  		rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (clippedPoints != null && GetPointAtRelativeDistance (clippedPoints' this.TextPosition' margin' out position' out angle)) {  	if (angle < -90) {  		angle += 180;  	}  	if (angle > 90) {  		angle -= 180;  	}  	switch (this.TextOrientation) {  	case AnnotationTextOrientation.Horizontal:  		angle = 0;  		break;  	case AnnotationTextOrientation.Vertical:  		angle = -90;  		break;  	}  	// Apply 'padding' to the position  	var angleInRadians = angle / 180 * Math.PI;  	var f = 1;  	if (this.TextHorizontalAlignment == HorizontalAlignment.Right) {  		f = -1;  	}  	if (this.TextHorizontalAlignment == HorizontalAlignment.Center) {  		f = 0;  	}  	position.X += f * this.TextPadding * Math.Cos (angleInRadians);  	position.Y += f * this.TextPadding * Math.Sin (angleInRadians);  	var cs = new CohenSutherlandClipping (clippingRectangle);  	if (!string.IsNullOrEmpty (this.Text) && cs.IsInside (position)) {  		rc.DrawClippedText (clippingRectangle' position' this.Text' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' angle' this.TextHorizontalAlignment' this.TextVerticalAlignment);  	}  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: angle += 180;  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: angle -= 180;  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: switch (this.TextOrientation) {  case AnnotationTextOrientation.Horizontal:  	angle = 0;  	break;  case AnnotationTextOrientation.Vertical:  	angle = -90;  	break;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following statement contains a magic number: angle = -90;  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,GetPointAtRelativeDistance,The following statement contains a magic number: for (int i = 1; i < pts.Count; i++) {  	double dl = (pts [i] - pts [i - 1]).Length;  	if (l >= length && l <= length + dl) {  		double f = (l - length) / dl;  		double x = (pts [i].X * f) + (pts [i - 1].X * (1 - f));  		double y = (pts [i].Y * f) + (pts [i - 1].Y * (1 - f));  		position = new ScreenPoint (x' y);  		double dx = pts [i].X - pts [i - 1].X;  		double dy = pts [i].Y - pts [i - 1].Y;  		angle = Math.Atan2 (dy' dx) / Math.PI * 180;  		return true;  	}  	length += dl;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,GetPointAtRelativeDistance,The following statement contains a magic number: if (l >= length && l <= length + dl) {  	double f = (l - length) / dl;  	double x = (pts [i].X * f) + (pts [i - 1].X * (1 - f));  	double y = (pts [i].Y * f) + (pts [i - 1].Y * (1 - f));  	position = new ScreenPoint (x' y);  	double dx = pts [i].X - pts [i - 1].X;  	double dy = pts [i].Y - pts [i - 1].Y;  	angle = Math.Atan2 (dy' dx) / Math.PI * 180;  	return true;  }  
Magic Number,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,GetPointAtRelativeDistance,The following statement contains a magic number: angle = Math.Atan2 (dy' dx) / Math.PI * 180;  
Magic Number,OxyPlot,CodeGenerator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,CodeGenerator,The following statement contains a magic number: this.Indents = 8;  
Magic Number,OxyPlot,CodeGenerator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,CodeGenerator,The following statement contains a magic number: this.Indents += 4;  
Magic Number,OxyPlot,CodeGenerator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CodeGenerator\CodeGenerator.cs,CodeGenerator,The following statement contains a magic number: this.Indents -= 4;  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,OxyPalettes,The following statement contains a magic number: BlueWhiteRed31 = BlueWhiteRed (31);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,OxyPalettes,The following statement contains a magic number: Hot64 = Hot (64);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,OxyPalettes,The following statement contains a magic number: Hue64 = Hue (64);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,OxyPalettes,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPalettes.cs,Hot,The following statement contains a magic number: return OxyPalette.Interpolate (numberOfColors' OxyColors.Black' OxyColor.FromRgb (127' 0' 0)' OxyColor.FromRgb (255' 127' 0)' OxyColor.FromRgb (255' 255' 127)' OxyColors.White);  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,PngEncoder,The following statement contains a magic number: CrcTable = new ulong[256];  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,PngEncoder,The following statement contains a magic number: for (int n = 0; n < 256; n++) {  	var c = (ulong)n;  	for (int k = 0; k < 8; k++) {  		if ((c & 1) != 0) {  			c = 0xedb88320L ^ (c >> 1);  		}  		else {  			c = c >> 1;  		}  	}  	CrcTable [n] = c;  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,PngEncoder,The following statement contains a magic number: for (int n = 0; n < 256; n++) {  	var c = (ulong)n;  	for (int k = 0; k < 8; k++) {  		if ((c & 1) != 0) {  			c = 0xedb88320L ^ (c >> 1);  		}  		else {  			c = c >> 1;  		}  	}  	CrcTable [n] = c;  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,PngEncoder,The following statement contains a magic number: for (int k = 0; k < 8; k++) {  	if ((c & 1) != 0) {  		c = 0xedb88320L ^ (c >> 1);  	}  	else {  		c = c >> 1;  	}  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,Adler32,The following statement contains a magic number: return (b << 16) | a;  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,CreateHeaderData,The following statement contains a magic number: w.Write ((byte)8);  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,CreateHeaderData,The following statement contains a magic number: w.Write ((byte)6);  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i += MaxDeflate) {  	var n = (ushort)Math.Min (bytes.Length - i' MaxDeflate);  	var last = (byte)(i + n < bytes.Length ? 0 : 1);  	w.Write (last);  	w.Write ((byte)(n & 0xFF));  	w.Write ((byte)((n >> 8) & 0xFF));  	var n2 = ~n;  	w.Write ((byte)(n2 & 0xFF));  	w.Write ((byte)((n2 >> 8) & 0xFF));  	w.Write (bytes' i' n);  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i += MaxDeflate) {  	var n = (ushort)Math.Min (bytes.Length - i' MaxDeflate);  	var last = (byte)(i + n < bytes.Length ? 0 : 1);  	w.Write (last);  	w.Write ((byte)(n & 0xFF));  	w.Write ((byte)((n >> 8) & 0xFF));  	var n2 = ~n;  	w.Write ((byte)(n2 & 0xFF));  	w.Write ((byte)((n2 >> 8) & 0xFF));  	w.Write (bytes' i' n);  }  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: w.Write ((byte)((n >> 8) & 0xFF));  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,CreateUncompressedBlocks,The following statement contains a magic number: w.Write ((byte)((n2 >> 8) & 0xFF));  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,UpdateCrc,The following statement contains a magic number: return data.Aggregate (crc' (current' x) => CrcTable [(current ^ x) & 0xff] ^ (current >> 8));  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [3]);  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [2]);  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [3]);  
Magic Number,OxyPlot,PngEncoder,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\PngEncoder.cs,WriteBigEndian,The following statement contains a magic number: w.Write (bytes [2]);  
Magic Number,OxyPlot,StringHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\StringHelper.cs,CreateValidFileName,The following statement contains a magic number: if (validFileName.Length > 160) {  	// safe value threshold is 260  	validFileName = validFileName.Remove (156) + "...";  }  
Magic Number,OxyPlot,StringHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\StringHelper.cs,CreateValidFileName,The following statement contains a magic number: if (validFileName.Length > 160) {  	// safe value threshold is 260  	validFileName = validFileName.Remove (156) + "...";  }  
Magic Number,OxyPlot,StringHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\StringHelper.cs,CreateValidFileName,The following statement contains a magic number: validFileName = validFileName.Remove (156) + "...";  
Magic Number,OxyPlot,DoubleExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\DoubleExtensions.cs,GetExponent,The following statement contains a magic number: return Math.Round (Math.Log (Math.Abs (x)' 10));  
Magic Number,OxyPlot,DoubleExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\DoubleExtensions.cs,GetMantissa,The following statement contains a magic number: return x / Math.Pow (10' x.GetExponent ());  
Magic Number,OxyPlot,DoubleExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\DoubleExtensions.cs,RemoveNoiseFromDoubleMath,The following statement contains a magic number: if (value.IsZero () || Math.Abs (Math.Log10 (Math.Abs (value))) < 27) {  	return (double)((decimal)value);  }  
Magic Number,OxyPlot,FractionHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\FractionHelper.cs,ConvertToFractionString,The following statement contains a magic number: for (int d = 1; d <= 64; d++) {  	double n = value * d;  	var ni = (int)Math.Round (n);  	if (Math.Abs (n - ni) < eps) {  		string nis = unitSymbol == null || ni != 1 ? ni.ToString (CultureInfo.InvariantCulture) : string.Empty;  		if (d == 1) {  			return string.Format ("{0}{1}"' nis' unitSymbol);  		}  		return string.Format ("{0}{1}/{2}"' nis' unitSymbol' d);  	}  }  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\ScreenPointHelper.cs,FindPositionOnLine,The following statement contains a magic number: if (u2 < 1e-6) {  	return double.NaN;  }  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\ScreenPointHelper.cs,GetCentroid,The following statement contains a magic number: a *= 0.5;  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\ScreenPointHelper.cs,GetCentroid,The following statement contains a magic number: cx /= 6 * a;  
Magic Number,OxyPlot,ScreenPointHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\ScreenPointHelper.cs,GetCentroid,The following statement contains a magic number: cy /= 6 * a;  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: if (this.FineControl) {  	scale *= 3;  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: scale *= 3;  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: if (scale < 0.1) {  	scale = 0.1;  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: if (scale < 0.1) {  	scale = 0.1;  }  
Magic Number,OxyPlot,ZoomStepManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomStepManipulator.cs,Started,The following statement contains a magic number: scale = 0.1;  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\TrackerManipulator.cs,GetNearestHit,The following statement contains a magic number: if (snap || pointsOnly) {  	TrackerHitResult result = s.GetNearestPoint (point' false);  	if (result != null) {  		if (result.Position.DistanceTo (point) < 20) {  			return result;  		}  	}  }  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\TrackerManipulator.cs,GetNearestHit,The following statement contains a magic number: if (result != null) {  	if (result.Position.DistanceTo (point) < 20) {  		return result;  	}  }  
Magic Number,OxyPlot,TrackerManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\TrackerManipulator.cs,GetNearestHit,The following statement contains a magic number: if (result.Position.DistanceTo (point) < 20) {  	return result;  }  
Magic Number,OxyPlot,ZoomRectangleManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomRectangleManipulator.cs,Completed,The following statement contains a magic number: if (this.ZoomRectangle.Width > 10 && this.ZoomRectangle.Height > 10) {  	DataPoint p0 = this.InverseTransform (this.ZoomRectangle.Left' this.ZoomRectangle.Top);  	DataPoint p1 = this.InverseTransform (this.ZoomRectangle.Right' this.ZoomRectangle.Bottom);  	if (this.XAxis != null) {  		this.PlotControl.Zoom (this.XAxis' p0.X' p1.X);  	}  	if (this.YAxis != null) {  		this.PlotControl.Zoom (this.YAxis' p0.Y' p1.Y);  	}  	this.PlotControl.InvalidatePlot ();  }  
Magic Number,OxyPlot,ZoomRectangleManipulator,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Manipulators\ZoomRectangleManipulator.cs,Completed,The following statement contains a magic number: if (this.ZoomRectangle.Width > 10 && this.ZoomRectangle.Height > 10) {  	DataPoint p0 = this.InverseTransform (this.ZoomRectangle.Left' this.ZoomRectangle.Top);  	DataPoint p1 = this.InverseTransform (this.ZoomRectangle.Right' this.ZoomRectangle.Bottom);  	if (this.XAxis != null) {  		this.PlotControl.Zoom (this.XAxis' p0.X' p1.X);  	}  	if (this.YAxis != null) {  		this.PlotControl.Zoom (this.YAxis' p0.Y' p1.Y);  	}  	this.PlotControl.InvalidatePlot ();  }  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,FromArgb,The following statement contains a magic number: WriteBitmapV4Header (w' width' height' 32' pixelData.Length' dpi);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,FromIndexed8,The following statement contains a magic number: WriteBitmapInfoHeader (w' width' height' 8' indexedPixelData.Length' dpi' palette.Length);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,FromArgbX,The following statement contains a magic number: WriteBitmapInfoHeader (w' width' height' 32' pixelData.Length' dpi);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapInfoHeader,The following statement contains a magic number: w.Write ((uint)40);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write ((uint)108);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write ((uint)3);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write (new byte[3 * 3 * 4]);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write (new byte[3 * 3 * 4]);  
Magic Number,OxyPlot,OxyImage,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyImage.cs,WriteBitmapV4Header,The following statement contains a magic number: w.Write (new byte[3 * 3 * 4]);  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n < 2) {  	result.AddRange (points);  	return result;  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	}  	else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  }  else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		}  		else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		}  		else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		}  		else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	}  	else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	}  	else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	}  	else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	}  	else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	}  	else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	}  	else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	}  	else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	}  	else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	}  	else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  }  else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  }  else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  }  else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  }  else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  }  else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,OxyPlot,CanonicalSplineHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  
Magic Number,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: switch (glt) {  case TickStyle.Crossing:  	x0 = -ticksize * sign * 0.75;  	x1 = ticksize * sign * 0.75;  	break;  case TickStyle.Inside:  	x0 = -ticksize * sign;  	break;  case TickStyle.Outside:  	x1 = ticksize * sign;  	break;  }  
Magic Number,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: switch (glt) {  case TickStyle.Crossing:  	x0 = -ticksize * sign * 0.75;  	x1 = ticksize * sign * 0.75;  	break;  case TickStyle.Inside:  	x0 = -ticksize * sign;  	break;  case TickStyle.Outside:  	x1 = ticksize * sign;  	break;  }  
Magic Number,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: x0 = -ticksize * sign * 0.75;  
Magic Number,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,The following statement contains a magic number: x1 = ticksize * sign * 0.75;  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double value in this.MajorLabelValues) {  	// skip the last value (overlapping with the first)  	if (isFullCircle && value > axis.ActualMaximum - eps) {  		continue;  	}  	var pt = magnitudeAxis.Transform (magnitudeAxis.ActualMaximum' value' axis);  	double angle = Math.Atan2 (pt.y - magnitudeAxis.MidPoint.y' pt.x - magnitudeAxis.MidPoint.x);  	// add some margin  	pt.x += Math.Cos (angle) * axis.AxisTickToLabelDistance;  	pt.y += Math.Sin (angle) * axis.AxisTickToLabelDistance;  	// Convert to degrees  	angle *= 180 / Math.PI;  	string text = axis.FormatValue (value);  	var ha = HorizontalAlignment.Left;  	var va = VerticalAlignment.Middle;  	if (Math.Abs (Math.Abs (angle) - 90) < 10) {  		ha = HorizontalAlignment.Center;  		va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  		angle = 0;  	}  	else if (angle > 90 || angle < -90) {  		angle -= 180;  		ha = HorizontalAlignment.Right;  	}  	this.rc.DrawMathText (pt' text' axis.ActualTextColor' axis.ActualFont' axis.ActualFontSize' axis.ActualFontWeight' angle' ha' va);  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: angle *= 180 / Math.PI;  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (Math.Abs (Math.Abs (angle) - 90) < 10) {  	ha = HorizontalAlignment.Center;  	va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  	angle = 0;  }  else if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: va = angle > 90 ? VerticalAlignment.Top : VerticalAlignment.Bottom;  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: if (angle > 90 || angle < -90) {  	angle -= 180;  	ha = HorizontalAlignment.Right;  }  
Magic Number,OxyPlot,AngleAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AngleAxisRenderer.cs,Render,The following statement contains a magic number: angle -= 180;  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: if (axis.ShowMinorTicks) {  	// GetVerticalTickPositions(axis' axis.TickStyle' axis.MinorTickSize' out y0' out y1);  	foreach (double xValue in this.MinorTickValues) {  		if (xValue < axis.ActualMinimum || xValue > axis.ActualMaximum) {  			continue;  		}  		if (this.MajorTickValues.Contains (xValue)) {  			continue;  		}  		var pts = new List<ScreenPoint> ();  		for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  			pts.Add (axis.Transform (xValue' th' angleAxis));  		}  		if (this.MinorPen != null) {  			this.rc.DrawLine (pts' this.MinorPen.Color' this.MinorPen.Thickness' this.MinorPen.DashArray);  		}  		// RenderGridline(x' y + y0' x' y + y1' minorTickPen);  	}  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: if (axis.ShowMinorTicks) {  	// GetVerticalTickPositions(axis' axis.TickStyle' axis.MinorTickSize' out y0' out y1);  	foreach (double xValue in this.MinorTickValues) {  		if (xValue < axis.ActualMinimum || xValue > axis.ActualMaximum) {  			continue;  		}  		if (this.MajorTickValues.Contains (xValue)) {  			continue;  		}  		var pts = new List<ScreenPoint> ();  		for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  			pts.Add (axis.Transform (xValue' th' angleAxis));  		}  		if (this.MinorPen != null) {  			this.rc.DrawLine (pts' this.MinorPen.Color' this.MinorPen.Thickness' this.MinorPen.DashArray);  		}  		// RenderGridline(x' y + y0' x' y + y1' minorTickPen);  	}  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double xValue in this.MinorTickValues) {  	if (xValue < axis.ActualMinimum || xValue > axis.ActualMaximum) {  		continue;  	}  	if (this.MajorTickValues.Contains (xValue)) {  		continue;  	}  	var pts = new List<ScreenPoint> ();  	for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  		pts.Add (axis.Transform (xValue' th' angleAxis));  	}  	if (this.MinorPen != null) {  		this.rc.DrawLine (pts' this.MinorPen.Color' this.MinorPen.Thickness' this.MinorPen.DashArray);  	}  	// RenderGridline(x' y + y0' x' y + y1' minorTickPen);  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double xValue in this.MinorTickValues) {  	if (xValue < axis.ActualMinimum || xValue > axis.ActualMaximum) {  		continue;  	}  	if (this.MajorTickValues.Contains (xValue)) {  		continue;  	}  	var pts = new List<ScreenPoint> ();  	for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  		pts.Add (axis.Transform (xValue' th' angleAxis));  	}  	if (this.MinorPen != null) {  		this.rc.DrawLine (pts' this.MinorPen.Color' this.MinorPen.Thickness' this.MinorPen.DashArray);  	}  	// RenderGridline(x' y + y0' x' y + y1' minorTickPen);  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  	pts.Add (axis.Transform (xValue' th' angleAxis));  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  	pts.Add (axis.Transform (xValue' th' angleAxis));  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: th += angleAxis.MinorStep * 0.1
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double xValue in this.MajorTickValues) {  	if (xValue < axis.ActualMinimum || xValue > axis.ActualMaximum) {  		continue;  	}  	var pts = new List<ScreenPoint> ();  	for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  		pts.Add (axis.Transform (xValue' th' angleAxis));  	}  	if (this.MajorPen != null) {  		this.rc.DrawLine (pts' this.MajorPen.Color' this.MajorPen.Thickness' this.MajorPen.DashArray);  	}  	// RenderGridline(x' y + y0' x' y + y1' majorTickPen);  	// var pt = new ScreenPoint(x' istop ? y + y1 - TICK_DIST : y + y1 + TICK_DIST);  	// string text = axis.FormatValue(xValue);  	// double h = rc.MeasureText(text' axis.Font' axis.FontSize' axis.FontWeight).Height;  	// rc.DrawText(pt' text' axis.LabelColor ?? plot.TextColor'  	// axis.Font' axis.FontSize' axis.FontWeight'  	// axis.Angle'  	// HorizontalAlignment.Center' istop ? VerticalAlignment.Bottom : VerticalAlignment.Top);  	// maxh = Math.Max(maxh' h);  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: foreach (double xValue in this.MajorTickValues) {  	if (xValue < axis.ActualMinimum || xValue > axis.ActualMaximum) {  		continue;  	}  	var pts = new List<ScreenPoint> ();  	for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  		pts.Add (axis.Transform (xValue' th' angleAxis));  	}  	if (this.MajorPen != null) {  		this.rc.DrawLine (pts' this.MajorPen.Color' this.MajorPen.Thickness' this.MajorPen.DashArray);  	}  	// RenderGridline(x' y + y0' x' y + y1' majorTickPen);  	// var pt = new ScreenPoint(x' istop ? y + y1 - TICK_DIST : y + y1 + TICK_DIST);  	// string text = axis.FormatValue(xValue);  	// double h = rc.MeasureText(text' axis.Font' axis.FontSize' axis.FontWeight).Height;  	// rc.DrawText(pt' text' axis.LabelColor ?? plot.TextColor'  	// axis.Font' axis.FontSize' axis.FontWeight'  	// axis.Angle'  	// HorizontalAlignment.Center' istop ? VerticalAlignment.Bottom : VerticalAlignment.Top);  	// maxh = Math.Max(maxh' h);  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  	pts.Add (axis.Transform (xValue' th' angleAxis));  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: for (double th = angleAxis.ActualMinimum; th <= angleAxis.ActualMaximum + angleAxis.MinorStep * 0.01; th += angleAxis.MinorStep * 0.1) {  	pts.Add (axis.Transform (xValue' th' angleAxis));  }  
Magic Number,OxyPlot,MagnitudeAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MagnitudeAxisRenderer.cs,Render,The following statement contains a magic number: th += angleAxis.MinorStep * 0.1
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,MathRenderingExtensions,The following statement contains a magic number: SubAlignment = 0.6;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,MathRenderingExtensions,The following statement contains a magic number: SubSize = 0.62;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,MathRenderingExtensions,The following statement contains a magic number: SuperSize = 0.62;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: if (angle.Equals (0) && (text.Contains ("^{") || text.Contains ("_{"))) {  	double x = pt.X;  	double y = pt.Y;  	// Measure  	var size = InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' true);  	switch (ha) {  	case HorizontalAlignment.Right:  		x -= size.Width;  		break;  	case HorizontalAlignment.Center:  		x -= size.Width * 0.5;  		break;  	}  	switch (va) {  	case VerticalAlignment.Bottom:  		y -= size.Height;  		break;  	case VerticalAlignment.Middle:  		y -= size.Height * 0.5;  		break;  	}  	InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' false);  	return measure ? size : OxySize.Empty;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: if (angle.Equals (0) && (text.Contains ("^{") || text.Contains ("_{"))) {  	double x = pt.X;  	double y = pt.Y;  	// Measure  	var size = InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' true);  	switch (ha) {  	case HorizontalAlignment.Right:  		x -= size.Width;  		break;  	case HorizontalAlignment.Center:  		x -= size.Width * 0.5;  		break;  	}  	switch (va) {  	case VerticalAlignment.Bottom:  		y -= size.Height;  		break;  	case VerticalAlignment.Middle:  		y -= size.Height * 0.5;  		break;  	}  	InternalDrawMathText (rc' x' y' text' textColor' fontFamily' fontSize' fontWeight' false);  	return measure ? size : OxySize.Empty;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: switch (ha) {  case HorizontalAlignment.Right:  	x -= size.Width;  	break;  case HorizontalAlignment.Center:  	x -= size.Width * 0.5;  	break;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: x -= size.Width * 0.5;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: switch (va) {  case VerticalAlignment.Bottom:  	y -= size.Height;  	break;  case VerticalAlignment.Middle:  	y -= size.Height * 0.5;  	break;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following statement contains a magic number: y -= size.Height * 0.5;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + 2;  	OxySize size2 = drawText (currentX' y' regularString' fontSize);  	currentX += size2.Width + 2;  	maxHeight = Math.Max (maxHeight' size2.Height);  	maximumX = currentX;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + 2;  	OxySize size2 = drawText (currentX' y' regularString' fontSize);  	currentX += size2.Width + 2;  	maxHeight = Math.Max (maxHeight' size2.Height);  	maximumX = currentX;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + 2;  	OxySize size2 = drawText (currentX' y' regularString' fontSize);  	currentX += size2.Width + 2;  	maxHeight = Math.Max (maxHeight' size2.Height);  	maximumX = currentX;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + 2;  	OxySize size2 = drawText (currentX' y' regularString' fontSize);  	currentX += size2.Width + 2;  	maxHeight = Math.Max (maxHeight' size2.Height);  	maximumX = currentX;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + 2;  	OxySize size2 = drawText (currentX' y' regularString' fontSize);  	currentX += size2.Width + 2;  	maxHeight = Math.Max (maxHeight' size2.Height);  	maximumX = currentX;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: while (i < s.Length) {  	// Superscript  	if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string supString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Subscript  	if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  		int i1 = s.IndexOf ('}'' i);  		if (i1 != -1) {  			string subString = s.Substring (i + 2' i1 - i - 2);  			i = i1 + 1;  			OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  			if (currentX + size.Width > maximumX) {  				maximumX = currentX + size.Width;  			}  			continue;  		}  	}  	// Regular text  	int i2 = s.IndexOfAny ("^_".ToCharArray ()' i);  	string regularString;  	if (i2 == -1) {  		regularString = s.Substring (i);  		i = s.Length;  	}  	else {  		regularString = s.Substring (i' i2 - i);  		i = i2;  	}  	currentX = maximumX + 2;  	OxySize size2 = drawText (currentX' y' regularString' fontSize);  	currentX += size2.Width + 2;  	maxHeight = Math.Max (maxHeight' size2.Height);  	maximumX = currentX;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string supString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  		if (currentX + size.Width > maximumX) {  			maximumX = currentX + size.Width;  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '^' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string supString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  		if (currentX + size.Width > maximumX) {  			maximumX = currentX + size.Width;  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string supString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  	if (currentX + size.Width > maximumX) {  		maximumX = currentX + size.Width;  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string supString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	OxySize size = drawText (currentX' superscriptY' supString' superscriptFontSize);  	if (currentX + size.Width > maximumX) {  		maximumX = currentX + size.Width;  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string subString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  		if (currentX + size.Width > maximumX) {  			maximumX = currentX + size.Width;  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i + 1 < s.Length && s [i] == '_' && s [i + 1] == '{') {  	int i1 = s.IndexOf ('}'' i);  	if (i1 != -1) {  		string subString = s.Substring (i + 2' i1 - i - 2);  		i = i1 + 1;  		OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  		if (currentX + size.Width > maximumX) {  			maximumX = currentX + size.Width;  		}  		continue;  	}  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string subString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  	if (currentX + size.Width > maximumX) {  		maximumX = currentX + size.Width;  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: if (i1 != -1) {  	string subString = s.Substring (i + 2' i1 - i - 2);  	i = i1 + 1;  	OxySize size = drawText (currentX' subscriptY' subString' subscriptFontSize);  	if (currentX + size.Width > maximumX) {  		maximumX = currentX + size.Width;  	}  	continue;  }  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: currentX = maximumX + 2;  
Magic Number,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,InternalDrawMathText,The following statement contains a magic number: currentX += size2.Width + 2;  
Magic Number,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawLineSegments,The following statement contains a magic number: for (int i = 0; i + 1 < points.Count; i += 2) {  	this.DrawLine (new[] {  		points [i]'  		points [i + 1]  	}' stroke' thickness' dashArray' lineJoin' aliased);  }  
Magic Number,OxyPlot,RenderContextBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderContextBase.cs,DrawLineSegments,The following statement contains a magic number: i += 2
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLineSegments,The following statement contains a magic number: for (int i = 0; i + 1 < points.Count; i += 2) {  	var s0 = points [i];  	var s1 = points [i + 1];  	if (clipping.ClipLine (ref s0' ref s1)) {  		clippedPoints.Add (s0);  		clippedPoints.Add (s1);  	}  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedLineSegments,The following statement contains a magic number: i += 2
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedEllipse,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double a = Math.PI * 2 * i / (n - 1);  	points [i] = new ScreenPoint (cx + (rx * Math.Cos (a))' cy + (ry * Math.Sin (a)));  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawClippedEllipse,The following statement contains a magic number: rc.DrawClippedPolygon (points' clippingRectangle' 4' fill' stroke' thickness);  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawMarkers,The following statement contains a magic number: foreach (var p in markerPoints) {  	if (resolution > 1) {  		var x = (int)((p.X - binOffset.X) / resolution);  		var y = (int)((p.Y - binOffset.Y) / resolution);  		uint hash = (uint)(x << 16) + (uint)y;  		if (hashset.ContainsKey (hash)) {  			i++;  			continue;  		}  		hashset.Add (hash' true);  	}  	bool outside = p.x < minx || p.x > maxx || p.y < miny || p.y > maxy;  	if (!outside) {  		int j = i < markerSize.Count ? i : 0;  		AddMarkerGeometry (p' markerType' markerOutline' markerSize [j]' ellipses' rects' polygons' lines);  	}  	i++;  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,DrawMarkers,The following statement contains a magic number: if (resolution > 1) {  	var x = (int)((p.X - binOffset.X) / resolution);  	var y = (int)((p.Y - binOffset.Y) / resolution);  	uint hash = (uint)(x << 16) + (uint)y;  	if (hashset.ContainsKey (hash)) {  		i++;  		continue;  	}  	hashset.Add (hash' true);  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following statement contains a magic number: rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  
Magic Number,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,EnsureNonEmptyLineIsVisible,The following statement contains a magic number: if (pts.Count == 2) {  	if (pts [0].DistanceTo (pts [1]) < 1) {  		// Modify to a small horizontal line to make sure it is being rendered  		pts [1] = new ScreenPoint (pts [0].X + 1' pts [0].Y);  		pts [0] = new ScreenPoint (pts [0].X - 1' pts [0].Y);  	}  }  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: Debug.Assert (angle <= 180 && angle >= -180' "Axis angle should be in the interval [-180'180] degrees.");  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: Debug.Assert (angle <= 180 && angle >= -180' "Axis angle should be in the interval [-180'180] degrees.");  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > -45 && angle < 45) {  	return;  }  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > -45 && angle < 45) {  	return;  }  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > 135 || angle < -135) {  	ha = (HorizontalAlignment)(-(int)defaultHorizontalAlignment);  	va = (VerticalAlignment)(-(int)defaultVerticalAlignment);  	return;  }  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > 135 || angle < -135) {  	ha = (HorizontalAlignment)(-(int)defaultHorizontalAlignment);  	va = (VerticalAlignment)(-(int)defaultVerticalAlignment);  	return;  }  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle > 45) {  	ha = (HorizontalAlignment)((int)defaultVerticalAlignment);  	va = (VerticalAlignment)(-(int)defaultHorizontalAlignment);  	return;  }  
Magic Number,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,GetRotatedAlignments,The following statement contains a magic number: if (angle < -45) {  	ha = (HorizontalAlignment)(-(int)defaultVerticalAlignment);  	va = (VerticalAlignment)((int)defaultHorizontalAlignment);  }  
Magic Number,OxyPlot,OxyPen,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPen.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.Color.GetHashCode ();  	result = (result * 397) ^ this.Thickness.GetHashCode ();  	result = (result * 397) ^ this.LineStyle.GetHashCode ();  	result = (result * 397) ^ this.LineJoin.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyPen,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPen.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.Color.GetHashCode ();  	result = (result * 397) ^ this.Thickness.GetHashCode ();  	result = (result * 397) ^ this.LineStyle.GetHashCode ();  	result = (result * 397) ^ this.LineJoin.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyPen,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPen.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.Color.GetHashCode ();  	result = (result * 397) ^ this.Thickness.GetHashCode ();  	result = (result * 397) ^ this.LineStyle.GetHashCode ();  	result = (result * 397) ^ this.LineJoin.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyPen,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPen.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Thickness.GetHashCode ();  
Magic Number,OxyPlot,OxyPen,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPen.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.LineStyle.GetHashCode ();  
Magic Number,OxyPlot,OxyPen,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyPen.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.LineJoin.GetHashCode ();  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: switch (style) {  case LineStyle.Solid:  	return null;  case LineStyle.Dash:  	return new double[] {  		4'  		1  	};  case LineStyle.Dot:  	return new double[] {  		1'  		1  	};  case LineStyle.DashDot:  	return new double[] {  		4'  		1'  		1'  		1  	};  case LineStyle.DashDashDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1  	};  case LineStyle.DashDotDot:  	return new double[] {  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.DashDashDotDot:  	return new double[] {  		4'  		1'  		4'  		1'  		1'  		1'  		1'  		1  	};  case LineStyle.LongDash:  	return new double[] {  		10'  		1  	};  case LineStyle.LongDashDot:  	return new double[] {  		10'  		1'  		1'  		1  	};  case LineStyle.LongDashDotDot:  	return new double[] {  		10'  		1'  		1'  		1'  		1'  		1  	};  default:  	return null;  }  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	4'  	1'  	4'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	10'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	10'  	1'  	1'  	1  };  
Magic Number,OxyPlot,LineStyleHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\LineStyleHelper.cs,GetDashArray,The following statement contains a magic number: return new double[] {  	10'  	1'  	1'  	1'  	1'  	1  };  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (int j = jub - 1; j >= jlb; j--) {  	int i;  	for (i = ilb; i <= iub - 1; i++) {  		double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  		double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  		double dmin = Math.Min (temp1' temp2);  		temp1 = Math.Max (d [i' j]' d [i' j + 1]);  		temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  		double dmax = Math.Max (temp1' temp2);  		if (dmax >= z [0] && dmin <= z [nc - 1]) {  			int k;  			for (k = 0; k < nc; k++) {  				if (z [k] >= dmin && z [k] <= dmax) {  					int m;  					for (m = 4; m >= 0; m--) {  						if (m > 0) {  							// The indexing of im and jm should be noted as it has to  							// start from zero  							h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  							xh [m] = x [i + im [m - 1]];  							yh [m] = y [j + jm [m - 1]];  						}  						else {  							h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  							xh [0] = 0.5 * (x [i] + x [i + 1]);  							yh [0] = 0.5 * (y [j] + y [j + 1]);  						}  						if (h [m] > 0.0) {  							sh [m] = 1;  						}  						else if (h [m] < 0.0) {  							sh [m] = -1;  						}  						else {  							sh [m] = 0;  						}  					}  					//// Note: at this stage the relative heights of the corners and the  					//// centre are in the h array' and the corresponding coordinates are  					//// in the xh and yh arrays. The centre of the box is indexed by 0  					//// and the 4 corners by 1 to 4 as shown below.  					//// Each triangle is then indexed by the parameter m' and the 3  					//// vertices of each triangle are indexed by parameters m1'm2'and  					//// m3.  					//// It is assumed that the centre of the box is always vertex 2  					//// though this isimportant only when all 3 vertices lie exactly on  					//// the same contour level' in which case only the side of the box  					//// is drawn.  					//// vertex 4 +-------------------+ vertex 3  					//// | \               / |  					//// |   \    m-3    /   |  					//// |     \       /     |  					//// |       \   /       |  					//// |  m=2    X   m=2   |       the centre is vertex 0  					//// |       /   \       |  					//// |     /       \     |  					//// |   /    m=1    \   |  					//// | /               \ |  					//// vertex 1 +-------------------+ vertex 2  					// Scan each triangle in the box  					for (m = 1; m <= 4; m++) {  						int m1 = m;  						int m2 = 0;  						int m3;  						if (m != 4) {  							m3 = m + 1;  						}  						else {  							m3 = 1;  						}  						int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  						if (caseValue != 0) {  							switch (caseValue) {  							case 1:  								// Line between vertices 1 and 2  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xh [m2];  								y2 = yh [m2];  								break;  							case 2:  								// Line between vertices 2 and 3  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xh [m3];  								y2 = yh [m3];  								break;  							case 3:  								// Line between vertices 3 and 1  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xh [m1];  								y2 = yh [m1];  								break;  							case 4:  								// Line between vertex 1 and side 2-3  								x1 = xh [m1];  								y1 = yh [m1];  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 5:  								// Line between vertex 2 and side 3-1  								x1 = xh [m2];  								y1 = yh [m2];  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 6:  								// Line between vertex 3 and side 1-2  								x1 = xh [m3];  								y1 = yh [m3];  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							case 7:  								// Line between sides 1-2 and 2-3  								x1 = xsect (m1' m2);  								y1 = ysect (m1' m2);  								x2 = xsect (m2' m3);  								y2 = ysect (m2' m3);  								break;  							case 8:  								// Line between sides 2-3 and 3-1  								x1 = xsect (m2' m3);  								y1 = ysect (m2' m3);  								x2 = xsect (m3' m1);  								y2 = ysect (m3' m1);  								break;  							case 9:  								// Line between sides 3-1 and 1-2  								x1 = xsect (m3' m1);  								y1 = ysect (m3' m1);  								x2 = xsect (m1' m2);  								y2 = ysect (m1' m2);  								break;  							}  							renderer (x1' y1' x2' y2' z [k]);  						}  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (i = ilb; i <= iub - 1; i++) {  	double temp1 = Math.Min (d [i' j]' d [i' j + 1]);  	double temp2 = Math.Min (d [i + 1' j]' d [i + 1' j + 1]);  	double dmin = Math.Min (temp1' temp2);  	temp1 = Math.Max (d [i' j]' d [i' j + 1]);  	temp2 = Math.Max (d [i + 1' j]' d [i + 1' j + 1]);  	double dmax = Math.Max (temp1' temp2);  	if (dmax >= z [0] && dmin <= z [nc - 1]) {  		int k;  		for (k = 0; k < nc; k++) {  			if (z [k] >= dmin && z [k] <= dmax) {  				int m;  				for (m = 4; m >= 0; m--) {  					if (m > 0) {  						// The indexing of im and jm should be noted as it has to  						// start from zero  						h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  						xh [m] = x [i + im [m - 1]];  						yh [m] = y [j + jm [m - 1]];  					}  					else {  						h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  						xh [0] = 0.5 * (x [i] + x [i + 1]);  						yh [0] = 0.5 * (y [j] + y [j + 1]);  					}  					if (h [m] > 0.0) {  						sh [m] = 1;  					}  					else if (h [m] < 0.0) {  						sh [m] = -1;  					}  					else {  						sh [m] = 0;  					}  				}  				//// Note: at this stage the relative heights of the corners and the  				//// centre are in the h array' and the corresponding coordinates are  				//// in the xh and yh arrays. The centre of the box is indexed by 0  				//// and the 4 corners by 1 to 4 as shown below.  				//// Each triangle is then indexed by the parameter m' and the 3  				//// vertices of each triangle are indexed by parameters m1'm2'and  				//// m3.  				//// It is assumed that the centre of the box is always vertex 2  				//// though this isimportant only when all 3 vertices lie exactly on  				//// the same contour level' in which case only the side of the box  				//// is drawn.  				//// vertex 4 +-------------------+ vertex 3  				//// | \               / |  				//// |   \    m-3    /   |  				//// |     \       /     |  				//// |       \   /       |  				//// |  m=2    X   m=2   |       the centre is vertex 0  				//// |       /   \       |  				//// |     /       \     |  				//// |   /    m=1    \   |  				//// | /               \ |  				//// vertex 1 +-------------------+ vertex 2  				// Scan each triangle in the box  				for (m = 1; m <= 4; m++) {  					int m1 = m;  					int m2 = 0;  					int m3;  					if (m != 4) {  						m3 = m + 1;  					}  					else {  						m3 = 1;  					}  					int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  					if (caseValue != 0) {  						switch (caseValue) {  						case 1:  							// Line between vertices 1 and 2  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xh [m2];  							y2 = yh [m2];  							break;  						case 2:  							// Line between vertices 2 and 3  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xh [m3];  							y2 = yh [m3];  							break;  						case 3:  							// Line between vertices 3 and 1  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xh [m1];  							y2 = yh [m1];  							break;  						case 4:  							// Line between vertex 1 and side 2-3  							x1 = xh [m1];  							y1 = yh [m1];  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 5:  							// Line between vertex 2 and side 3-1  							x1 = xh [m2];  							y1 = yh [m2];  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 6:  							// Line between vertex 3 and side 1-2  							x1 = xh [m3];  							y1 = yh [m3];  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						case 7:  							// Line between sides 1-2 and 2-3  							x1 = xsect (m1' m2);  							y1 = ysect (m1' m2);  							x2 = xsect (m2' m3);  							y2 = ysect (m2' m3);  							break;  						case 8:  							// Line between sides 2-3 and 3-1  							x1 = xsect (m2' m3);  							y1 = ysect (m2' m3);  							x2 = xsect (m3' m1);  							y2 = ysect (m3' m1);  							break;  						case 9:  							// Line between sides 3-1 and 1-2  							x1 = xsect (m3' m1);  							y1 = ysect (m3' m1);  							x2 = xsect (m1' m2);  							y2 = ysect (m1' m2);  							break;  						}  						renderer (x1' y1' x2' y2' z [k]);  					}  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (dmax >= z [0] && dmin <= z [nc - 1]) {  	int k;  	for (k = 0; k < nc; k++) {  		if (z [k] >= dmin && z [k] <= dmax) {  			int m;  			for (m = 4; m >= 0; m--) {  				if (m > 0) {  					// The indexing of im and jm should be noted as it has to  					// start from zero  					h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  					xh [m] = x [i + im [m - 1]];  					yh [m] = y [j + jm [m - 1]];  				}  				else {  					h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  					xh [0] = 0.5 * (x [i] + x [i + 1]);  					yh [0] = 0.5 * (y [j] + y [j + 1]);  				}  				if (h [m] > 0.0) {  					sh [m] = 1;  				}  				else if (h [m] < 0.0) {  					sh [m] = -1;  				}  				else {  					sh [m] = 0;  				}  			}  			//// Note: at this stage the relative heights of the corners and the  			//// centre are in the h array' and the corresponding coordinates are  			//// in the xh and yh arrays. The centre of the box is indexed by 0  			//// and the 4 corners by 1 to 4 as shown below.  			//// Each triangle is then indexed by the parameter m' and the 3  			//// vertices of each triangle are indexed by parameters m1'm2'and  			//// m3.  			//// It is assumed that the centre of the box is always vertex 2  			//// though this isimportant only when all 3 vertices lie exactly on  			//// the same contour level' in which case only the side of the box  			//// is drawn.  			//// vertex 4 +-------------------+ vertex 3  			//// | \               / |  			//// |   \    m-3    /   |  			//// |     \       /     |  			//// |       \   /       |  			//// |  m=2    X   m=2   |       the centre is vertex 0  			//// |       /   \       |  			//// |     /       \     |  			//// |   /    m=1    \   |  			//// | /               \ |  			//// vertex 1 +-------------------+ vertex 2  			// Scan each triangle in the box  			for (m = 1; m <= 4; m++) {  				int m1 = m;  				int m2 = 0;  				int m3;  				if (m != 4) {  					m3 = m + 1;  				}  				else {  					m3 = 1;  				}  				int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  				if (caseValue != 0) {  					switch (caseValue) {  					case 1:  						// Line between vertices 1 and 2  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xh [m2];  						y2 = yh [m2];  						break;  					case 2:  						// Line between vertices 2 and 3  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xh [m3];  						y2 = yh [m3];  						break;  					case 3:  						// Line between vertices 3 and 1  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xh [m1];  						y2 = yh [m1];  						break;  					case 4:  						// Line between vertex 1 and side 2-3  						x1 = xh [m1];  						y1 = yh [m1];  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 5:  						// Line between vertex 2 and side 3-1  						x1 = xh [m2];  						y1 = yh [m2];  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 6:  						// Line between vertex 3 and side 1-2  						x1 = xh [m3];  						y1 = yh [m3];  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					case 7:  						// Line between sides 1-2 and 2-3  						x1 = xsect (m1' m2);  						y1 = ysect (m1' m2);  						x2 = xsect (m2' m3);  						y2 = ysect (m2' m3);  						break;  					case 8:  						// Line between sides 2-3 and 3-1  						x1 = xsect (m2' m3);  						y1 = ysect (m2' m3);  						x2 = xsect (m3' m1);  						y2 = ysect (m3' m1);  						break;  					case 9:  						// Line between sides 3-1 and 1-2  						x1 = xsect (m3' m1);  						y1 = ysect (m3' m1);  						x2 = xsect (m1' m2);  						y2 = ysect (m1' m2);  						break;  					}  					renderer (x1' y1' x2' y2' z [k]);  				}  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (k = 0; k < nc; k++) {  	if (z [k] >= dmin && z [k] <= dmax) {  		int m;  		for (m = 4; m >= 0; m--) {  			if (m > 0) {  				// The indexing of im and jm should be noted as it has to  				// start from zero  				h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  				xh [m] = x [i + im [m - 1]];  				yh [m] = y [j + jm [m - 1]];  			}  			else {  				h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  				xh [0] = 0.5 * (x [i] + x [i + 1]);  				yh [0] = 0.5 * (y [j] + y [j + 1]);  			}  			if (h [m] > 0.0) {  				sh [m] = 1;  			}  			else if (h [m] < 0.0) {  				sh [m] = -1;  			}  			else {  				sh [m] = 0;  			}  		}  		//// Note: at this stage the relative heights of the corners and the  		//// centre are in the h array' and the corresponding coordinates are  		//// in the xh and yh arrays. The centre of the box is indexed by 0  		//// and the 4 corners by 1 to 4 as shown below.  		//// Each triangle is then indexed by the parameter m' and the 3  		//// vertices of each triangle are indexed by parameters m1'm2'and  		//// m3.  		//// It is assumed that the centre of the box is always vertex 2  		//// though this isimportant only when all 3 vertices lie exactly on  		//// the same contour level' in which case only the side of the box  		//// is drawn.  		//// vertex 4 +-------------------+ vertex 3  		//// | \               / |  		//// |   \    m-3    /   |  		//// |     \       /     |  		//// |       \   /       |  		//// |  m=2    X   m=2   |       the centre is vertex 0  		//// |       /   \       |  		//// |     /       \     |  		//// |   /    m=1    \   |  		//// | /               \ |  		//// vertex 1 +-------------------+ vertex 2  		// Scan each triangle in the box  		for (m = 1; m <= 4; m++) {  			int m1 = m;  			int m2 = 0;  			int m3;  			if (m != 4) {  				m3 = m + 1;  			}  			else {  				m3 = 1;  			}  			int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  			if (caseValue != 0) {  				switch (caseValue) {  				case 1:  					// Line between vertices 1 and 2  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xh [m2];  					y2 = yh [m2];  					break;  				case 2:  					// Line between vertices 2 and 3  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xh [m3];  					y2 = yh [m3];  					break;  				case 3:  					// Line between vertices 3 and 1  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xh [m1];  					y2 = yh [m1];  					break;  				case 4:  					// Line between vertex 1 and side 2-3  					x1 = xh [m1];  					y1 = yh [m1];  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 5:  					// Line between vertex 2 and side 3-1  					x1 = xh [m2];  					y1 = yh [m2];  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 6:  					// Line between vertex 3 and side 1-2  					x1 = xh [m3];  					y1 = yh [m3];  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				case 7:  					// Line between sides 1-2 and 2-3  					x1 = xsect (m1' m2);  					y1 = ysect (m1' m2);  					x2 = xsect (m2' m3);  					y2 = ysect (m2' m3);  					break;  				case 8:  					// Line between sides 2-3 and 3-1  					x1 = xsect (m2' m3);  					y1 = ysect (m2' m3);  					x2 = xsect (m3' m1);  					y2 = ysect (m3' m1);  					break;  				case 9:  					// Line between sides 3-1 and 1-2  					x1 = xsect (m3' m1);  					y1 = ysect (m3' m1);  					x2 = xsect (m1' m2);  					y2 = ysect (m1' m2);  					break;  				}  				renderer (x1' y1' x2' y2' z [k]);  			}  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (z [k] >= dmin && z [k] <= dmax) {  	int m;  	for (m = 4; m >= 0; m--) {  		if (m > 0) {  			// The indexing of im and jm should be noted as it has to  			// start from zero  			h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  			xh [m] = x [i + im [m - 1]];  			yh [m] = y [j + jm [m - 1]];  		}  		else {  			h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  			xh [0] = 0.5 * (x [i] + x [i + 1]);  			yh [0] = 0.5 * (y [j] + y [j + 1]);  		}  		if (h [m] > 0.0) {  			sh [m] = 1;  		}  		else if (h [m] < 0.0) {  			sh [m] = -1;  		}  		else {  			sh [m] = 0;  		}  	}  	//// Note: at this stage the relative heights of the corners and the  	//// centre are in the h array' and the corresponding coordinates are  	//// in the xh and yh arrays. The centre of the box is indexed by 0  	//// and the 4 corners by 1 to 4 as shown below.  	//// Each triangle is then indexed by the parameter m' and the 3  	//// vertices of each triangle are indexed by parameters m1'm2'and  	//// m3.  	//// It is assumed that the centre of the box is always vertex 2  	//// though this isimportant only when all 3 vertices lie exactly on  	//// the same contour level' in which case only the side of the box  	//// is drawn.  	//// vertex 4 +-------------------+ vertex 3  	//// | \               / |  	//// |   \    m-3    /   |  	//// |     \       /     |  	//// |       \   /       |  	//// |  m=2    X   m=2   |       the centre is vertex 0  	//// |       /   \       |  	//// |     /       \     |  	//// |   /    m=1    \   |  	//// | /               \ |  	//// vertex 1 +-------------------+ vertex 2  	// Scan each triangle in the box  	for (m = 1; m <= 4; m++) {  		int m1 = m;  		int m2 = 0;  		int m3;  		if (m != 4) {  			m3 = m + 1;  		}  		else {  			m3 = 1;  		}  		int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  		if (caseValue != 0) {  			switch (caseValue) {  			case 1:  				// Line between vertices 1 and 2  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xh [m2];  				y2 = yh [m2];  				break;  			case 2:  				// Line between vertices 2 and 3  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xh [m3];  				y2 = yh [m3];  				break;  			case 3:  				// Line between vertices 3 and 1  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xh [m1];  				y2 = yh [m1];  				break;  			case 4:  				// Line between vertex 1 and side 2-3  				x1 = xh [m1];  				y1 = yh [m1];  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 5:  				// Line between vertex 2 and side 3-1  				x1 = xh [m2];  				y1 = yh [m2];  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 6:  				// Line between vertex 3 and side 1-2  				x1 = xh [m3];  				y1 = yh [m3];  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			case 7:  				// Line between sides 1-2 and 2-3  				x1 = xsect (m1' m2);  				y1 = ysect (m1' m2);  				x2 = xsect (m2' m3);  				y2 = ysect (m2' m3);  				break;  			case 8:  				// Line between sides 2-3 and 3-1  				x1 = xsect (m2' m3);  				y1 = ysect (m2' m3);  				x2 = xsect (m3' m1);  				y2 = ysect (m3' m1);  				break;  			case 9:  				// Line between sides 3-1 and 1-2  				x1 = xsect (m3' m1);  				y1 = ysect (m3' m1);  				x2 = xsect (m1' m2);  				y2 = ysect (m1' m2);  				break;  			}  			renderer (x1' y1' x2' y2' z [k]);  		}  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 4; m >= 0; m--) {  	if (m > 0) {  		// The indexing of im and jm should be noted as it has to  		// start from zero  		h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  		xh [m] = x [i + im [m - 1]];  		yh [m] = y [j + jm [m - 1]];  	}  	else {  		h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  		xh [0] = 0.5 * (x [i] + x [i + 1]);  		yh [0] = 0.5 * (y [j] + y [j + 1]);  	}  	if (h [m] > 0.0) {  		sh [m] = 1;  	}  	else if (h [m] < 0.0) {  		sh [m] = -1;  	}  	else {  		sh [m] = 0;  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: m = 4
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m > 0) {  	// The indexing of im and jm should be noted as it has to  	// start from zero  	h [m] = d [i + im [m - 1]' j + jm [m - 1]] - z [k];  	xh [m] = x [i + im [m - 1]];  	yh [m] = y [j + jm [m - 1]];  }  else {  	h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  	xh [0] = 0.5 * (x [i] + x [i + 1]);  	yh [0] = 0.5 * (y [j] + y [j + 1]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: h [0] = 0.25 * (h [1] + h [2] + h [3] + h [4]);  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: xh [0] = 0.5 * (x [i] + x [i + 1]);  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: yh [0] = 0.5 * (y [j] + y [j + 1]);  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: for (m = 1; m <= 4; m++) {  	int m1 = m;  	int m2 = 0;  	int m3;  	if (m != 4) {  		m3 = m + 1;  	}  	else {  		m3 = 1;  	}  	int caseValue = castab [sh [m1] + 1' sh [m2] + 1' sh [m3] + 1];  	if (caseValue != 0) {  		switch (caseValue) {  		case 1:  			// Line between vertices 1 and 2  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xh [m2];  			y2 = yh [m2];  			break;  		case 2:  			// Line between vertices 2 and 3  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xh [m3];  			y2 = yh [m3];  			break;  		case 3:  			// Line between vertices 3 and 1  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xh [m1];  			y2 = yh [m1];  			break;  		case 4:  			// Line between vertex 1 and side 2-3  			x1 = xh [m1];  			y1 = yh [m1];  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 5:  			// Line between vertex 2 and side 3-1  			x1 = xh [m2];  			y1 = yh [m2];  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 6:  			// Line between vertex 3 and side 1-2  			x1 = xh [m3];  			y1 = yh [m3];  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		case 7:  			// Line between sides 1-2 and 2-3  			x1 = xsect (m1' m2);  			y1 = ysect (m1' m2);  			x2 = xsect (m2' m3);  			y2 = ysect (m2' m3);  			break;  		case 8:  			// Line between sides 2-3 and 3-1  			x1 = xsect (m2' m3);  			y1 = ysect (m2' m3);  			x2 = xsect (m3' m1);  			y2 = ysect (m3' m1);  			break;  		case 9:  			// Line between sides 3-1 and 1-2  			x1 = xsect (m3' m1);  			y1 = ysect (m3' m1);  			x2 = xsect (m1' m2);  			y2 = ysect (m1' m2);  			break;  		}  		renderer (x1' y1' x2' y2' z [k]);  	}  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (m != 4) {  	m3 = m + 1;  }  else {  	m3 = 1;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: if (caseValue != 0) {  	switch (caseValue) {  	case 1:  		// Line between vertices 1 and 2  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xh [m2];  		y2 = yh [m2];  		break;  	case 2:  		// Line between vertices 2 and 3  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xh [m3];  		y2 = yh [m3];  		break;  	case 3:  		// Line between vertices 3 and 1  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xh [m1];  		y2 = yh [m1];  		break;  	case 4:  		// Line between vertex 1 and side 2-3  		x1 = xh [m1];  		y1 = yh [m1];  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 5:  		// Line between vertex 2 and side 3-1  		x1 = xh [m2];  		y1 = yh [m2];  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 6:  		// Line between vertex 3 and side 1-2  		x1 = xh [m3];  		y1 = yh [m3];  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	case 7:  		// Line between sides 1-2 and 2-3  		x1 = xsect (m1' m2);  		y1 = ysect (m1' m2);  		x2 = xsect (m2' m3);  		y2 = ysect (m2' m3);  		break;  	case 8:  		// Line between sides 2-3 and 3-1  		x1 = xsect (m2' m3);  		y1 = ysect (m2' m3);  		x2 = xsect (m3' m1);  		y2 = ysect (m3' m1);  		break;  	case 9:  		// Line between sides 3-1 and 1-2  		x1 = xsect (m3' m1);  		y1 = ysect (m3' m1);  		x2 = xsect (m1' m2);  		y2 = ysect (m1' m2);  		break;  	}  	renderer (x1' y1' x2' y2' z [k]);  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following statement contains a magic number: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: if (valign == VerticalAlignment.Bottom) {  	for (var i = lines.Length - 1; i >= 0; i--) {  		var line = lines [i];  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  else {  	foreach (var line in lines) {  		var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  		this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  		p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  		p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  	}  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: for (var i = lines.Length - 1; i >= 0; i--) {  	var line = lines [i];  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  	p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: for (var i = lines.Length - 1; i >= 0; i--) {  	var line = lines [i];  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  	p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p.X += Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p.Y -= Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: foreach (var line in lines) {  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  	p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: foreach (var line in lines) {  	var size = this.MeasureText (line' fontFamily' fontSize' fontWeight);  	this.w.WriteText (p' line' c' fontFamily' fontSize' fontWeight' rotate' halign' valign);  	p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  	p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  }  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p.X -= Math.Sin (rotate / 180.0 * Math.PI) * size.Height;  
Magic Number,OxyPlot,SvgRenderContext,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgRenderContext.cs,DrawText,The following statement contains a magic number: p.Y += Math.Cos (rotate / 180.0 * Math.PI) * size.Height;  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (fill == null) {  	style.AppendFormat ("fill:none;");  }  else {  	style.AppendFormat ("fill:{0};"' this.ColorToString (fill));  	if (fill.A != 0xFF) {  		style.AppendFormat (CultureInfo.InvariantCulture' "fill-opacity:{0};"' fill.A / 255.0);  	}  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (fill.A != 0xFF) {  	style.AppendFormat (CultureInfo.InvariantCulture' "fill-opacity:{0};"' fill.A / 255.0);  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: style.AppendFormat (CultureInfo.InvariantCulture' "fill-opacity:{0};"' fill.A / 255.0);  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (stroke == null) {  	style.AppendFormat ("stroke:none;");  }  else {  	string formatString = "stroke:{0};stroke-width:{1:" + this.NumberFormat + "}";  	style.AppendFormat (formatString' this.ColorToString (stroke)' thickness);  	switch (lineJoin) {  	case OxyPenLineJoin.Round:  		style.AppendFormat (";stroke-linejoin:round");  		break;  	case OxyPenLineJoin.Bevel:  		style.AppendFormat (";stroke-linejoin:bevel");  		break;  	}  	if (stroke.A != 0xFF) {  		style.AppendFormat (CultureInfo.InvariantCulture' ";stroke-opacity:{0}"' stroke.A / 255.0);  	}  	if (dashArray != null && dashArray.Length > 0) {  		style.Append (";stroke-dasharray:");  		for (int i = 0; i < dashArray.Length; i++) {  			style.AppendFormat (CultureInfo.InvariantCulture' "{0}{1}"' i > 0 ? "'" : string.Empty' dashArray [i]);  		}  	}  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: if (stroke.A != 0xFF) {  	style.AppendFormat (CultureInfo.InvariantCulture' ";stroke-opacity:{0}"' stroke.A / 255.0);  }  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following statement contains a magic number: style.AppendFormat (CultureInfo.InvariantCulture' ";stroke-opacity:{0}"' stroke.A / 255.0);  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("cx"' x + (width / 2));  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("cy"' y + (height / 2));  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("rx"' width / 2);  
Magic Number,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,WriteEllipse,The following statement contains a magic number: this.WriteAttributeString ("ry"' height / 2);  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,Parse,The following statement contains a magic number: if (value.StartsWith ("#")) {  	value = value.Trim ('#');  	var u = uint.Parse (value' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  	if (value.Length < 8) {  		// alpha value was not specified  		u += 0xFF000000;  	}  	return FromUInt32 (u);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,Parse,The following statement contains a magic number: if (value.Length < 8) {  	// alpha value was not specified  	u += 0xFF000000;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,Parse,The following statement contains a magic number: if (values.Length < 3 || values.Length > 4) {  	throw new FormatException ("Invalid format.");  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,Parse,The following statement contains a magic number: if (values.Length < 3 || values.Length > 4) {  	throw new FormatException ("Invalid format.");  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,Parse,The following statement contains a magic number: if (values.Length > 3) {  	alpha = byte.Parse (values [i++]' CultureInfo.InvariantCulture);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: if (hsv.Length != 3) {  	throw new InvalidOperationException ("Wrong length of hsv array.");  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromHsv (hsv [0]' hsv [1]' hsv [2]);  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	int i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	int i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	int i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	int i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: if (sat.Equals (0)) {  	// Gray scale  	r = g = b = val;  }  else {  	if (hue.Equals (1)) {  		hue = 0;  	}  	hue *= 6.0;  	int i = (int)Math.Floor (hue);  	double f = hue - i;  	double aa = val * (1 - sat);  	double bb = val * (1 - (sat * f));  	double cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: hue *= 6.0;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following statement contains a magic number: return FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,HueDifference,The following statement contains a magic number: if (dh > 0.5) {  	dh -= 1.0;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,HueDifference,The following statement contains a magic number: if (dh < -0.5) {  	dh += 1.0;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromRgb,The following statement contains a magic number: return new OxyColor {  	A = 255'  	R = r'  	G = g'  	B = b  };  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.A.GetHashCode ();  	result = (result * 397) ^ this.R.GetHashCode ();  	result = (result * 397) ^ this.G.GetHashCode ();  	result = (result * 397) ^ this.B.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.A.GetHashCode ();  	result = (result * 397) ^ this.R.GetHashCode ();  	result = (result * 397) ^ this.G.GetHashCode ();  	result = (result * 397) ^ this.B.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = this.A.GetHashCode ();  	result = (result * 397) ^ this.R.GetHashCode ();  	result = (result * 397) ^ this.G.GetHashCode ();  	result = (result * 397) ^ this.B.GetHashCode ();  	return result;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.R.GetHashCode ();  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.G.GetHashCode ();  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.B.GetHashCode ();  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,Complementary,The following statement contains a magic number: return FromHsv (newHue' hsv [1]' hsv [2]);  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (s.Equals (0)) {  	h = 0.0;  }  else {  	if (r == v) {  		h = (g - b) / delta;  	}  	else if (g == v) {  		h = 2 + ((b - r) / delta);  	}  	else if (b == v) {  		h = 4 + ((r - g) / delta);  	}  	h *= 60;  	if (h < 0.0) {  		h += 360;  	}  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (r == v) {  	h = (g - b) / delta;  }  else if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (r == v) {  	h = (g - b) / delta;  }  else if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (g == v) {  	h = 2 + ((b - r) / delta);  }  else if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: h = 2 + ((b - r) / delta);  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (b == v) {  	h = 4 + ((r - g) / delta);  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: h = 4 + ((r - g) / delta);  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: h *= 60;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: if (h < 0.0) {  	h += 360;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: h += 360;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: hsv [0] = h / 360.0;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: hsv [2] = v / 255.0;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToHsv,The following statement contains a magic number: hsv [2] = v / 255.0;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ChangeIntensity,The following statement contains a magic number: hsv [2] *= factor;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ChangeIntensity,The following statement contains a magic number: if (hsv [2] > 1.0) {  	hsv [2] = 1.0;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ChangeIntensity,The following statement contains a magic number: if (hsv [2] > 1.0) {  	hsv [2] = 1.0;  }  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ChangeIntensity,The following statement contains a magic number: hsv [2] = 1.0;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToUint,The following statement contains a magic number: u += (uint)this.R << 16;  
Magic Number,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,ToUint,The following statement contains a magic number: u += (uint)this.G << 8;  
Magic Number,OxyPlot.Axes,AngleAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\AngleAxis.cs,AngleAxis,The following statement contains a magic number: this.EndAngle = 360;  
Magic Number,OxyPlot.Axes,AngleAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\AngleAxis.cs,AngleAxis,The following statement contains a magic number: this.EndAngle = 360;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MinimumPadding = 0.01;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MaximumPadding = 0.01;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MinorTickSize = 4;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.MajorTickSize = 7;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.TitlePosition = 0.5;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.TitleClippingLength = 0.9;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.IntervalLength = 60;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.AxisTitleDistance = 4;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Axis,The following statement contains a magic number: this.AxisTickToLabelDistance = 4;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (double.IsNaN (this.ActualMaximum) || double.IsInfinity (this.ActualMaximum)) {  	this.ActualMaximum = 100;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = 100;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (this.ActualMaximum <= this.ActualMinimum) {  	this.ActualMaximum = this.ActualMinimum + 100;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = this.ActualMinimum + 100;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (range < this.MinimumRange) {  	double avg = (this.ActualMaximum + this.ActualMinimum) * 0.5;  	this.ActualMinimum = avg - (this.MinimumRange * 0.5);  	this.ActualMaximum = avg + (this.MinimumRange * 0.5);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (range < this.MinimumRange) {  	double avg = (this.ActualMaximum + this.ActualMinimum) * 0.5;  	this.ActualMinimum = avg - (this.MinimumRange * 0.5);  	this.ActualMaximum = avg + (this.MinimumRange * 0.5);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (range < this.MinimumRange) {  	double avg = (this.ActualMaximum + this.ActualMinimum) * 0.5;  	this.ActualMinimum = avg - (this.MinimumRange * 0.5);  	this.ActualMaximum = avg + (this.MinimumRange * 0.5);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMinimum = avg - (this.MinimumRange * 0.5);  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = avg + (this.MinimumRange * 0.5);  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,FormatValue,The following statement contains a magic number: if (this.UseSuperExponentialFormat) {  	// if (x == 1 || x == 10 || x == -1 || x == -10)  	// return x.ToString();  	double exp = Exponent (x);  	double mantissa = Mantissa (x);  	string fmt;  	if (this.StringFormat == null) {  		fmt = Math.Abs (mantissa - 1.0) < 1e-6 ? "10^{{{1:0}}}" : "{0}10^{{{1:0}}}";  	}  	else {  		fmt = "{0:" + this.StringFormat + "}10^{{{1:0}}}";  	}  	return string.Format (this.ActualCulture' fmt' mantissa' exp);  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,FormatValue,The following statement contains a magic number: if (this.StringFormat == null) {  	fmt = Math.Abs (mantissa - 1.0) < 1e-6 ? "10^{{{1:0}}}" : "{0}10^{{{1:0}}}";  }  else {  	fmt = "{0:" + this.StringFormat + "}10^{{{1:0}}}";  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,FormatValue,The following statement contains a magic number: fmt = Math.Abs (mantissa - 1.0) < 1e-6 ? "10^{{{1:0}}}" : "{0}10^{{{1:0}}}";  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: if (this.IsHorizontal ()) {  	switch (this.TickStyle) {  	case TickStyle.Outside:  		height += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		height += this.MajorTickSize * 0.75;  		break;  	}  	height += this.AxisTickToLabelDistance;  	height += maximumTextSize.Height;  	if (labelTextSize.Height > 0) {  		height += this.AxisTitleDistance;  		height += labelTextSize.Height;  	}  }  else {  	switch (this.TickStyle) {  	case TickStyle.Outside:  		width += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		width += this.MajorTickSize * 0.75;  		break;  	}  	width += this.AxisTickToLabelDistance;  	width += maximumTextSize.Width;  	if (labelTextSize.Height > 0) {  		width += this.AxisTitleDistance;  		width += labelTextSize.Height;  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: if (this.IsHorizontal ()) {  	switch (this.TickStyle) {  	case TickStyle.Outside:  		height += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		height += this.MajorTickSize * 0.75;  		break;  	}  	height += this.AxisTickToLabelDistance;  	height += maximumTextSize.Height;  	if (labelTextSize.Height > 0) {  		height += this.AxisTitleDistance;  		height += labelTextSize.Height;  	}  }  else {  	switch (this.TickStyle) {  	case TickStyle.Outside:  		width += this.MajorTickSize;  		break;  	case TickStyle.Crossing:  		width += this.MajorTickSize * 0.75;  		break;  	}  	width += this.AxisTickToLabelDistance;  	width += maximumTextSize.Width;  	if (labelTextSize.Height > 0) {  		width += this.AxisTitleDistance;  		width += labelTextSize.Height;  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: switch (this.TickStyle) {  case TickStyle.Outside:  	height += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	height += this.MajorTickSize * 0.75;  	break;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: height += this.MajorTickSize * 0.75;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: switch (this.TickStyle) {  case TickStyle.Outside:  	width += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	width += this.MajorTickSize * 0.75;  	break;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following statement contains a magic number: width += this.MajorTickSize * 0.75;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (!double.IsNaN (this.ViewMaximum)) {  	// Override the ActualMaximum by the ViewMaximum value (from zoom/pan)  	this.ActualMaximum = this.ViewMaximum;  }  else if (!double.IsNaN (this.Maximum)) {  	// Override the ActualMaximum by the Maximum value  	this.ActualMaximum = this.Maximum;  }  else {  	if (range < double.Epsilon) {  		this.ActualMaximum += zeroRange * 0.5;  	}  	if (!double.IsNaN (this.ActualMinimum) && !double.IsNaN (this.ActualMaximum)) {  		double x1 = this.PreTransform (this.ActualMaximum);  		double x0 = this.PreTransform (this.ActualMinimum);  		double dx = this.MaximumPadding * (x1 - x0);  		this.ActualMaximum = this.PostInverseTransform (x1 + dx);  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (!double.IsNaN (this.Maximum)) {  	// Override the ActualMaximum by the Maximum value  	this.ActualMaximum = this.Maximum;  }  else {  	if (range < double.Epsilon) {  		this.ActualMaximum += zeroRange * 0.5;  	}  	if (!double.IsNaN (this.ActualMinimum) && !double.IsNaN (this.ActualMaximum)) {  		double x1 = this.PreTransform (this.ActualMaximum);  		double x0 = this.PreTransform (this.ActualMinimum);  		double dx = this.MaximumPadding * (x1 - x0);  		this.ActualMaximum = this.PostInverseTransform (x1 + dx);  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (range < double.Epsilon) {  	this.ActualMaximum += zeroRange * 0.5;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.ActualMaximum += zeroRange * 0.5;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (!double.IsNaN (this.ViewMinimum)) {  	this.ActualMinimum = this.ViewMinimum;  }  else if (!double.IsNaN (this.Minimum)) {  	this.ActualMinimum = this.Minimum;  }  else {  	if (range < double.Epsilon) {  		this.ActualMinimum -= zeroRange * 0.5;  	}  	if (!double.IsNaN (this.ActualMaximum) && !double.IsNaN (this.ActualMaximum)) {  		double x1 = this.PreTransform (this.ActualMaximum);  		double x0 = this.PreTransform (this.ActualMinimum);  		double dx = this.MinimumPadding * (x1 - x0);  		this.ActualMinimum = this.PostInverseTransform (x0 - dx);  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (!double.IsNaN (this.Minimum)) {  	this.ActualMinimum = this.Minimum;  }  else {  	if (range < double.Epsilon) {  		this.ActualMinimum -= zeroRange * 0.5;  	}  	if (!double.IsNaN (this.ActualMaximum) && !double.IsNaN (this.ActualMaximum)) {  		double x1 = this.PreTransform (this.ActualMaximum);  		double x0 = this.PreTransform (this.ActualMinimum);  		double dx = this.MinimumPadding * (x1 - x0);  		this.ActualMinimum = this.PostInverseTransform (x0 - dx);  	}  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (range < double.Epsilon) {  	this.ActualMinimum -= zeroRange * 0.5;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.ActualMinimum -= zeroRange * 0.5;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: if (double.IsNaN (this.ActualMinorStep)) {  	this.ActualMinorStep = 2;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMinorStep = 2;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: if (double.IsNaN (this.ActualMajorStep)) {  	this.ActualMajorStep = 10;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMajorStep = 10;  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (tempInterval);  	if (m == 5) {  		// reduce 5 to 2  		tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	else {  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	if (range / tempInterval > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (tempInterval) || double.IsInfinity (tempInterval)) {  		break;  	}  	interval = tempInterval;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (tempInterval);  	if (m == 5) {  		// reduce 5 to 2  		tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	else {  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	if (range / tempInterval > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (tempInterval) || double.IsInfinity (tempInterval)) {  		break;  	}  	interval = tempInterval;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (tempInterval);  	if (m == 5) {  		// reduce 5 to 2  		tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	else {  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	if (range / tempInterval > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (tempInterval) || double.IsInfinity (tempInterval)) {  		break;  	}  	interval = tempInterval;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (tempInterval);  	if (m == 5) {  		// reduce 5 to 2  		tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	else {  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	if (range / tempInterval > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (tempInterval) || double.IsInfinity (tempInterval)) {  		break;  	}  	interval = tempInterval;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (tempInterval);  	if (m == 5) {  		// reduce 5 to 2  		tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	else {  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	if (range / tempInterval > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (tempInterval) || double.IsInfinity (tempInterval)) {  		break;  	}  	interval = tempInterval;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	var m = (int)mantissa (tempInterval);  	if (m == 5) {  		// reduce 5 to 2  		tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  	}  	else if (m == 2 || m == 1 || m == 10) {  		// reduce 2 to 1' 10 to 5' 1 to 0.5  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	else {  		tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  	}  	if (range / tempInterval > maxIntervalCount) {  		break;  	}  	if (double.IsNaN (tempInterval) || double.IsInfinity (tempInterval)) {  		break;  	}  	interval = tempInterval;  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 5) {  	// reduce 5 to 2  	tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  }  else if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: tempInterval = (tempInterval / 2.5).RemoveNoiseFromDoubleMath ();  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: if (m == 2 || m == 1 || m == 10) {  	// reduce 2 to 1' 10 to 5' 1 to 0.5  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  else {  	tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  }  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateActualInterval,The following statement contains a magic number: tempInterval = (tempInterval / 2.0).RemoveNoiseFromDoubleMath ();  
Magic Number,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,CalculateMinorInterval,The following statement contains a magic number: return majorInterval / 5;  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,GetCategoryValue,The following statement contains a magic number: return categoryIndex - 0.5 + ((offsetEnd + offsetBegin - actualBarWidth) * 0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,GetCategoryValue,The following statement contains a magic number: return categoryIndex - 0.5 + ((offsetEnd + offsetBegin - actualBarWidth) * 0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,GetCategoryValue,The following statement contains a magic number: return categoryIndex - 0.5 + this.BarOffset [categoryIndex];  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,GetTickValues,The following statement contains a magic number: if (!this.IsTickCentered) {  	// Subtract 0.5 from the label values to get the tick values.  	// Add one extra tick at the end.  	var mv = new List<double> (majorLabelValues.Count);  	mv.AddRange (majorLabelValues.Select (v => v - 0.5));  	if (mv.Count > 0) {  		mv.Add (mv [mv.Count - 1] + 1);  	}  	majorTickValues = mv;  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,GetTickValues,The following statement contains a magic number: mv.AddRange (majorLabelValues.Select (v => v - 0.5));  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.Include (-0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (this.Labels != null && this.Labels.Count > 0) {  	this.Include ((this.Labels.Count - 1) + 0.5);  }  else {  	this.Include (0.5);  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: if (this.Labels != null && this.Labels.Count > 0) {  	this.Include ((this.Labels.Count - 1) + 0.5);  }  else {  	this.Include (0.5);  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.Include ((this.Labels.Count - 1) + 0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateActualMaxMin,The following statement contains a magic number: this.Include (0.5);  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The following statement contains a magic number: for (var i = 0; i < this.Labels.Count; i++) {  	this.BarOffset [i] = 0.5 - (this.TotalWidthPerCategory [i] * factor);  }  
Magic Number,OxyPlot.Axes,CategoryAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\CategoryAxis.cs,UpdateFromSeries,The following statement contains a magic number: this.BarOffset [i] = 0.5 - (this.TotalWidthPerCategory [i] * factor);  
Magic Number,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' null);  	};  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double ylow = this.Transform (this.GetLowValue (i));  		double yhigh = this.Transform (this.GetHighValue (i));  		drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (this.LowColor != null) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (this.HighColor != null) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' null);  	};  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double ylow = this.Transform (this.GetLowValue (i));  		double yhigh = this.Transform (this.GetHighValue (i));  		drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (this.LowColor != null) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (this.HighColor != null) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,The following statement contains a magic number: if (pass == 0) {  	double left = model.PlotArea.Left;  	double top = model.PlotArea.Top;  	double width = this.MajorTickSize - 2;  	double height = this.MajorTickSize - 2;  	switch (this.Position) {  	case AxisPosition.Left:  		left = model.PlotArea.Left - this.PositionTierMinShift - width;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Right:  		left = model.PlotArea.Right + this.PositionTierMinShift;  		top = model.PlotArea.Top;  		break;  	case AxisPosition.Top:  		left = model.PlotArea.Left;  		top = model.PlotArea.Top - this.PositionTierMinShift - height;  		break;  	case AxisPosition.Bottom:  		left = model.PlotArea.Left;  		top = model.PlotArea.Bottom + this.PositionTierMinShift;  		break;  	}  	Action<double' double' OxyColor> drawColorRect = (ylow' yhigh' color) =>  {  		double ymin = Math.Min (ylow' yhigh);  		double ymax = Math.Max (ylow' yhigh);  		rc.DrawRectangle (this.IsHorizontal () ? new OxyRect (ymin' top' ymax - ymin' height) : new OxyRect (left' ymin' width' ymax - ymin)' color' null);  	};  	int n = this.Palette.Colors.Count;  	for (int i = 0; i < n; i++) {  		double ylow = this.Transform (this.GetLowValue (i));  		double yhigh = this.Transform (this.GetHighValue (i));  		drawColorRect (ylow' yhigh' this.Palette.Colors [i]);  	}  	double highLowLength = 10;  	if (this.IsHorizontal ()) {  		highLowLength *= -1;  	}  	if (this.LowColor != null) {  		double ylow = this.Transform (this.ActualMinimum);  		drawColorRect (ylow' ylow + highLowLength' this.LowColor);  	}  	if (this.HighColor != null) {  		double yhigh = this.Transform (this.ActualMaximum);  		drawColorRect (yhigh' yhigh - highLowLength' this.HighColor);  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: switch (this.actualIntervalType) {  case DateTimeIntervalType.Years:  	this.ActualMinorStep = 31;  	this.actualMinorIntervalType = DateTimeIntervalType.Years;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy";  	}  	break;  case DateTimeIntervalType.Months:  	this.actualMinorIntervalType = DateTimeIntervalType.Months;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Weeks:  	this.actualMinorIntervalType = DateTimeIntervalType.Days;  	this.ActualMajorStep = 7;  	this.ActualMinorStep = 1;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy/ww";  	}  	break;  case DateTimeIntervalType.Days:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Hours:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Minutes:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Seconds:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm:ss";  	}  	break;  case DateTimeIntervalType.Manual:  	break;  case DateTimeIntervalType.Auto:  	break;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: switch (this.actualIntervalType) {  case DateTimeIntervalType.Years:  	this.ActualMinorStep = 31;  	this.actualMinorIntervalType = DateTimeIntervalType.Years;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy";  	}  	break;  case DateTimeIntervalType.Months:  	this.actualMinorIntervalType = DateTimeIntervalType.Months;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Weeks:  	this.actualMinorIntervalType = DateTimeIntervalType.Days;  	this.ActualMajorStep = 7;  	this.ActualMinorStep = 1;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy/ww";  	}  	break;  case DateTimeIntervalType.Days:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Hours:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Minutes:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Seconds:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm:ss";  	}  	break;  case DateTimeIntervalType.Manual:  	break;  case DateTimeIntervalType.Auto:  	break;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMinorStep = 31;  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following statement contains a magic number: this.ActualMajorStep = 7;  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	if (range / interval < maxNumberOfIntervals) {  		break;  	}  	double nextInterval = goodIntervals.FirstOrDefault (i => i > interval);  	if (Math.Abs (nextInterval) < double.Epsilon) {  		nextInterval = interval * 2;  	}  	interval = nextInterval;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (Math.Abs (nextInterval) < double.Epsilon) {  	nextInterval = interval * 2;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: nextInterval = interval * 2;  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.IntervalType == DateTimeIntervalType.Auto) {  	this.actualIntervalType = DateTimeIntervalType.Seconds;  	if (interval >= 1.0 / 24 / 60) {  		this.actualIntervalType = DateTimeIntervalType.Minutes;  	}  	if (interval >= 1.0 / 24) {  		this.actualIntervalType = DateTimeIntervalType.Hours;  	}  	if (interval >= 1) {  		this.actualIntervalType = DateTimeIntervalType.Days;  	}  	if (interval >= 30) {  		this.actualIntervalType = DateTimeIntervalType.Months;  	}  	if (range >= 365.25) {  		this.actualIntervalType = DateTimeIntervalType.Years;  	}  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 1.0 / 24 / 60) {  	this.actualIntervalType = DateTimeIntervalType.Minutes;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 1.0 / 24 / 60) {  	this.actualIntervalType = DateTimeIntervalType.Minutes;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 1.0 / 24) {  	this.actualIntervalType = DateTimeIntervalType.Hours;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (interval >= 30) {  	this.actualIntervalType = DateTimeIntervalType.Months;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (range >= 365.25) {  	this.actualIntervalType = DateTimeIntervalType.Years;  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.actualIntervalType == DateTimeIntervalType.Months) {  	double monthsRange = range / 30.5;  	interval = this.CalculateActualInterval (availableSize' maxIntervalSize' monthsRange);  }  
Magic Number,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (this.actualIntervalType == DateTimeIntervalType.Years) {  	double yearsRange = range / 365.25;  	interval = this.CalculateActualInterval (availableSize' maxIntervalSize' yearsRange);  }  
Magic Number,OxyPlot.Axes,LinearAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LinearAxis.cs,FormatValue,The following statement contains a magic number: if (this.FormatAsFractions) {  	return FractionHelper.ConvertToFractionString (x' this.FractionUnit' this.FractionUnitSymbol' 1e-6' this.ActualCulture);  }  
Magic Number,OxyPlot.Axes,LinearAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LinearAxis.cs,FormatValue,The following statement contains a magic number: return FractionHelper.ConvertToFractionString (x' this.FractionUnit' this.FractionUnitSymbol' 1e-6' this.ActualCulture);  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\MagnitudeAxis.cs,UpdateTransform,The following statement contains a magic number: this.MidPoint = new ScreenPoint ((x0 + x1) / 2' (y0 + y1) / 2);  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\MagnitudeAxis.cs,UpdateTransform,The following statement contains a magic number: this.MidPoint = new ScreenPoint ((x0 + x1) / 2' (y0 + y1) / 2);  
Magic Number,OxyPlot.Axes,MagnitudeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\MagnitudeAxis.cs,UpdateTransform,The following statement contains a magic number: this.scale = 0.5 * r / (this.ActualMaximum - this.ActualMinimum);  
Magic Number,OxyPlot.Axes,TimeSpanAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\TimeSpanAxis.cs,CalculateActualInterval,The following statement contains a magic number: while (true) {  	if (range / interval < maxNumberOfIntervals) {  		return interval;  	}  	double nextInterval = goodIntervals.FirstOrDefault (i => i > interval);  	if (Math.Abs (nextInterval) < double.Epsilon) {  		nextInterval = interval * 2;  	}  	interval = nextInterval;  }  
Magic Number,OxyPlot.Axes,TimeSpanAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\TimeSpanAxis.cs,CalculateActualInterval,The following statement contains a magic number: if (Math.Abs (nextInterval) < double.Epsilon) {  	nextInterval = interval * 2;  }  
Magic Number,OxyPlot.Axes,TimeSpanAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\TimeSpanAxis.cs,CalculateActualInterval,The following statement contains a magic number: nextInterval = interval * 2;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,LogarithmicAxis,The following statement contains a magic number: this.Base = 10;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,CoerceActualMaxMin,The following statement contains a magic number: if (this.ActualMaximum <= this.ActualMinimum) {  	this.ActualMaximum = this.ActualMinimum * 100;  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,CoerceActualMaxMin,The following statement contains a magic number: this.ActualMaximum = this.ActualMinimum * 100;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,The following statement contains a magic number: if (this.ActualMinimum <= 0) {  	this.ActualMinimum = 0.1;  }  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,The following statement contains a magic number: this.ActualMinimum = 0.1;  
Magic Number,OxyPlot.Axes,LogarithmicAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\LogarithmicAxis.cs,GetTickValues,The following statement contains a magic number: if (majorTickValues.Count < 2) {  	base.GetTickValues (out majorLabelValues' out majorTickValues' out minorTickValues);  }  else {  	majorLabelValues = majorTickValues;  }  
Magic Number,OxyPlot.Reporting,WikiReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,WikiReportWriter,The following statement contains a magic number: this.MaxLineLength = 60;  
Magic Number,OxyPlot.Reporting,WikiReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,PadString,The following statement contains a magic number: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
Magic Number,OxyPlot.Reporting,WikiReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,PadString,The following statement contains a magic number: text = text.PadRight ((text.Length + width) / 2);  
Magic Number,OxyPlot.Reporting,TextReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,TextReportWriter,The following statement contains a magic number: this.MaxLineLength = 60;  
Magic Number,OxyPlot.Reporting,TextReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,PadString,The following statement contains a magic number: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
Magic Number,OxyPlot.Reporting,TextReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,PadString,The following statement contains a magic number: text = text.PadRight ((text.Length + width) / 2);  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.DefaultStyle = new ParagraphStyle {  	FontFamily = bodyTextFontFamily'  	FontSize = 11'  	SpacingAfter = 10  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.DefaultStyle = new ParagraphStyle {  	FontFamily = bodyTextFontFamily'  	FontSize = 11'  	SpacingAfter = 10  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles = new ParagraphStyle[5];  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [0] = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = titleFontFamily'  	SpacingBefore = 12'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [0] = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = titleFontFamily'  	SpacingBefore = 12'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [0].FontSize = 16;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [1].FontSize = 14;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [2].FontSize = 13;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [2].FontSize = 13;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [3].FontSize = 12;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [3].FontSize = 12;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [4].FontSize = 11;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.HeaderStyles [4].FontSize = 11;  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableTextStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = tableTextFontFamily'  	SpacingAfter = 0'  	LeftIndentation = 3'  	RightIndentation = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableTextStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	FontFamily = tableTextFontFamily'  	SpacingAfter = 0'  	LeftIndentation = 3'  	RightIndentation = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableCaptionStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	Italic = true'  	SpacingBefore = 10'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.TableCaptionStyle = new ParagraphStyle {  	BasedOn = this.DefaultStyle'  	Italic = true'  	SpacingBefore = 10'  	SpacingAfter = 3  };  
Magic Number,OxyPlot.Reporting,ReportStyle,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\ReportStyle.cs,ReportStyle,The following statement contains a magic number: this.Margins = new OxyThickness (25);  
Magic Number,OxyPlot.Reporting,HeaderHelper,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\HeaderHelper.cs,GetHeader,The following statement contains a magic number: for (int i = level + 1; i < 10; i++) {  	this.headerLevel [i] = 0;  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (this.Width < 0) {  	this.ActualWidth = 150 * (-this.Width);  }  else {  	this.ActualWidth = this.Width;  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: this.ActualWidth = 150 * (-this.Width);  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: foreach (var c in this.Columns) {  	if (double.IsNaN (c.Width)) {  		// todo: find auto width  		c.ActualWidth = 40;  		totalWidth += c.ActualWidth;  	}  	if (c.Width < 0) {  		totalWeight += -c.Width;  	}  	if (c.Width >= 0) {  		totalWidth += c.Width;  		c.ActualWidth = c.Width;  	}  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (double.IsNaN (c.Width)) {  	// todo: find auto width  	c.ActualWidth = 40;  	totalWidth += c.ActualWidth;  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: c.ActualWidth = 40;  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (double.IsNaN (this.ActualWidth)) {  	this.ActualWidth = Math.Max (150' totalWidth + 100);  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: if (double.IsNaN (this.ActualWidth)) {  	this.ActualWidth = Math.Max (150' totalWidth + 100);  }  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: this.ActualWidth = Math.Max (150' totalWidth + 100);  
Magic Number,OxyPlot.Reporting,Table,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\Report\Table.cs,UpdateWidths,The following statement contains a magic number: this.ActualWidth = Math.Max (150' totalWidth + 100);  
Magic Number,OxyPlot.Series,ErrorColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ErrorColumnSeries.cs,ErrorColumnSeries,The following statement contains a magic number: this.ErrorWidth = 0.4;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.BoxWidth = 0.3;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.MedianThickness = 2;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.OutlierSize = 2;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.MedianPointSize = 2;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,BoxPlotSeries,The following statement contains a magic number: this.WhiskerWidth = 0.5;  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	// Add the outlier points  	outlierScreenPoints.AddRange (item.Outliers.Select (outlier => this.Transform (item.X' outlier)));  	var topWhiskerTop = this.Transform (item.X' item.UpperWhisker);  	var topWhiskerBottom = this.Transform (item.X' item.BoxTop);  	var bottomWhiskerTop = this.Transform (item.X' item.BoxBottom);  	var bottomWhiskerBottom = this.Transform (item.X' item.LowerWhisker);  	rc.DrawClippedLine (new[] {  		topWhiskerTop'  		topWhiskerBottom  	}' clippingRect' 0' strokeColor' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' true);  	rc.DrawClippedLine (new[] {  		bottomWhiskerTop'  		bottomWhiskerBottom  	}' clippingRect' 0' strokeColor' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' true);  	// Draw the whiskers  	if (this.WhiskerWidth > 0) {  		var topWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.UpperWhisker);  		var topWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.UpperWhisker);  		var bottomWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.LowerWhisker);  		var bottomWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.LowerWhisker);  		rc.DrawClippedLine (new[] {  			topWhiskerLine1'  			topWhiskerLine2  		}' clippingRect' 0' strokeColor' this.StrokeThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  		rc.DrawClippedLine (new[] {  			bottomWhiskerLine1'  			bottomWhiskerLine2  		}' clippingRect' 0' strokeColor' this.StrokeThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  	}  	if (this.ShowBox) {  		// Draw the box  		var rect = this.GetBoxRect (item);  		rc.DrawClippedRectangleAsPolygon (rect' clippingRect' fillColor' strokeColor' this.StrokeThickness);  	}  	if (!this.ShowMedianAsDot) {  		// Draw the median line  		var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  		var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  		rc.DrawClippedLine (new[] {  			medianLeft'  			medianRight  		}' clippingRect' 0' strokeColor' this.StrokeThickness * this.MedianThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  	}  	else {  		var mc = this.Transform (item.X' item.Median);  		if (clippingRect.Contains (mc)) {  			var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  			rc.DrawEllipse (ellipseRect' fillColor' null' 0);  		}  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	// Add the outlier points  	outlierScreenPoints.AddRange (item.Outliers.Select (outlier => this.Transform (item.X' outlier)));  	var topWhiskerTop = this.Transform (item.X' item.UpperWhisker);  	var topWhiskerBottom = this.Transform (item.X' item.BoxTop);  	var bottomWhiskerTop = this.Transform (item.X' item.BoxBottom);  	var bottomWhiskerBottom = this.Transform (item.X' item.LowerWhisker);  	rc.DrawClippedLine (new[] {  		topWhiskerTop'  		topWhiskerBottom  	}' clippingRect' 0' strokeColor' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' true);  	rc.DrawClippedLine (new[] {  		bottomWhiskerTop'  		bottomWhiskerBottom  	}' clippingRect' 0' strokeColor' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' true);  	// Draw the whiskers  	if (this.WhiskerWidth > 0) {  		var topWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.UpperWhisker);  		var topWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.UpperWhisker);  		var bottomWhiskerLine1 = this.Transform (item.X - halfWhiskerWidth' item.LowerWhisker);  		var bottomWhiskerLine2 = this.Transform (item.X + halfWhiskerWidth' item.LowerWhisker);  		rc.DrawClippedLine (new[] {  			topWhiskerLine1'  			topWhiskerLine2  		}' clippingRect' 0' strokeColor' this.StrokeThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  		rc.DrawClippedLine (new[] {  			bottomWhiskerLine1'  			bottomWhiskerLine2  		}' clippingRect' 0' strokeColor' this.StrokeThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  	}  	if (this.ShowBox) {  		// Draw the box  		var rect = this.GetBoxRect (item);  		rc.DrawClippedRectangleAsPolygon (rect' clippingRect' fillColor' strokeColor' this.StrokeThickness);  	}  	if (!this.ShowMedianAsDot) {  		// Draw the median line  		var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  		var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  		rc.DrawClippedLine (new[] {  			medianLeft'  			medianRight  		}' clippingRect' 0' strokeColor' this.StrokeThickness * this.MedianThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  	}  	else {  		var mc = this.Transform (item.X' item.Median);  		if (clippingRect.Contains (mc)) {  			var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  			rc.DrawEllipse (ellipseRect' fillColor' null' 0);  		}  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	// Draw the median line  	var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  	var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  	rc.DrawClippedLine (new[] {  		medianLeft'  		medianRight  	}' clippingRect' 0' strokeColor' this.StrokeThickness * this.MedianThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  }  else {  	var mc = this.Transform (item.X' item.Median);  	if (clippingRect.Contains (mc)) {  		var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  		rc.DrawEllipse (ellipseRect' fillColor' null' 0);  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	// Draw the median line  	var medianLeft = this.Transform (item.X - halfBoxWidth' item.Median);  	var medianRight = this.Transform (item.X + halfBoxWidth' item.Median);  	rc.DrawClippedLine (new[] {  		medianLeft'  		medianRight  	}' clippingRect' 0' strokeColor' this.StrokeThickness * this.MedianThickness' LineStyle.Solid' OxyPenLineJoin.Miter' true);  }  else {  	var mc = this.Transform (item.X' item.Median);  	if (clippingRect.Contains (mc)) {  		var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  		rc.DrawEllipse (ellipseRect' fillColor' null' 0);  	}  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (clippingRect.Contains (mc)) {  	var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' null' 0);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,Render,The following statement contains a magic number: if (clippingRect.Contains (mc)) {  	var ellipseRect = new OxyRect (mc.X - this.MedianPointSize' mc.Y - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' null' 0);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: if (this.ShowBox) {  	// box  	rc.DrawRectangleAsPolygon (new OxyRect (xmid - halfBoxWidth' ytop' 2 * halfBoxWidth' ybottom - ytop)' fillColor' strokeColor' LegendStrokeThickness);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - halfBoxWidth' ytop' 2 * halfBoxWidth' ybottom - ytop)' fillColor' strokeColor' LegendStrokeThickness);  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	rc.DrawLine (new[] {  		new ScreenPoint (xmid - halfBoxWidth' ymid)'  		new ScreenPoint (xmid + halfBoxWidth' ymid)  	}' strokeColor' LegendStrokeThickness * this.MedianThickness' LineStyle.Solid.GetDashArray ()' OxyPenLineJoin.Miter' true);  }  else {  	var ellipseRect = new OxyRect (xmid - this.MedianPointSize' ymid - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' null);  }  
Magic Number,OxyPlot.Series,BoxPlotSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BoxPlotSeries.cs,RenderLegend,The following statement contains a magic number: if (!this.ShowMedianAsDot) {  	rc.DrawLine (new[] {  		new ScreenPoint (xmid - halfBoxWidth' ymid)'  		new ScreenPoint (xmid + halfBoxWidth' ymid)  	}' strokeColor' LegendStrokeThickness * this.MedianThickness' LineStyle.Solid.GetDashArray ()' OxyPenLineJoin.Miter' true);  }  else {  	var ellipseRect = new OxyRect (xmid - this.MedianPointSize' ymid - this.MedianPointSize' this.MedianPointSize * 2' this.MedianPointSize * 2);  	rc.DrawEllipse (ellipseRect' fillColor' null);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: if (this.Smooth) {  	var rpts0 = ScreenPointHelper.ResamplePoints (pts0' this.MinimumSegmentLength);  	var rpts1 = ScreenPointHelper.ResamplePoints (pts1' this.MinimumSegmentLength);  	pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  	pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts0 = CanonicalSplineHelper.CreateSpline (rpts0' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,AreaSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\AreaSeries.cs,Render,The following statement contains a magic number: pts1 = CanonicalSplineHelper.CreateSpline (rpts1' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,CandleStickSeries,The following statement contains a magic number: this.CandleWidth = 10;  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (new[] {  				low'  				high  			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			rc.DrawClippedLine (new[] {  				high'  				min  			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  			rc.DrawClippedLine (new[] {  				max'  				low  			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  			var openLeft = open;  			openLeft.X -= this.CandleWidth * 0.5;  			var closeRight = close;  			closeRight.X += this.CandleWidth * 0.5;  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: foreach (var v in this.Items) {  	if (!this.IsValidItem (v' this.XAxis' this.YAxis)) {  		continue;  	}  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var high = this.Transform (v.X' v.High);  		var low = this.Transform (v.X' v.Low);  		if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  			rc.DrawClippedLine (new[] {  				low'  				high  			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false);  		}  		else {  			var open = this.Transform (v.X' v.Open);  			var close = this.Transform (v.X' v.Close);  			var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  			var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  			rc.DrawClippedLine (new[] {  				high'  				min  			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  			rc.DrawClippedLine (new[] {  				max'  				low  			}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  			var openLeft = open;  			openLeft.X -= this.CandleWidth * 0.5;  			var closeRight = close;  			closeRight.X += this.CandleWidth * 0.5;  			var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  			rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  		}  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (new[] {  			low'  			high  		}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		rc.DrawClippedLine (new[] {  			high'  			min  		}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  		rc.DrawClippedLine (new[] {  			max'  			low  		}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  		var openLeft = open;  		openLeft.X -= this.CandleWidth * 0.5;  		var closeRight = close;  		closeRight.X += this.CandleWidth * 0.5;  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var high = this.Transform (v.X' v.High);  	var low = this.Transform (v.X' v.Low);  	if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  		rc.DrawClippedLine (new[] {  			low'  			high  		}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false);  	}  	else {  		var open = this.Transform (v.X' v.Open);  		var close = this.Transform (v.X' v.Close);  		var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  		var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  		rc.DrawClippedLine (new[] {  			high'  			min  		}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  		rc.DrawClippedLine (new[] {  			max'  			low  		}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  		var openLeft = open;  		openLeft.X -= this.CandleWidth * 0.5;  		var closeRight = close;  		closeRight.X += this.CandleWidth * 0.5;  		var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  		rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  	}  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (new[] {  		low'  		high  	}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	rc.DrawClippedLine (new[] {  		high'  		min  	}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  	rc.DrawClippedLine (new[] {  		max'  		low  	}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  	var openLeft = open;  	openLeft.X -= this.CandleWidth * 0.5;  	var closeRight = close;  	closeRight.X += this.CandleWidth * 0.5;  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: if (double.IsNaN (v.Open) || double.IsNaN (v.Close)) {  	rc.DrawClippedLine (new[] {  		low'  		high  	}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' false);  }  else {  	var open = this.Transform (v.X' v.Open);  	var close = this.Transform (v.X' v.Close);  	var max = new ScreenPoint (open.X' Math.Max (open.Y' close.Y));  	var min = new ScreenPoint (open.X' Math.Min (open.Y' close.Y));  	rc.DrawClippedLine (new[] {  		high'  		min  	}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  	rc.DrawClippedLine (new[] {  		max'  		low  	}' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' this.LineStyle' this.LineJoin' true);  	var openLeft = open;  	openLeft.X -= this.CandleWidth * 0.5;  	var closeRight = close;  	closeRight.X += this.CandleWidth * 0.5;  	var rect = new OxyRect (openLeft.X' min.Y' this.CandleWidth' max.Y - min.Y);  	rc.DrawClippedRectangleAsPolygon (rect' clippingRect' v.Open > v.Close ? this.GetSelectableFillColor (this.ActualColor) : null' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  }  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: openLeft.X -= this.CandleWidth * 0.5;  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,Render,The following statement contains a magic number: closeRight.X += this.CandleWidth * 0.5;  
Magic Number,OxyPlot.Series,CandleStickSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\CandleStickSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (this.CandleWidth * 0.5)' yclose' this.CandleWidth' yopen - yclose)' this.GetSelectableFillColor (this.ActualColor)' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,ContourSeries,The following statement contains a magic number: this.LabelBackground = OxyColor.FromAColor (220' OxyColors.White);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		actualStep = Math.Pow (10' Math.Floor (step.GetExponent ()));  	}  	max = max.ToUpperMultiple (actualStep);  	min = min.ToLowerMultiple (actualStep);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (actualContourLevels == null) {  	double max = this.Data [0' 0];  	double min = this.Data [0' 0];  	for (int i = 0; i < this.Data.GetUpperBound (0); i++) {  		for (int j = 0; j < this.Data.GetUpperBound (1); j++) {  			max = Math.Max (max' this.Data [i' j]);  			min = Math.Min (min' this.Data [i' j]);  		}  	}  	double actualStep = this.ContourLevelStep;  	if (double.IsNaN (actualStep)) {  		double range = max - min;  		double step = range / 20;  		actualStep = Math.Pow (10' Math.Floor (step.GetExponent ()));  	}  	max = max.ToUpperMultiple (actualStep);  	min = min.ToLowerMultiple (actualStep);  	actualContourLevels = ArrayHelper.CreateVector (min' max' actualStep);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (double.IsNaN (actualStep)) {  	double range = max - min;  	double step = range / 20;  	actualStep = Math.Pow (10' Math.Floor (step.GetExponent ()));  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: if (double.IsNaN (actualStep)) {  	double range = max - min;  	double step = range / 20;  	actualStep = Math.Pow (10' Math.Floor (step.GetExponent ()));  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,CalculateContours,The following statement contains a magic number: actualStep = Math.Pow (10' Math.Floor (step.GetExponent ()));  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: foreach (var contour in this.contours) {  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var pts = new ScreenPoint[contour.Points.Count];  		{  			int i = 0;  			foreach (var pt in contour.Points) {  				pts [i++] = this.Transform (pt.X' pt.Y);  			}  		// rc.DrawClippedPolygon(pts' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  		}  		rc.DrawClippedLine (pts' clippingRect' 4' this.GetSelectableColor (contour.Color ?? this.ActualColor)' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' false);  		if (pts.Length > 10) {  			this.AddContourLabels (contour' pts' clippingRect' contourLabels);  		}  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: foreach (var contour in this.contours) {  	if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  		var pts = new ScreenPoint[contour.Points.Count];  		{  			int i = 0;  			foreach (var pt in contour.Points) {  				pts [i++] = this.Transform (pt.X' pt.Y);  			}  		// rc.DrawClippedPolygon(pts' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  		}  		rc.DrawClippedLine (pts' clippingRect' 4' this.GetSelectableColor (contour.Color ?? this.ActualColor)' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' false);  		if (pts.Length > 10) {  			this.AddContourLabels (contour' pts' clippingRect' contourLabels);  		}  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var pts = new ScreenPoint[contour.Points.Count];  	{  		int i = 0;  		foreach (var pt in contour.Points) {  			pts [i++] = this.Transform (pt.X' pt.Y);  		}  	// rc.DrawClippedPolygon(pts' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  	}  	rc.DrawClippedLine (pts' clippingRect' 4' this.GetSelectableColor (contour.Color ?? this.ActualColor)' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' false);  	if (pts.Length > 10) {  		this.AddContourLabels (contour' pts' clippingRect' contourLabels);  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && this.LineStyle != LineStyle.None) {  	var pts = new ScreenPoint[contour.Points.Count];  	{  		int i = 0;  		foreach (var pt in contour.Points) {  			pts [i++] = this.Transform (pt.X' pt.Y);  		}  	// rc.DrawClippedPolygon(pts' clippingRect' 4' model.GetDefaultColor()' OxyColors.Black);  	}  	rc.DrawClippedLine (pts' clippingRect' 4' this.GetSelectableColor (contour.Color ?? this.ActualColor)' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' false);  	if (pts.Length > 10) {  		this.AddContourLabels (contour' pts' clippingRect' contourLabels);  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: rc.DrawClippedLine (pts' clippingRect' 4' this.GetSelectableColor (contour.Color ?? this.ActualColor)' this.StrokeThickness' this.LineStyle' OxyPenLineJoin.Miter' false);  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,Render,The following statement contains a magic number: if (pts.Length > 10) {  	this.AddContourLabels (contour' pts' clippingRect' contourLabels);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (pts.Length < 2) {  	return;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle > 90) {  	angle -= 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: angle -= 180;  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: if (angle < -90) {  	angle += 180;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,AddContourLabels,The following statement contains a magic number: angle += 180;  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: while (segmentCount > 0) {  	ContourSegment segment1 = null' segment2 = null;  	if (firstSegment != null) {  		bool reverse;  		// Find a segment that is connected to the head of the contour  		segment1 = this.FindConnectedSegment ((DataPoint)contourPoints [0]' firstSegment.ContourLevel' eps' out reverse);  		if (segment1 != null) {  			contourPoints.Insert (0' reverse ? segment1.StartPoint : segment1.EndPoint);  			contourPointsCount++;  			this.segments.Remove (segment1);  			segmentCount--;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = this.FindConnectedSegment ((DataPoint)contourPoints [contourPointsCount - 1]' firstSegment.ContourLevel' eps' out reverse);  		if (segment2 != null) {  			contourPoints.Add (reverse ? segment2.StartPoint : segment2.EndPoint);  			contourPointsCount++;  			this.segments.Remove (segment2);  			segmentCount--;  		}  	}  	if ((segment1 == null && segment2 == null) || segmentCount == 0) {  		if (contourPointsCount > 0 && firstSegment != null) {  			this.contours.Add (new Contour (contourPoints' firstSegment.ContourLevel));  			contourPoints = new List<IDataPoint> ();  			contourPointsCount = 0;  		}  		if (segmentCount > 0) {  			firstSegment = this.segments.First ();  			contourPoints.Add (firstSegment.StartPoint);  			contourPoints.Add (firstSegment.EndPoint);  			contourPointsCount += 2;  			this.segments.Remove (firstSegment);  			segmentCount--;  		}  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: if ((segment1 == null && segment2 == null) || segmentCount == 0) {  	if (contourPointsCount > 0 && firstSegment != null) {  		this.contours.Add (new Contour (contourPoints' firstSegment.ContourLevel));  		contourPoints = new List<IDataPoint> ();  		contourPointsCount = 0;  	}  	if (segmentCount > 0) {  		firstSegment = this.segments.First ();  		contourPoints.Add (firstSegment.StartPoint);  		contourPoints.Add (firstSegment.EndPoint);  		contourPointsCount += 2;  		this.segments.Remove (firstSegment);  		segmentCount--;  	}  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: if (segmentCount > 0) {  	firstSegment = this.segments.First ();  	contourPoints.Add (firstSegment.StartPoint);  	contourPoints.Add (firstSegment.EndPoint);  	contourPointsCount += 2;  	this.segments.Remove (firstSegment);  	segmentCount--;  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,JoinContourSegments,The following statement contains a magic number: contourPointsCount += 2;  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,RenderLabelBackground,The following statement contains a magic number: if (this.LabelBackground != null) {  	// Calculate background polygon  	var size = rc.MeasureText (cl.Text' this.ActualFont' this.ActualFontSize' this.ActualFontWeight);  	double a = cl.Angle / 180 * Math.PI;  	double dx = Math.Cos (a);  	double dy = Math.Sin (a);  	double ux = dx * 0.6;  	double uy = dy * 0.6;  	double vx = -dy * 0.5;  	double vy = dx * 0.5;  	double x = cl.Position.X;  	double y = cl.Position.Y;  	var bpts = new[] {  		new ScreenPoint (x - (size.Width * ux) - (size.Height * vx)' y - (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) - (size.Height * vx)' y + (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) + (size.Height * vx)' y + (size.Width * uy) + (size.Height * vy))'  		new ScreenPoint (x - (size.Width * ux) + (size.Height * vx)' y - (size.Width * uy) + (size.Height * vy))  	};  	rc.DrawPolygon (bpts' this.LabelBackground' null);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,RenderLabelBackground,The following statement contains a magic number: if (this.LabelBackground != null) {  	// Calculate background polygon  	var size = rc.MeasureText (cl.Text' this.ActualFont' this.ActualFontSize' this.ActualFontWeight);  	double a = cl.Angle / 180 * Math.PI;  	double dx = Math.Cos (a);  	double dy = Math.Sin (a);  	double ux = dx * 0.6;  	double uy = dy * 0.6;  	double vx = -dy * 0.5;  	double vy = dx * 0.5;  	double x = cl.Position.X;  	double y = cl.Position.Y;  	var bpts = new[] {  		new ScreenPoint (x - (size.Width * ux) - (size.Height * vx)' y - (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) - (size.Height * vx)' y + (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) + (size.Height * vx)' y + (size.Width * uy) + (size.Height * vy))'  		new ScreenPoint (x - (size.Width * ux) + (size.Height * vx)' y - (size.Width * uy) + (size.Height * vy))  	};  	rc.DrawPolygon (bpts' this.LabelBackground' null);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,RenderLabelBackground,The following statement contains a magic number: if (this.LabelBackground != null) {  	// Calculate background polygon  	var size = rc.MeasureText (cl.Text' this.ActualFont' this.ActualFontSize' this.ActualFontWeight);  	double a = cl.Angle / 180 * Math.PI;  	double dx = Math.Cos (a);  	double dy = Math.Sin (a);  	double ux = dx * 0.6;  	double uy = dy * 0.6;  	double vx = -dy * 0.5;  	double vy = dx * 0.5;  	double x = cl.Position.X;  	double y = cl.Position.Y;  	var bpts = new[] {  		new ScreenPoint (x - (size.Width * ux) - (size.Height * vx)' y - (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) - (size.Height * vx)' y + (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) + (size.Height * vx)' y + (size.Width * uy) + (size.Height * vy))'  		new ScreenPoint (x - (size.Width * ux) + (size.Height * vx)' y - (size.Width * uy) + (size.Height * vy))  	};  	rc.DrawPolygon (bpts' this.LabelBackground' null);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,RenderLabelBackground,The following statement contains a magic number: if (this.LabelBackground != null) {  	// Calculate background polygon  	var size = rc.MeasureText (cl.Text' this.ActualFont' this.ActualFontSize' this.ActualFontWeight);  	double a = cl.Angle / 180 * Math.PI;  	double dx = Math.Cos (a);  	double dy = Math.Sin (a);  	double ux = dx * 0.6;  	double uy = dy * 0.6;  	double vx = -dy * 0.5;  	double vy = dx * 0.5;  	double x = cl.Position.X;  	double y = cl.Position.Y;  	var bpts = new[] {  		new ScreenPoint (x - (size.Width * ux) - (size.Height * vx)' y - (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) - (size.Height * vx)' y + (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) + (size.Height * vx)' y + (size.Width * uy) + (size.Height * vy))'  		new ScreenPoint (x - (size.Width * ux) + (size.Height * vx)' y - (size.Width * uy) + (size.Height * vy))  	};  	rc.DrawPolygon (bpts' this.LabelBackground' null);  }  
Magic Number,OxyPlot.Series,ContourSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ContourSeries.cs,RenderLabelBackground,The following statement contains a magic number: if (this.LabelBackground != null) {  	// Calculate background polygon  	var size = rc.MeasureText (cl.Text' this.ActualFont' this.ActualFontSize' this.ActualFontWeight);  	double a = cl.Angle / 180 * Math.PI;  	double dx = Math.Cos (a);  	double dy = Math.Sin (a);  	double ux = dx * 0.6;  	double uy = dy * 0.6;  	double vx = -dy * 0.5;  	double vy = dx * 0.5;  	double x = cl.Position.X;  	double y = cl.Position.Y;  	var bpts = new[] {  		new ScreenPoint (x - (size.Width * ux) - (size.Height * vx)' y - (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) - (size.Height * vx)' y + (size.Width * uy) - (size.Height * vy))'  		new ScreenPoint (x + (size.Width * ux) + (size.Height * vx)' y + (size.Width * uy) + (size.Height * vy))'  		new ScreenPoint (x - (size.Width * ux) + (size.Height * vx)' y - (size.Width * uy) + (size.Height * vy))  	};  	rc.DrawPolygon (bpts' this.LabelBackground' null);  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  	va = VerticalAlignment.Top;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  	va = VerticalAlignment.Middle;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  default:  	// outside  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  	va = VerticalAlignment.Bottom;  	break;  }  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top + this.LabelMargin);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Bottom + rect.Top) / 2);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Bottom - this.LabelMargin);  
Magic Number,OxyPlot.Series,ColumnSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\ColumnSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' rect.Top - this.LabelMargin);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: switch (this.LabelPlacement) {  case LabelPlacement.Inside:  	pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Right;  	break;  case LabelPlacement.Middle:  	pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Center;  	break;  case LabelPlacement.Base:  	pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  default:  	// Outside  	pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  	ha = HorizontalAlignment.Left;  	break;  }  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint (rect.Right - this.LabelMargin' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint ((rect.Left + rect.Right) / 2' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint (rect.Left + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,BarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\BarSeries.cs,RenderLabel,The following statement contains a magic number: pt = new ScreenPoint (rect.Right + this.LabelMargin' (rect.Top + rect.Bottom) / 2);  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,GetNearestPoint,The following statement contains a magic number: for (int i = 0; i < this.ActualBarRectangles.Count; i++) {  	var r = this.ActualBarRectangles [i];  	if (r.Contains (point)) {  		double value = (this.Items [i].Y0 + this.Items [i].Y1) / 2;  		var sp = point;  		var dp = new DataPoint (i' value);  		var item = this.GetItem (i);  		var text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Items [i].X0' this.Items [i].X1' this.Items [i].Y0' this.Items [i].Y1' this.Items [i].Title);  		return new TrackerHitResult (this' dp' sp' item' i' text);  	}  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,GetNearestPoint,The following statement contains a magic number: if (r.Contains (point)) {  	double value = (this.Items [i].Y0 + this.Items [i].Y1) / 2;  	var sp = point;  	var dp = new DataPoint (i' value);  	var item = this.GetItem (i);  	var text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Items [i].X0' this.Items [i].X1' this.Items [i].Y0' this.Items [i].Y1' this.Items [i].Title);  	return new TrackerHitResult (this' dp' sp' item' i' text);  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	if (!this.IsValid (item.X0) || !this.IsValid (item.X1) || !this.IsValid (item.Y0) || !this.IsValid (item.Y1)) {  		continue;  	}  	var p0 = this.Transform (item.X0' item.Y0);  	var p1 = this.Transform (item.X1' item.Y1);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (rectangle' clippingRect' this.GetSelectableFillColor (item.Color ?? this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  	i++;  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: foreach (var item in this.Items) {  	if (!this.IsValid (item.X0) || !this.IsValid (item.X1) || !this.IsValid (item.Y0) || !this.IsValid (item.Y1)) {  		continue;  	}  	var p0 = this.Transform (item.X0' item.Y0);  	var p1 = this.Transform (item.X1' item.Y1);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (rectangle' clippingRect' this.GetSelectableFillColor (item.Color ?? this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  	i++;  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.X0' item.X1' item.Y0' item.Y1' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,RectangleBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\RectangleBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,IntervalBarSeries,The following statement contains a magic number: this.LabelMargin = 4;  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,GetNearestPoint,The following statement contains a magic number: for (int i = 0; i < this.ActualBarRectangles.Count; i++) {  	var r = this.ActualBarRectangles [i];  	if (r.Contains (point)) {  		var item = (IntervalBarItem)this.GetItem (this.ValidItemsIndexInversion [i]);  		var categoryIndex = item.GetCategoryIndex (i);  		double value = (this.ValidItems [i].Start + this.ValidItems [i].End) / 2;  		var dp = new DataPoint (categoryIndex' value);  		var text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Items [i].Start' this.Items [i].End' this.Items [i].Title);  		return new TrackerHitResult (this' dp' point' item' i' text);  	}  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,GetNearestPoint,The following statement contains a magic number: if (r.Contains (point)) {  	var item = (IntervalBarItem)this.GetItem (this.ValidItemsIndexInversion [i]);  	var categoryIndex = item.GetCategoryIndex (i);  	double value = (this.ValidItems [i].Start + this.ValidItems [i].End) / 2;  	var dp = new DataPoint (categoryIndex' value);  	var text = StringHelper.Format (this.ActualCulture' this.TrackerFormatString' item' this.Items [i].Start' this.Items [i].End' this.Items [i].Title);  	return new TrackerHitResult (this' dp' point' item' i' text);  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	double categoryValue = categoryAxis.GetCategoryValue (categoryIndex' stackIndex' actualBarWidth);  	var p0 = this.Transform (item.Start' categoryValue);  	var p1 = this.Transform (item.End' categoryValue + actualBarWidth);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (rectangle' clippingRect' this.GetSelectableFillColor (item.Color ?? this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	double categoryValue = categoryAxis.GetCategoryValue (categoryIndex' stackIndex' actualBarWidth);  	var p0 = this.Transform (item.Start' categoryValue);  	var p1 = this.Transform (item.End' categoryValue + actualBarWidth);  	var rectangle = OxyRect.Create (p0.X' p0.Y' p1.X' p1.Y);  	this.ActualBarRectangles.Add (rectangle);  	rc.DrawClippedRectangleAsPolygon (rectangle' clippingRect' this.GetSelectableFillColor (item.Color ?? this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  	if (this.LabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  		var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,Render,The following statement contains a magic number: if (this.LabelFormatString != null) {  	var s = StringHelper.Format (this.ActualCulture' this.LabelFormatString' this.GetItem (i)' item.Start' item.End' item.Title);  	var pt = new ScreenPoint ((rectangle.Left + rectangle.Right) / 2' (rectangle.Top + rectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,IntervalBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\IntervalBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' width' height)' this.GetSelectableFillColor (this.ActualFillColor)' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MaximumFillColor = OxyColor.FromRgb (216' 82' 85);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MaximumFillColor = OxyColor.FromRgb (216' 82' 85);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MaximumFillColor = OxyColor.FromRgb (216' 82' 85);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MinimumFillColor = OxyColor.FromRgb (84' 138' 209);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MinimumFillColor = OxyColor.FromRgb (84' 138' 209);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.MinimumFillColor = OxyColor.FromRgb (84' 138' 209);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,TornadoBarSeries,The following statement contains a magic number: this.LabelMargin = 4;  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex] + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	p2.X = (int)p2.X;  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (minimumRectangle' clippingRect' item.MinimumColor ?? this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (maximumRectangle' clippingRect' item.MaximumColor ?? this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex] + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	p2.X = (int)p2.X;  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (minimumRectangle' clippingRect' item.MinimumColor ?? this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (maximumRectangle' clippingRect' item.MaximumColor ?? this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex] + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	p2.X = (int)p2.X;  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (minimumRectangle' clippingRect' item.MinimumColor ?? this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (maximumRectangle' clippingRect' item.MaximumColor ?? this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex] + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	p2.X = (int)p2.X;  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (minimumRectangle' clippingRect' item.MinimumColor ?? this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (maximumRectangle' clippingRect' item.MaximumColor ?? this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: for (var i = 0; i < this.ValidItems.Count; i++) {  	var item = this.ValidItems [i];  	var categoryIndex = item.GetCategoryIndex (i);  	var baseValue = double.IsNaN (item.BaseValue) ? this.BaseValue : item.BaseValue;  	var p0 = this.Transform (item.Minimum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	var p1 = this.Transform (item.Maximum' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex] + actualBarWidth);  	var p2 = this.Transform (baseValue' categoryIndex - 0.5 + categoryAxis.BarOffset [categoryIndex]);  	p2.X = (int)p2.X;  	var minimumRectangle = OxyRect.Create (p0.X' p0.Y' p2.X' p1.Y);  	var maximumRectangle = OxyRect.Create (p2.X' p0.Y' p1.X' p1.Y);  	this.ActualMinimumBarRectangles.Add (minimumRectangle);  	this.ActualMaximumBarRectangles.Add (maximumRectangle);  	rc.DrawClippedRectangleAsPolygon (minimumRectangle' clippingRect' item.MinimumColor ?? this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  	rc.DrawClippedRectangleAsPolygon (maximumRectangle' clippingRect' item.MaximumColor ?? this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  	if (this.MinimumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  		var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	if (this.MaximumLabelFormatString != null) {  		var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  		var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  		rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: if (this.MinimumLabelFormatString != null) {  	var s = StringHelper.Format (this.ActualCulture' this.MinimumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Minimum);  	var pt = new ScreenPoint (minimumRectangle.Left - this.LabelMargin' (minimumRectangle.Top + minimumRectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Right' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,Render,The following statement contains a magic number: if (this.MaximumLabelFormatString != null) {  	var s = StringHelper.Format (this.ActualCulture' this.MaximumLabelFormatString' this.GetItem (this.ValidItemsIndexInversion [i])' item.Maximum);  	var pt = new ScreenPoint (maximumRectangle.Right + this.LabelMargin' (maximumRectangle.Top + maximumRectangle.Bottom) / 2);  	rc.DrawClippedText (clippingRect' pt' s' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' HorizontalAlignment.Left' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid - (0.5 * width)' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMinimumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,TornadoBarSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\BarSeries\TornadoBarSeries.cs,RenderLegend,The following statement contains a magic number: rc.DrawRectangleAsPolygon (new OxyRect (xmid' ymid - (0.5 * height)' 0.5 * width' height)' this.ActualMaximumFillColor' this.StrokeColor' this.StrokeThickness);  
Magic Number,OxyPlot.Series,HighLowSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\HighLowSeries.cs,HighLowSeries,The following statement contains a magic number: this.TickLength = 4;  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,GetNearestPoint,The following statement contains a magic number: for (int i = 0; i + 1 < this.Points.Count; i++) {  	var p1 = this.Points [i];  	var p2 = this.Points [i + 1];  	var sp1 = this.Transform (p1.X' p1.Y);  	var sp2 = this.Transform (p2.X' p1.Y);  	double spdx = sp2.x - sp1.x;  	double spdy = sp2.y - sp1.y;  	double u1 = ((point.x - sp1.x) * spdx) + ((point.y - sp1.y) * spdy);  	double u2 = (spdx * spdx) + (spdy * spdy);  	double ds = (spdx * spdx) + (spdy * spdy);  	if (ds < 4) {  		// if the points are very close' we can get numerical problems' just use the first point...  		u1 = 0;  		u2 = 1;  	}  	if (Math.Abs (u2) < double.Epsilon) {  		continue;  		// P1 && P2 coincident  	}  	double u = u1 / u2;  	if (u < 0 || u > 1) {  		continue;  		// outside line  	}  	double sx = sp1.x + (u * spdx);  	double sy = sp1.y + (u * spdy);  	double dx = point.x - sx;  	double dy = point.y - sy;  	double distance = (dx * dx) + (dy * dy);  	if (distance < minimumDistance) {  		double px = p1.X + (u * (p2.X - p1.X));  		double py = p1.Y;  		result = new TrackerHitResult (this' new DataPoint (px' py)' new ScreenPoint (sx' sy)' this.GetItem (i)' i);  		minimumDistance = distance;  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,GetNearestPoint,The following statement contains a magic number: if (ds < 4) {  	// if the points are very close' we can get numerical problems' just use the first point...  	u1 = 0;  	u2 = 1;  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && lineStyle != LineStyle.None) {  	var verticalStrokeThickness = double.IsNaN (this.VerticalStrokeThickness) ? this.StrokeThickness : this.VerticalStrokeThickness;  	if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  		var hlpts = new List<ScreenPoint> ();  		var vlpts = new List<ScreenPoint> ();  		for (int i = 0; i + 2 < lpts.Count; i += 2) {  			hlpts.Add (lpts [i]);  			hlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 2]);  		}  		rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  		rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false);  	}  	else {  		rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && lineStyle != LineStyle.None) {  	var verticalStrokeThickness = double.IsNaN (this.VerticalStrokeThickness) ? this.StrokeThickness : this.VerticalStrokeThickness;  	if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  		var hlpts = new List<ScreenPoint> ();  		var vlpts = new List<ScreenPoint> ();  		for (int i = 0; i + 2 < lpts.Count; i += 2) {  			hlpts.Add (lpts [i]);  			hlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 2]);  		}  		rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  		rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false);  	}  	else {  		rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (this.StrokeThickness > 0 && lineStyle != LineStyle.None) {  	var verticalStrokeThickness = double.IsNaN (this.VerticalStrokeThickness) ? this.StrokeThickness : this.VerticalStrokeThickness;  	if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  		var hlpts = new List<ScreenPoint> ();  		var vlpts = new List<ScreenPoint> ();  		for (int i = 0; i + 2 < lpts.Count; i += 2) {  			hlpts.Add (lpts [i]);  			hlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 1]);  			vlpts.Add (lpts [i + 2]);  		}  		rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  		rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false);  	}  	else {  		rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  	}  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  	var hlpts = new List<ScreenPoint> ();  	var vlpts = new List<ScreenPoint> ();  	for (int i = 0; i + 2 < lpts.Count; i += 2) {  		hlpts.Add (lpts [i]);  		hlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 2]);  	}  	rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  	rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false);  }  else {  	rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  	var hlpts = new List<ScreenPoint> ();  	var vlpts = new List<ScreenPoint> ();  	for (int i = 0; i + 2 < lpts.Count; i += 2) {  		hlpts.Add (lpts [i]);  		hlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 2]);  	}  	rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  	rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false);  }  else {  	rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: if (!verticalStrokeThickness.Equals (this.StrokeThickness) || this.VerticalLineStyle != lineStyle) {  	var hlpts = new List<ScreenPoint> ();  	var vlpts = new List<ScreenPoint> ();  	for (int i = 0; i + 2 < lpts.Count; i += 2) {  		hlpts.Add (lpts [i]);  		hlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 1]);  		vlpts.Add (lpts [i + 2]);  	}  	rc.DrawClippedLineSegments (hlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  	rc.DrawClippedLineSegments (vlpts' clippingRect' this.GetSelectableColor (this.ActualColor)' verticalStrokeThickness' this.VerticalLineStyle' this.LineJoin' false);  }  else {  	rc.DrawClippedLine (lpts' clippingRect' 0' this.GetSelectableColor (this.ActualColor)' this.StrokeThickness' lineStyle' this.LineJoin' false);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: for (int i = 0; i + 2 < lpts.Count; i += 2) {  	hlpts.Add (lpts [i]);  	hlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 2]);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: for (int i = 0; i + 2 < lpts.Count; i += 2) {  	hlpts.Add (lpts [i]);  	hlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 2]);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: for (int i = 0; i + 2 < lpts.Count; i += 2) {  	hlpts.Add (lpts [i]);  	hlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 1]);  	vlpts.Add (lpts [i + 2]);  }  
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: i += 2
Magic Number,OxyPlot.Series,StairStepSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\StairStepSeries.cs,Render,The following statement contains a magic number: vlpts.Add (lpts [i + 2]);  
Magic Number,OxyPlot.Series,ScatterSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\ScatterSeries.cs,ScatterSeries,The following statement contains a magic number: this.MarkerSize = 5;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.AngleSpan = 360.0;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.TickRadialLength = 6;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.TickHorizontalLength = 8;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.TickLabelDistance = 4;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.InsideLabelPosition = 0.5;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,PieSeries,The following statement contains a magic number: this.FontSize = 12;  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render label inside the slice  	if (this.InsideLabelFormat != null) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render label inside the slice  	if (this.InsideLabelFormat != null) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render label inside the slice  	if (this.InsideLabelFormat != null) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render label inside the slice  	if (this.InsideLabelFormat != null) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render label inside the slice  	if (this.InsideLabelFormat != null) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: foreach (var slice in this.slices) {  	var outerPoints = new List<ScreenPoint> ();  	var innerPoints = new List<ScreenPoint> ();  	double sliceAngle = slice.Value / total * this.AngleSpan;  	double endAngle = angle + sliceAngle;  	double explodedRadius = slice.IsExploded ? this.ExplodedDistance * radius : 0.0;  	double midAngle = angle + (sliceAngle / 2);  	double midAngleRadians = midAngle * Math.PI / 180;  	var mp = new ScreenPoint (midPoint.X + (explodedRadius * Math.Cos (midAngleRadians))' midPoint.Y + (explodedRadius * Math.Sin (midAngleRadians)));  	// Create the pie sector points for both outside and inside arcs  	while (true) {  		bool stop = false;  		if (angle >= endAngle) {  			angle = endAngle;  			stop = true;  		}  		double a = angle * Math.PI / 180;  		var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  		outerPoints.Add (op);  		var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  		if (innerRadius + explodedRadius > 0) {  			innerPoints.Add (ip);  		}  		if (stop) {  			break;  		}  		angle += this.AngleIncrement;  	}  	innerPoints.Reverse ();  	if (innerPoints.Count == 0) {  		innerPoints.Add (mp);  	}  	innerPoints.Add (outerPoints [0]);  	var points = outerPoints;  	points.AddRange (innerPoints);  	rc.DrawPolygon (points' slice.ActualFillColor' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// Render label outside the slice  	if (this.OutsideLabelFormat != null) {  		string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		int sign = Math.Sign (Math.Cos (midAngleRadians));  		// tick points  		var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  		var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  		var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  		rc.DrawLine (new[] {  			tp0'  			tp1'  			tp2  		}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  		// label  		var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  	}  	// Render label inside the slice  	if (this.InsideLabelFormat != null) {  		string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  		double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  		var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  		double textAngle = 0;  		if (this.AreInsideLabelsAngled) {  			textAngle = midAngle;  			if (Math.Cos (midAngleRadians) < 0) {  				textAngle += 180;  			}  		}  		rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: while (true) {  	bool stop = false;  	if (angle >= endAngle) {  		angle = endAngle;  		stop = true;  	}  	double a = angle * Math.PI / 180;  	var op = new ScreenPoint (mp.X + (outerRadius * Math.Cos (a))' mp.Y + (outerRadius * Math.Sin (a)));  	outerPoints.Add (op);  	var ip = new ScreenPoint (mp.X + (innerRadius * Math.Cos (a))' mp.Y + (innerRadius * Math.Sin (a)));  	if (innerRadius + explodedRadius > 0) {  		innerPoints.Add (ip);  	}  	if (stop) {  		break;  	}  	angle += this.AngleIncrement;  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.OutsideLabelFormat != null) {  	string label = string.Format (this.OutsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  	int sign = Math.Sign (Math.Cos (midAngleRadians));  	// tick points  	var tp0 = new ScreenPoint (mp.X + ((outerRadius + this.TickDistance) * Math.Cos (midAngleRadians))' mp.Y + ((outerRadius + this.TickDistance) * Math.Sin (midAngleRadians)));  	var tp1 = new ScreenPoint (tp0.X + (this.TickRadialLength * Math.Cos (midAngleRadians))' tp0.Y + (this.TickRadialLength * Math.Sin (midAngleRadians)));  	var tp2 = new ScreenPoint (tp1.X + (this.TickHorizontalLength * sign)' tp1.Y);  	rc.DrawLine (new[] {  		tp0'  		tp1'  		tp2  	}' this.Stroke' this.StrokeThickness' null' OxyPenLineJoin.Bevel);  	// label  	var labelPosition = new ScreenPoint (tp2.X + (this.TickLabelDistance * sign)' tp2.Y);  	rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' 0' sign > 0 ? HorizontalAlignment.Left : HorizontalAlignment.Right' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.InsideLabelFormat != null) {  	string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  	double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  	var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  	double textAngle = 0;  	if (this.AreInsideLabelsAngled) {  		textAngle = midAngle;  		if (Math.Cos (midAngleRadians) < 0) {  			textAngle += 180;  		}  	}  	rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.InsideLabelFormat != null) {  	string label = string.Format (this.InsideLabelFormat' slice.Value' slice.Label' slice.Value / total * 100);  	double r = (innerRadius * (1 - this.InsideLabelPosition)) + (outerRadius * this.InsideLabelPosition);  	var labelPosition = new ScreenPoint (mp.X + (r * Math.Cos (midAngleRadians))' mp.Y + (r * Math.Sin (midAngleRadians)));  	double textAngle = 0;  	if (this.AreInsideLabelsAngled) {  		textAngle = midAngle;  		if (Math.Cos (midAngleRadians) < 0) {  			textAngle += 180;  		}  	}  	rc.DrawText (labelPosition' label' this.ActualTextColor' this.ActualFont' this.ActualFontSize' this.ActualFontWeight' textAngle' HorizontalAlignment.Center' VerticalAlignment.Middle);  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (this.AreInsideLabelsAngled) {  	textAngle = midAngle;  	if (Math.Cos (midAngleRadians) < 0) {  		textAngle += 180;  	}  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: if (Math.Cos (midAngleRadians) < 0) {  	textAngle += 180;  }  
Magic Number,OxyPlot.Series,PieSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\PieSeries.cs,Render,The following statement contains a magic number: textAngle += 180;  
Magic Number,OxyPlot.Series,FunctionSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The following statement contains a magic number: for (double x = x0; x <= x1 + (dx * 0.5); x += dx) {  	this.Points.Add (new DataPoint (x' f (x)));  }  
Magic Number,OxyPlot.Series,FunctionSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\FunctionSeries.cs,FunctionSeries,The following statement contains a magic number: for (double t = t0; t <= t1 + (dt * 0.5); t += dt) {  	this.Points.Add (new DataPoint (fx (t)' fy (t)));  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.MinimumSegmentLength = 2;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.StrokeThickness = 2;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.MarkerSize = 3;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,LineSeries,The following statement contains a magic number: this.LabelMargin = 6;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: switch (this.LineLegendPosition) {  case LineLegendPosition.Start:  	// start position  	point = this.Points [0];  	ha = HorizontalAlignment.Right;  	dx = -4;  	break;  default:  	// end position  	point = this.Points [this.Points.Count - 1];  	dx = 4;  	break;  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: switch (this.LineLegendPosition) {  case LineLegendPosition.Start:  	// start position  	point = this.Points [0];  	ha = HorizontalAlignment.Right;  	dx = -4;  	break;  default:  	// end position  	point = this.Points [this.Points.Count - 1];  	dx = 4;  	break;  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: dx = -4;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderLegendOnLine,The following statement contains a magic number: dx = 4;  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderPoints,The following statement contains a magic number: if (this.Smooth) {  	// spline smoothing (should only be used on small datasets)  	var resampledPoints = ScreenPointHelper.ResamplePoints (pointsToRender' this.MinimumSegmentLength);  	screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderPoints,The following statement contains a magic number: if (this.Smooth) {  	// spline smoothing (should only be used on small datasets)  	var resampledPoints = ScreenPointHelper.ResamplePoints (pointsToRender' this.MinimumSegmentLength);  	screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  }  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderPoints,The following statement contains a magic number: screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,RenderPoints,The following statement contains a magic number: screenPoints = CanonicalSplineHelper.CreateSpline (resampledPoints' 0.5' null' false' 0.25);  
Magic Number,OxyPlot.Series,LineSeries,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Series\LineSeries.cs,ResetSmoothedPoints,The following statement contains a magic number: this.smoothedPoints = CanonicalSplineHelper.CreateSpline (this.Points' 0.5' null' false' tolerance);  
Missing Default,OxyPlot.Annotations,LineAnnotation,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Annotations\LineAnnotation.cs,Render,The following switch statement is missing a default case: switch (this.TextOrientation) {  case AnnotationTextOrientation.Horizontal:  	angle = 0;  	break;  case AnnotationTextOrientation.Vertical:  	angle = -90;  	break;  }  
Missing Default,OxyPlot,SutherlandHodgmanClipping,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\SutherlandHodgmanClipping.cs,LineIntercept,The following switch statement is missing a default case: switch (edge) {  case RectangleEdge.Bottom:  	if (b.Y == a.Y) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (a.X + (((b.X - a.X) * (bounds.Bottom - a.Y)) / (b.Y - a.Y))' bounds.Bottom);  case RectangleEdge.Left:  	if (b.X == a.X) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (bounds.Left' a.Y + (((b.Y - a.Y) * (bounds.Left - a.X)) / (b.X - a.X)));  case RectangleEdge.Right:  	if (b.X == a.X) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (bounds.Right' a.Y + (((b.Y - a.Y) * (bounds.Right - a.X)) / (b.X - a.X)));  case RectangleEdge.Top:  	if (b.Y == a.Y) {  		throw new ArgumentException ("no intercept found");  	}  	return new ScreenPoint (a.X + (((b.X - a.X) * (bounds.Top - a.Y)) / (b.Y - a.Y))' bounds.Top);  }  
Missing Default,OxyPlot,AxisRendererBase,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\AxisRendererBase.cs,GetTickPositions,The following switch statement is missing a default case: switch (glt) {  case TickStyle.Crossing:  	x0 = -ticksize * sign * 0.75;  	x1 = ticksize * sign * 0.75;  	break;  case TickStyle.Inside:  	x0 = -ticksize * sign;  	break;  case TickStyle.Outside:  	x1 = ticksize * sign;  	break;  }  
Missing Default,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following switch statement is missing a default case: switch (ha) {  case HorizontalAlignment.Right:  	x -= size.Width;  	break;  case HorizontalAlignment.Center:  	x -= size.Width * 0.5;  	break;  }  
Missing Default,OxyPlot,MathRenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\MathRenderingExtensions.cs,DrawMathText,The following switch statement is missing a default case: switch (va) {  case VerticalAlignment.Bottom:  	y -= size.Height;  	break;  case VerticalAlignment.Middle:  	y -= size.Height * 0.5;  	break;  }  
Missing Default,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following switch statement is missing a default case: switch (type) {  case MarkerType.Circle: {  	ellipses.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Square: {  	rects.Add (new OxyRect (p.x - size' p.y - size' size * 2' size * 2));  	break;  }  case MarkerType.Diamond: {  	polygons.Add (new[] {  		new ScreenPoint (p.x' p.y - (M2 * size))'  		new ScreenPoint (p.x + (M2 * size)' p.y)'  		new ScreenPoint (p.x' p.y + (M2 * size))'  		new ScreenPoint (p.x - (M2 * size)' p.y)  	});  	break;  }  case MarkerType.Triangle: {  	polygons.Add (new[] {  		new ScreenPoint (p.x - size' p.y + (M1 * size))'  		new ScreenPoint (p.x + size' p.y + (M1 * size))'  		new ScreenPoint (p.x' p.y - (M2 * size))  	});  	break;  }  case MarkerType.Plus:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - size' p.y));  	lines.Add (new ScreenPoint (p.x + size' p.y));  	lines.Add (new ScreenPoint (p.x' p.y - size));  	lines.Add (new ScreenPoint (p.x' p.y + size));  	break;  }  }  
Missing Default,OxyPlot,RenderingExtensions,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\RenderingExtensions.cs,AddMarkerGeometry,The following switch statement is missing a default case: switch (type) {  case MarkerType.Cross:  case MarkerType.Star: {  	lines.Add (new ScreenPoint (p.x - (size * M3)' p.y - (size * M3)));  	lines.Add (new ScreenPoint (p.x + (size * M3)' p.y + (size * M3)));  	lines.Add (new ScreenPoint (p.x - (size * M3)' p.y + (size * M3)));  	lines.Add (new ScreenPoint (p.x + (size * M3)' p.y - (size * M3)));  	break;  }  }  
Missing Default,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,Render,The following switch statement is missing a default case: switch (axis.Position) {  case AxisPosition.Left:  	axisPosition = plotAreaLeft - totalShift;  	titlePosition = axisPosition - tierSize;  	break;  case AxisPosition.Right:  	axisPosition = plotAreaRight + totalShift;  	titlePosition = axisPosition + tierSize;  	break;  case AxisPosition.Top:  	axisPosition = plotAreaTop - totalShift;  	titlePosition = axisPosition - tierSize;  	break;  case AxisPosition.Bottom:  	axisPosition = plotAreaBottom + totalShift;  	titlePosition = axisPosition + tierSize;  	break;  }  
Missing Default,OxyPlot,HorizontalAndVerticalAxisRenderer,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Render\HorizontalAndVerticalAxisRenderer.cs,RenderMajorItems,The following switch statement is missing a default case: switch (axis.Position) {  case AxisPosition.Left:  	pt = new ScreenPoint (axisPosition + a1 - axis.AxisTickToLabelDistance' transformedValue);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Right' VerticalAlignment.Middle' out ha' out va);  	break;  case AxisPosition.Right:  	pt = new ScreenPoint (axisPosition + a1 + axis.AxisTickToLabelDistance' transformedValue);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Left' VerticalAlignment.Middle' out ha' out va);  	break;  case AxisPosition.Top:  	pt = new ScreenPoint (transformedValue' axisPosition + a1 - axis.AxisTickToLabelDistance);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Center' VerticalAlignment.Bottom' out ha' out va);  	break;  case AxisPosition.Bottom:  	pt = new ScreenPoint (transformedValue' axisPosition + a1 + axis.AxisTickToLabelDistance);  	this.GetRotatedAlignments (axis.Angle' HorizontalAlignment.Center' VerticalAlignment.Top' out ha' out va);  	break;  }  
Missing Default,OxyPlot,Conrec,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\Conrec.cs,Contour,The following switch statement is missing a default case: switch (caseValue) {  case 1:  	// Line between vertices 1 and 2  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xh [m2];  	y2 = yh [m2];  	break;  case 2:  	// Line between vertices 2 and 3  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xh [m3];  	y2 = yh [m3];  	break;  case 3:  	// Line between vertices 3 and 1  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xh [m1];  	y2 = yh [m1];  	break;  case 4:  	// Line between vertex 1 and side 2-3  	x1 = xh [m1];  	y1 = yh [m1];  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 5:  	// Line between vertex 2 and side 3-1  	x1 = xh [m2];  	y1 = yh [m2];  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 6:  	// Line between vertex 3 and side 1-2  	x1 = xh [m3];  	y1 = yh [m3];  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  case 7:  	// Line between sides 1-2 and 2-3  	x1 = xsect (m1' m2);  	y1 = ysect (m1' m2);  	x2 = xsect (m2' m3);  	y2 = ysect (m2' m3);  	break;  case 8:  	// Line between sides 2-3 and 3-1  	x1 = xsect (m2' m3);  	y1 = ysect (m2' m3);  	x2 = xsect (m3' m1);  	y2 = ysect (m3' m1);  	break;  case 9:  	// Line between sides 3-1 and 1-2  	x1 = xsect (m3' m1);  	y1 = ysect (m3' m1);  	x2 = xsect (m1' m2);  	y2 = ysect (m1' m2);  	break;  }  
Missing Default,OxyPlot,SvgWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Svg\SvgWriter.cs,CreateStyle,The following switch statement is missing a default case: switch (lineJoin) {  case OxyPenLineJoin.Round:  	style.AppendFormat (";stroke-linejoin:round");  	break;  case OxyPenLineJoin.Bevel:  	style.AppendFormat (";stroke-linejoin:bevel");  	break;  }  
Missing Default,OxyPlot,OxyColor,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Foundation\OxyColor.cs,FromHsv,The following switch statement is missing a default case: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Missing Default,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following switch statement is missing a default case: switch (this.TickStyle) {  case TickStyle.Outside:  	height += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	height += this.MajorTickSize * 0.75;  	break;  }  
Missing Default,OxyPlot.Axes,Axis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\Axis.cs,Measure,The following switch statement is missing a default case: switch (this.TickStyle) {  case TickStyle.Outside:  	width += this.MajorTickSize;  	break;  case TickStyle.Crossing:  	width += this.MajorTickSize * 0.75;  	break;  }  
Missing Default,OxyPlot.Axes,ColorAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\ColorAxis.cs,Render,The following switch statement is missing a default case: switch (this.Position) {  case AxisPosition.Left:  	left = model.PlotArea.Left - this.PositionTierMinShift - width;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Right:  	left = model.PlotArea.Right + this.PositionTierMinShift;  	top = model.PlotArea.Top;  	break;  case AxisPosition.Top:  	left = model.PlotArea.Left;  	top = model.PlotArea.Top - this.PositionTierMinShift - height;  	break;  case AxisPosition.Bottom:  	left = model.PlotArea.Left;  	top = model.PlotArea.Bottom + this.PositionTierMinShift;  	break;  }  
Missing Default,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,UpdateIntervals,The following switch statement is missing a default case: switch (this.actualIntervalType) {  case DateTimeIntervalType.Years:  	this.ActualMinorStep = 31;  	this.actualMinorIntervalType = DateTimeIntervalType.Years;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy";  	}  	break;  case DateTimeIntervalType.Months:  	this.actualMinorIntervalType = DateTimeIntervalType.Months;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Weeks:  	this.actualMinorIntervalType = DateTimeIntervalType.Days;  	this.ActualMajorStep = 7;  	this.ActualMinorStep = 1;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy/ww";  	}  	break;  case DateTimeIntervalType.Days:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "yyyy-MM-dd";  	}  	break;  case DateTimeIntervalType.Hours:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Minutes:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm";  	}  	break;  case DateTimeIntervalType.Seconds:  	this.ActualMinorStep = this.ActualMajorStep;  	if (this.ActualStringFormat == null) {  		this.ActualStringFormat = "HH:mm:ss";  	}  	break;  case DateTimeIntervalType.Manual:  	break;  case DateTimeIntervalType.Auto:  	break;  }  
Missing Default,OxyPlot.Axes,DateTimeAxis,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Axes\DateTimeAxis.cs,CreateDateTickValues,The following switch statement is missing a default case: switch (intervalType) {  case DateTimeIntervalType.Weeks:  	// make sure the first tick is at the 1st day of a week  	start = start.AddDays (-(int)start.DayOfWeek + (int)this.FirstDayOfWeek);  	break;  case DateTimeIntervalType.Months:  	// make sure the first tick is at the 1st of a month  	start = new DateTime (start.Year' start.Month' 1);  	break;  case DateTimeIntervalType.Years:  	// make sure the first tick is at Jan 1st  	start = new DateTime (start.Year' 1' 1);  	break;  }  
Missing Default,OxyPlot.Reporting,WikiReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\WikiReportWriter.cs,PadString,The following switch statement is missing a default case: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
Missing Default,OxyPlot.Reporting,HtmlReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\HtmlReportWriter.cs,WritePlot,The following switch statement is missing a default case: switch (this.PlotElementType) {  case HtmlPlotElementType.Embed:  case HtmlPlotElementType.Object:  	// TODO: need a Func<string'Stream> to provide streams for the plot files?  	//string source = string.Format(  	//    "{0}_Plot{1}.svg"' Path.GetFileNameWithoutExtension(this.outputFile)' plot.FigureNumber);  	//plot.PlotModel.SaveSvg(this.GetFullFileName(source)' plot.Width' plot.Height' this.textMeasurer);  	//this.WriteStartElement(this.PlotElementType == HtmlPlotElementType.Embed ? "embed" : "object");  	//this.WriteAttributeString("src"' source);  	//this.WriteAttributeString("type"' "image/svg+xml");  	//this.WriteEndElement();  	break;  case HtmlPlotElementType.Svg:  	this.WriteRaw (plot.PlotModel.ToSvg (plot.Width' plot.Height' false' this.textMeasurer));  	break;  }  
Missing Default,OxyPlot.Reporting,TextReportWriter,C:\repos\timkoers_OpenHardwareMonitor\External\OxyPlot\OxyPlot\Reporting\ReportWriters\TextReportWriter.cs,PadString,The following switch statement is missing a default case: switch (alignment) {  case Alignment.Left:  	return text.PadRight (width);  case Alignment.Right:  	return text.PadLeft (width);  case Alignment.Center:  	text = text.PadRight ((text.Length + width) / 2);  	return text.PadLeft (width);  }  
