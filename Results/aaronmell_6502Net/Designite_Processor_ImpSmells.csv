Implementation smell,Namespace,Class,File,Method,Description
Long Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ExecuteOpCode,The method has 1041 lines of code.
Long Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The method has 116 lines of code.
Long Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The method has 129 lines of code.
Long Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressingMode,The method has 194 lines of code.
Long Method,Processor,Utility,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Utility.cs,ConvertOpCodeIntoString,The method has 329 lines of code.
Complex Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ExecuteOpCode,Cyclomatic complexity of the method is 153
Complex Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,Cyclomatic complexity of the method is 16
Complex Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,Cyclomatic complexity of the method is 16
Complex Method,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressingMode,Cyclomatic complexity of the method is 13
Complex Method,Processor,Utility,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Utility.cs,ConvertOpCodeIntoString,Cyclomatic complexity of the method is 58
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,LoadProgram,The length of the statement  "                throw new InvalidOperationException(string.Format("Program Size '{0}' Cannot be Larger than Memory Size '{1}' plus offset '{2}'"' program.Length' Memory.Length' offset)); " is 170.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ExecuteOpCode,The length of the statement  "			//The x++ cycles denotes that 1 cycle is added when a branch occurs and it on the same page' and two cycles are added if its on a different page./ " is 146.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetNegativeFlag,The length of the statement  "			//on the 6502' any value greater than 127 is negative. 128 = 1000000 in Binary. the 8th bit is set' therefore the number is a negative number. " is 142.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The length of the statement  "					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode)); " is 121.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,MoveProgramCounterByRelativeValue,The length of the statement  "            //We Crossed a Page Boundary. So we increment the cycle counter by one. The +1 is because we always check from the end of the instruction not the beginning " is 155.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The length of the statement  "						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0')); " is 136.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The length of the statement  "						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0')); " is 138.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The length of the statement  "						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0')); " is 138.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The length of the statement  "						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0')); " is 138.
Long Statement,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The length of the statement  "			_logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"' " is 124.
Long Statement,Processor,Utility,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Utility.cs,ConvertOpCodeIntoString,The length of the statement  "					throw new InvalidEnumArgumentException(string.Format("A Valid Conversion does not exist for OpCode {0}"' i.ToString("X"))); " is 123.
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,Reset,The following statement contains a magic number: ProgramCounter = ( Memory[ProgramCounter] | ( Memory[ProgramCounter + 1] << 8));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ExecuteOpCode,The following statement contains a magic number: switch (CurrentOpCode)  			{  				#region Add / Subtract Operations  				//ADC Add With Carry' Immediate' 2 Bytes' 2 Cycles  				case 0x69:  					{  						AddWithCarryOperation(AddressingMode.Immediate);  						break;  					}                  //ADC Add With Carry' Zero Page' 2 Bytes' 3 Cycles  				case 0x65:  					{  						AddWithCarryOperation(AddressingMode.ZeroPage);  						break;  					}                  //ADC Add With Carry' Zero Page X' 2 Bytes' 4 Cycles  				case 0x75:  					{  						AddWithCarryOperation(AddressingMode.ZeroPageX);						  						break;  					}                  //ADC Add With Carry' Absolute' 3 Bytes' 4 Cycles  				case 0x6D:  					{  						AddWithCarryOperation(AddressingMode.Absolute);  						break;  					}                  //ADC Add With Carry' Absolute X' 3 Bytes' 4+ Cycles  				case 0x7D:  					{  						AddWithCarryOperation(AddressingMode.AbsoluteX);  						break;  					}                  //ADC Add With Carry' Absolute Y' 3 Bytes' 4+ Cycles  				case 0x79:  					{  						AddWithCarryOperation(AddressingMode.AbsoluteY);  						break;  					}                  //ADC Add With Carry' Indexed Indirect' 2 Bytes' 6 Cycles  				case 0x61:  					{  						AddWithCarryOperation(AddressingMode.IndirectX);  						break;  					}                  //ADC Add With Carry' Indexed Indirect' 2 Bytes' 5+ Cycles  				case 0x71:  					{  						AddWithCarryOperation(AddressingMode.IndirectY);  						break;  					}  				//SBC Subtract with Borrow' Immediate' 2 Bytes' 2 Cycles  				case 0xE9:  					{  						SubtractWithBorrowOperation(AddressingMode.Immediate);  						break;  					}  				//SBC Subtract with Borrow' Zero Page' 2 Bytes' 3 Cycles  				case 0xE5:  					{  						SubtractWithBorrowOperation(AddressingMode.ZeroPage);  						break;  					}  				//SBC Subtract with Borrow' Zero Page X' 2 Bytes' 4 Cycles  				case 0xF5:  					{  						SubtractWithBorrowOperation(AddressingMode.ZeroPageX);  						break;  					}  				//SBC Subtract with Borrow' Absolute' 3 Bytes' 4 Cycles  				case 0xED:  					{  						SubtractWithBorrowOperation(AddressingMode.Absolute);  						break;  					}  				//SBC Subtract with Borrow' Absolute X' 3 Bytes' 4+ Cycles  				case 0xFD:  					{  						SubtractWithBorrowOperation(AddressingMode.AbsoluteX);  						break;  					}  				//SBC Subtract with Borrow' Absolute Y' 3 Bytes' 4+ Cycles  				case 0xF9:  					{  						SubtractWithBorrowOperation(AddressingMode.AbsoluteY);  						break;  					}  				//SBC Subtract with Borrow' Indexed Indirect' 2 Bytes' 6 Cycles  				case 0xE1:  					{  						SubtractWithBorrowOperation(AddressingMode.IndirectX);  						break;  					}  				//SBC Subtract with Borrow' Indexed Indirect' 2 Bytes' 5+ Cycles  				case 0xF1:  					{  						SubtractWithBorrowOperation(AddressingMode.IndirectY);  						break;  					}  				#endregion  				  				#region Branch Operations  				//BCC Branch if Carry is Clear' Relative' 2 Bytes' 2++ Cycles  				case 0x90:  					{  						BranchOperation(!CarryFlag);  						break;    					}  				//BCS Branch if Carry is Set' Relative' 2 Bytes' 2++ Cycles  				case 0xB0:  					{  						BranchOperation(CarryFlag);  						break;  					}  				//BEQ Branch if Zero is Set' Relative' 2 Bytes' 2++ Cycles  				case 0xF0:  					{  						BranchOperation(ZeroFlag);  						break;  					}    				// BMI Branch if Negative Set  				case 0x30:  					{  						BranchOperation(NegativeFlag);  						break;  					}  				//BNE Branch if Zero is Not Set' Relative' 2 Bytes' 2++ Cycles  				case 0xD0:  					{  						BranchOperation(!ZeroFlag);  						break;  					}  				// BPL Branch if Negative Clear' 2 Bytes' 2++ Cycles  				case 0x10:  					{  						BranchOperation(!NegativeFlag);  						break;  					}  				// BVC Branch if Overflow Clear' 2 Bytes' 2++ Cycles  				case 0x50:  					{  						BranchOperation(!OverflowFlag);  						break;  					}  				// BVS Branch if Overflow Set' 2 Bytes' 2++ Cycles  				case 0x70:  					{  						BranchOperation(OverflowFlag);  						break;  					}  				#endregion    				#region BitWise Comparison Operations  				//AND Compare Memory with Accumulator' Immediate' 2 Bytes' 2 Cycles  				case 0x29:  					{  						AndOperation(AddressingMode.Immediate);  						break;  					}  				//AND Compare Memory with Accumulator' Zero Page' 2 Bytes' 3 Cycles  				case 0x25:  					{  						AndOperation(AddressingMode.ZeroPage);  						break;  					}  				//AND Compare Memory with Accumulator' Zero PageX' 2 Bytes' 3 Cycles  				case 0x35:  					{  						AndOperation(AddressingMode.ZeroPageX);  						break;  					}  				//AND Compare Memory with Accumulator' Absolute'  3 Bytes' 4 Cycles  				case 0x2D:  					{  						AndOperation(AddressingMode.Absolute);  						break;  					}  				//AND Compare Memory with Accumulator' AbsolueteX 3 Bytes' 4+ Cycles  				case 0x3D:  					{  						AndOperation(AddressingMode.AbsoluteX);  						break;  					}  				//AND Compare Memory with Accumulator' AbsoluteY' 3 Bytes' 4+ Cycles  				case 0x39:  					{  						AndOperation(AddressingMode.AbsoluteY);  						break;  					}  				//AND Compare Memory with Accumulator' IndexedIndirect' 2 Bytes' 6 Cycles  				case 0x21:  					{  						AndOperation(AddressingMode.IndirectX);  						break;  					}  				//AND Compare Memory with Accumulator' IndirectIndexed' 2 Bytes' 5 Cycles  				case 0x31:  					{  						AndOperation(AddressingMode.IndirectY);  						break;  					}  				//BIT Compare Memory with Accumulator' Zero Page' 2 Bytes' 3 Cycles  				case 0x24:  					{  						BitOperation(AddressingMode.ZeroPage);  						break;  					}  				//BIT Compare Memory with Accumulator' Absolute' 2 Bytes' 4 Cycles  				case 0x2C:  					{  						BitOperation(AddressingMode.Absolute);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Immediate' 2 Bytes' 2 Cycles  				case 0x49:  					{  						EorOperation(AddressingMode.Immediate);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Zero Page' 2 Bytes' 3 Cycles  				case 0x45:  					{  						EorOperation(AddressingMode.ZeroPage);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Zero Page X' 2 Bytes' 4 Cycles  				case 0x55:  					{  						EorOperation(AddressingMode.ZeroPageX);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Absolute' 3 Bytes' 4 Cycles  				case 0x4D:  					{  						EorOperation(AddressingMode.Absolute);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Absolute X' 3 Bytes' 4+ Cycles  				case 0x5D:  					{  						EorOperation(AddressingMode.AbsoluteX);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Absolute Y' 3 Bytes' 4+ Cycles  				case 0x59:  					{  						EorOperation(AddressingMode.AbsoluteY);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' IndexedIndirect' 2 Bytes 6 Cycles  				case 0x41:  					{  						EorOperation(AddressingMode.IndirectX);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' IndirectIndexed' 2 Bytes 5 Cycles  				case 0x51:  					{  						EorOperation(AddressingMode.IndirectY);  						break;  					}  				//ORA Compare Memory with Accumulator' Immediate' 2 Bytes' 2 Cycles  				case 0x09:  					{  						OrOperation(AddressingMode.Immediate);  						break;  					}  				//ORA Compare Memory with Accumulator' Zero Page' 2 Bytes' 2 Cycles  				case 0x05:  					{  						OrOperation(AddressingMode.ZeroPage);  						break;  					}  				//ORA Compare Memory with Accumulator' Zero PageX' 2 Bytes' 4 Cycles  				case 0x15:  					{  						OrOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ORA Compare Memory with Accumulator' Absolute'  3 Bytes' 4 Cycles  				case 0x0D:  					{  						OrOperation(AddressingMode.Absolute);  						break;  					}  				//ORA Compare Memory with Accumulator' AbsolueteX 3 Bytes' 4+ Cycles  				case 0x1D:  					{  						OrOperation(AddressingMode.AbsoluteX);  						break;  					}  				//ORA Compare Memory with Accumulator' AbsoluteY' 3 Bytes' 4+ Cycles  				case 0x19:  					{  						OrOperation(AddressingMode.AbsoluteY);  						break;  					}  				//ORA Compare Memory with Accumulator' IndexedIndirect' 2 Bytes' 6 Cycles  				case 0x01:  					{  						OrOperation(AddressingMode.IndirectX);  						break;  					}  				//ORA Compare Memory with Accumulator' IndirectIndexed' 2 Bytes' 5 Cycles  				case 0x11:  					{  						OrOperation(AddressingMode.IndirectY);  						break;  					}  				#endregion    				#region Clear Flag Operations  				//CLC Clear Carry Flag' Implied' 1 Byte' 2 Cycles  				case 0x18:  					{  						CarryFlag = false;  					    IncrementCycleCount();  						break;  					}  				//CLD Clear Decimal Flag' Implied' 1 Byte' 2 Cycles  				case 0xD8:  					{  						DecimalFlag = false;                          IncrementCycleCount();  						break;    					}  				//CLI Clear Interrupt Flag' Implied' 1 Byte' 2 Cycles  				case 0x58:  					{  						DisableInterruptFlag = false;                          IncrementCycleCount();  						break;    					}  				//CLV Clear Overflow Flag' Implied' 1 Byte' 2 Cycles  				case 0xB8:  					{  						OverflowFlag = false;                          IncrementCycleCount();  						break;  					}    				#endregion    				#region Compare Operations  				//CMP Compare Accumulator with Memory' Immediate' 2 Bytes' 2 Cycles  				case 0xC9:  					{  						CompareOperation(AddressingMode.Immediate' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xC5:  					{  						CompareOperation(AddressingMode.ZeroPage' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Zero Page x' 2 Bytes' 4 Cycles  				case 0xD5:  					{  						CompareOperation(AddressingMode.ZeroPageX' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Absolute' 3 Bytes' 4 Cycles  				case 0xCD:  					{  						CompareOperation(AddressingMode.Absolute' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Absolute X' 2 Bytes' 4 Cycles  				case 0xDD:  					{  						CompareOperation(AddressingMode.AbsoluteX' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Absolute Y' 2 Bytes' 4 Cycles  				case 0xD9:  					{  						CompareOperation(AddressingMode.AbsoluteY' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Indirect X' 2 Bytes' 6 Cycles  				case 0xC1:  					{  						CompareOperation(AddressingMode.IndirectX' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Indirect Y' 2 Bytes' 5 Cycles  				case 0xD1:  					{  						CompareOperation(AddressingMode.IndirectY' Accumulator);  						break;  					}  				//CPX Compare Accumulator with X Register' Immediate' 2 Bytes' 2 Cycles  				case 0xE0:  					{  						CompareOperation(AddressingMode.Immediate' XRegister);  						break;  					}  				//CPX Compare Accumulator with X Register' Zero Page' 2 Bytes' 3 Cycles  				case 0xE4:  					{  						CompareOperation(AddressingMode.ZeroPage' XRegister);  						break;  					}  				//CPX Compare Accumulator with X Register' Absolute' 3 Bytes' 4 Cycles  				case 0xEC:  					{  						CompareOperation(AddressingMode.Absolute' XRegister);  						break;  					}  				//CPY Compare Accumulator with Y Register' Immediate' 2 Bytes' 2 Cycles  				case 0xC0:  					{  						CompareOperation(AddressingMode.Immediate' YRegister);  						break;  					}  				//CPY Compare Accumulator with Y Register' Zero Page' 2 Bytes' 3 Cycles  				case 0xC4:  					{  						CompareOperation(AddressingMode.ZeroPage' YRegister);  						break;  					}  				//CPY Compare Accumulator with Y Register' Absolute' 3 Bytes' 4 Cycles  				case 0xCC:  					{  						CompareOperation(AddressingMode.Absolute' YRegister);  						break;  					}  				#endregion    				#region Increment/Decrement Operations  				//DEC Decrement Memory by One' Zero Page' 2 Bytes' 5 Cycles  				case 0xC6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPage' true);  						break;  					}  				//DEC Decrement Memory by One' Zero Page X' 2 Bytes' 6 Cycles  				case 0xD6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPageX' true);  						break;  					}  				//DEC Decrement Memory by One' Absolute' 3 Bytes' 6 Cycles  				case 0xCE:  					{  						ChangeMemoryByOne(AddressingMode.Absolute' true);  						break;  					}  				//DEC Decrement Memory by One' Absolute X' 3 Bytes' 7 Cycles  				case 0xDE:  					{  						ChangeMemoryByOne(AddressingMode.AbsoluteX' true);                          IncrementCycleCount();  						break;  					}  				//DEX Decrement X Register by One' Implied' 1 Bytes' 2 Cycles  				case 0xCA:  					{  						ChangeRegisterByOne(true' true);  						break;  					}  				//DEY Decrement Y Register by One' Implied' 1 Bytes' 2 Cycles  				case 0x88:  					{  						ChangeRegisterByOne(false' true);  						break;  					}  				//INC Increment Memory by One' Zero Page' 2 Bytes' 5 Cycles  				case 0xE6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPage' false);  						break;  					}  				//INC Increment Memory by One' Zero Page X' 2 Bytes' 6 Cycles  				case 0xF6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPageX' false);  						break;  					}  				//INC Increment Memory by One' Absolute' 3 Bytes' 6 Cycles  				case 0xEE:  					{  						ChangeMemoryByOne(AddressingMode.Absolute' false);  						break;  					}  				//INC Increment Memory by One' Absolute X' 3 Bytes' 7 Cycles  				case 0xFE:  					{  						ChangeMemoryByOne(AddressingMode.AbsoluteX' false);                          IncrementCycleCount();  						break;  					}  				//INX Increment X Register by One' Implied' 1 Bytes' 2 Cycles  				case 0xE8:  					{  						ChangeRegisterByOne(true' false);  						break;  					}  				//INY Increment Y Register by One' Implied' 1 Bytes' 2 Cycles  				case 0xC8:  					{  						ChangeRegisterByOne(false' false);  						break;  					}  				#endregion    				#region GOTO and GOSUB Operations  				//JMP Jump to New Location' Absolute 3 Bytes' 3 Cycles  				case 0x4C:  					{  						ProgramCounter = GetAddressByAddressingMode(AddressingMode.Absolute);  						break;  					}  				//JMP Jump to New Location' Indirect 3 Bytes' 5 Cycles  				case 0x6C:                      {                          ProgramCounter = GetAddressByAddressingMode(AddressingMode.Absolute);                            if ((ProgramCounter & 0xFF) == 0xFF)                          {                              //Get the first half of the address                              int address = ReadMemoryValue(ProgramCounter);                                //Get the second half of the address' due to the issue with page boundary it reads from the wrong location!                              address += 256 * ReadMemoryValue(ProgramCounter - 255);                              ProgramCounter = address;                          }                          else                          {                              ProgramCounter = GetAddressByAddressingMode(AddressingMode.Absolute);                          }                            break;                      }  				//JSR Jump to SubRoutine' Absolute' 3 Bytes' 6 Cycles  				case 0x20:  					{  						JumpToSubRoutineOperation();  						break;  					}  				//BRK Simulate IRQ' Implied' 1 Byte' 7 Cycles  				case 0x00:  					{  						BreakOperation(true' 0xFFFE);  						break;  					}  				//RTI Return From Interrupt' Implied' 1 Byte' 6 Cycles  				case 0x40:  					{  						ReturnFromInterruptOperation();  						break;  					}  				//RTS Return From Subroutine' Implied' 1 Byte' 6 Cycles  				case 0x60:  					{  						ReturnFromSubRoutineOperation();                          break;  					}  				#endregion    				#region Load Value From Memory Operations  				//LDA Load Accumulator with Memory' Immediate' 2 Bytes' 2 Cycles  				case 0xA9:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Immediate));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xA5:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Zero Page X' 2 Bytes' 4 Cycles  				case 0xB5:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Absolute' 3 Bytes' 4 Cycles  				case 0xAD:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Absolute X' 3 Bytes' 4+ Cycles  				case 0xBD:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteX));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Absolute Y' 3 Bytes' 4+ Cycles  				case 0xB9:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteY));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Index Indirect' 2 Bytes' 6 Cycles  				case 0xA1:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectX));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Indirect Index' 2 Bytes' 5+ Cycles  				case 0xB1:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectY));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDX Load X with memory' Immediate' 2 Bytes' 2 Cycles  				case 0xA2:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Immediate));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xA6:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Zero Page Y' 2 Bytes' 4 Cycles  				case 0xB6:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageY));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Absolute' 3 Bytes' 4 Cycles  				case 0xAE:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Absolute Y' 3 Bytes' 4+ Cycles  				case 0xBE:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteY));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDY Load Y with memory' Immediate' 2 Bytes' 2 Cycles  				case 0xA0:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Immediate));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xA4:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Zero Page X' 2 Bytes' 4 Cycles  				case 0xB4:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Absolute' 3 Bytes' 4 Cycles  				case 0xAC:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Absolue X' 3 Bytes' 4+ Cycles  				case 0xBC:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteX));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				#endregion    				#region Push/Pull Stack  				//PHA Push Accumulator onto Stack' Implied' 1 Byte' 3 Cycles  				case 0x48:  			        {                          ReadMemoryValue(ProgramCounter + 1);                            PokeStack((byte)Accumulator);  					    StackPointer--;  			            IncrementCycleCount();  						break;    					}  				//PHP Push Flags onto Stack' Implied' 1 Byte' 3 Cycles  				case 0x08:  			        {                          ReadMemoryValue(ProgramCounter + 1);                            PushFlagsOperation();  						StackPointer--;  						IncrementCycleCount();  						break;  					}  				//PLA Pull Accumulator from Stack' Implied' 1 Byte' 4 Cycles  				case 0x68:  			        {                          ReadMemoryValue(ProgramCounter + 1);  						StackPointer++;                          IncrementCycleCount();    						Accumulator = PeekStack();  						SetNegativeFlag(Accumulator);  						SetZeroFlag(Accumulator);                            IncrementCycleCount();  						break;  					}  				//PLP Pull Flags from Stack' Implied' 1 Byte' 4 Cycles  				case 0x28:  					{                          ReadMemoryValue(ProgramCounter + 1);    						StackPointer++;                          IncrementCycleCount();    						PullFlagsOperation();                                                    IncrementCycleCount();   						break;  					}  				//TSX Transfer Stack Pointer to X Register' 1 Bytes' 2 Cycles  				case 0xBA:  					{  						XRegister = StackPointer;    						SetNegativeFlag(XRegister);  						SetZeroFlag(XRegister);  					    IncrementCycleCount();  						break;  					}  				//TXS Transfer X Register to Stack Pointer' 1 Bytes' 2 Cycles  				case 0x9A:  					{  						StackPointer = (byte)XRegister;  					    IncrementCycleCount();  						break;  					}  				#endregion    				#region Set Flag Operations  				//SEC Set Carry' Implied' 1 Bytes' 2 Cycles  				case 0x38:  					{  						CarryFlag = true;                          IncrementCycleCount();  						break;  					}  				//SED Set Interrupt' Implied' 1 Bytes' 2 Cycles  				case 0xF8:  					{  						DecimalFlag = true;                          IncrementCycleCount();  						break;  					}  				//SEI Set Interrupt' Implied' 1 Bytes' 2 Cycles  				case 0x78:  					{  						DisableInterruptFlag = true;  					    IncrementCycleCount();                          break;  					}  				#endregion    				#region Shift/Rotate Operations  				//ASL Shift Left 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x0A:  					{  						AslOperation(AddressingMode.Accumulator);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x06:  					{  						AslOperation(AddressingMode.ZeroPage);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x16:  					{  						AslOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x0E:  					{  						AslOperation(AddressingMode.Absolute);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x1E:  					{  						AslOperation(AddressingMode.AbsoluteX);                          IncrementCycleCount();  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x4A:  					{  						LsrOperation(AddressingMode.Accumulator);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x46:  					{  						LsrOperation(AddressingMode.ZeroPage);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x56:  					{  						LsrOperation(AddressingMode.ZeroPageX);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x4E:  					{  						LsrOperation(AddressingMode.Absolute);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x5E:  					{  						LsrOperation(AddressingMode.AbsoluteX);                          IncrementCycleCount();  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x2A:  					{  						RolOperation(AddressingMode.Accumulator);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x26:  					{  						RolOperation(AddressingMode.ZeroPage);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x36:  					{  						RolOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x2E:  					{  						RolOperation(AddressingMode.Absolute);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x3E:  					{  						RolOperation(AddressingMode.AbsoluteX);                          IncrementCycleCount();  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x6A:  					{  						RorOperation(AddressingMode.Accumulator);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x66:  					{  						RorOperation(AddressingMode.ZeroPage);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x76:  					{  						RorOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x6E:  					{  						RorOperation(AddressingMode.Absolute);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x7E:  					{  						RorOperation(AddressingMode.AbsoluteX);  					    IncrementCycleCount();  						break;  					}  				#endregion    				#region Store Value In Memory Operations  				//STA Store Accumulator In Memory' Zero Page' 2 Bytes' 3 Cycles  				case 0x85:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Zero Page X' 2 Bytes' 4 Cycles  				case 0x95:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Absolute' 3 Bytes' 4 Cycles  				case 0x8D:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Absolute X' 3 Bytes' 5 Cycles  				case 0x9D:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteX)' (byte)Accumulator);  					    IncrementCycleCount();  						break;  					}  				//STA Store Accumulator In Memory' Absolute Y' 3 Bytes' 5 Cycles  				case 0x99:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteY)' (byte)Accumulator);  					    IncrementCycleCount();  						break;  					}  				//STA Store Accumulator In Memory' Indexed Indirect' 2 Bytes' 6 Cycles  				case 0x81:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectX)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Indirect Indexed' 2 Bytes' 6 Cycles  				case 0x91:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectY)' (byte)Accumulator);  					    IncrementCycleCount();  						break;  					}  				//STX Store Index X' Zero Page' 2 Bytes' 3 Cycles  				case 0x86:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage)' (byte)XRegister);  						break;  					}  				//STX Store Index X' Zero Page Y' 2 Bytes' 4 Cycles  				case 0x96:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageY)' (byte)XRegister);  						break;  					}  				//STX Store Index X' Absolute' 3 Bytes' 4 Cycles  				case 0x8E:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute)' (byte)XRegister);  						break;  					}  				//STY Store Index Y' Zero Page' 2 Bytes' 3 Cycles  				case 0x84:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage)' (byte)YRegister);  						break;  					}  				//STY Store Index Y' Zero Page X' 2 Bytes' 4 Cycles  				case 0x94:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX)' (byte)YRegister);  						break;  					}  				//STY Store Index Y' Absolute' 2 Bytes' 4 Cycles  				case 0x8C:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute)' (byte)YRegister);  						break;  					}  				#endregion    				#region Transfer Operations  				//TAX Transfer Accumulator to X Register' Implied' 1 Bytes' 2 Cycles  				case 0xAA:  					{                          IncrementCycleCount();  						XRegister = Accumulator;    						SetNegativeFlag(XRegister);  						SetZeroFlag(XRegister);  						break;  					}  				//TAY Transfer Accumulator to Y Register' 1 Bytes' 2 Cycles  				case 0xA8:  					{                          IncrementCycleCount();  						YRegister = Accumulator;    						SetNegativeFlag(YRegister);  						SetZeroFlag(YRegister);  						break;  					}  				//TXA Transfer X Register to Accumulator' Implied' 1 Bytes' 2 Cycles  				case 0x8A:  					{                          IncrementCycleCount();  						Accumulator = XRegister;    						SetNegativeFlag(Accumulator);  						SetZeroFlag(Accumulator);  						break;  					}  				//TYA Transfer Y Register to Accumulator' Implied' 1 Bytes' 2 Cycles  				case 0x98:  					{                          IncrementCycleCount();  						Accumulator = YRegister;    						SetNegativeFlag(Accumulator);  						SetZeroFlag(Accumulator);  						break;  					}  				#endregion  				  				//NOP Operation' Implied' 1 Byte' 2 Cycles  				case 0xEA:  			    {  			        IncrementCycleCount();  						break;  				}    				default:  					throw new NotSupportedException(string.Format("The OpCode {0} is not supported"' CurrentOpCode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ExecuteOpCode,The following statement contains a magic number: switch (CurrentOpCode)  			{  				#region Add / Subtract Operations  				//ADC Add With Carry' Immediate' 2 Bytes' 2 Cycles  				case 0x69:  					{  						AddWithCarryOperation(AddressingMode.Immediate);  						break;  					}                  //ADC Add With Carry' Zero Page' 2 Bytes' 3 Cycles  				case 0x65:  					{  						AddWithCarryOperation(AddressingMode.ZeroPage);  						break;  					}                  //ADC Add With Carry' Zero Page X' 2 Bytes' 4 Cycles  				case 0x75:  					{  						AddWithCarryOperation(AddressingMode.ZeroPageX);						  						break;  					}                  //ADC Add With Carry' Absolute' 3 Bytes' 4 Cycles  				case 0x6D:  					{  						AddWithCarryOperation(AddressingMode.Absolute);  						break;  					}                  //ADC Add With Carry' Absolute X' 3 Bytes' 4+ Cycles  				case 0x7D:  					{  						AddWithCarryOperation(AddressingMode.AbsoluteX);  						break;  					}                  //ADC Add With Carry' Absolute Y' 3 Bytes' 4+ Cycles  				case 0x79:  					{  						AddWithCarryOperation(AddressingMode.AbsoluteY);  						break;  					}                  //ADC Add With Carry' Indexed Indirect' 2 Bytes' 6 Cycles  				case 0x61:  					{  						AddWithCarryOperation(AddressingMode.IndirectX);  						break;  					}                  //ADC Add With Carry' Indexed Indirect' 2 Bytes' 5+ Cycles  				case 0x71:  					{  						AddWithCarryOperation(AddressingMode.IndirectY);  						break;  					}  				//SBC Subtract with Borrow' Immediate' 2 Bytes' 2 Cycles  				case 0xE9:  					{  						SubtractWithBorrowOperation(AddressingMode.Immediate);  						break;  					}  				//SBC Subtract with Borrow' Zero Page' 2 Bytes' 3 Cycles  				case 0xE5:  					{  						SubtractWithBorrowOperation(AddressingMode.ZeroPage);  						break;  					}  				//SBC Subtract with Borrow' Zero Page X' 2 Bytes' 4 Cycles  				case 0xF5:  					{  						SubtractWithBorrowOperation(AddressingMode.ZeroPageX);  						break;  					}  				//SBC Subtract with Borrow' Absolute' 3 Bytes' 4 Cycles  				case 0xED:  					{  						SubtractWithBorrowOperation(AddressingMode.Absolute);  						break;  					}  				//SBC Subtract with Borrow' Absolute X' 3 Bytes' 4+ Cycles  				case 0xFD:  					{  						SubtractWithBorrowOperation(AddressingMode.AbsoluteX);  						break;  					}  				//SBC Subtract with Borrow' Absolute Y' 3 Bytes' 4+ Cycles  				case 0xF9:  					{  						SubtractWithBorrowOperation(AddressingMode.AbsoluteY);  						break;  					}  				//SBC Subtract with Borrow' Indexed Indirect' 2 Bytes' 6 Cycles  				case 0xE1:  					{  						SubtractWithBorrowOperation(AddressingMode.IndirectX);  						break;  					}  				//SBC Subtract with Borrow' Indexed Indirect' 2 Bytes' 5+ Cycles  				case 0xF1:  					{  						SubtractWithBorrowOperation(AddressingMode.IndirectY);  						break;  					}  				#endregion  				  				#region Branch Operations  				//BCC Branch if Carry is Clear' Relative' 2 Bytes' 2++ Cycles  				case 0x90:  					{  						BranchOperation(!CarryFlag);  						break;    					}  				//BCS Branch if Carry is Set' Relative' 2 Bytes' 2++ Cycles  				case 0xB0:  					{  						BranchOperation(CarryFlag);  						break;  					}  				//BEQ Branch if Zero is Set' Relative' 2 Bytes' 2++ Cycles  				case 0xF0:  					{  						BranchOperation(ZeroFlag);  						break;  					}    				// BMI Branch if Negative Set  				case 0x30:  					{  						BranchOperation(NegativeFlag);  						break;  					}  				//BNE Branch if Zero is Not Set' Relative' 2 Bytes' 2++ Cycles  				case 0xD0:  					{  						BranchOperation(!ZeroFlag);  						break;  					}  				// BPL Branch if Negative Clear' 2 Bytes' 2++ Cycles  				case 0x10:  					{  						BranchOperation(!NegativeFlag);  						break;  					}  				// BVC Branch if Overflow Clear' 2 Bytes' 2++ Cycles  				case 0x50:  					{  						BranchOperation(!OverflowFlag);  						break;  					}  				// BVS Branch if Overflow Set' 2 Bytes' 2++ Cycles  				case 0x70:  					{  						BranchOperation(OverflowFlag);  						break;  					}  				#endregion    				#region BitWise Comparison Operations  				//AND Compare Memory with Accumulator' Immediate' 2 Bytes' 2 Cycles  				case 0x29:  					{  						AndOperation(AddressingMode.Immediate);  						break;  					}  				//AND Compare Memory with Accumulator' Zero Page' 2 Bytes' 3 Cycles  				case 0x25:  					{  						AndOperation(AddressingMode.ZeroPage);  						break;  					}  				//AND Compare Memory with Accumulator' Zero PageX' 2 Bytes' 3 Cycles  				case 0x35:  					{  						AndOperation(AddressingMode.ZeroPageX);  						break;  					}  				//AND Compare Memory with Accumulator' Absolute'  3 Bytes' 4 Cycles  				case 0x2D:  					{  						AndOperation(AddressingMode.Absolute);  						break;  					}  				//AND Compare Memory with Accumulator' AbsolueteX 3 Bytes' 4+ Cycles  				case 0x3D:  					{  						AndOperation(AddressingMode.AbsoluteX);  						break;  					}  				//AND Compare Memory with Accumulator' AbsoluteY' 3 Bytes' 4+ Cycles  				case 0x39:  					{  						AndOperation(AddressingMode.AbsoluteY);  						break;  					}  				//AND Compare Memory with Accumulator' IndexedIndirect' 2 Bytes' 6 Cycles  				case 0x21:  					{  						AndOperation(AddressingMode.IndirectX);  						break;  					}  				//AND Compare Memory with Accumulator' IndirectIndexed' 2 Bytes' 5 Cycles  				case 0x31:  					{  						AndOperation(AddressingMode.IndirectY);  						break;  					}  				//BIT Compare Memory with Accumulator' Zero Page' 2 Bytes' 3 Cycles  				case 0x24:  					{  						BitOperation(AddressingMode.ZeroPage);  						break;  					}  				//BIT Compare Memory with Accumulator' Absolute' 2 Bytes' 4 Cycles  				case 0x2C:  					{  						BitOperation(AddressingMode.Absolute);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Immediate' 2 Bytes' 2 Cycles  				case 0x49:  					{  						EorOperation(AddressingMode.Immediate);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Zero Page' 2 Bytes' 3 Cycles  				case 0x45:  					{  						EorOperation(AddressingMode.ZeroPage);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Zero Page X' 2 Bytes' 4 Cycles  				case 0x55:  					{  						EorOperation(AddressingMode.ZeroPageX);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Absolute' 3 Bytes' 4 Cycles  				case 0x4D:  					{  						EorOperation(AddressingMode.Absolute);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Absolute X' 3 Bytes' 4+ Cycles  				case 0x5D:  					{  						EorOperation(AddressingMode.AbsoluteX);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' Absolute Y' 3 Bytes' 4+ Cycles  				case 0x59:  					{  						EorOperation(AddressingMode.AbsoluteY);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' IndexedIndirect' 2 Bytes 6 Cycles  				case 0x41:  					{  						EorOperation(AddressingMode.IndirectX);  						break;  					}  				//EOR Exclusive OR Memory with Accumulator' IndirectIndexed' 2 Bytes 5 Cycles  				case 0x51:  					{  						EorOperation(AddressingMode.IndirectY);  						break;  					}  				//ORA Compare Memory with Accumulator' Immediate' 2 Bytes' 2 Cycles  				case 0x09:  					{  						OrOperation(AddressingMode.Immediate);  						break;  					}  				//ORA Compare Memory with Accumulator' Zero Page' 2 Bytes' 2 Cycles  				case 0x05:  					{  						OrOperation(AddressingMode.ZeroPage);  						break;  					}  				//ORA Compare Memory with Accumulator' Zero PageX' 2 Bytes' 4 Cycles  				case 0x15:  					{  						OrOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ORA Compare Memory with Accumulator' Absolute'  3 Bytes' 4 Cycles  				case 0x0D:  					{  						OrOperation(AddressingMode.Absolute);  						break;  					}  				//ORA Compare Memory with Accumulator' AbsolueteX 3 Bytes' 4+ Cycles  				case 0x1D:  					{  						OrOperation(AddressingMode.AbsoluteX);  						break;  					}  				//ORA Compare Memory with Accumulator' AbsoluteY' 3 Bytes' 4+ Cycles  				case 0x19:  					{  						OrOperation(AddressingMode.AbsoluteY);  						break;  					}  				//ORA Compare Memory with Accumulator' IndexedIndirect' 2 Bytes' 6 Cycles  				case 0x01:  					{  						OrOperation(AddressingMode.IndirectX);  						break;  					}  				//ORA Compare Memory with Accumulator' IndirectIndexed' 2 Bytes' 5 Cycles  				case 0x11:  					{  						OrOperation(AddressingMode.IndirectY);  						break;  					}  				#endregion    				#region Clear Flag Operations  				//CLC Clear Carry Flag' Implied' 1 Byte' 2 Cycles  				case 0x18:  					{  						CarryFlag = false;  					    IncrementCycleCount();  						break;  					}  				//CLD Clear Decimal Flag' Implied' 1 Byte' 2 Cycles  				case 0xD8:  					{  						DecimalFlag = false;                          IncrementCycleCount();  						break;    					}  				//CLI Clear Interrupt Flag' Implied' 1 Byte' 2 Cycles  				case 0x58:  					{  						DisableInterruptFlag = false;                          IncrementCycleCount();  						break;    					}  				//CLV Clear Overflow Flag' Implied' 1 Byte' 2 Cycles  				case 0xB8:  					{  						OverflowFlag = false;                          IncrementCycleCount();  						break;  					}    				#endregion    				#region Compare Operations  				//CMP Compare Accumulator with Memory' Immediate' 2 Bytes' 2 Cycles  				case 0xC9:  					{  						CompareOperation(AddressingMode.Immediate' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xC5:  					{  						CompareOperation(AddressingMode.ZeroPage' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Zero Page x' 2 Bytes' 4 Cycles  				case 0xD5:  					{  						CompareOperation(AddressingMode.ZeroPageX' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Absolute' 3 Bytes' 4 Cycles  				case 0xCD:  					{  						CompareOperation(AddressingMode.Absolute' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Absolute X' 2 Bytes' 4 Cycles  				case 0xDD:  					{  						CompareOperation(AddressingMode.AbsoluteX' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Absolute Y' 2 Bytes' 4 Cycles  				case 0xD9:  					{  						CompareOperation(AddressingMode.AbsoluteY' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Indirect X' 2 Bytes' 6 Cycles  				case 0xC1:  					{  						CompareOperation(AddressingMode.IndirectX' Accumulator);  						break;  					}  				//CMP Compare Accumulator with Memory' Indirect Y' 2 Bytes' 5 Cycles  				case 0xD1:  					{  						CompareOperation(AddressingMode.IndirectY' Accumulator);  						break;  					}  				//CPX Compare Accumulator with X Register' Immediate' 2 Bytes' 2 Cycles  				case 0xE0:  					{  						CompareOperation(AddressingMode.Immediate' XRegister);  						break;  					}  				//CPX Compare Accumulator with X Register' Zero Page' 2 Bytes' 3 Cycles  				case 0xE4:  					{  						CompareOperation(AddressingMode.ZeroPage' XRegister);  						break;  					}  				//CPX Compare Accumulator with X Register' Absolute' 3 Bytes' 4 Cycles  				case 0xEC:  					{  						CompareOperation(AddressingMode.Absolute' XRegister);  						break;  					}  				//CPY Compare Accumulator with Y Register' Immediate' 2 Bytes' 2 Cycles  				case 0xC0:  					{  						CompareOperation(AddressingMode.Immediate' YRegister);  						break;  					}  				//CPY Compare Accumulator with Y Register' Zero Page' 2 Bytes' 3 Cycles  				case 0xC4:  					{  						CompareOperation(AddressingMode.ZeroPage' YRegister);  						break;  					}  				//CPY Compare Accumulator with Y Register' Absolute' 3 Bytes' 4 Cycles  				case 0xCC:  					{  						CompareOperation(AddressingMode.Absolute' YRegister);  						break;  					}  				#endregion    				#region Increment/Decrement Operations  				//DEC Decrement Memory by One' Zero Page' 2 Bytes' 5 Cycles  				case 0xC6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPage' true);  						break;  					}  				//DEC Decrement Memory by One' Zero Page X' 2 Bytes' 6 Cycles  				case 0xD6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPageX' true);  						break;  					}  				//DEC Decrement Memory by One' Absolute' 3 Bytes' 6 Cycles  				case 0xCE:  					{  						ChangeMemoryByOne(AddressingMode.Absolute' true);  						break;  					}  				//DEC Decrement Memory by One' Absolute X' 3 Bytes' 7 Cycles  				case 0xDE:  					{  						ChangeMemoryByOne(AddressingMode.AbsoluteX' true);                          IncrementCycleCount();  						break;  					}  				//DEX Decrement X Register by One' Implied' 1 Bytes' 2 Cycles  				case 0xCA:  					{  						ChangeRegisterByOne(true' true);  						break;  					}  				//DEY Decrement Y Register by One' Implied' 1 Bytes' 2 Cycles  				case 0x88:  					{  						ChangeRegisterByOne(false' true);  						break;  					}  				//INC Increment Memory by One' Zero Page' 2 Bytes' 5 Cycles  				case 0xE6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPage' false);  						break;  					}  				//INC Increment Memory by One' Zero Page X' 2 Bytes' 6 Cycles  				case 0xF6:  					{  						ChangeMemoryByOne(AddressingMode.ZeroPageX' false);  						break;  					}  				//INC Increment Memory by One' Absolute' 3 Bytes' 6 Cycles  				case 0xEE:  					{  						ChangeMemoryByOne(AddressingMode.Absolute' false);  						break;  					}  				//INC Increment Memory by One' Absolute X' 3 Bytes' 7 Cycles  				case 0xFE:  					{  						ChangeMemoryByOne(AddressingMode.AbsoluteX' false);                          IncrementCycleCount();  						break;  					}  				//INX Increment X Register by One' Implied' 1 Bytes' 2 Cycles  				case 0xE8:  					{  						ChangeRegisterByOne(true' false);  						break;  					}  				//INY Increment Y Register by One' Implied' 1 Bytes' 2 Cycles  				case 0xC8:  					{  						ChangeRegisterByOne(false' false);  						break;  					}  				#endregion    				#region GOTO and GOSUB Operations  				//JMP Jump to New Location' Absolute 3 Bytes' 3 Cycles  				case 0x4C:  					{  						ProgramCounter = GetAddressByAddressingMode(AddressingMode.Absolute);  						break;  					}  				//JMP Jump to New Location' Indirect 3 Bytes' 5 Cycles  				case 0x6C:                      {                          ProgramCounter = GetAddressByAddressingMode(AddressingMode.Absolute);                            if ((ProgramCounter & 0xFF) == 0xFF)                          {                              //Get the first half of the address                              int address = ReadMemoryValue(ProgramCounter);                                //Get the second half of the address' due to the issue with page boundary it reads from the wrong location!                              address += 256 * ReadMemoryValue(ProgramCounter - 255);                              ProgramCounter = address;                          }                          else                          {                              ProgramCounter = GetAddressByAddressingMode(AddressingMode.Absolute);                          }                            break;                      }  				//JSR Jump to SubRoutine' Absolute' 3 Bytes' 6 Cycles  				case 0x20:  					{  						JumpToSubRoutineOperation();  						break;  					}  				//BRK Simulate IRQ' Implied' 1 Byte' 7 Cycles  				case 0x00:  					{  						BreakOperation(true' 0xFFFE);  						break;  					}  				//RTI Return From Interrupt' Implied' 1 Byte' 6 Cycles  				case 0x40:  					{  						ReturnFromInterruptOperation();  						break;  					}  				//RTS Return From Subroutine' Implied' 1 Byte' 6 Cycles  				case 0x60:  					{  						ReturnFromSubRoutineOperation();                          break;  					}  				#endregion    				#region Load Value From Memory Operations  				//LDA Load Accumulator with Memory' Immediate' 2 Bytes' 2 Cycles  				case 0xA9:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Immediate));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xA5:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Zero Page X' 2 Bytes' 4 Cycles  				case 0xB5:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Absolute' 3 Bytes' 4 Cycles  				case 0xAD:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Absolute X' 3 Bytes' 4+ Cycles  				case 0xBD:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteX));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Absolute Y' 3 Bytes' 4+ Cycles  				case 0xB9:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteY));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Index Indirect' 2 Bytes' 6 Cycles  				case 0xA1:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectX));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDA Load Accumulator with Memory' Indirect Index' 2 Bytes' 5+ Cycles  				case 0xB1:  					{  						Accumulator =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectY));  						SetZeroFlag(Accumulator);  						SetNegativeFlag(Accumulator);  						break;  					}  				//LDX Load X with memory' Immediate' 2 Bytes' 2 Cycles  				case 0xA2:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Immediate));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xA6:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Zero Page Y' 2 Bytes' 4 Cycles  				case 0xB6:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageY));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Absolute' 3 Bytes' 4 Cycles  				case 0xAE:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDX Load X with memory' Absolute Y' 3 Bytes' 4+ Cycles  				case 0xBE:  					{  						XRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteY));  						SetZeroFlag(XRegister);  						SetNegativeFlag(XRegister);  						break;  					}  				//LDY Load Y with memory' Immediate' 2 Bytes' 2 Cycles  				case 0xA0:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Immediate));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Zero Page' 2 Bytes' 3 Cycles  				case 0xA4:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Zero Page X' 2 Bytes' 4 Cycles  				case 0xB4:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Absolute' 3 Bytes' 4 Cycles  				case 0xAC:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				//LDY Load Y with memory' Absolue X' 3 Bytes' 4+ Cycles  				case 0xBC:  					{  						YRegister =ReadMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteX));  						SetZeroFlag(YRegister);  						SetNegativeFlag(YRegister);  						break;  					}  				#endregion    				#region Push/Pull Stack  				//PHA Push Accumulator onto Stack' Implied' 1 Byte' 3 Cycles  				case 0x48:  			        {                          ReadMemoryValue(ProgramCounter + 1);                            PokeStack((byte)Accumulator);  					    StackPointer--;  			            IncrementCycleCount();  						break;    					}  				//PHP Push Flags onto Stack' Implied' 1 Byte' 3 Cycles  				case 0x08:  			        {                          ReadMemoryValue(ProgramCounter + 1);                            PushFlagsOperation();  						StackPointer--;  						IncrementCycleCount();  						break;  					}  				//PLA Pull Accumulator from Stack' Implied' 1 Byte' 4 Cycles  				case 0x68:  			        {                          ReadMemoryValue(ProgramCounter + 1);  						StackPointer++;                          IncrementCycleCount();    						Accumulator = PeekStack();  						SetNegativeFlag(Accumulator);  						SetZeroFlag(Accumulator);                            IncrementCycleCount();  						break;  					}  				//PLP Pull Flags from Stack' Implied' 1 Byte' 4 Cycles  				case 0x28:  					{                          ReadMemoryValue(ProgramCounter + 1);    						StackPointer++;                          IncrementCycleCount();    						PullFlagsOperation();                                                    IncrementCycleCount();   						break;  					}  				//TSX Transfer Stack Pointer to X Register' 1 Bytes' 2 Cycles  				case 0xBA:  					{  						XRegister = StackPointer;    						SetNegativeFlag(XRegister);  						SetZeroFlag(XRegister);  					    IncrementCycleCount();  						break;  					}  				//TXS Transfer X Register to Stack Pointer' 1 Bytes' 2 Cycles  				case 0x9A:  					{  						StackPointer = (byte)XRegister;  					    IncrementCycleCount();  						break;  					}  				#endregion    				#region Set Flag Operations  				//SEC Set Carry' Implied' 1 Bytes' 2 Cycles  				case 0x38:  					{  						CarryFlag = true;                          IncrementCycleCount();  						break;  					}  				//SED Set Interrupt' Implied' 1 Bytes' 2 Cycles  				case 0xF8:  					{  						DecimalFlag = true;                          IncrementCycleCount();  						break;  					}  				//SEI Set Interrupt' Implied' 1 Bytes' 2 Cycles  				case 0x78:  					{  						DisableInterruptFlag = true;  					    IncrementCycleCount();                          break;  					}  				#endregion    				#region Shift/Rotate Operations  				//ASL Shift Left 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x0A:  					{  						AslOperation(AddressingMode.Accumulator);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x06:  					{  						AslOperation(AddressingMode.ZeroPage);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x16:  					{  						AslOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x0E:  					{  						AslOperation(AddressingMode.Absolute);  						break;  					}  				//ASL Shift Left 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x1E:  					{  						AslOperation(AddressingMode.AbsoluteX);                          IncrementCycleCount();  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x4A:  					{  						LsrOperation(AddressingMode.Accumulator);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x46:  					{  						LsrOperation(AddressingMode.ZeroPage);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x56:  					{  						LsrOperation(AddressingMode.ZeroPageX);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x4E:  					{  						LsrOperation(AddressingMode.Absolute);  						break;  					}  				//LSR Shift Left 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x5E:  					{  						LsrOperation(AddressingMode.AbsoluteX);                          IncrementCycleCount();  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x2A:  					{  						RolOperation(AddressingMode.Accumulator);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x26:  					{  						RolOperation(AddressingMode.ZeroPage);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x36:  					{  						RolOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x2E:  					{  						RolOperation(AddressingMode.Absolute);  						break;  					}  				//ROL Rotate Left 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x3E:  					{  						RolOperation(AddressingMode.AbsoluteX);                          IncrementCycleCount();  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Accumulator' 1 Bytes' 2 Cycles  				case 0x6A:  					{  						RorOperation(AddressingMode.Accumulator);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Zero Page' 2 Bytes' 5 Cycles  				case 0x66:  					{  						RorOperation(AddressingMode.ZeroPage);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Zero PageX' 2 Bytes' 6 Cycles  				case 0x76:  					{  						RorOperation(AddressingMode.ZeroPageX);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' Absolute' 3 Bytes' 6 Cycles  				case 0x6E:  					{  						RorOperation(AddressingMode.Absolute);  						break;  					}  				//ROR Rotate Right 1 Bit Memory or Accumulator' AbsoluteX' 3 Bytes' 7 Cycles  				case 0x7E:  					{  						RorOperation(AddressingMode.AbsoluteX);  					    IncrementCycleCount();  						break;  					}  				#endregion    				#region Store Value In Memory Operations  				//STA Store Accumulator In Memory' Zero Page' 2 Bytes' 3 Cycles  				case 0x85:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Zero Page X' 2 Bytes' 4 Cycles  				case 0x95:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Absolute' 3 Bytes' 4 Cycles  				case 0x8D:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Absolute X' 3 Bytes' 5 Cycles  				case 0x9D:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteX)' (byte)Accumulator);  					    IncrementCycleCount();  						break;  					}  				//STA Store Accumulator In Memory' Absolute Y' 3 Bytes' 5 Cycles  				case 0x99:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.AbsoluteY)' (byte)Accumulator);  					    IncrementCycleCount();  						break;  					}  				//STA Store Accumulator In Memory' Indexed Indirect' 2 Bytes' 6 Cycles  				case 0x81:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectX)' (byte)Accumulator);  						break;  					}  				//STA Store Accumulator In Memory' Indirect Indexed' 2 Bytes' 6 Cycles  				case 0x91:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.IndirectY)' (byte)Accumulator);  					    IncrementCycleCount();  						break;  					}  				//STX Store Index X' Zero Page' 2 Bytes' 3 Cycles  				case 0x86:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage)' (byte)XRegister);  						break;  					}  				//STX Store Index X' Zero Page Y' 2 Bytes' 4 Cycles  				case 0x96:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageY)' (byte)XRegister);  						break;  					}  				//STX Store Index X' Absolute' 3 Bytes' 4 Cycles  				case 0x8E:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute)' (byte)XRegister);  						break;  					}  				//STY Store Index Y' Zero Page' 2 Bytes' 3 Cycles  				case 0x84:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPage)' (byte)YRegister);  						break;  					}  				//STY Store Index Y' Zero Page X' 2 Bytes' 4 Cycles  				case 0x94:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.ZeroPageX)' (byte)YRegister);  						break;  					}  				//STY Store Index Y' Absolute' 2 Bytes' 4 Cycles  				case 0x8C:  					{  						WriteMemoryValue(GetAddressByAddressingMode(AddressingMode.Absolute)' (byte)YRegister);  						break;  					}  				#endregion    				#region Transfer Operations  				//TAX Transfer Accumulator to X Register' Implied' 1 Bytes' 2 Cycles  				case 0xAA:  					{                          IncrementCycleCount();  						XRegister = Accumulator;    						SetNegativeFlag(XRegister);  						SetZeroFlag(XRegister);  						break;  					}  				//TAY Transfer Accumulator to Y Register' 1 Bytes' 2 Cycles  				case 0xA8:  					{                          IncrementCycleCount();  						YRegister = Accumulator;    						SetNegativeFlag(YRegister);  						SetZeroFlag(YRegister);  						break;  					}  				//TXA Transfer X Register to Accumulator' Implied' 1 Bytes' 2 Cycles  				case 0x8A:  					{                          IncrementCycleCount();  						Accumulator = XRegister;    						SetNegativeFlag(Accumulator);  						SetZeroFlag(Accumulator);  						break;  					}  				//TYA Transfer Y Register to Accumulator' Implied' 1 Bytes' 2 Cycles  				case 0x98:  					{                          IncrementCycleCount();  						Accumulator = YRegister;    						SetNegativeFlag(Accumulator);  						SetZeroFlag(Accumulator);  						break;  					}  				#endregion  				  				//NOP Operation' Implied' 1 Byte' 2 Cycles  				case 0xEA:  			    {  			        IncrementCycleCount();  						break;  				}    				default:  					throw new NotSupportedException(string.Format("The OpCode {0} is not supported"' CurrentOpCode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetNegativeFlag,The following statement contains a magic number: NegativeFlag = value > 127;
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,GetAddressByAddressingMode,The following statement contains a magic number: switch (addressingMode)  			{  				case (AddressingMode.Absolute):  			    {  			        return (ReadMemoryValue(ProgramCounter++) | (ReadMemoryValue(ProgramCounter++) << 8));  				}  				case AddressingMode.AbsoluteX:  					{  						//Get the low half of the address  						address =ReadMemoryValue(ProgramCounter++);                            //Get the high byte  						highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so an extra read has occurred.                          //However' if this is an ASL' LSR' DEC' INC' ROR' ROL or STA operation' we do not decrease it by 1.  					    if (address + XRegister > 0xFF)  					    {                              switch (CurrentOpCode)                              {                                  case 0x1E:                                  case 0xDE:                                  case 0xFE:                                  case 0x5E:                                  case 0x3E:                                  case 0x7E:                                  case 0x9D:                                  {                                      //This is a Read Fetch Write Operation' so we don't make the extra read.                                      return ((highByte << 8 | address) + XRegister) & 0xFFFF;                                  }                                  default:                                  {                                      ReadMemoryValue((((highByte << 8 | address) + XRegister) - 0xFF) & 0xFFFF);                                      break;                                  }                              }  					    }    					    return ((highByte << 8 | address) + XRegister) & 0xFFFF;  					}  				case AddressingMode.AbsoluteY:  					{                          //Get the low half of the address                          address = ReadMemoryValue(ProgramCounter++);                            //Get the high byte                          highByte = ReadMemoryValue(ProgramCounter++);                            //We crossed a page boundry' so decrease the number of cycles by 1 if the operation is not STA  					    if (address + YRegister > 0xFF && CurrentOpCode != 0x99)  					    {                              ReadMemoryValue((((highByte << 8 | address) + YRegister) - 0xFF) & 0xFFFF);  					    }                            //Bitshift the high byte into place' AND with FFFF to handle wrapping.                          return ((highByte << 8 | address) + YRegister) & 0xFFFF;  					}  				case AddressingMode.Immediate:  					{  						return ProgramCounter++;  					}  				case AddressingMode.IndirectX:  					{  						//Get the location of the address to retrieve  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    					    address += XRegister;  						  						//Now get the final Address. The is not a zero page address either.  						var finalAddress = ReadMemoryValue((address & 0xFF)) | (ReadMemoryValue((address + 1) & 0xFF) << 8);  						return finalAddress;  					}  				case AddressingMode.IndirectY:  					{  						address = ReadMemoryValue(ProgramCounter++);    					    var finalAddress = ReadMemoryValue(address) + (ReadMemoryValue((address + 1) & 0xFF) << 8);                            if ((finalAddress & 0xFF) + YRegister > 0xFF && CurrentOpCode != 0x91)                          {                              ReadMemoryValue((finalAddress + YRegister - 0xFF) & 0xFFFF);                          }  						  						return (finalAddress + YRegister) & 0xFFFF;  					}  				case AddressingMode.Relative:  					{  						return ProgramCounter;  					}  				case (AddressingMode.ZeroPage):  					{  						address =ReadMemoryValue(ProgramCounter++);  						return address;  					}  				case (AddressingMode.ZeroPageX):  					{  						address = ReadMemoryValue(ProgramCounter++);  					    ReadMemoryValue(address);    						address += XRegister;  					    address &= 0xFF;    						//This address wraps if its greater than 0xFF  						if (address > 0xFF)  						{  							address -= 0x100;  							return address;  						}    						return address;  					}  				case (AddressingMode.ZeroPageY):  					{  						address =ReadMemoryValue(ProgramCounter++);                          ReadMemoryValue(address);                            address += YRegister;                          address &= 0xFF;    						return address;  					}  				default:  					throw new InvalidOperationException(string.Format("The Address Mode '{0}' does not require an address"' addressingMode));  			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,MoveProgramCounterByRelativeValue,The following statement contains a magic number: var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,MoveProgramCounterByRelativeValue,The following statement contains a magic number: var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ConvertFlagsToByte,The following statement contains a magic number: return (byte)((CarryFlag ? 0x01 : 0) + (ZeroFlag ? 0x02 : 0) + (DisableInterruptFlag ? 0x04 : 0) +  						 (DecimalFlag ? 8 : 0) + (setBreak ? 0x10 : 0) + 0x20 + (OverflowFlag ? 0x40 : 0) + (NegativeFlag ? 0x80 : 0));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: switch (addressMode)  			{  				case AddressingMode.Absolute:  					{  						disassembledStep = string.Format("${0}{1}"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteX:  					{  						disassembledStep = string.Format("${0}{1}'X"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.AbsoluteY:  					{  						disassembledStep = string.Format("${0}{1}'Y"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Accumulator:  					{  						address1 = null;  						address2 = null;    						disassembledStep = "A";  						break;  					}  				case AddressingMode.Immediate:  					{  						disassembledStep = string.Format("#${0}"' address1.Value.ToString("X").PadLeft(4' '0'));  						address2 = null;  						break;  					}  				case AddressingMode.Implied:  					{  						address1 = null;  						address2 = null;  						break;  					}  				case AddressingMode.Indirect:  					{  						disassembledStep = string.Format("(${0}{1})"' address2.Value.ToString("X").PadLeft(2' '0')' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectX:  					{  						address2 = null;    						disassembledStep = string.Format("(${0}'X)"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.IndirectY:  					{  						address2 = null;    						disassembledStep = string.Format("(${0})'Y"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.Relative:  			    {                      var valueToMove = (byte)address1.Value;                        var movement = valueToMove > 127 ? (valueToMove - 255) : valueToMove;                        var newProgramCounter = ProgramCounter + movement;                        //This makes sure that we always land on the correct spot for a positive number                      if (movement >= 0)                          newProgramCounter++;                        var stringAddress = ProgramCounter.ToString("X").PadLeft(4' '0');                        address1 = int.Parse(stringAddress.Substring(0' 2)' NumberStyles.AllowHexSpecifier);                      address2 = int.Parse(stringAddress.Substring(2' 2)' NumberStyles.AllowHexSpecifier);                        disassembledStep = string.Format("${0}"' newProgramCounter.ToString("X").PadLeft(4' '0'));                        break;  				}  				case AddressingMode.ZeroPage:  					{  						address2 = null;    						disassembledStep = string.Format("${0}"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageX:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'X"' address1.Value.ToString("X").PadLeft(2' '0'));  						break;  					}  				case AddressingMode.ZeroPageY:  					{  						address2 = null;    						disassembledStep = string.Format("${0}'Y"' address1.Value.ToString("X").PadLeft(4' '0'));  						break;  					}  				default:  					throw new InvalidEnumArgumentException("Invalid Addressing Mode");    			}
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: CurrentDisassembly = new Disassembly  				                     {  					                     HighAddress = address2.HasValue ? address2.Value.ToString("X").PadLeft(2''0') : string.Empty'  					                     LowAddress = address1.HasValue ? address1.Value.ToString("X").PadLeft(2''0') : string.Empty'  					                     OpCodeString = CurrentOpCode.ConvertOpCodeIntoString()'  					                     DisassemblyOutput = disassembledStep  				                     };
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: CurrentDisassembly = new Disassembly  				                     {  					                     HighAddress = address2.HasValue ? address2.Value.ToString("X").PadLeft(2''0') : string.Empty'  					                     LowAddress = address1.HasValue ? address1.Value.ToString("X").PadLeft(2''0') : string.Empty'  					                     OpCodeString = CurrentOpCode.ConvertOpCodeIntoString()'  					                     DisassemblyOutput = disassembledStep  				                     };
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SetDisassembly,The following statement contains a magic number: _logger.Debug("{0} : {1}{2}{3} {4} {5} A: {6} X: {7} Y: {8} SP {9} N: {10} V: {11} B: {12} D: {13} I: {14} Z: {15} C: {16}"'  							 ProgramCounter.ToString("X").PadLeft(4' '0')'  							 CurrentOpCode.ToString("X").PadLeft(2' '0')'  							 CurrentDisassembly.LowAddress'  							 CurrentDisassembly.HighAddress'  							   							 CurrentDisassembly.OpCodeString'  							 CurrentDisassembly.DisassemblyOutput.PadRight(10' ' ')'  			                   							 Accumulator.ToString("X").PadLeft(3' '0')'  			                 XRegister.ToString("X").PadLeft(3' '0')'  			                 YRegister.ToString("X").PadLeft(3' '0')'  			                 StackPointer.ToString("X").PadLeft(3' '0')'  			                 Convert.ToInt16(NegativeFlag)'  			                 Convert.ToInt16(OverflowFlag)'  			                 0'  			                 Convert.ToInt16(DecimalFlag)'  			                 Convert.ToInt16(DisableInterruptFlag)'  			                 Convert.ToInt16(ZeroFlag)'  			                 Convert.ToInt16(CarryFlag));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,AddWithCarryOperation,The following statement contains a magic number: newValue -= 100;
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,AddWithCarryOperation,The following statement contains a magic number: newValue > 99
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,AddWithCarryOperation,The following statement contains a magic number: newValue = (int)Convert.ToInt64(string.Concat("0x"' newValue)' 16);
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SubtractWithBorrowOperation,The following statement contains a magic number: newValue += 100;
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,SubtractWithBorrowOperation,The following statement contains a magic number: newValue = (int)Convert.ToInt64(string.Concat("0x"' newValue)' 16);
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,JumpToSubRoutineOperation,The following statement contains a magic number: PokeStack((byte)(((ProgramCounter + 1) >> 8) & 0xFF));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ReturnFromSubRoutineOperation,The following statement contains a magic number: var highBit = PeekStack() << 8;
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,BreakOperation,The following statement contains a magic number: PokeStack((byte)(((ProgramCounter) >> 8) & 0xFF));
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,BreakOperation,The following statement contains a magic number: ProgramCounter = (ReadMemoryValue(vector + 1) << 8) | ReadMemoryValue(vector);
Magic Number,Processor,Processor,D:\research\architectureSmells\repos\aaronmell_6502Net\Processor\Processor.cs,ReturnFromInterruptOperation,The following statement contains a magic number: var highBit = PeekStack() << 8;
