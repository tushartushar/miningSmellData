Implementation smell,Namespace,Class,File,Method,Description
Long Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The method has 254 lines of code.
Long Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The method has 161 lines of code.
Long Method,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The method has 182 lines of code.
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldMember,Cyclomatic complexity of the method is 51
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldFromBytes,Cyclomatic complexity of the method is 64
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldToBytes,Cyclomatic complexity of the method is 68
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,Cyclomatic complexity of the method is 21
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,Cyclomatic complexity of the method is 16
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,Cyclomatic complexity of the method is 36
Complex Method,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,Cyclomatic complexity of the method is 57
Complex Method,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,Cyclomatic complexity of the method is 10
Complex Method,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,Cyclomatic complexity of the method is 22
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldMember,The length of the statement  "		writer.WriteLine ("                    if (value.Length > " + ((field.Count == 1) ? "255" : "1500") + ") { throw new OverflowException(" + "\"Value exceeds " + ((field.Count == 1) ? "255" : "1500") + " characters\"); }"); " is 221.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldMember,The length of the statement  "		writer.WriteLine ("                    else { _" + field.Name.ToLower () + " = new byte[value.Length]; Buffer.BlockCopy(value' 0' _" + field.Name.ToLower () + "' 0' value.Length); }"); " is 184.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldFromBytes,The length of the statement  "		writer.WriteLine ("                    Buffer.BlockCopy(bytes' i' " + field.Name + "' 0' " + field.Count + "); i += " + field.Count + ";"); " is 139.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldFromBytes,The length of the statement  "		writer.WriteLine ("                    " + field.Name + " = (uint)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));"); " is 144.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldFromBytes,The length of the statement  "		writer.WriteLine ("                    " + field.Name + " = (int)(bytes[i++] + (bytes[i++] << 8) + (bytes[i++] << 16) + (bytes[i++] << 24));"); " is 143.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldFromBytes,The length of the statement  "		writer.WriteLine ("                    " + field.Name + " = (ulong)((ulong)bytes[i++] + ((ulong)bytes[i++] << 8) + " + "((ulong)bytes[i++] << 16) + ((ulong)bytes[i++] << 24) + " + "((ulong)bytes[i++] << 32) + ((ulong)bytes[i++] << 40) + " + "((ulong)bytes[i++] << 48) + ((ulong)bytes[i++] << 56));"); " is 300.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldFromBytes,The length of the statement  "		writer.WriteLine ("                    Buffer.BlockCopy(bytes' i' _" + field.Name.ToLower () + "' 0' length); i += length;"); " is 125.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldToBytes,The length of the statement  "		writer.WriteLine ("ba = BitConverter.GetBytes(" + field.Name + ");" + Environment.NewLine + "                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba' 0' 4); }" + Environment.NewLine + "                Buffer.BlockCopy(ba' 0' bytes' i' 4); i += 4;"); " is 261.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldToBytes,The length of the statement  "		writer.WriteLine ("ba = BitConverter.GetBytes(" + field.Name + ");" + Environment.NewLine + "                if(!BitConverter.IsLittleEndian) { Array.Reverse(ba' 0' 8); }" + Environment.NewLine + "                Buffer.BlockCopy(ba' 0' bytes' i' 8); i += 8;"); " is 261.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldToBytes,The length of the statement  "		writer.WriteLine ("                Buffer.BlockCopy(" + field.Name + "' 0' bytes' i' " + field.Count + ");" + "i += " + field.Count + ";"); " is 139.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldToBytes,The length of the statement  "		writer.WriteLine ("if(" + field.Name + " == null) { Console.WriteLine(\"Warning: " + field.Name + " is null' in \" + this.GetType()); }"); " is 138.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldToBytes,The length of the statement  "		writer.WriteLine ("                Buffer.BlockCopy(" + field.Name + "' 0' bytes' i' " + field.Name + ".Length); " + "i += " + field.Name + ".Length;"); " is 152.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,The length of the statement  "	"            public int Length" + Environment.NewLine + "            {" + Environment.NewLine + "                get" + Environment.NewLine + "                {"); " is 163.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,The length of the statement  "				writer.WriteLine ("                    if (" + field.Name + " != null) { length += " + field.Count + " + " + field.Name + ".Length; }"); " is 136.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,The length of the statement  "	writer.WriteLine ("            public " + block.Name + "Block(byte[] bytes' ref int i)" + Environment.NewLine + "            {" + Environment.NewLine + "                FromBytes(bytes' ref i);" + Environment.NewLine + "            }" + Environment.NewLine); " is 258.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,The length of the statement  "	writer.WriteLine ("            public void FromBytes(byte[] bytes' ref int i)" + Environment.NewLine + "            {"); " is 120.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,The length of the statement  "	writer.WriteLine ("                }" + Environment.NewLine + "                catch (Exception)" + Environment.NewLine + "                {" + Environment.NewLine + "                    throw new MalformedDataException();" + Environment.NewLine + "                }" + Environment.NewLine + "            }" + Environment.NewLine); " is 331.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteBlockClass,The length of the statement  "				writer.WriteLine ("                output.AppendLine(String.Format(\"" + field.Name + ": {0}\"' " + field.Name + "));"); " is 120.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "		writer.WriteLine ("        public " + block.Name + "Block" + ((block.Count != 1) ? "[]" : "") + " " + sanitizedName + ";"); " is 123.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	//writer.WriteLine("        /// <summary>Constructor that takes a byte array and beginning position (no prebuilt header)</summary>"); " is 133.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	writer.WriteLine ("        public " + packet.Name + "Packet(byte[] bytes' ref int i) : this()" + Environment.NewLine + "        {" + Environment.NewLine + "            int packetEnd = bytes.Length - 1;" + Environment.NewLine + "            FromBytes(bytes' ref i' ref packetEnd' null);" + Environment.NewLine + "        }" + Environment.NewLine); " is 346.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	writer.WriteLine ("        override public void FromBytes(byte[] bytes' ref int i' ref int packetEnd' byte[] zeroBuffer)" + Environment.NewLine + "        {"); " is 159.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("                for(int j = 0; j < count; j++) " + sanitizedName + "[j] = new " + block.Name + "Block();"); " is 126.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("                for(int j = 0; j < " + block.Count + "; j++) " + sanitizedName + "[j] = new " + block.Name + "Block();"); " is 140.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	writer.WriteLine ("        public " + packet.Name + "Packet(Header head' byte[] bytes' ref int i): this()" + Environment.NewLine + "        {" + Environment.NewLine + "            int packetEnd = bytes.Length - 1;" + Environment.NewLine + "            FromBytes(head' bytes' ref i' ref packetEnd' null);" + Environment.NewLine + "        }" + Environment.NewLine); " is 364.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	writer.WriteLine ("        override public void FromBytes(Header head' byte[] bytes' ref int i' ref int packetEnd' byte[] zeroBuffer)" + Environment.NewLine + "        {"); " is 172.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("                for(int j = 0; j < count; j++) " + sanitizedName + "[j] = new " + block.Name + "Block();"); " is 126.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("                for(int j = 0; j < " + block.Count + "; j++) " + sanitizedName + "[j] = new " + block.Name + "Block();"); " is 140.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	//writer.WriteLine("        /// <summary>Serialize this packet to a byte array</summary><returns>A byte array containing the serialized packet</returns>"); " is 155.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("            for (int j = 0; j < " + sanitizedName + ".Length; j++) { length += " + sanitizedName + "[j].Length; }"); " is 135.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("            for (int j = 0; j < " + block.Count + "; j++) { length += " + sanitizedName + "[j].Length; }"); " is 126.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("            for (int j = 0; j < " + sanitizedName + ".Length; j++) { " + sanitizedName + "[j].ToBytes(bytes' ref i); }"); " is 140.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("            for (int j = 0; j < " + block.Count + "; j++) { " + sanitizedName + "[j].ToBytes(bytes' ref i); }"); " is 131.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "	//writer.WriteLine("        /// <summary>Serialize this packet to a string</summary><returns>A string containing the serialized packet</returns>"); " is 147.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("            for (int j = 0; j < " + sanitizedName + ".Length; j++)" + Environment.NewLine + "            {"); " is 128.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("                output += " + sanitizedName + "[j].ToString() + Environment.NewLine;" + Environment.NewLine + "            }"); " is 146.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The length of the statement  "			writer.WriteLine ("                output += " + sanitizedName + "[j].ToString() + Environment.NewLine;" + Environment.NewLine + "            }"); " is 146.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("    public enum PacketType" + Environment.NewLine + "    {" + Environment.NewLine + "        /// <summary>A generic value' not an actual packet type</summary>" + Environment.NewLine + "        Default'"); " is 223.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("    public abstract partial class Packet" + Environment.NewLine + "    {" + Environment.NewLine + "        public abstract Header Header { get; set; }" + Environment.NewLine + "        public abstract PacketType Type { get; }" + Environment.NewLine + "        public abstract void FromBytes(byte[] bytes' ref int i' ref int packetEnd' byte[] zeroBuffer);" + Environment.NewLine + "        public abstract void FromBytes(Header header' byte[] bytes' ref int i' ref int packetEnd' byte[] zeroBuffer);" + Environment.NewLine + "        public int ResendCount;" + Environment.NewLine + "        public int TickCount;" + Environment.NewLine + Environment.NewLine + "        public abstract byte[] ToBytes();"//+ Environment.NewLine + Environment.NewLine + " is 769.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("        public static PacketType GetType(ushort id' PacketFrequency frequency)" + Environment.NewLine + "        {" + Environment.NewLine + "            switch (frequency)" + Environment.NewLine + "            {" + Environment.NewLine + "                case PacketFrequency.Low:" + Environment.NewLine + "                    switch (id)" + Environment.NewLine + "                    {"); " is 407.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("                    }" + Environment.NewLine + "                    break;" + Environment.NewLine + "                case PacketFrequency.Medium:" + Environment.NewLine + "                    switch (id)" + Environment.NewLine + "                    {"); " is 273.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("                    }" + Environment.NewLine + "                    break;" + Environment.NewLine + "                case PacketFrequency.High:" + Environment.NewLine + "                    switch (id)" + Environment.NewLine + "                    {"); " is 271.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("                    }" + Environment.NewLine + "                    break;" + Environment.NewLine + "            }" + Environment.NewLine + Environment.NewLine + "            return PacketType.Default;" + Environment.NewLine + "        }" + Environment.NewLine); " is 281.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	//    "        public static PacketType GetType(byte[] bytes' int packetEnd' byte[] zeroBuffer)" + Environment.NewLine + " is 120.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	//    "                bytes = zeroBuffer;" + Environment.NewLine + "            }" + Environment.NewLine + Environment.NewLine + " is 129.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	//    "                    id = (ushort)((bytes[8] << 8) + bytes[9]); freq = PacketFrequency.Low;" + Environment.NewLine + " is 122.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	//    "                {" + Environment.NewLine + "                    id = (ushort)bytes[7];  freq = PacketFrequency.Medium;" + " is 128.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("        public static Packet BuildPacket(byte[] packetBuffer' ref int packetEnd' byte[] zeroBuffer)" + Environment.NewLine + "        {" + Environment.NewLine + "            byte[] bytes; ushort id; PacketFrequency freq;" + Environment.NewLine + "            int i = 0;" + Environment.NewLine + "            Header header = Header.BuildHeader(packetBuffer' ref i' ref packetEnd);" + Environment.NewLine + "            if (header.Zerocoded)" + Environment.NewLine + "            {" + Environment.NewLine + "                packetEnd = Helpers.ZeroDecode(packetBuffer' packetEnd + 1' zeroBuffer) - 1;" + Environment.NewLine + "                bytes = zeroBuffer;" + Environment.NewLine + "            }" + Environment.NewLine + "            else" + Environment.NewLine + "            {" + Environment.NewLine + "                bytes = packetBuffer;" + Environment.NewLine + "            }" + Environment.NewLine + Environment.NewLine + "            if (bytes[6] == 0xFF)" + Environment.NewLine + "            {" + Environment.NewLine + "                if (bytes[7] == 0xFF)" + Environment.NewLine + "                {" + Environment.NewLine + "                    id = (ushort)((bytes[8] << 8) + bytes[9]); freq = PacketFrequency.Low;" + Environment.NewLine + "                    switch (id)" + Environment.NewLine + "                    {"); " is 1362.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "			writer.WriteLine ("                        case " + packet.ID + ": return new " + packet.Name + "Packet(header' bytes' ref i);"); " is 129.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("                    }" + Environment.NewLine + "                }" + Environment.NewLine + "                else" + Environment.NewLine + "                {" + Environment.NewLine + "                    id = (ushort)bytes[7];  freq = PacketFrequency.Medium;" + Environment.NewLine + "                    switch (id)" + Environment.NewLine + "                    {"); " is 385.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "			writer.WriteLine ("                        case " + packet.ID + ": return new " + packet.Name + "Packet(header' bytes' ref i);"); " is 129.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("                    }" + Environment.NewLine + "                }" + Environment.NewLine + "            }" + Environment.NewLine + "            else" + Environment.NewLine + "            {" + Environment.NewLine + "                id = (ushort)bytes[6];  freq = PacketFrequency.High;" + Environment.NewLine + "                switch (id)" + Environment.NewLine + "                    {"); " is 407.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "			writer.WriteLine ("                        case " + packet.ID + ": return new " + packet.Name + "Packet(header' bytes' ref i);"); " is 129.
Long Statement,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The length of the statement  "	writer.WriteLine ("                }" + Environment.NewLine + "            }" + Environment.NewLine + Environment.NewLine + "            throw new MalformedDataException(\"Unknown packet ID \"+freq+\" \"+id);" + Environment.NewLine + "        }" + Environment.NewLine + "    }" + Environment.NewLine); " is 301.
Long Statement,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,PrintOneMap,The length of the statement  "			writer.WriteLine ("{0} {1'5} - {2} - {3} - {4}"' frequency' i' map [i].Name' map [i].Trusted ? "Trusted" : "Untrusted"' map [i].Encoded ? "Unencoded" : "Zerocoded"); " is 165.
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: switch (field.Type) {  case FieldType.BOOL:  case FieldType.U8:  case FieldType.S8:  	return 1;  case FieldType.U16:  case FieldType.S16:  case FieldType.IPPORT:  	return 2;  case FieldType.U32:  case FieldType.S32:  case FieldType.F32:  case FieldType.IPADDR:  	return 4;  case FieldType.U64:  case FieldType.F64:  	return 8;  case FieldType.LLVector3:  case FieldType.LLQuaternion:  	return 12;  case FieldType.LLUUID:  case FieldType.LLVector4:  	//case FieldType.LLQuaternion:  	return 16;  case FieldType.LLVector3d:  	return 24;  case FieldType.Fixed:  	return field.Count;  case FieldType.Variable:  	return 0;  default:  	writer.WriteLine ("!!! ERROR: Unhandled FieldType " + field.Type.ToString () + " !!!");  	return 0;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: switch (field.Type) {  case FieldType.BOOL:  case FieldType.U8:  case FieldType.S8:  	return 1;  case FieldType.U16:  case FieldType.S16:  case FieldType.IPPORT:  	return 2;  case FieldType.U32:  case FieldType.S32:  case FieldType.F32:  case FieldType.IPADDR:  	return 4;  case FieldType.U64:  case FieldType.F64:  	return 8;  case FieldType.LLVector3:  case FieldType.LLQuaternion:  	return 12;  case FieldType.LLUUID:  case FieldType.LLVector4:  	//case FieldType.LLQuaternion:  	return 16;  case FieldType.LLVector3d:  	return 24;  case FieldType.Fixed:  	return field.Count;  case FieldType.Variable:  	return 0;  default:  	writer.WriteLine ("!!! ERROR: Unhandled FieldType " + field.Type.ToString () + " !!!");  	return 0;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: switch (field.Type) {  case FieldType.BOOL:  case FieldType.U8:  case FieldType.S8:  	return 1;  case FieldType.U16:  case FieldType.S16:  case FieldType.IPPORT:  	return 2;  case FieldType.U32:  case FieldType.S32:  case FieldType.F32:  case FieldType.IPADDR:  	return 4;  case FieldType.U64:  case FieldType.F64:  	return 8;  case FieldType.LLVector3:  case FieldType.LLQuaternion:  	return 12;  case FieldType.LLUUID:  case FieldType.LLVector4:  	//case FieldType.LLQuaternion:  	return 16;  case FieldType.LLVector3d:  	return 24;  case FieldType.Fixed:  	return field.Count;  case FieldType.Variable:  	return 0;  default:  	writer.WriteLine ("!!! ERROR: Unhandled FieldType " + field.Type.ToString () + " !!!");  	return 0;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: switch (field.Type) {  case FieldType.BOOL:  case FieldType.U8:  case FieldType.S8:  	return 1;  case FieldType.U16:  case FieldType.S16:  case FieldType.IPPORT:  	return 2;  case FieldType.U32:  case FieldType.S32:  case FieldType.F32:  case FieldType.IPADDR:  	return 4;  case FieldType.U64:  case FieldType.F64:  	return 8;  case FieldType.LLVector3:  case FieldType.LLQuaternion:  	return 12;  case FieldType.LLUUID:  case FieldType.LLVector4:  	//case FieldType.LLQuaternion:  	return 16;  case FieldType.LLVector3d:  	return 24;  case FieldType.Fixed:  	return field.Count;  case FieldType.Variable:  	return 0;  default:  	writer.WriteLine ("!!! ERROR: Unhandled FieldType " + field.Type.ToString () + " !!!");  	return 0;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: switch (field.Type) {  case FieldType.BOOL:  case FieldType.U8:  case FieldType.S8:  	return 1;  case FieldType.U16:  case FieldType.S16:  case FieldType.IPPORT:  	return 2;  case FieldType.U32:  case FieldType.S32:  case FieldType.F32:  case FieldType.IPADDR:  	return 4;  case FieldType.U64:  case FieldType.F64:  	return 8;  case FieldType.LLVector3:  case FieldType.LLQuaternion:  	return 12;  case FieldType.LLUUID:  case FieldType.LLVector4:  	//case FieldType.LLQuaternion:  	return 16;  case FieldType.LLVector3d:  	return 24;  case FieldType.Fixed:  	return field.Count;  case FieldType.Variable:  	return 0;  default:  	writer.WriteLine ("!!! ERROR: Unhandled FieldType " + field.Type.ToString () + " !!!");  	return 0;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: switch (field.Type) {  case FieldType.BOOL:  case FieldType.U8:  case FieldType.S8:  	return 1;  case FieldType.U16:  case FieldType.S16:  case FieldType.IPPORT:  	return 2;  case FieldType.U32:  case FieldType.S32:  case FieldType.F32:  case FieldType.IPADDR:  	return 4;  case FieldType.U64:  case FieldType.F64:  	return 8;  case FieldType.LLVector3:  case FieldType.LLQuaternion:  	return 12;  case FieldType.LLUUID:  case FieldType.LLVector4:  	//case FieldType.LLQuaternion:  	return 16;  case FieldType.LLVector3d:  	return 24;  case FieldType.Fixed:  	return field.Count;  case FieldType.Variable:  	return 0;  default:  	writer.WriteLine ("!!! ERROR: Unhandled FieldType " + field.Type.ToString () + " !!!");  	return 0;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: return 2;  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: return 4;  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: return 8;  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: return 12;  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: return 16;  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,GetFieldLength,The following statement contains a magic number: return 24;  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: try {  	if (args.Length != 4) {  		Console.WriteLine ("Usage: [message_template.msg] [template.cs] [unusedpackets.txt] [_Packets_.cs]");  		return -1;  	}  	writer = new StreamWriter (args [3]);  	protocol = new ProtocolManager (args [0]);  	// Build a list of unused packets  	using (StreamReader unusedReader = new StreamReader (args [2])) {  		while (unusedReader.Peek () >= 0) {  			unused.Add (unusedReader.ReadLine ().Trim ());  		}  	}  	// Read in the template.cs file and write it to our output  	TextReader reader = new StreamReader (args [1]);  	writer.WriteLine (reader.ReadToEnd ());  	reader.Close ();  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  	return -2;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: try {  	if (args.Length != 4) {  		Console.WriteLine ("Usage: [message_template.msg] [template.cs] [unusedpackets.txt] [_Packets_.cs]");  		return -1;  	}  	writer = new StreamWriter (args [3]);  	protocol = new ProtocolManager (args [0]);  	// Build a list of unused packets  	using (StreamReader unusedReader = new StreamReader (args [2])) {  		while (unusedReader.Peek () >= 0) {  			unused.Add (unusedReader.ReadLine ().Trim ());  		}  	}  	// Read in the template.cs file and write it to our output  	TextReader reader = new StreamReader (args [1]);  	writer.WriteLine (reader.ReadToEnd ());  	reader.Close ();  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  	return -2;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: try {  	if (args.Length != 4) {  		Console.WriteLine ("Usage: [message_template.msg] [template.cs] [unusedpackets.txt] [_Packets_.cs]");  		return -1;  	}  	writer = new StreamWriter (args [3]);  	protocol = new ProtocolManager (args [0]);  	// Build a list of unused packets  	using (StreamReader unusedReader = new StreamReader (args [2])) {  		while (unusedReader.Peek () >= 0) {  			unused.Add (unusedReader.ReadLine ().Trim ());  		}  	}  	// Read in the template.cs file and write it to our output  	TextReader reader = new StreamReader (args [1]);  	writer.WriteLine (reader.ReadToEnd ());  	reader.Close ();  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  	return -2;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: try {  	if (args.Length != 4) {  		Console.WriteLine ("Usage: [message_template.msg] [template.cs] [unusedpackets.txt] [_Packets_.cs]");  		return -1;  	}  	writer = new StreamWriter (args [3]);  	protocol = new ProtocolManager (args [0]);  	// Build a list of unused packets  	using (StreamReader unusedReader = new StreamReader (args [2])) {  		while (unusedReader.Peek () >= 0) {  			unused.Add (unusedReader.ReadLine ().Trim ());  		}  	}  	// Read in the template.cs file and write it to our output  	TextReader reader = new StreamReader (args [1]);  	writer.WriteLine (reader.ReadToEnd ());  	reader.Close ();  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  	return -2;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: if (args.Length != 4) {  	Console.WriteLine ("Usage: [message_template.msg] [template.cs] [unusedpackets.txt] [_Packets_.cs]");  	return -1;  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: writer = new StreamWriter (args [3]);  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: using (StreamReader unusedReader = new StreamReader (args [2])) {  	while (unusedReader.Peek () >= 0) {  		unused.Add (unusedReader.ReadLine ().Trim ());  	}  }  
Magic Number,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,Main,The following statement contains a magic number: return -2;  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: LowMaps = new MapPacket[65536];  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: MediumMaps = new MapPacket[256];  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: HighMaps = new MapPacket[256];  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.U16' 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.U32' 4);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.U64' 8);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.S16' 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.S32' 4);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.F32' 4);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.F64' 8);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.LLUUID' 16);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.LLVector3' 12);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.LLVector3d' 24);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.LLVector4' 16);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.LLQuaternion' 16);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.IPADDR' 4);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.IPPORT' 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,ProtocolManager,The following statement contains a magic number: TypeSizes.Add (FieldType.Fixed' -2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data.Length < 5) {  	return null;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if (data [4] == 0xFF) {  	if ((byte)data [5] == 0xFF) {  		// Low frequency  		command = (ushort)(data [6] * 256 + data [7]);  		return Command (command' PacketFrequency.Low);  	}  	else {  		// Medium frequency  		command = (ushort)data [5];  		return Command (command' PacketFrequency.Medium);  	}  }  else {  	// High frequency  	command = (ushort)data [4];  	return Command (command' PacketFrequency.High);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if ((byte)data [5] == 0xFF) {  	// Low frequency  	command = (ushort)(data [6] * 256 + data [7]);  	return Command (command' PacketFrequency.Low);  }  else {  	// Medium frequency  	command = (ushort)data [5];  	return Command (command' PacketFrequency.Medium);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if ((byte)data [5] == 0xFF) {  	// Low frequency  	command = (ushort)(data [6] * 256 + data [7]);  	return Command (command' PacketFrequency.Low);  }  else {  	// Medium frequency  	command = (ushort)data [5];  	return Command (command' PacketFrequency.Medium);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if ((byte)data [5] == 0xFF) {  	// Low frequency  	command = (ushort)(data [6] * 256 + data [7]);  	return Command (command' PacketFrequency.Low);  }  else {  	// Medium frequency  	command = (ushort)data [5];  	return Command (command' PacketFrequency.Medium);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if ((byte)data [5] == 0xFF) {  	// Low frequency  	command = (ushort)(data [6] * 256 + data [7]);  	return Command (command' PacketFrequency.Low);  }  else {  	// Medium frequency  	command = (ushort)data [5];  	return Command (command' PacketFrequency.Medium);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: if ((byte)data [5] == 0xFF) {  	// Low frequency  	command = (ushort)(data [6] * 256 + data [7]);  	return Command (command' PacketFrequency.Low);  }  else {  	// Medium frequency  	command = (ushort)data [5];  	return Command (command' PacketFrequency.Medium);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: command = (ushort)(data [6] * 256 + data [7]);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: command = (ushort)(data [6] * 256 + data [7]);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: command = (ushort)(data [6] * 256 + data [7]);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: command = (ushort)data [5];  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following statement contains a magic number: command = (ushort)data [4];  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,DecodeMapFile,The following statement contains a magic number: while ((nread = map.Read (buffer' 0' 2048)) != 0) {  	for (int i = 0; i < nread; ++i) {  		buffer [i] ^= magicKey;  		magicKey += 43;  	}  	output.Write (buffer' 0' nread);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,DecodeMapFile,The following statement contains a magic number: while ((nread = map.Read (buffer' 0' 2048)) != 0) {  	for (int i = 0; i < nread; ++i) {  		buffer [i] ^= magicKey;  		magicKey += 43;  	}  	output.Write (buffer' 0' nread);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,DecodeMapFile,The following statement contains a magic number: for (int i = 0; i < nread; ++i) {  	buffer [i] ^= magicKey;  	magicKey += 43;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,DecodeMapFile,The following statement contains a magic number: magicKey += 43;  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: try {  	StreamReader r = new StreamReader (map);  	r.BaseStream.Seek (0' SeekOrigin.Begin);  	string newline;  	string trimmedline;  	bool inPacket = false;  	bool inBlock = false;  	MapPacket currentPacket = null;  	MapBlock currentBlock = null;  	char[] trimArray = new char[] {  		' ''  		'\t'  	};  	// While not at the end of the file  	while (r.Peek () > -1) {  		#region ParseMap  		newline = r.ReadLine ();  		trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  		trimmedline = trimmedline.Trim (trimArray);  		if (!inPacket) {  			// Outside of all packet blocks  			if (trimmedline == "{") {  				inPacket = true;  			}  		}  		else {  			// Inside of a packet block  			if (!inBlock) {  				// Inside a packet block' outside of the blocks  				if (trimmedline == "{") {  					inBlock = true;  				}  				else if (trimmedline == "}") {  					// Reached the end of the packet  					// currentPacket.Blocks.Sort();  					inPacket = false;  				}  				else {  					// The packet header  					#region ParsePacketHeader  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					if (tokens.Length > 3) {  						//Hash packet name to insure correct keyword ordering  						KeywordPosition (tokens [0]);  						uint packetID;  						// Remove the leading "0x"  						if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  							tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  							packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  						}  						else {  							packetID = UInt32.Parse (tokens [2]);  						}  						if (tokens [1] == "Fixed") {  							// Truncate the id to a short  							packetID &= 0xFFFF;  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Low") {  							LowMaps [packetID] = new MapPacket ();  							LowMaps [packetID].ID = (ushort)packetID;  							LowMaps [packetID].Frequency = PacketFrequency.Low;  							LowMaps [packetID].Name = tokens [0];  							LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  							LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							LowMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = LowMaps [packetID];  						}  						else if (tokens [1] == "Medium") {  							MediumMaps [packetID] = new MapPacket ();  							MediumMaps [packetID].ID = (ushort)packetID;  							MediumMaps [packetID].Frequency = PacketFrequency.Medium;  							MediumMaps [packetID].Name = tokens [0];  							MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  							MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							MediumMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = MediumMaps [packetID];  						}  						else if (tokens [1] == "High") {  							HighMaps [packetID] = new MapPacket ();  							HighMaps [packetID].ID = (ushort)packetID;  							HighMaps [packetID].Frequency = PacketFrequency.High;  							HighMaps [packetID].Name = tokens [0];  							HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  							HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  							HighMaps [packetID].Blocks = new List<MapBlock> ();  							currentPacket = HighMaps [packetID];  						}  						else {  							//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  							throw new Exception ("Unknown packet frequency");  						}  					}  					#endregion  				}  			}  			else {  				if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  					// A field  					#region ParseField  					MapField field = new MapField ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					field.Name = tokens [1];  					field.KeywordPosition = KeywordPosition (field.Name);  					field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  					if (tokens [3] != "}") {  						field.Count = Int32.Parse (tokens [3]);  					}  					else {  						field.Count = 1;  					}  					// Save this field to the current block  					currentBlock.Fields.Add (field);  					#endregion  				}  				else if (trimmedline == "}") {  					// currentBlock.Fields.Sort();  					inBlock = false;  				}  				else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  					// The block header  					#region ParseBlockHeader  					currentBlock = new MapBlock ();  					// Splice the string in to tokens  					string[] tokens = trimmedline.Split (new char[] {  						' ''  						'\t'  					});  					currentBlock.Name = tokens [0];  					currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  					currentBlock.Fields = new List<MapField> ();  					currentPacket.Blocks.Add (currentBlock);  					if (tokens [1] == "Single") {  						currentBlock.Count = 1;  					}  					else if (tokens [1] == "Multiple") {  						currentBlock.Count = Int32.Parse (tokens [2]);  					}  					else if (tokens [1] == "Variable") {  						currentBlock.Count = -1;  					}  					else {  						//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown block frequency");  					}  					#endregion  				}  			}  		}  		#endregion  	}  	r.Close ();  	map.Close ();  }  catch (Exception e) {  	throw e;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: while (r.Peek () > -1) {  	#region ParseMap  	newline = r.ReadLine ();  	trimmedline = System.Text.RegularExpressions.Regex.Replace (newline' @"\s+"' " ");  	trimmedline = trimmedline.Trim (trimArray);  	if (!inPacket) {  		// Outside of all packet blocks  		if (trimmedline == "{") {  			inPacket = true;  		}  	}  	else {  		// Inside of a packet block  		if (!inBlock) {  			// Inside a packet block' outside of the blocks  			if (trimmedline == "{") {  				inBlock = true;  			}  			else if (trimmedline == "}") {  				// Reached the end of the packet  				// currentPacket.Blocks.Sort();  				inPacket = false;  			}  			else {  				// The packet header  				#region ParsePacketHeader  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				if (tokens.Length > 3) {  					//Hash packet name to insure correct keyword ordering  					KeywordPosition (tokens [0]);  					uint packetID;  					// Remove the leading "0x"  					if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  						tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  						packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  					}  					else {  						packetID = UInt32.Parse (tokens [2]);  					}  					if (tokens [1] == "Fixed") {  						// Truncate the id to a short  						packetID &= 0xFFFF;  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Low") {  						LowMaps [packetID] = new MapPacket ();  						LowMaps [packetID].ID = (ushort)packetID;  						LowMaps [packetID].Frequency = PacketFrequency.Low;  						LowMaps [packetID].Name = tokens [0];  						LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  						LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						LowMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = LowMaps [packetID];  					}  					else if (tokens [1] == "Medium") {  						MediumMaps [packetID] = new MapPacket ();  						MediumMaps [packetID].ID = (ushort)packetID;  						MediumMaps [packetID].Frequency = PacketFrequency.Medium;  						MediumMaps [packetID].Name = tokens [0];  						MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  						MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						MediumMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = MediumMaps [packetID];  					}  					else if (tokens [1] == "High") {  						HighMaps [packetID] = new MapPacket ();  						HighMaps [packetID].ID = (ushort)packetID;  						HighMaps [packetID].Frequency = PacketFrequency.High;  						HighMaps [packetID].Name = tokens [0];  						HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  						HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  						HighMaps [packetID].Blocks = new List<MapBlock> ();  						currentPacket = HighMaps [packetID];  					}  					else {  						//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  						throw new Exception ("Unknown packet frequency");  					}  				}  				#endregion  			}  		}  		else {  			if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  				// A field  				#region ParseField  				MapField field = new MapField ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				field.Name = tokens [1];  				field.KeywordPosition = KeywordPosition (field.Name);  				field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  				if (tokens [3] != "}") {  					field.Count = Int32.Parse (tokens [3]);  				}  				else {  					field.Count = 1;  				}  				// Save this field to the current block  				currentBlock.Fields.Add (field);  				#endregion  			}  			else if (trimmedline == "}") {  				// currentBlock.Fields.Sort();  				inBlock = false;  			}  			else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  				// The block header  				#region ParseBlockHeader  				currentBlock = new MapBlock ();  				// Splice the string in to tokens  				string[] tokens = trimmedline.Split (new char[] {  					' ''  					'\t'  				});  				currentBlock.Name = tokens [0];  				currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  				currentBlock.Fields = new List<MapField> ();  				currentPacket.Blocks.Add (currentBlock);  				if (tokens [1] == "Single") {  					currentBlock.Count = 1;  				}  				else if (tokens [1] == "Multiple") {  					currentBlock.Count = Int32.Parse (tokens [2]);  				}  				else if (tokens [1] == "Variable") {  					currentBlock.Count = -1;  				}  				else {  					//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown block frequency");  				}  				#endregion  			}  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inPacket) {  	// Outside of all packet blocks  	if (trimmedline == "{") {  		inPacket = true;  	}  }  else {  	// Inside of a packet block  	if (!inBlock) {  		// Inside a packet block' outside of the blocks  		if (trimmedline == "{") {  			inBlock = true;  		}  		else if (trimmedline == "}") {  			// Reached the end of the packet  			// currentPacket.Blocks.Sort();  			inPacket = false;  		}  		else {  			// The packet header  			#region ParsePacketHeader  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			if (tokens.Length > 3) {  				//Hash packet name to insure correct keyword ordering  				KeywordPosition (tokens [0]);  				uint packetID;  				// Remove the leading "0x"  				if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  					tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  					packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  				}  				else {  					packetID = UInt32.Parse (tokens [2]);  				}  				if (tokens [1] == "Fixed") {  					// Truncate the id to a short  					packetID &= 0xFFFF;  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Low") {  					LowMaps [packetID] = new MapPacket ();  					LowMaps [packetID].ID = (ushort)packetID;  					LowMaps [packetID].Frequency = PacketFrequency.Low;  					LowMaps [packetID].Name = tokens [0];  					LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  					LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					LowMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = LowMaps [packetID];  				}  				else if (tokens [1] == "Medium") {  					MediumMaps [packetID] = new MapPacket ();  					MediumMaps [packetID].ID = (ushort)packetID;  					MediumMaps [packetID].Frequency = PacketFrequency.Medium;  					MediumMaps [packetID].Name = tokens [0];  					MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  					MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					MediumMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = MediumMaps [packetID];  				}  				else if (tokens [1] == "High") {  					HighMaps [packetID] = new MapPacket ();  					HighMaps [packetID].ID = (ushort)packetID;  					HighMaps [packetID].Frequency = PacketFrequency.High;  					HighMaps [packetID].Name = tokens [0];  					HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  					HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  					HighMaps [packetID].Blocks = new List<MapBlock> ();  					currentPacket = HighMaps [packetID];  				}  				else {  					//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  					throw new Exception ("Unknown packet frequency");  				}  			}  			#endregion  		}  	}  	else {  		if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  			// A field  			#region ParseField  			MapField field = new MapField ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			field.Name = tokens [1];  			field.KeywordPosition = KeywordPosition (field.Name);  			field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  			if (tokens [3] != "}") {  				field.Count = Int32.Parse (tokens [3]);  			}  			else {  				field.Count = 1;  			}  			// Save this field to the current block  			currentBlock.Fields.Add (field);  			#endregion  		}  		else if (trimmedline == "}") {  			// currentBlock.Fields.Sort();  			inBlock = false;  		}  		else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  			// The block header  			#region ParseBlockHeader  			currentBlock = new MapBlock ();  			// Splice the string in to tokens  			string[] tokens = trimmedline.Split (new char[] {  				' ''  				'\t'  			});  			currentBlock.Name = tokens [0];  			currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  			currentBlock.Fields = new List<MapField> ();  			currentPacket.Blocks.Add (currentBlock);  			if (tokens [1] == "Single") {  				currentBlock.Count = 1;  			}  			else if (tokens [1] == "Multiple") {  				currentBlock.Count = Int32.Parse (tokens [2]);  			}  			else if (tokens [1] == "Variable") {  				currentBlock.Count = -1;  			}  			else {  				//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown block frequency");  			}  			#endregion  		}  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (!inBlock) {  	// Inside a packet block' outside of the blocks  	if (trimmedline == "{") {  		inBlock = true;  	}  	else if (trimmedline == "}") {  		// Reached the end of the packet  		// currentPacket.Blocks.Sort();  		inPacket = false;  	}  	else {  		// The packet header  		#region ParsePacketHeader  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		if (tokens.Length > 3) {  			//Hash packet name to insure correct keyword ordering  			KeywordPosition (tokens [0]);  			uint packetID;  			// Remove the leading "0x"  			if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  				tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  				packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  			}  			else {  				packetID = UInt32.Parse (tokens [2]);  			}  			if (tokens [1] == "Fixed") {  				// Truncate the id to a short  				packetID &= 0xFFFF;  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Low") {  				LowMaps [packetID] = new MapPacket ();  				LowMaps [packetID].ID = (ushort)packetID;  				LowMaps [packetID].Frequency = PacketFrequency.Low;  				LowMaps [packetID].Name = tokens [0];  				LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  				LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				LowMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = LowMaps [packetID];  			}  			else if (tokens [1] == "Medium") {  				MediumMaps [packetID] = new MapPacket ();  				MediumMaps [packetID].ID = (ushort)packetID;  				MediumMaps [packetID].Frequency = PacketFrequency.Medium;  				MediumMaps [packetID].Name = tokens [0];  				MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  				MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				MediumMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = MediumMaps [packetID];  			}  			else if (tokens [1] == "High") {  				HighMaps [packetID] = new MapPacket ();  				HighMaps [packetID].ID = (ushort)packetID;  				HighMaps [packetID].Frequency = PacketFrequency.High;  				HighMaps [packetID].Name = tokens [0];  				HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  				HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  				HighMaps [packetID].Blocks = new List<MapBlock> ();  				currentPacket = HighMaps [packetID];  			}  			else {  				//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  				throw new Exception ("Unknown packet frequency");  			}  		}  		#endregion  	}  }  else {  	if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  		// A field  		#region ParseField  		MapField field = new MapField ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		field.Name = tokens [1];  		field.KeywordPosition = KeywordPosition (field.Name);  		field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  		if (tokens [3] != "}") {  			field.Count = Int32.Parse (tokens [3]);  		}  		else {  			field.Count = 1;  		}  		// Save this field to the current block  		currentBlock.Fields.Add (field);  		#endregion  	}  	else if (trimmedline == "}") {  		// currentBlock.Fields.Sort();  		inBlock = false;  	}  	else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  		// The block header  		#region ParseBlockHeader  		currentBlock = new MapBlock ();  		// Splice the string in to tokens  		string[] tokens = trimmedline.Split (new char[] {  			' ''  			'\t'  		});  		currentBlock.Name = tokens [0];  		currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  		currentBlock.Fields = new List<MapField> ();  		currentPacket.Blocks.Add (currentBlock);  		if (tokens [1] == "Single") {  			currentBlock.Count = 1;  		}  		else if (tokens [1] == "Multiple") {  			currentBlock.Count = Int32.Parse (tokens [2]);  		}  		else if (tokens [1] == "Variable") {  			currentBlock.Count = -1;  		}  		else {  			//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown block frequency");  		}  		#endregion  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "{") {  	inBlock = true;  }  else if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// Reached the end of the packet  	// currentPacket.Blocks.Sort();  	inPacket = false;  }  else {  	// The packet header  	#region ParsePacketHeader  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	if (tokens.Length > 3) {  		//Hash packet name to insure correct keyword ordering  		KeywordPosition (tokens [0]);  		uint packetID;  		// Remove the leading "0x"  		if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  			tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  			packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  		}  		else {  			packetID = UInt32.Parse (tokens [2]);  		}  		if (tokens [1] == "Fixed") {  			// Truncate the id to a short  			packetID &= 0xFFFF;  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Low") {  			LowMaps [packetID] = new MapPacket ();  			LowMaps [packetID].ID = (ushort)packetID;  			LowMaps [packetID].Frequency = PacketFrequency.Low;  			LowMaps [packetID].Name = tokens [0];  			LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  			LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			LowMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = LowMaps [packetID];  		}  		else if (tokens [1] == "Medium") {  			MediumMaps [packetID] = new MapPacket ();  			MediumMaps [packetID].ID = (ushort)packetID;  			MediumMaps [packetID].Frequency = PacketFrequency.Medium;  			MediumMaps [packetID].Name = tokens [0];  			MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  			MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			MediumMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = MediumMaps [packetID];  		}  		else if (tokens [1] == "High") {  			HighMaps [packetID] = new MapPacket ();  			HighMaps [packetID].ID = (ushort)packetID;  			HighMaps [packetID].Frequency = PacketFrequency.High;  			HighMaps [packetID].Name = tokens [0];  			HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  			HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  			HighMaps [packetID].Blocks = new List<MapBlock> ();  			currentPacket = HighMaps [packetID];  		}  		else {  			//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  			throw new Exception ("Unknown packet frequency");  		}  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens.Length > 3) {  	//Hash packet name to insure correct keyword ordering  	KeywordPosition (tokens [0]);  	uint packetID;  	// Remove the leading "0x"  	if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  		tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  		packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  	}  	else {  		packetID = UInt32.Parse (tokens [2]);  	}  	if (tokens [1] == "Fixed") {  		// Truncate the id to a short  		packetID &= 0xFFFF;  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Low") {  		LowMaps [packetID] = new MapPacket ();  		LowMaps [packetID].ID = (ushort)packetID;  		LowMaps [packetID].Frequency = PacketFrequency.Low;  		LowMaps [packetID].Name = tokens [0];  		LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  		LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		LowMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = LowMaps [packetID];  	}  	else if (tokens [1] == "Medium") {  		MediumMaps [packetID] = new MapPacket ();  		MediumMaps [packetID].ID = (ushort)packetID;  		MediumMaps [packetID].Frequency = PacketFrequency.Medium;  		MediumMaps [packetID].Name = tokens [0];  		MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  		MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		MediumMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = MediumMaps [packetID];  	}  	else if (tokens [1] == "High") {  		HighMaps [packetID] = new MapPacket ();  		HighMaps [packetID].ID = (ushort)packetID;  		HighMaps [packetID].Frequency = PacketFrequency.High;  		HighMaps [packetID].Name = tokens [0];  		HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  		HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  		HighMaps [packetID].Blocks = new List<MapBlock> ();  		currentPacket = HighMaps [packetID];  	}  	else {  		//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown packet frequency");  	}  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [2].Length > 2 && tokens [2].Substring (0' 2) == "0x") {  	tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  	packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  }  else {  	packetID = UInt32.Parse (tokens [2]);  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: tokens [2] = tokens [2].Substring (2' tokens [2].Length - 2);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: packetID = UInt32.Parse (tokens [2]' System.Globalization.NumberStyles.HexNumber);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: packetID = UInt32.Parse (tokens [2]);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Fixed") {  	// Truncate the id to a short  	packetID &= 0xFFFF;  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: LowMaps [packetID].Trusted = (tokens [3] == "Trusted");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: LowMaps [packetID].Encoded = (tokens [4] == "Zerocoded");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Low") {  	LowMaps [packetID] = new MapPacket ();  	LowMaps [packetID].ID = (ushort)packetID;  	LowMaps [packetID].Frequency = PacketFrequency.Low;  	LowMaps [packetID].Name = tokens [0];  	LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  	LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	LowMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = LowMaps [packetID];  }  else if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: LowMaps [packetID].Trusted = (tokens [2] == "Trusted");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: LowMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Medium") {  	MediumMaps [packetID] = new MapPacket ();  	MediumMaps [packetID].ID = (ushort)packetID;  	MediumMaps [packetID].Frequency = PacketFrequency.Medium;  	MediumMaps [packetID].Name = tokens [0];  	MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  	MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	MediumMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = MediumMaps [packetID];  }  else if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: MediumMaps [packetID].Trusted = (tokens [2] == "Trusted");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: MediumMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "High") {  	HighMaps [packetID] = new MapPacket ();  	HighMaps [packetID].ID = (ushort)packetID;  	HighMaps [packetID].Frequency = PacketFrequency.High;  	HighMaps [packetID].Name = tokens [0];  	HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  	HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  	HighMaps [packetID].Blocks = new List<MapBlock> ();  	currentPacket = HighMaps [packetID];  }  else {  	//Client.Log("Unknown packet frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown packet frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: HighMaps [packetID].Trusted = (tokens [2] == "Trusted");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: HighMaps [packetID].Encoded = (tokens [3] == "Zerocoded");  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  	// A field  	#region ParseField  	MapField field = new MapField ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	field.Name = tokens [1];  	field.KeywordPosition = KeywordPosition (field.Name);  	field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  	if (tokens [3] != "}") {  		field.Count = Int32.Parse (tokens [3]);  	}  	else {  		field.Count = 1;  	}  	// Save this field to the current block  	currentBlock.Fields.Add (field);  	#endregion  }  else if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  	// A field  	#region ParseField  	MapField field = new MapField ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	field.Name = tokens [1];  	field.KeywordPosition = KeywordPosition (field.Name);  	field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  	if (tokens [3] != "}") {  		field.Count = Int32.Parse (tokens [3]);  	}  	else {  		field.Count = 1;  	}  	// Save this field to the current block  	currentBlock.Fields.Add (field);  	#endregion  }  else if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  	// A field  	#region ParseField  	MapField field = new MapField ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	field.Name = tokens [1];  	field.KeywordPosition = KeywordPosition (field.Name);  	field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  	if (tokens [3] != "}") {  		field.Count = Int32.Parse (tokens [3]);  	}  	else {  		field.Count = 1;  	}  	// Save this field to the current block  	currentBlock.Fields.Add (field);  	#endregion  }  else if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  	// A field  	#region ParseField  	MapField field = new MapField ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	field.Name = tokens [1];  	field.KeywordPosition = KeywordPosition (field.Name);  	field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  	if (tokens [3] != "}") {  		field.Count = Int32.Parse (tokens [3]);  	}  	else {  		field.Count = 1;  	}  	// Save this field to the current block  	currentBlock.Fields.Add (field);  	#endregion  }  else if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length > 0 && trimmedline.Substring (0' 1) == "{") {  	// A field  	#region ParseField  	MapField field = new MapField ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	field.Name = tokens [1];  	field.KeywordPosition = KeywordPosition (field.Name);  	field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  	if (tokens [3] != "}") {  		field.Count = Int32.Parse (tokens [3]);  	}  	else {  		field.Count = 1;  	}  	// Save this field to the current block  	currentBlock.Fields.Add (field);  	#endregion  }  else if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: field.Type = (FieldType)Enum.Parse (typeof(FieldType)' tokens [2]' true);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [3] != "}") {  	field.Count = Int32.Parse (tokens [3]);  }  else {  	field.Count = 1;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [3] != "}") {  	field.Count = Int32.Parse (tokens [3]);  }  else {  	field.Count = 1;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: field.Count = Int32.Parse (tokens [3]);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline == "}") {  	// currentBlock.Fields.Sort();  	inBlock = false;  }  else if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (trimmedline.Length != 0 && trimmedline.Substring (0' 2) != "//") {  	// The block header  	#region ParseBlockHeader  	currentBlock = new MapBlock ();  	// Splice the string in to tokens  	string[] tokens = trimmedline.Split (new char[] {  		' ''  		'\t'  	});  	currentBlock.Name = tokens [0];  	currentBlock.KeywordPosition = KeywordPosition (currentBlock.Name);  	currentBlock.Fields = new List<MapField> ();  	currentPacket.Blocks.Add (currentBlock);  	if (tokens [1] == "Single") {  		currentBlock.Count = 1;  	}  	else if (tokens [1] == "Multiple") {  		currentBlock.Count = Int32.Parse (tokens [2]);  	}  	else if (tokens [1] == "Variable") {  		currentBlock.Count = -1;  	}  	else {  		//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  		throw new Exception ("Unknown block frequency");  	}  	#endregion  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Single") {  	currentBlock.Count = 1;  }  else if (tokens [1] == "Multiple") {  	currentBlock.Count = Int32.Parse (tokens [2]);  }  else if (tokens [1] == "Variable") {  	currentBlock.Count = -1;  }  else {  	//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown block frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: if (tokens [1] == "Multiple") {  	currentBlock.Count = Int32.Parse (tokens [2]);  }  else if (tokens [1] == "Variable") {  	currentBlock.Count = -1;  }  else {  	//Client.Log("Unknown block frequency"' Helpers.LogLevel.Error);  	throw new Exception ("Unknown block frequency");  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,LoadMapFile,The following statement contains a magic number: currentBlock.Count = Int32.Parse (tokens [2]);  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,KeywordPosition,The following statement contains a magic number: for (int i = 1; i < keyword.Length; i++) {  	hash = (hash + (int)(keyword [i])) * 2;  }  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,KeywordPosition,The following statement contains a magic number: hash = (hash + (int)(keyword [i])) * 2;  
Magic Number,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,KeywordPosition,The following statement contains a magic number: hash *= 2;  
Duplicate Code,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WritePacketClass,The method contains a code clone-set at the following line numbers (starting from the method definition): ((68' 109)' (117' 158))
Missing Default,mapgenerator,mapgenerator,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\mapgenerator.cs,WriteFieldMember,The following switch statement is missing a default case: switch (field.Type) {  case FieldType.BOOL:  	type = "bool";  	break;  case FieldType.F32:  	type = "float";  	break;  case FieldType.F64:  	type = "double";  	break;  case FieldType.IPPORT:  case FieldType.U16:  	type = "ushort";  	break;  case FieldType.IPADDR:  case FieldType.U32:  	type = "uint";  	break;  case FieldType.LLQuaternion:  	type = "LLQuaternion";  	break;  case FieldType.LLUUID:  	type = "LLUUID";  	break;  case FieldType.LLVector3:  	type = "LLVector3";  	break;  case FieldType.LLVector3d:  	type = "LLVector3d";  	break;  case FieldType.LLVector4:  	type = "LLVector4";  	break;  case FieldType.S16:  	type = "short";  	break;  case FieldType.S32:  	type = "int";  	break;  case FieldType.S8:  	type = "sbyte";  	break;  case FieldType.U64:  	type = "ulong";  	break;  case FieldType.U8:  	type = "byte";  	break;  case FieldType.Fixed:  	type = "byte[]";  	break;  }  
Missing Default,libsecondlife,ProtocolManager,C:\repos\chrbayer84_SLAgentCSServer\libsecondlife-0.5.0\libsecondlife\mapgenerator\ProtocolManager.cs,Command,The following switch statement is missing a default case: switch (frequency) {  case PacketFrequency.High:  	return HighMaps [command];  case PacketFrequency.Medium:  	return MediumMaps [command];  case PacketFrequency.Low:  	return LowMaps [command];  }  
