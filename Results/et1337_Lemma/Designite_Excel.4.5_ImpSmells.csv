Implementation smell,Namespace,Class,File,Method,Description
Long Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkBookGlobals,The method has 114 lines of code.
Long Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The method has 118 lines of code.
Complex Method,Excel.Core.BinaryFormat,XlsBiffRecord,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRecord.cs,GetRecord,Cyclomatic complexity of the method is 44
Complex Method,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,Cyclomatic complexity of the method is 9
Complex Method,Excel.Core.BinaryFormat,XlsBiffStream,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffStream.cs,Seek,Cyclomatic complexity of the method is 11
Complex Method,Excel.Core,Helpers,F:\newReposMay17\et1337_Lemma\Excel\Core\Helpers.cs,FixDataTypes,Cyclomatic complexity of the method is 13
Complex Method,Excel.Core,ZipWorker,F:\newReposMay17\et1337_Lemma\Excel\Core\ZipWorker.cs,ExtractZipEntry,Cyclomatic complexity of the method is 8
Complex Method,Excel.Core.OpenXmlFormat,XlsxWorkbook,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxWorkbook.cs,ReadStyles,Cyclomatic complexity of the method is 12
Complex Method,Excel.Core.OpenXmlFormat,XlsxWorkbook,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxWorkbook.cs,ReadSharedStrings,Cyclomatic complexity of the method is 8
Complex Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkBookGlobals,Cyclomatic complexity of the method is 69
Complex Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkSheetGlobals,Cyclomatic complexity of the method is 15
Complex Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWholeWorkSheetWithIndex,Cyclomatic complexity of the method is 10
Complex Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWholeWorkSheetNoIndex,Cyclomatic complexity of the method is 10
Complex Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,Cyclomatic complexity of the method is 51
Complex Method,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,Cyclomatic complexity of the method is 55
Complex Method,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetGlobals,Cyclomatic complexity of the method is 14
Complex Method,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,Cyclomatic complexity of the method is 22
Complex Method,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,AsDataSet,Cyclomatic complexity of the method is 10
Long Parameter List,Excel.Core.BinaryFormat,XlsBiffStream,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffStream.cs,XlsBiffStream,The method has 5 parameters.
Long Parameter List,Excel.Core.BinaryFormat,XlsFat,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsFat.cs,XlsFat,The method has 5 parameters.
Long Parameter List,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,GetBytes,The method has 5 parameters.
Long Parameter List,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,GetChars,The method has 5 parameters.
Long Parameter List,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,GetBytes,The method has 5 parameters.
Long Parameter List,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,GetChars,The method has 5 parameters.
Long Statement,Excel.Core,FormatReader,F:\newReposMay17\et1337_Lemma\Excel\Core\FormatReader.cs,IsDateFormatString,The length of the statement  "				if (!IsSurroundedByBracket (dateChar' pos) && !IsPrecededByBackSlash (dateChar' pos) && !IsSurroundedByQuotes (dateChar' pos)) " is 126.
Long Statement,Excel.Core,ZipWorker,F:\newReposMay17\et1337_Lemma\Excel\Core\ZipWorker.cs,Extract,The length of the statement  "		//true tells CleanFromTemp not to raise an IO Exception if this operation fails. If it did then the real error here would be masked " is 131.
Long Statement,Excel.Core,ZipWorker,F:\newReposMay17\et1337_Lemma\Excel\Core\ZipWorker.cs,GetWorksheetStream,The length of the statement  "	return GetStream (Path.Combine (Path.Combine (_xlPath' FOLDER_worksheets)' string.Format (FILE_sheet' sheetId' _format))); " is 122.
Long Statement,Excel.Core,ZipWorker,F:\newReposMay17\et1337_Lemma\Excel\Core\ZipWorker.cs,CheckFolderTree,The length of the statement  "	return Directory.Exists (_xlPath) && Directory.Exists (Path.Combine (_xlPath' FOLDER_worksheets)) && File.Exists (Path.Combine (_xlPath' FILE_workbook)) && File.Exists (Path.Combine (_xlPath' FILE_styles)); " is 206.
Long Statement,Excel.Core.OpenXmlFormat,XlsxWorkbook,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxWorkbook.cs,ReadStyles,The length of the statement  "						_Styles.NumFmts.Add (new XlsxNumFmt (int.Parse (reader.GetAttribute (XlsxNumFmt.A_numFmtId))' reader.GetAttribute (XlsxNumFmt.A_formatCode))); " is 142.
Long Statement,Excel.Core.OpenXmlFormat,XlsxWorkbook,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxWorkbook.cs,ReadStyles,The length of the statement  "						_Styles.CellXfs.Add (new XlsxXf (xfId == null ? -1 : int.Parse (xfId)' numFmtId == null ? -1 : int.Parse (numFmtId)' reader.GetAttribute (XlsxXf.A_applyNumberFormat))); " is 168.
Long Statement,Excel.Core.OpenXmlFormat,XlsxWorkbook,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxWorkbook.cs,ReadWorkbook,The length of the statement  "				sheets.Add (new XlsxWorksheet (reader.GetAttribute (A_name)' int.Parse (reader.GetAttribute (A_sheetId))' reader.GetAttribute (A_rid))); " is 136.
Long Statement,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkSheetGlobals,The length of the statement  "		LogManager.Log (this).Debug ("Got row {0}' rec: id={1}'rowindex={2}' rowColumnStart={3}' rowColumnEnd={4}"' rowRecord.Offset' rowRecord.ID' rowRecord.RowIndex' rowRecord.FirstDefinedColumn' rowRecord.LastDefinedColumn); " is 219.
Long Statement,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,Initialize,The length of the statement  "	// set the sheet index to the index of the first sheet.. this is so that properties such as Name which use m_sheetIndex reflect the first sheet in the file without having to perform a read() operation " is 200.
Long Statement,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadGlobals,The length of the statement  "	_workbook = new XlsxWorkbook (_zipWorker.GetWorkbookStream ()' _zipWorker.GetWorkbookRelsStream ()' _zipWorker.GetSharedStringsStream ()' _zipWorker.GetStylesStream ()); " is 169.
Long Statement,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetGlobals,The length of the statement  "		//removed: Do not use col to work out number of columns as this is really for defining formatting' so may not contain all columns " is 129.
Long Statement,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetGlobals,The length of the statement  "		//check cells so we can find size of sheet if can't work it out from dimension or col elements (dimension should have been set before the cells if it was available) " is 164.
Long Statement,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetGlobals,The length of the statement  "		if (sheet.Dimension == null && cols == 0 && _xmlReader.NodeType == XmlNodeType.Element && _xmlReader.LocalName == XlsxWorksheet.N_c) { " is 134.
Long Statement,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetGlobals,The length of the statement  "	//read up to the sheetData element. if this element is empty then there aren't any rows and we need to null out dimension " is 121.
Long Statement,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The length of the statement  "	if ((_xmlReader.NodeType == XmlNodeType.Element && _xmlReader.LocalName == XlsxWorksheet.N_row) || _xmlReader.ReadToFollowing (XlsxWorksheet.N_row' _namespaceUri)) { " is 165.
Complex Conditional,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWholeWorkSheetWithIndex,The conditional expression  "_isFirstRowAsColumnNames && readWorkSheetRow () || (_isFirstRowAsColumnNames && m_maxRow == 1)"  is complex.
Complex Conditional,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWholeWorkSheetNoIndex,The conditional expression  "!justAddedColumns && m_depth > 0 && !(_isFirstRowAsColumnNames && m_maxRow == 1)"  is complex.
Complex Conditional,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetGlobals,The conditional expression  "sheet.Dimension == null && cols == 0 && _xmlReader.NodeType == XmlNodeType.Element && _xmlReader.LocalName == XlsxWorksheet.N_c"  is complex.
Complex Conditional,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The conditional expression  "xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId)"  is complex.
Empty Catch Block,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkBookGlobals,The method has an empty catch block.
Magic Number,Excel.Core.BinaryFormat,XlsBiffMulBlankCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffMulBlankCell.cs,GetXF,The following statement contains a magic number: if (ofs > RecordSize - 2)  	return 0;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffMulRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffMulRKCell.cs,GetXF,The following statement contains a magic number: if (ofs > RecordSize - 2)  	return 0;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRecord,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRecord.cs,XlsBiffRecord,The following statement contains a magic number: if (bytes.Length - offset < 4)  	throw new ArgumentException (Errors.ErrorBIFFRecordSize);  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRecord,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRecord.cs,XlsBiffRecord,The following statement contains a magic number: m_readoffset = (int)(4 + offset);  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRKCell.cs,NumFromRK,The following statement contains a magic number: if ((rk & 0x2) == 0x2) {  	num = (int)(rk >> 2 | ((rk & 0x80000000) == 0 ? 0 : 0xC0000000));  } else {  	// hi words of IEEE num  	num = Helpers.Int64BitsToDouble (((long)(rk & 0xfffffffc) << 32));  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRKCell.cs,NumFromRK,The following statement contains a magic number: if ((rk & 0x2) == 0x2) {  	num = (int)(rk >> 2 | ((rk & 0x80000000) == 0 ? 0 : 0xC0000000));  } else {  	// hi words of IEEE num  	num = Helpers.Int64BitsToDouble (((long)(rk & 0xfffffffc) << 32));  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRKCell.cs,NumFromRK,The following statement contains a magic number: num = (int)(rk >> 2 | ((rk & 0x80000000) == 0 ? 0 : 0xC0000000));  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRKCell.cs,NumFromRK,The following statement contains a magic number: num = Helpers.Int64BitsToDouble (((long)(rk & 0xfffffffc) << 32));  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRKCell.cs,NumFromRK,The following statement contains a magic number: if ((rk & 0x1) == 0x1)  	num /= 100;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffRKCell,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffRKCell.cs,NumFromRK,The following statement contains a magic number: num /= 100;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: while (offset < last) {  	XlsFormattedUnicodeString str = new XlsFormattedUnicodeString (m_bytes' offset);  	uint prefix = str.HeadSize;  	uint postfix = str.TailSize;  	uint len = str.CharacterCount;  	uint size = prefix + postfix + len + ((str.IsMultiByte) ? len : 0);  	if (offset + size > last) {  		if (lastcontinue >= continues.Count)  			break;  		uint contoffset = continues [lastcontinue];  		byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  		byte[] buff = new byte[size * 2];  		Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  		if (encoding == 0 && str.IsMultiByte) {  			len -= (last - prefix - offset) / 2;  			string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  			byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  			offset = contoffset + 5 + len + postfix;  		} else if (encoding == 1 && str.IsMultiByte == false) {  			len -= (last - offset - prefix);  			string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  			byte[] tempbytes = Encoding.Default.GetBytes (temp);  			Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  			Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  			offset = contoffset + 5 + len + len + postfix;  		} else {  			Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  			offset = contoffset + 5 + size - last + offset;  		}  		last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  		str = new XlsFormattedUnicodeString (buff' 0);  	} else {  		offset += size;  		if (offset == last) {  			if (lastcontinue < continues.Count) {  				uint contoffset = continues [lastcontinue];  				offset = contoffset + 4;  				last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  				lastcontinue++;  			} else  				count = 1;  		}  	}  	m_strings.Add (str.Value);  	count--;  	if (count == 0)  		break;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset + size > last) {  	if (lastcontinue >= continues.Count)  		break;  	uint contoffset = continues [lastcontinue];  	byte encoding = Buffer.GetByte (m_bytes' (int)contoffset + 4);  	byte[] buff = new byte[size * 2];  	Buffer.BlockCopy (m_bytes' (int)offset' buff' 0' (int)(last - offset));  	if (encoding == 0 && str.IsMultiByte) {  		len -= (last - prefix - offset) / 2;  		string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  		byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  		offset = contoffset + 5 + len + postfix;  	} else if (encoding == 1 && str.IsMultiByte == false) {  		len -= (last - offset - prefix);  		string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  		byte[] tempbytes = Encoding.Default.GetBytes (temp);  		Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  		Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  		offset = contoffset + 5 + len + len + postfix;  	} else {  		Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  		offset = contoffset + 5 + size - last + offset;  	}  	last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  	str = new XlsFormattedUnicodeString (buff' 0);  } else {  	offset += size;  	if (offset == last) {  		if (lastcontinue < continues.Count) {  			uint contoffset = continues [lastcontinue];  			offset = contoffset + 4;  			last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  			lastcontinue++;  		} else  			count = 1;  	}  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 0 && str.IsMultiByte) {  	len -= (last - prefix - offset) / 2;  	string temp = Encoding.Default.GetString (m_bytes' (int)contoffset + 5' (int)len);  	byte[] tempbytes = Encoding.Unicode.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  	offset = contoffset + 5 + len + postfix;  } else if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: len -= (last - prefix - offset) / 2;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len)' buff' (int)(last - offset + len + len)' (int)postfix);  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: offset = contoffset + 5 + len + postfix;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (encoding == 1 && str.IsMultiByte == false) {  	len -= (last - offset - prefix);  	string temp = Encoding.Unicode.GetString (m_bytes' (int)contoffset + 5' (int)(len + len));  	byte[] tempbytes = Encoding.Default.GetBytes (temp);  	Buffer.BlockCopy (tempbytes' 0' buff' (int)(last - offset)' tempbytes.Length);  	Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  	offset = contoffset + 5 + len + len + postfix;  } else {  	Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  	offset = contoffset + 5 + size - last + offset;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: Buffer.BlockCopy (m_bytes' (int)(contoffset + 5 + len + len)' buff' (int)(last - offset + len)' (int)postfix);  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: offset = contoffset + 5 + len + len + postfix;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: Buffer.BlockCopy (m_bytes' (int)contoffset + 5' buff' (int)(last - offset)' (int)(size - last + offset));  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: offset = contoffset + 5 + size - last + offset;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: last = contoffset + 4 + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset == last) {  	if (lastcontinue < continues.Count) {  		uint contoffset = continues [lastcontinue];  		offset = contoffset + 4;  		last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  	} else  		count = 1;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (offset == last) {  	if (lastcontinue < continues.Count) {  		uint contoffset = continues [lastcontinue];  		offset = contoffset + 4;  		last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  		lastcontinue++;  	} else  		count = 1;  }  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (lastcontinue < continues.Count) {  	uint contoffset = continues [lastcontinue];  	offset = contoffset + 4;  	last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  } else  	count = 1;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: if (lastcontinue < continues.Count) {  	uint contoffset = continues [lastcontinue];  	offset = contoffset + 4;  	last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  	lastcontinue++;  } else  	count = 1;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: offset = contoffset + 4;  
Magic Number,Excel.Core.BinaryFormat,XlsBiffSST,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffSST.cs,ReadStrings,The following statement contains a magic number: last = offset + BitConverter.ToUInt16 (m_bytes' (int)contoffset + 2);  
Magic Number,Excel.Core.BinaryFormat,XlsFat,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsFat.cs,XlsFat,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (sizeOfSector * m_sectors_for_fat)) {  	lock (file) {  		for (int i = 0; i < sectors.Count; i++) {  			sector = sectors [i];  			if (prevSector == 0 || (sector - prevSector) != 1)  				file.Seek ((sector + 1) * sizeOfSector' SeekOrigin.Begin);  			prevSector = sector;  			file.Read (buff' 0' sizeOfSector);  			ms.Write (buff' 0' sizeOfSector);  		}  	}  	ms.Seek (0' SeekOrigin.Begin);  	BinaryReader rd = new BinaryReader (ms);  	m_sectors = (int)ms.Length / 4;  	m_fat = new List<uint> (m_sectors);  	for (int i = 0; i < m_sectors; i++)  		m_fat.Add (rd.ReadUInt32 ());  	rd.Close ();  	ms.Close ();  }  
Magic Number,Excel.Core.BinaryFormat,XlsFat,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsFat.cs,XlsFat,The following statement contains a magic number: m_sectors = (int)ms.Length / 4;  
Magic Number,Excel.Core.BinaryFormat,XlsHeader,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsHeader.cs,XlsHeader,The following statement contains a magic number: m_bytes = new byte[512];  
Magic Number,Excel.Core.BinaryFormat,XlsHeader,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsHeader.cs,ReadHeader,The following statement contains a magic number: lock (file) {  	file.Seek (0' SeekOrigin.Begin);  	file.Read (hdr.m_bytes' 0' 512);  }  
Magic Number,Excel.Core.BinaryFormat,XlsHeader,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsHeader.cs,ReadHeader,The following statement contains a magic number: file.Read (hdr.m_bytes' 0' 512);  
Magic Number,Excel.Core.BinaryFormat,XlsStream,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsStream.cs,ReadStream,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (sectorSize * 8)) {  	lock (m_fileStream) {  		do {  			if (prevSector == 0 || (sector - prevSector) != 1) {  				var adjustedSector = m_isMini ? sector : sector + 1;  				//standard sector is + 1 because header is first  				m_fileStream.Seek (adjustedSector * sectorSize + offset' SeekOrigin.Begin);  			}  			if (prevSector != 0 && prevSector == sector)  				throw new InvalidOperationException ("The excel file may be corrupt. We appear to be stuck");  			prevSector = sector;  			m_fileStream.Read (buff' 0' sectorSize);  			ms.Write (buff' 0' sectorSize);  			sector = fat.GetNextSector (sector);  			if (sector == 0)  				throw new InvalidOperationException ("Next sector cannot be 0. Possibly corrupt excel file");  		} while (sector != (uint)FATMARKERS.FAT_EndOfChain);  	}  	ret = ms.ToArray ();  }  
Magic Number,Excel.Core,FormatReader,F:\newReposMay17\et1337_Lemma\Excel\Core\FormatReader.cs,IsSurroundedByQuotes,The following statement contains a magic number: return numAfter % 2 == 1 && numBefore % 2 == 1;  
Magic Number,Excel.Core,FormatReader,F:\newReposMay17\et1337_Lemma\Excel\Core\FormatReader.cs,IsSurroundedByQuotes,The following statement contains a magic number: return numAfter % 2 == 1 && numBefore % 2 == 1;  
Magic Number,Excel.Core,FormatReader,F:\newReposMay17\et1337_Lemma\Excel\Core\FormatReader.cs,IsSurroundedByBracket,The following statement contains a magic number: return numOpenBefore % 2 == 1 && numClosedAfter % 2 == 1;  
Magic Number,Excel.Core,FormatReader,F:\newReposMay17\et1337_Lemma\Excel\Core\FormatReader.cs,IsSurroundedByBracket,The following statement contains a magic number: return numOpenBefore % 2 == 1 && numClosedAfter % 2 == 1;  
Magic Number,Excel.Core,Helpers,F:\newReposMay17\et1337_Lemma\Excel\Core\Helpers.cs,ConvertFromOATime,The following statement contains a magic number: if ((value >= 0.0) && (value < 60.0)) {  	value++;  }  
Magic Number,Excel.Core,ReferenceHelper,F:\newReposMay17\et1337_Lemma\Excel\Core\ReferenceHelper.cs,ReferenceToColumnAndRow,The following statement contains a magic number: for (int i = column.Length - 1; i >= 0; i--) {  	int pos = column [i] - 'A' + 1;  	columnValue += pow * pos;  	pow *= 26;  }  
Magic Number,Excel.Core,ReferenceHelper,F:\newReposMay17\et1337_Lemma\Excel\Core\ReferenceHelper.cs,ReferenceToColumnAndRow,The following statement contains a magic number: pow *= 26;  
Magic Number,Excel.Core,ReferenceHelper,F:\newReposMay17\et1337_Lemma\Excel\Core\ReferenceHelper.cs,ReferenceToColumnAndRow,The following statement contains a magic number: return new int[2] {  	int.Parse (rowString)'  	columnValue  };  
Magic Number,Excel.Core,ZipWorker,F:\newReposMay17\et1337_Lemma\Excel\Core\ZipWorker.cs,GetWorksheetStream,The following statement contains a magic number: if (sheetPath.StartsWith ("/xl/"))  	sheetPath = sheetPath.Substring (4);  
Magic Number,Excel.Core,ZipWorker,F:\newReposMay17\et1337_Lemma\Excel\Core\ZipWorker.cs,GetWorksheetStream,The following statement contains a magic number: sheetPath = sheetPath.Substring (4);  
Magic Number,Excel.Core.OpenXmlFormat,XlsxDimension,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxDimension.cs,XlsxDim,The following statement contains a magic number: for (int i = 0; i < index; i++) {  	val1 += (int)(arr [i] * Math.Pow (26' index - i - 1));  }  
Magic Number,Excel.Core.OpenXmlFormat,XlsxDimension,F:\newReposMay17\et1337_Lemma\Excel\Core\OpenXmlFormat\XlsxDimension.cs,XlsxDim,The following statement contains a magic number: val1 += (int)(arr [i] * Math.Pow (26' index - i - 1));  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkSheetGlobals,The following statement contains a magic number: if (dims != null) {  	dims.IsV8 = isV8 ();  	LogManager.Log (this).Debug ("dims IsV8={0}"' dims.IsV8);  	m_maxCol = dims.LastColumn - 1;  	//handle case where sheet reports last column is 1 but there are actually more  	if (m_maxCol <= 0 && rowRecord != null) {  		m_maxCol = rowRecord.LastDefinedColumn;  	}  	m_maxRow = (int)dims.LastRow;  	sheet.Dimensions = dims;  } else {  	m_maxCol = 256;  	m_maxRow = (int)idx.LastExistingRow;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,readWorkSheetGlobals,The following statement contains a magic number: m_maxCol = 256;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: switch (cell.ID) {  case BIFFRECORDTYPE.BOOLERR:  	if (cell.ReadByte (7) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  	break;  case BIFFRECORDTYPE.BOOLERR_OLD:  	if (cell.ReadByte (8) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  	break;  case BIFFRECORDTYPE.INTEGER:  case BIFFRECORDTYPE.INTEGER_OLD:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffIntegerCell)cell).Value;  	break;  case BIFFRECORDTYPE.NUMBER:  case BIFFRECORDTYPE.NUMBER_OLD:  	_dValue = ((XlsBiffNumberCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.LABEL:  case BIFFRECORDTYPE.LABEL_OLD:  case BIFFRECORDTYPE.RSTRING:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffLabelCell)cell).Value;  	LogManager.Log (this).Debug ("VALUE: {0}"' m_cellsValues [cell.ColumnIndex]);  	break;  case BIFFRECORDTYPE.LABELSST:  	string tmp = m_globals.SST.GetString (((XlsBiffLabelSSTCell)cell).SSTIndex);  	LogManager.Log (this).Debug ("VALUE: {0}"' tmp);  	m_cellsValues [cell.ColumnIndex] = tmp;  	break;  case BIFFRECORDTYPE.RK:  	_dValue = ((XlsBiffRKCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.MULRK:  	XlsBiffMulRKCell _rkCell = (XlsBiffMulRKCell)cell;  	for (ushort j = cell.ColumnIndex; j <= _rkCell.LastColumnIndex; j++) {  		_dValue = _rkCell.GetValue (j);  		LogManager.Log (this).Debug ("VALUE[{1}]: {0}"' _dValue' j);  		m_cellsValues [j] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' _rkCell.GetXF (j));  	}  	break;  case BIFFRECORDTYPE.BLANK:  case BIFFRECORDTYPE.BLANK_OLD:  case BIFFRECORDTYPE.MULBLANK:  	// Skip blank cells  	break;  case BIFFRECORDTYPE.FORMULA:  case BIFFRECORDTYPE.FORMULA_OLD:  	object _oValue = ((XlsBiffFormulaCell)cell).Value;  	if (null != _oValue && _oValue is FORMULAERROR) {  		_oValue = null;  	} else {  		m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _oValue : tryConvertOADateTime (_oValue' (ushort)(cell.XFormat));  		//date time offset  	}  	break;  default:  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: switch (cell.ID) {  case BIFFRECORDTYPE.BOOLERR:  	if (cell.ReadByte (7) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  	break;  case BIFFRECORDTYPE.BOOLERR_OLD:  	if (cell.ReadByte (8) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  	break;  case BIFFRECORDTYPE.INTEGER:  case BIFFRECORDTYPE.INTEGER_OLD:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffIntegerCell)cell).Value;  	break;  case BIFFRECORDTYPE.NUMBER:  case BIFFRECORDTYPE.NUMBER_OLD:  	_dValue = ((XlsBiffNumberCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.LABEL:  case BIFFRECORDTYPE.LABEL_OLD:  case BIFFRECORDTYPE.RSTRING:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffLabelCell)cell).Value;  	LogManager.Log (this).Debug ("VALUE: {0}"' m_cellsValues [cell.ColumnIndex]);  	break;  case BIFFRECORDTYPE.LABELSST:  	string tmp = m_globals.SST.GetString (((XlsBiffLabelSSTCell)cell).SSTIndex);  	LogManager.Log (this).Debug ("VALUE: {0}"' tmp);  	m_cellsValues [cell.ColumnIndex] = tmp;  	break;  case BIFFRECORDTYPE.RK:  	_dValue = ((XlsBiffRKCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.MULRK:  	XlsBiffMulRKCell _rkCell = (XlsBiffMulRKCell)cell;  	for (ushort j = cell.ColumnIndex; j <= _rkCell.LastColumnIndex; j++) {  		_dValue = _rkCell.GetValue (j);  		LogManager.Log (this).Debug ("VALUE[{1}]: {0}"' _dValue' j);  		m_cellsValues [j] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' _rkCell.GetXF (j));  	}  	break;  case BIFFRECORDTYPE.BLANK:  case BIFFRECORDTYPE.BLANK_OLD:  case BIFFRECORDTYPE.MULBLANK:  	// Skip blank cells  	break;  case BIFFRECORDTYPE.FORMULA:  case BIFFRECORDTYPE.FORMULA_OLD:  	object _oValue = ((XlsBiffFormulaCell)cell).Value;  	if (null != _oValue && _oValue is FORMULAERROR) {  		_oValue = null;  	} else {  		m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _oValue : tryConvertOADateTime (_oValue' (ushort)(cell.XFormat));  		//date time offset  	}  	break;  default:  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: switch (cell.ID) {  case BIFFRECORDTYPE.BOOLERR:  	if (cell.ReadByte (7) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  	break;  case BIFFRECORDTYPE.BOOLERR_OLD:  	if (cell.ReadByte (8) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  	break;  case BIFFRECORDTYPE.INTEGER:  case BIFFRECORDTYPE.INTEGER_OLD:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffIntegerCell)cell).Value;  	break;  case BIFFRECORDTYPE.NUMBER:  case BIFFRECORDTYPE.NUMBER_OLD:  	_dValue = ((XlsBiffNumberCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.LABEL:  case BIFFRECORDTYPE.LABEL_OLD:  case BIFFRECORDTYPE.RSTRING:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffLabelCell)cell).Value;  	LogManager.Log (this).Debug ("VALUE: {0}"' m_cellsValues [cell.ColumnIndex]);  	break;  case BIFFRECORDTYPE.LABELSST:  	string tmp = m_globals.SST.GetString (((XlsBiffLabelSSTCell)cell).SSTIndex);  	LogManager.Log (this).Debug ("VALUE: {0}"' tmp);  	m_cellsValues [cell.ColumnIndex] = tmp;  	break;  case BIFFRECORDTYPE.RK:  	_dValue = ((XlsBiffRKCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.MULRK:  	XlsBiffMulRKCell _rkCell = (XlsBiffMulRKCell)cell;  	for (ushort j = cell.ColumnIndex; j <= _rkCell.LastColumnIndex; j++) {  		_dValue = _rkCell.GetValue (j);  		LogManager.Log (this).Debug ("VALUE[{1}]: {0}"' _dValue' j);  		m_cellsValues [j] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' _rkCell.GetXF (j));  	}  	break;  case BIFFRECORDTYPE.BLANK:  case BIFFRECORDTYPE.BLANK_OLD:  case BIFFRECORDTYPE.MULBLANK:  	// Skip blank cells  	break;  case BIFFRECORDTYPE.FORMULA:  case BIFFRECORDTYPE.FORMULA_OLD:  	object _oValue = ((XlsBiffFormulaCell)cell).Value;  	if (null != _oValue && _oValue is FORMULAERROR) {  		_oValue = null;  	} else {  		m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _oValue : tryConvertOADateTime (_oValue' (ushort)(cell.XFormat));  		//date time offset  	}  	break;  default:  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: switch (cell.ID) {  case BIFFRECORDTYPE.BOOLERR:  	if (cell.ReadByte (7) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  	break;  case BIFFRECORDTYPE.BOOLERR_OLD:  	if (cell.ReadByte (8) == 0)  		m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  	break;  case BIFFRECORDTYPE.INTEGER:  case BIFFRECORDTYPE.INTEGER_OLD:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffIntegerCell)cell).Value;  	break;  case BIFFRECORDTYPE.NUMBER:  case BIFFRECORDTYPE.NUMBER_OLD:  	_dValue = ((XlsBiffNumberCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.LABEL:  case BIFFRECORDTYPE.LABEL_OLD:  case BIFFRECORDTYPE.RSTRING:  	m_cellsValues [cell.ColumnIndex] = ((XlsBiffLabelCell)cell).Value;  	LogManager.Log (this).Debug ("VALUE: {0}"' m_cellsValues [cell.ColumnIndex]);  	break;  case BIFFRECORDTYPE.LABELSST:  	string tmp = m_globals.SST.GetString (((XlsBiffLabelSSTCell)cell).SSTIndex);  	LogManager.Log (this).Debug ("VALUE: {0}"' tmp);  	m_cellsValues [cell.ColumnIndex] = tmp;  	break;  case BIFFRECORDTYPE.RK:  	_dValue = ((XlsBiffRKCell)cell).Value;  	m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' cell.XFormat);  	LogManager.Log (this).Debug ("VALUE: {0}"' _dValue);  	break;  case BIFFRECORDTYPE.MULRK:  	XlsBiffMulRKCell _rkCell = (XlsBiffMulRKCell)cell;  	for (ushort j = cell.ColumnIndex; j <= _rkCell.LastColumnIndex; j++) {  		_dValue = _rkCell.GetValue (j);  		LogManager.Log (this).Debug ("VALUE[{1}]: {0}"' _dValue' j);  		m_cellsValues [j] = !ConvertOaDate ? _dValue : tryConvertOADateTime (_dValue' _rkCell.GetXF (j));  	}  	break;  case BIFFRECORDTYPE.BLANK:  case BIFFRECORDTYPE.BLANK_OLD:  case BIFFRECORDTYPE.MULBLANK:  	// Skip blank cells  	break;  case BIFFRECORDTYPE.FORMULA:  case BIFFRECORDTYPE.FORMULA_OLD:  	object _oValue = ((XlsBiffFormulaCell)cell).Value;  	if (null != _oValue && _oValue is FORMULAERROR) {  		_oValue = null;  	} else {  		m_cellsValues [cell.ColumnIndex] = !ConvertOaDate ? _oValue : tryConvertOADateTime (_oValue' (ushort)(cell.XFormat));  		//date time offset  	}  	break;  default:  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: if (cell.ReadByte (7) == 0)  	m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: if (cell.ReadByte (7) == 0)  	m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: m_cellsValues [cell.ColumnIndex] = cell.ReadByte (6) != 0;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: if (cell.ReadByte (8) == 0)  	m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: if (cell.ReadByte (8) == 0)  	m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,pushCellValue,The following statement contains a magic number: m_cellsValues [cell.ColumnIndex] = cell.ReadByte (7) != 0;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if (XFormat >= 0 && XFormat < m_globals.ExtendedFormats.Count) {  	var rec = m_globals.ExtendedFormats [XFormat];  	switch (rec.ID) {  	case BIFFRECORDTYPE.XF_V2:  		format = (ushort)(rec.ReadByte (2) & 0x3F);  		break;  	case BIFFRECORDTYPE.XF_V3:  		if ((rec.ReadByte (3) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	case BIFFRECORDTYPE.XF_V4:  		if ((rec.ReadByte (5) & 4) == 0)  			return value;  		format = rec.ReadByte (1);  		break;  	default:  		if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  			return value;  		format = rec.ReadUInt16 (2);  		break;  	}  } else {  	format = XFormat;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (rec.ID) {  case BIFFRECORDTYPE.XF_V2:  	format = (ushort)(rec.ReadByte (2) & 0x3F);  	break;  case BIFFRECORDTYPE.XF_V3:  	if ((rec.ReadByte (3) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  case BIFFRECORDTYPE.XF_V4:  	if ((rec.ReadByte (5) & 4) == 0)  		return value;  	format = rec.ReadByte (1);  	break;  default:  	if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  		return value;  	format = rec.ReadUInt16 (2);  	break;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: format = (ushort)(rec.ReadByte (2) & 0x3F);  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (3) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (3) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (5) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (5) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: if ((rec.ReadByte (m_globals.Sheets [m_globals.Sheets.Count - 1].IsV8 ? 9 : 7) & 4) == 0)  	return value;  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: format = rec.ReadUInt16 (2);  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelBinaryReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelBinaryReader.cs,tryConvertOADateTime,The following statement contains a magic number: switch (format) {  // numeric built in formats  case 0:  //"General";  case 1:  //"0";  case 2:  //"0.00";  case 3:  //"#'##0";  case 4:  //"#'##0.00";  case 5:  //"\"$\"#'##0_);(\"$\"#'##0)";  case 6:  //"\"$\"#'##0_);[Red](\"$\"#'##0)";  case 7:  //"\"$\"#'##0.00_);(\"$\"#'##0.00)";  case 8:  //"\"$\"#'##0.00_);[Red](\"$\"#'##0.00)";  case 9:  //"0%";  case 10:  //"0.00%";  case 11:  //"0.00E+00";  case 12:  //"# ?/?";  case 13:  //"# ??/??";  case 0x30:  // "##0.0E+0";  case 0x25:  // "_(#'##0_);(#'##0)";  case 0x26:  // "_(#'##0_);[Red](#'##0)";  case 0x27:  // "_(#'##0.00_);(#'##0.00)";  case 40:  // "_(#'##0.00_);[Red](#'##0.00)";  case 0x29:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2a:  // "_(\"$\"* #'##0_);_(\"$\"* (#'##0);_(\"$\"* \"-\"_);_(@_)";  case 0x2b:  // "_(\"$\"* #'##0.00_);_(\"$\"* (#'##0.00);_(\"$\"* \"-\"??_);_(@_)";  case 0x2c:  	// "_(* #'##0.00_);_(* (#'##0.00);_(* \"-\"??_);_(@_)";  	return value;  // date formats  case 14:  //this.GetDefaultDateFormat();  case 15:  //"D-MM-YY";  case 0x10:  // "D-MMM";  case 0x11:  // "MMM-YY";  case 0x12:  // "h:mm AM/PM";  case 0x13:  // "h:mm:ss AM/PM";  case 20:  // "h:mm";  case 0x15:  // "h:mm:ss";  case 0x16:  // string.Format("{0} {1}"' this.GetDefaultDateFormat()' this.GetDefaultTimeFormat());  case 0x2d:  // "mm:ss";  case 0x2e:  // "[h]:mm:ss";  case 0x2f:  	// "mm:ss.0";  	return Helpers.ConvertFromOATime (value);  case 0x31:  	// "@";  	return value.ToString ();  default:  	XlsBiffFormatString fmtString;  	if (m_globals.Formats.TryGetValue (format' out fmtString)) {  		var fmt = fmtString.Value;  		var formatReader = new FormatReader () {  			FormatString = fmt  		};  		if (formatReader.IsDateFormatString ())  			return Helpers.ConvertFromOATime (value);  	}  	return value;  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ExcelOpenXmlReader,The following statement contains a magic number: _defaultDateTimeStyles = new List<int> (new int[] {  	14'  	15'  	16'  	17'  	18'  	19'  	20'  	21'  	22'  	45'  	46'  	47  });  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if ((_xmlReader.NodeType == XmlNodeType.Element && _xmlReader.LocalName == XlsxWorksheet.N_row) || _xmlReader.ReadToFollowing (XlsxWorksheet.N_row' _namespaceUri)) {  	_cellsValues = new object[sheet.ColumnsCount];  	int rowIndex = int.Parse (_xmlReader.GetAttribute (XlsxWorksheet.A_r));  	if (rowIndex != (_depth + 1))  		if (rowIndex != (_depth + 1)) {  			_emptyRowCount = rowIndex - _depth - 1;  		}  	bool hasValue = false;  	string a_s = String.Empty;  	string a_t = String.Empty;  	string a_r = String.Empty;  	int col = 0;  	int row = 0;  	while (_xmlReader.Read ()) {  		if (_xmlReader.Depth == 2)  			break;  		if (_xmlReader.NodeType == XmlNodeType.Element) {  			hasValue = false;  			if (_xmlReader.LocalName == XlsxWorksheet.N_c) {  				a_s = _xmlReader.GetAttribute (XlsxWorksheet.A_s);  				a_t = _xmlReader.GetAttribute (XlsxWorksheet.A_t);  				a_r = _xmlReader.GetAttribute (XlsxWorksheet.A_r);  				XlsxDimension.XlsxDim (a_r' out col' out row);  			} else if (_xmlReader.LocalName == XlsxWorksheet.N_v || _xmlReader.LocalName == XlsxWorksheet.N_t) {  				hasValue = true;  			}  		}  		if (_xmlReader.NodeType == XmlNodeType.Text && hasValue) {  			double number;  			object o = _xmlReader.Value;  			var style = NumberStyles.Any;  			var culture = CultureInfo.InvariantCulture;  			if (double.TryParse (o.ToString ()' style' culture' out number))  				o = number;  			if (null != a_t && a_t == XlsxWorksheet.A_s)//if string  			 {  				o = Helpers.ConvertEscapeChars (_workbook.SST [int.Parse (o.ToString ())]);  			} // Requested change 4: missing (it appears that if should be else if)  			else if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline  			 {  				o = Helpers.ConvertEscapeChars (o.ToString ());  			} else if (a_t == "b")//boolean  			 {  				o = _xmlReader.Value == "1";  			} else if (null != a_s)//if something else  			 {  				XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  				if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  					o = Helpers.ConvertFromOATime (number);  				else if (xf.NumFmtId == 49)  					o = o.ToString ();  			}  			if (col - 1 < _cellsValues.Length)  				_cellsValues [col - 1] = o;  		}  	}  	if (_emptyRowCount > 0) {  		_savedCellsValues = _cellsValues;  		return ReadSheetRow (sheet);  	}  	_depth++;  	return true;  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if ((_xmlReader.NodeType == XmlNodeType.Element && _xmlReader.LocalName == XlsxWorksheet.N_row) || _xmlReader.ReadToFollowing (XlsxWorksheet.N_row' _namespaceUri)) {  	_cellsValues = new object[sheet.ColumnsCount];  	int rowIndex = int.Parse (_xmlReader.GetAttribute (XlsxWorksheet.A_r));  	if (rowIndex != (_depth + 1))  		if (rowIndex != (_depth + 1)) {  			_emptyRowCount = rowIndex - _depth - 1;  		}  	bool hasValue = false;  	string a_s = String.Empty;  	string a_t = String.Empty;  	string a_r = String.Empty;  	int col = 0;  	int row = 0;  	while (_xmlReader.Read ()) {  		if (_xmlReader.Depth == 2)  			break;  		if (_xmlReader.NodeType == XmlNodeType.Element) {  			hasValue = false;  			if (_xmlReader.LocalName == XlsxWorksheet.N_c) {  				a_s = _xmlReader.GetAttribute (XlsxWorksheet.A_s);  				a_t = _xmlReader.GetAttribute (XlsxWorksheet.A_t);  				a_r = _xmlReader.GetAttribute (XlsxWorksheet.A_r);  				XlsxDimension.XlsxDim (a_r' out col' out row);  			} else if (_xmlReader.LocalName == XlsxWorksheet.N_v || _xmlReader.LocalName == XlsxWorksheet.N_t) {  				hasValue = true;  			}  		}  		if (_xmlReader.NodeType == XmlNodeType.Text && hasValue) {  			double number;  			object o = _xmlReader.Value;  			var style = NumberStyles.Any;  			var culture = CultureInfo.InvariantCulture;  			if (double.TryParse (o.ToString ()' style' culture' out number))  				o = number;  			if (null != a_t && a_t == XlsxWorksheet.A_s)//if string  			 {  				o = Helpers.ConvertEscapeChars (_workbook.SST [int.Parse (o.ToString ())]);  			} // Requested change 4: missing (it appears that if should be else if)  			else if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline  			 {  				o = Helpers.ConvertEscapeChars (o.ToString ());  			} else if (a_t == "b")//boolean  			 {  				o = _xmlReader.Value == "1";  			} else if (null != a_s)//if something else  			 {  				XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  				if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  					o = Helpers.ConvertFromOATime (number);  				else if (xf.NumFmtId == 49)  					o = o.ToString ();  			}  			if (col - 1 < _cellsValues.Length)  				_cellsValues [col - 1] = o;  		}  	}  	if (_emptyRowCount > 0) {  		_savedCellsValues = _cellsValues;  		return ReadSheetRow (sheet);  	}  	_depth++;  	return true;  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: while (_xmlReader.Read ()) {  	if (_xmlReader.Depth == 2)  		break;  	if (_xmlReader.NodeType == XmlNodeType.Element) {  		hasValue = false;  		if (_xmlReader.LocalName == XlsxWorksheet.N_c) {  			a_s = _xmlReader.GetAttribute (XlsxWorksheet.A_s);  			a_t = _xmlReader.GetAttribute (XlsxWorksheet.A_t);  			a_r = _xmlReader.GetAttribute (XlsxWorksheet.A_r);  			XlsxDimension.XlsxDim (a_r' out col' out row);  		} else if (_xmlReader.LocalName == XlsxWorksheet.N_v || _xmlReader.LocalName == XlsxWorksheet.N_t) {  			hasValue = true;  		}  	}  	if (_xmlReader.NodeType == XmlNodeType.Text && hasValue) {  		double number;  		object o = _xmlReader.Value;  		var style = NumberStyles.Any;  		var culture = CultureInfo.InvariantCulture;  		if (double.TryParse (o.ToString ()' style' culture' out number))  			o = number;  		if (null != a_t && a_t == XlsxWorksheet.A_s)//if string  		 {  			o = Helpers.ConvertEscapeChars (_workbook.SST [int.Parse (o.ToString ())]);  		} // Requested change 4: missing (it appears that if should be else if)  		else if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline  		 {  			o = Helpers.ConvertEscapeChars (o.ToString ());  		} else if (a_t == "b")//boolean  		 {  			o = _xmlReader.Value == "1";  		} else if (null != a_s)//if something else  		 {  			XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  			if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  				o = Helpers.ConvertFromOATime (number);  			else if (xf.NumFmtId == 49)  				o = o.ToString ();  		}  		if (col - 1 < _cellsValues.Length)  			_cellsValues [col - 1] = o;  	}  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: while (_xmlReader.Read ()) {  	if (_xmlReader.Depth == 2)  		break;  	if (_xmlReader.NodeType == XmlNodeType.Element) {  		hasValue = false;  		if (_xmlReader.LocalName == XlsxWorksheet.N_c) {  			a_s = _xmlReader.GetAttribute (XlsxWorksheet.A_s);  			a_t = _xmlReader.GetAttribute (XlsxWorksheet.A_t);  			a_r = _xmlReader.GetAttribute (XlsxWorksheet.A_r);  			XlsxDimension.XlsxDim (a_r' out col' out row);  		} else if (_xmlReader.LocalName == XlsxWorksheet.N_v || _xmlReader.LocalName == XlsxWorksheet.N_t) {  			hasValue = true;  		}  	}  	if (_xmlReader.NodeType == XmlNodeType.Text && hasValue) {  		double number;  		object o = _xmlReader.Value;  		var style = NumberStyles.Any;  		var culture = CultureInfo.InvariantCulture;  		if (double.TryParse (o.ToString ()' style' culture' out number))  			o = number;  		if (null != a_t && a_t == XlsxWorksheet.A_s)//if string  		 {  			o = Helpers.ConvertEscapeChars (_workbook.SST [int.Parse (o.ToString ())]);  		} // Requested change 4: missing (it appears that if should be else if)  		else if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline  		 {  			o = Helpers.ConvertEscapeChars (o.ToString ());  		} else if (a_t == "b")//boolean  		 {  			o = _xmlReader.Value == "1";  		} else if (null != a_s)//if something else  		 {  			XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  			if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  				o = Helpers.ConvertFromOATime (number);  			else if (xf.NumFmtId == 49)  				o = o.ToString ();  		}  		if (col - 1 < _cellsValues.Length)  			_cellsValues [col - 1] = o;  	}  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (_xmlReader.Depth == 2)  	break;  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (_xmlReader.NodeType == XmlNodeType.Text && hasValue) {  	double number;  	object o = _xmlReader.Value;  	var style = NumberStyles.Any;  	var culture = CultureInfo.InvariantCulture;  	if (double.TryParse (o.ToString ()' style' culture' out number))  		o = number;  	if (null != a_t && a_t == XlsxWorksheet.A_s)//if string  	 {  		o = Helpers.ConvertEscapeChars (_workbook.SST [int.Parse (o.ToString ())]);  	} // Requested change 4: missing (it appears that if should be else if)  	else if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline  	 {  		o = Helpers.ConvertEscapeChars (o.ToString ());  	} else if (a_t == "b")//boolean  	 {  		o = _xmlReader.Value == "1";  	} else if (null != a_s)//if something else  	 {  		XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  		if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  			o = Helpers.ConvertFromOATime (number);  		else if (xf.NumFmtId == 49)  			o = o.ToString ();  	}  	if (col - 1 < _cellsValues.Length)  		_cellsValues [col - 1] = o;  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (null != a_t && a_t == XlsxWorksheet.A_s)//if string   {  	o = Helpers.ConvertEscapeChars (_workbook.SST [int.Parse (o.ToString ())]);  } // Requested change 4: missing (it appears that if should be else if)  else if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline   {  	o = Helpers.ConvertEscapeChars (o.ToString ());  } else if (a_t == "b")//boolean   {  	o = _xmlReader.Value == "1";  } else if (null != a_s)//if something else   {  	XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  	if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  		o = Helpers.ConvertFromOATime (number);  	else if (xf.NumFmtId == 49)  		o = o.ToString ();  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (null != a_t && a_t == XlsxWorksheet.N_inlineStr)//if string inline   {  	o = Helpers.ConvertEscapeChars (o.ToString ());  } else if (a_t == "b")//boolean   {  	o = _xmlReader.Value == "1";  } else if (null != a_s)//if something else   {  	XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  	if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  		o = Helpers.ConvertFromOATime (number);  	else if (xf.NumFmtId == 49)  		o = o.ToString ();  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (a_t == "b")//boolean   {  	o = _xmlReader.Value == "1";  } else if (null != a_s)//if something else   {  	XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  	if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  		o = Helpers.ConvertFromOATime (number);  	else if (xf.NumFmtId == 49)  		o = o.ToString ();  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (null != a_s)//if something else   {  	XlsxXf xf = _workbook.Styles.CellXfs [int.Parse (a_s)];  	if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  		o = Helpers.ConvertFromOATime (number);  	else if (xf.NumFmtId == 49)  		o = o.ToString ();  }  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (xf.ApplyNumberFormat && o != null && o.ToString () != string.Empty && IsDateTimeStyle (xf.NumFmtId))  	o = Helpers.ConvertFromOATime (number);  else if (xf.NumFmtId == 49)  	o = o.ToString ();  
Magic Number,Excel,ExcelOpenXmlReader,F:\newReposMay17\et1337_Lemma\Excel\ExcelOpenXmlReader.cs,ReadSheetRow,The following statement contains a magic number: if (xf.NumFmtId == 49)  	o = o.ToString ();  
Missing Default,Excel.Core.BinaryFormat,XlsBiffStream,F:\newReposMay17\et1337_Lemma\Excel\Core\BinaryFormat\XlsBiffStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin:  	m_offset = offset;  	break;  case SeekOrigin.Current:  	m_offset += offset;  	break;  case SeekOrigin.End:  	m_offset = m_size - offset;  	break;  }  
